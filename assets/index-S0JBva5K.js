var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link2 of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link2);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link2) {
    const fetchOpts = {};
    if (link2.integrity)
      fetchOpts.integrity = link2.integrity;
    if (link2.referrerPolicy)
      fetchOpts.referrerPolicy = link2.referrerPolicy;
    if (link2.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link2.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link2) {
    if (link2.ep)
      return;
    link2.ep = true;
    const fetchOpts = getFetchOpts(link2);
    fetch(link2.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var jszip_min = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(module, exports) {
  !function(e2) {
    module.exports = e2();
  }(function() {
    return function s(a, o, h2) {
      function u(r, e3) {
        if (!o[r]) {
          if (!a[r]) {
            var t = "function" == typeof commonjsRequire && commonjsRequire;
            if (!e3 && t)
              return t(r, true);
            if (l)
              return l(r, true);
            var n = new Error("Cannot find module '" + r + "'");
            throw n.code = "MODULE_NOT_FOUND", n;
          }
          var i = o[r] = { exports: {} };
          a[r][0].call(i.exports, function(e4) {
            var t2 = a[r][1][e4];
            return u(t2 || e4);
          }, i, i.exports, s, a, o, h2);
        }
        return o[r].exports;
      }
      for (var l = "function" == typeof commonjsRequire && commonjsRequire, e2 = 0; e2 < h2.length; e2++)
        u(h2[e2]);
      return u;
    }({ 1: [function(e2, t, r) {
      var d = e2("./utils"), c = e2("./support"), p2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      r.encode = function(e3) {
        for (var t2, r2, n, i, s, a, o, h2 = [], u = 0, l = e3.length, f = l, c2 = "string" !== d.getTypeOf(e3); u < e3.length; )
          f = l - u, n = c2 ? (t2 = e3[u++], r2 = u < l ? e3[u++] : 0, u < l ? e3[u++] : 0) : (t2 = e3.charCodeAt(u++), r2 = u < l ? e3.charCodeAt(u++) : 0, u < l ? e3.charCodeAt(u++) : 0), i = t2 >> 2, s = (3 & t2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h2.push(p2.charAt(i) + p2.charAt(s) + p2.charAt(a) + p2.charAt(o));
        return h2.join("");
      }, r.decode = function(e3) {
        var t2, r2, n, i, s, a, o = 0, h2 = 0, u = "data:";
        if (e3.substr(0, u.length) === u)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var l, f = 3 * (e3 = e3.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (e3.charAt(e3.length - 1) === p2.charAt(64) && f--, e3.charAt(e3.length - 2) === p2.charAt(64) && f--, f % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e3.length; )
          t2 = p2.indexOf(e3.charAt(o++)) << 2 | (i = p2.indexOf(e3.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p2.indexOf(e3.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p2.indexOf(e3.charAt(o++))), l[h2++] = t2, 64 !== s && (l[h2++] = r2), 64 !== a && (l[h2++] = n);
        return l;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(e2, t, r) {
      var n = e2("./external"), i = e2("./stream/DataWorker"), s = e2("./stream/Crc32Probe"), a = e2("./stream/DataLengthProbe");
      function o(e3, t2, r2, n2, i2) {
        this.compressedSize = e3, this.uncompressedSize = t2, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
      }
      o.prototype = { getContentWorker: function() {
        var e3 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t2 = this;
        return e3.on("end", function() {
          if (this.streamInfo.data_length !== t2.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), e3;
      }, getCompressedWorker: function() {
        return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, o.createWorkerFrom = function(e3, t2, r2) {
        return e3.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t2.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t2);
      }, t.exports = o;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e2, t, r) {
      var n = e2("./stream/GenericWorker");
      r.STORE = { magic: "\0\0", compressWorker: function() {
        return new n("STORE compression");
      }, uncompressWorker: function() {
        return new n("STORE decompression");
      } }, r.DEFLATE = e2("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e2, t, r) {
      var n = e2("./utils");
      var o = function() {
        for (var e3, t2 = [], r2 = 0; r2 < 256; r2++) {
          e3 = r2;
          for (var n2 = 0; n2 < 8; n2++)
            e3 = 1 & e3 ? 3988292384 ^ e3 >>> 1 : e3 >>> 1;
          t2[r2] = e3;
        }
        return t2;
      }();
      t.exports = function(e3, t2) {
        return void 0 !== e3 && e3.length ? "string" !== n.getTypeOf(e3) ? function(e4, t3, r2, n2) {
          var i = o, s = n2 + r2;
          e4 ^= -1;
          for (var a = n2; a < s; a++)
            e4 = e4 >>> 8 ^ i[255 & (e4 ^ t3[a])];
          return -1 ^ e4;
        }(0 | t2, e3, e3.length, 0) : function(e4, t3, r2, n2) {
          var i = o, s = n2 + r2;
          e4 ^= -1;
          for (var a = n2; a < s; a++)
            e4 = e4 >>> 8 ^ i[255 & (e4 ^ t3.charCodeAt(a))];
          return -1 ^ e4;
        }(0 | t2, e3, e3.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(e2, t, r) {
      r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
    }, {}], 6: [function(e2, t, r) {
      var n = null;
      n = "undefined" != typeof Promise ? Promise : e2("lie"), t.exports = { Promise: n };
    }, { lie: 37 }], 7: [function(e2, t, r) {
      var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e2("pako"), s = e2("./utils"), a = e2("./stream/GenericWorker"), o = n ? "uint8array" : "array";
      function h2(e3, t2) {
        a.call(this, "FlateWorker/" + e3), this._pako = null, this._pakoAction = e3, this._pakoOptions = t2, this.meta = {};
      }
      r.magic = "\b\0", s.inherits(h2, a), h2.prototype.processChunk = function(e3) {
        this.meta = e3.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e3.data), false);
      }, h2.prototype.flush = function() {
        a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
      }, h2.prototype.cleanUp = function() {
        a.prototype.cleanUp.call(this), this._pako = null;
      }, h2.prototype._createPako = function() {
        this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
        var t2 = this;
        this._pako.onData = function(e3) {
          t2.push({ data: e3, meta: t2.meta });
        };
      }, r.compressWorker = function(e3) {
        return new h2("Deflate", e3);
      }, r.uncompressWorker = function() {
        return new h2("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e2, t, r) {
      function A(e3, t2) {
        var r2, n2 = "";
        for (r2 = 0; r2 < t2; r2++)
          n2 += String.fromCharCode(255 & e3), e3 >>>= 8;
        return n2;
      }
      function n(e3, t2, r2, n2, i2, s2) {
        var a, o, h2 = e3.file, u = e3.compression, l = s2 !== O.utf8encode, f = I2.transformTo("string", s2(h2.name)), c = I2.transformTo("string", O.utf8encode(h2.name)), d = h2.comment, p2 = I2.transformTo("string", s2(d)), m = I2.transformTo("string", O.utf8encode(d)), _ = c.length !== h2.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h2.dir, k = h2.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        t2 && !r2 || (x.crc32 = e3.crc32, x.compressedSize = e3.compressedSize, x.uncompressedSize = e3.uncompressedSize);
        var S2 = 0;
        t2 && (S2 |= 8), l || !_ && !g || (S2 |= 2048);
        var z = 0, C = 0;
        w && (z |= 16), "UNIX" === i2 ? (C = 798, z |= function(e4, t3) {
          var r3 = e4;
          return e4 || (r3 = t3 ? 16893 : 33204), (65535 & r3) << 16;
        }(h2.unixPermissions, w)) : (C = 20, z |= function(e4) {
          return 63 & (e4 || 0);
        }(h2.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p2), 4) + m, b += "uc" + A(y.length, 2) + y);
        var E2 = "";
        return E2 += "\n\0", E2 += A(S2, 2), E2 += u.magic, E2 += A(a, 2), E2 += A(o, 2), E2 += A(x.crc32, 4), E2 += A(x.compressedSize, 4), E2 += A(x.uncompressedSize, 4), E2 += A(f.length, 2), E2 += A(b.length, 2), { fileRecord: R2.LOCAL_FILE_HEADER + E2 + f + b, dirRecord: R2.CENTRAL_FILE_HEADER + A(C, 2) + E2 + A(p2.length, 2) + "\0\0\0\0" + A(z, 4) + A(n2, 4) + f + b + p2 };
      }
      var I2 = e2("../utils"), i = e2("../stream/GenericWorker"), O = e2("../utf8"), B = e2("../crc32"), R2 = e2("../signature");
      function s(e3, t2, r2, n2) {
        i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t2, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e3, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      I2.inherits(s, i), s.prototype.push = function(e3) {
        var t2 = e3.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
        this.accumulate ? this.contentBuffer.push(e3) : (this.bytesWritten += e3.data.length, i.prototype.push.call(this, { data: e3.data, meta: { currentFile: this.currentFile, percent: r2 ? (t2 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
      }, s.prototype.openedSource = function(e3) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = e3.file.name;
        var t2 = this.streamFiles && !e3.file.dir;
        if (t2) {
          var r2 = n(e3, t2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: r2.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = true;
      }, s.prototype.closedSource = function(e3) {
        this.accumulate = false;
        var t2 = this.streamFiles && !e3.file.dir, r2 = n(e3, t2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(r2.dirRecord), t2)
          this.push({ data: function(e4) {
            return R2.DATA_DESCRIPTOR + A(e4.crc32, 4) + A(e4.compressedSize, 4) + A(e4.uncompressedSize, 4);
          }(e3), meta: { percent: 100 } });
        else
          for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, s.prototype.flush = function() {
        for (var e3 = this.bytesWritten, t2 = 0; t2 < this.dirRecords.length; t2++)
          this.push({ data: this.dirRecords[t2], meta: { percent: 100 } });
        var r2 = this.bytesWritten - e3, n2 = function(e4, t3, r3, n3, i2) {
          var s2 = I2.transformTo("string", i2(n3));
          return R2.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e4, 2) + A(e4, 2) + A(t3, 4) + A(r3, 4) + A(s2.length, 2) + s2;
        }(this.dirRecords.length, r2, e3, this.zipComment, this.encodeFileName);
        this.push({ data: n2, meta: { percent: 100 } });
      }, s.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, s.prototype.registerPrevious = function(e3) {
        this._sources.push(e3);
        var t2 = this;
        return e3.on("data", function(e4) {
          t2.processChunk(e4);
        }), e3.on("end", function() {
          t2.closedSource(t2.previous.streamInfo), t2._sources.length ? t2.prepareNextSource() : t2.end();
        }), e3.on("error", function(e4) {
          t2.error(e4);
        }), this;
      }, s.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
      }, s.prototype.error = function(e3) {
        var t2 = this._sources;
        if (!i.prototype.error.call(this, e3))
          return false;
        for (var r2 = 0; r2 < t2.length; r2++)
          try {
            t2[r2].error(e3);
          } catch (e4) {
          }
        return true;
      }, s.prototype.lock = function() {
        i.prototype.lock.call(this);
        for (var e3 = this._sources, t2 = 0; t2 < e3.length; t2++)
          e3[t2].lock();
      }, t.exports = s;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e2, t, r) {
      var u = e2("../compressions"), n = e2("./ZipFileWorker");
      r.generateWorker = function(e3, a, t2) {
        var o = new n(a.streamFiles, t2, a.platform, a.encodeFileName), h2 = 0;
        try {
          e3.forEach(function(e4, t3) {
            h2++;
            var r2 = function(e5, t4) {
              var r3 = e5 || t4, n3 = u[r3];
              if (!n3)
                throw new Error(r3 + " is not a valid compression method !");
              return n3;
            }(t3.options.compression, a.compression), n2 = t3.options.compressionOptions || a.compressionOptions || {}, i = t3.dir, s = t3.date;
            t3._compressWorker(r2, n2).withStreamInfo("file", { name: e4, dir: i, date: s, comment: t3.comment || "", unixPermissions: t3.unixPermissions, dosPermissions: t3.dosPermissions }).pipe(o);
          }), o.entriesCount = h2;
        } catch (e4) {
          o.error(e4);
        }
        return o;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e2, t, r) {
      function n() {
        if (!(this instanceof n))
          return new n();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var e3 = new n();
          for (var t2 in this)
            "function" != typeof this[t2] && (e3[t2] = this[t2]);
          return e3;
        };
      }
      (n.prototype = e2("./object")).loadAsync = e2("./load"), n.support = e2("./support"), n.defaults = e2("./defaults"), n.version = "3.10.1", n.loadAsync = function(e3, t2) {
        return new n().loadAsync(e3, t2);
      }, n.external = e2("./external"), t.exports = n;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e2, t, r) {
      var u = e2("./utils"), i = e2("./external"), n = e2("./utf8"), s = e2("./zipEntries"), a = e2("./stream/Crc32Probe"), l = e2("./nodejsUtils");
      function f(n2) {
        return new i.Promise(function(e3, t2) {
          var r2 = n2.decompressed.getContentWorker().pipe(new a());
          r2.on("error", function(e4) {
            t2(e4);
          }).on("end", function() {
            r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t2(new Error("Corrupted zip : CRC32 mismatch")) : e3();
          }).resume();
        });
      }
      t.exports = function(e3, o) {
        var h2 = this;
        return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e3) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e3, true, o.optimizedBinaryString, o.base64).then(function(e4) {
          var t2 = new s(o);
          return t2.load(e4), t2;
        }).then(function(e4) {
          var t2 = [i.Promise.resolve(e4)], r2 = e4.files;
          if (o.checkCRC32)
            for (var n2 = 0; n2 < r2.length; n2++)
              t2.push(f(r2[n2]));
          return i.Promise.all(t2);
        }).then(function(e4) {
          for (var t2 = e4.shift(), r2 = t2.files, n2 = 0; n2 < r2.length; n2++) {
            var i2 = r2[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
            h2.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h2.file(a2).unsafeOriginalName = s2);
          }
          return t2.zipComment.length && (h2.comment = t2.zipComment), h2;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e2, t, r) {
      var n = e2("../utils"), i = e2("../stream/GenericWorker");
      function s(e3, t2) {
        i.call(this, "Nodejs stream input adapter for " + e3), this._upstreamEnded = false, this._bindStream(t2);
      }
      n.inherits(s, i), s.prototype._bindStream = function(e3) {
        var t2 = this;
        (this._stream = e3).pause(), e3.on("data", function(e4) {
          t2.push({ data: e4, meta: { percent: 0 } });
        }).on("error", function(e4) {
          t2.isPaused ? this.generatedError = e4 : t2.error(e4);
        }).on("end", function() {
          t2.isPaused ? t2._upstreamEnded = true : t2.end();
        });
      }, s.prototype.pause = function() {
        return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
      }, s.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
      }, t.exports = s;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e2, t, r) {
      var i = e2("readable-stream").Readable;
      function n(e3, t2, r2) {
        i.call(this, t2), this._helper = e3;
        var n2 = this;
        e3.on("data", function(e4, t3) {
          n2.push(e4) || n2._helper.pause(), r2 && r2(t3);
        }).on("error", function(e4) {
          n2.emit("error", e4);
        }).on("end", function() {
          n2.push(null);
        });
      }
      e2("../utils").inherits(n, i), n.prototype._read = function() {
        this._helper.resume();
      }, t.exports = n;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e2, t, r) {
      t.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e3, t2) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(e3, t2);
        if ("number" == typeof e3)
          throw new Error('The "data" argument must not be a number');
        return new Buffer(e3, t2);
      }, allocBuffer: function(e3) {
        if (Buffer.alloc)
          return Buffer.alloc(e3);
        var t2 = new Buffer(e3);
        return t2.fill(0), t2;
      }, isBuffer: function(e3) {
        return Buffer.isBuffer(e3);
      }, isStream: function(e3) {
        return e3 && "function" == typeof e3.on && "function" == typeof e3.pause && "function" == typeof e3.resume;
      } };
    }, {}], 15: [function(e2, t, r) {
      function s(e3, t2, r2) {
        var n2, i2 = u.getTypeOf(t2), s2 = u.extend(r2 || {}, f);
        s2.date = s2.date || /* @__PURE__ */ new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e3 = g(e3)), s2.createFolders && (n2 = _(e3)) && b.call(this, n2, true);
        var a2 = "string" === i2 && false === s2.binary && false === s2.base64;
        r2 && void 0 !== r2.binary || (s2.binary = !a2), (t2 instanceof c && 0 === t2.uncompressedSize || s2.dir || !t2 || 0 === t2.length) && (s2.base64 = false, s2.binary = true, t2 = "", s2.compression = "STORE", i2 = "string");
        var o2 = null;
        o2 = t2 instanceof c || t2 instanceof l ? t2 : p2.isNode && p2.isStream(t2) ? new m(e3, t2) : u.prepareContent(e3, t2, s2.binary, s2.optimizedBinaryString, s2.base64);
        var h3 = new d(e3, o2, s2);
        this.files[e3] = h3;
      }
      var i = e2("./utf8"), u = e2("./utils"), l = e2("./stream/GenericWorker"), a = e2("./stream/StreamHelper"), f = e2("./defaults"), c = e2("./compressedObject"), d = e2("./zipObject"), o = e2("./generate"), p2 = e2("./nodejsUtils"), m = e2("./nodejs/NodejsStreamInputAdapter"), _ = function(e3) {
        "/" === e3.slice(-1) && (e3 = e3.substring(0, e3.length - 1));
        var t2 = e3.lastIndexOf("/");
        return 0 < t2 ? e3.substring(0, t2) : "";
      }, g = function(e3) {
        return "/" !== e3.slice(-1) && (e3 += "/"), e3;
      }, b = function(e3, t2) {
        return t2 = void 0 !== t2 ? t2 : f.createFolders, e3 = g(e3), this.files[e3] || s.call(this, e3, null, { dir: true, createFolders: t2 }), this.files[e3];
      };
      function h2(e3) {
        return "[object RegExp]" === Object.prototype.toString.call(e3);
      }
      var n = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(e3) {
        var t2, r2, n2;
        for (t2 in this.files)
          n2 = this.files[t2], (r2 = t2.slice(this.root.length, t2.length)) && t2.slice(0, this.root.length) === this.root && e3(r2, n2);
      }, filter: function(r2) {
        var n2 = [];
        return this.forEach(function(e3, t2) {
          r2(e3, t2) && n2.push(t2);
        }), n2;
      }, file: function(e3, t2, r2) {
        if (1 !== arguments.length)
          return e3 = this.root + e3, s.call(this, e3, t2, r2), this;
        if (h2(e3)) {
          var n2 = e3;
          return this.filter(function(e4, t3) {
            return !t3.dir && n2.test(e4);
          });
        }
        var i2 = this.files[this.root + e3];
        return i2 && !i2.dir ? i2 : null;
      }, folder: function(r2) {
        if (!r2)
          return this;
        if (h2(r2))
          return this.filter(function(e4, t3) {
            return t3.dir && r2.test(e4);
          });
        var e3 = this.root + r2, t2 = b.call(this, e3), n2 = this.clone();
        return n2.root = t2.name, n2;
      }, remove: function(r2) {
        r2 = this.root + r2;
        var e3 = this.files[r2];
        if (e3 || ("/" !== r2.slice(-1) && (r2 += "/"), e3 = this.files[r2]), e3 && !e3.dir)
          delete this.files[r2];
        else
          for (var t2 = this.filter(function(e4, t3) {
            return t3.name.slice(0, r2.length) === r2;
          }), n2 = 0; n2 < t2.length; n2++)
            delete this.files[t2[n2].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(e3) {
        var t2, r2 = {};
        try {
          if ((r2 = u.extend(e3 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), "binarystring" === r2.type && (r2.type = "string"), !r2.type)
            throw new Error("No output type specified.");
          u.checkSupport(r2.type), "darwin" !== r2.platform && "freebsd" !== r2.platform && "linux" !== r2.platform && "sunos" !== r2.platform || (r2.platform = "UNIX"), "win32" === r2.platform && (r2.platform = "DOS");
          var n2 = r2.comment || this.comment || "";
          t2 = o.generateWorker(this, r2, n2);
        } catch (e4) {
          (t2 = new l("error")).error(e4);
        }
        return new a(t2, r2.type || "string", r2.mimeType);
      }, generateAsync: function(e3, t2) {
        return this.generateInternalStream(e3).accumulate(t2);
      }, generateNodeStream: function(e3, t2) {
        return (e3 = e3 || {}).type || (e3.type = "nodebuffer"), this.generateInternalStream(e3).toNodejsStream(t2);
      } };
      t.exports = n;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e2, t, r) {
      t.exports = e2("stream");
    }, { stream: void 0 }], 17: [function(e2, t, r) {
      var n = e2("./DataReader");
      function i(e3) {
        n.call(this, e3);
        for (var t2 = 0; t2 < this.data.length; t2++)
          e3[t2] = 255 & e3[t2];
      }
      e2("../utils").inherits(i, n), i.prototype.byteAt = function(e3) {
        return this.data[this.zero + e3];
      }, i.prototype.lastIndexOfSignature = function(e3) {
        for (var t2 = e3.charCodeAt(0), r2 = e3.charCodeAt(1), n2 = e3.charCodeAt(2), i2 = e3.charCodeAt(3), s = this.length - 4; 0 <= s; --s)
          if (this.data[s] === t2 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2)
            return s - this.zero;
        return -1;
      }, i.prototype.readAndCheckSignature = function(e3) {
        var t2 = e3.charCodeAt(0), r2 = e3.charCodeAt(1), n2 = e3.charCodeAt(2), i2 = e3.charCodeAt(3), s = this.readData(4);
        return t2 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];
      }, i.prototype.readData = function(e3) {
        if (this.checkOffset(e3), 0 === e3)
          return [];
        var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
        return this.index += e3, t2;
      }, t.exports = i;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e2, t, r) {
      var n = e2("../utils");
      function i(e3) {
        this.data = e3, this.length = e3.length, this.index = 0, this.zero = 0;
      }
      i.prototype = { checkOffset: function(e3) {
        this.checkIndex(this.index + e3);
      }, checkIndex: function(e3) {
        if (this.length < this.zero + e3 || e3 < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e3 + "). Corrupted zip ?");
      }, setIndex: function(e3) {
        this.checkIndex(e3), this.index = e3;
      }, skip: function(e3) {
        this.setIndex(this.index + e3);
      }, byteAt: function() {
      }, readInt: function(e3) {
        var t2, r2 = 0;
        for (this.checkOffset(e3), t2 = this.index + e3 - 1; t2 >= this.index; t2--)
          r2 = (r2 << 8) + this.byteAt(t2);
        return this.index += e3, r2;
      }, readString: function(e3) {
        return n.transformTo("string", this.readData(e3));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var e3 = this.readInt(4);
        return new Date(Date.UTC(1980 + (e3 >> 25 & 127), (e3 >> 21 & 15) - 1, e3 >> 16 & 31, e3 >> 11 & 31, e3 >> 5 & 63, (31 & e3) << 1));
      } }, t.exports = i;
    }, { "../utils": 32 }], 19: [function(e2, t, r) {
      var n = e2("./Uint8ArrayReader");
      function i(e3) {
        n.call(this, e3);
      }
      e2("../utils").inherits(i, n), i.prototype.readData = function(e3) {
        this.checkOffset(e3);
        var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
        return this.index += e3, t2;
      }, t.exports = i;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e2, t, r) {
      var n = e2("./DataReader");
      function i(e3) {
        n.call(this, e3);
      }
      e2("../utils").inherits(i, n), i.prototype.byteAt = function(e3) {
        return this.data.charCodeAt(this.zero + e3);
      }, i.prototype.lastIndexOfSignature = function(e3) {
        return this.data.lastIndexOf(e3) - this.zero;
      }, i.prototype.readAndCheckSignature = function(e3) {
        return e3 === this.readData(4);
      }, i.prototype.readData = function(e3) {
        this.checkOffset(e3);
        var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
        return this.index += e3, t2;
      }, t.exports = i;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e2, t, r) {
      var n = e2("./ArrayReader");
      function i(e3) {
        n.call(this, e3);
      }
      e2("../utils").inherits(i, n), i.prototype.readData = function(e3) {
        if (this.checkOffset(e3), 0 === e3)
          return new Uint8Array(0);
        var t2 = this.data.subarray(this.zero + this.index, this.zero + this.index + e3);
        return this.index += e3, t2;
      }, t.exports = i;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e2, t, r) {
      var n = e2("../utils"), i = e2("../support"), s = e2("./ArrayReader"), a = e2("./StringReader"), o = e2("./NodeBufferReader"), h2 = e2("./Uint8ArrayReader");
      t.exports = function(e3) {
        var t2 = n.getTypeOf(e3);
        return n.checkSupport(t2), "string" !== t2 || i.uint8array ? "nodebuffer" === t2 ? new o(e3) : i.uint8array ? new h2(n.transformTo("uint8array", e3)) : new s(n.transformTo("array", e3)) : new a(e3);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e2, t, r) {
      r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(e2, t, r) {
      var n = e2("./GenericWorker"), i = e2("../utils");
      function s(e3) {
        n.call(this, "ConvertWorker to " + e3), this.destType = e3;
      }
      i.inherits(s, n), s.prototype.processChunk = function(e3) {
        this.push({ data: i.transformTo(this.destType, e3.data), meta: e3.meta });
      }, t.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e2, t, r) {
      var n = e2("./GenericWorker"), i = e2("../crc32");
      function s() {
        n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      e2("../utils").inherits(s, n), s.prototype.processChunk = function(e3) {
        this.streamInfo.crc32 = i(e3.data, this.streamInfo.crc32 || 0), this.push(e3);
      }, t.exports = s;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e2, t, r) {
      var n = e2("../utils"), i = e2("./GenericWorker");
      function s(e3) {
        i.call(this, "DataLengthProbe for " + e3), this.propName = e3, this.withStreamInfo(e3, 0);
      }
      n.inherits(s, i), s.prototype.processChunk = function(e3) {
        if (e3) {
          var t2 = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = t2 + e3.data.length;
        }
        i.prototype.processChunk.call(this, e3);
      }, t.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e2, t, r) {
      var n = e2("../utils"), i = e2("./GenericWorker");
      function s(e3) {
        i.call(this, "DataWorker");
        var t2 = this;
        this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e3.then(function(e4) {
          t2.dataIsReady = true, t2.data = e4, t2.max = e4 && e4.length || 0, t2.type = n.getTypeOf(e4), t2.isPaused || t2._tickAndRepeat();
        }, function(e4) {
          t2.error(e4);
        });
      }
      n.inherits(s, i), s.prototype.cleanUp = function() {
        i.prototype.cleanUp.call(this), this.data = null;
      }, s.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
      }, s.prototype._tickAndRepeat = function() {
        this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
      }, s.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return false;
        var e3 = null, t2 = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            e3 = this.data.substring(this.index, t2);
            break;
          case "uint8array":
            e3 = this.data.subarray(this.index, t2);
            break;
          case "array":
          case "nodebuffer":
            e3 = this.data.slice(this.index, t2);
        }
        return this.index = t2, this.push({ data: e3, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, t.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e2, t, r) {
      function n(e3) {
        this.name = e3 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      n.prototype = { push: function(e3) {
        this.emit("data", e3);
      }, end: function() {
        if (this.isFinished)
          return false;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = true;
        } catch (e3) {
          this.emit("error", e3);
        }
        return true;
      }, error: function(e3) {
        return !this.isFinished && (this.isPaused ? this.generatedError = e3 : (this.isFinished = true, this.emit("error", e3), this.previous && this.previous.error(e3), this.cleanUp()), true);
      }, on: function(e3, t2) {
        return this._listeners[e3].push(t2), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(e3, t2) {
        if (this._listeners[e3])
          for (var r2 = 0; r2 < this._listeners[e3].length; r2++)
            this._listeners[e3][r2].call(this, t2);
      }, pipe: function(e3) {
        return e3.registerPrevious(this);
      }, registerPrevious: function(e3) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = e3.streamInfo, this.mergeStreamInfo(), this.previous = e3;
        var t2 = this;
        return e3.on("data", function(e4) {
          t2.processChunk(e4);
        }), e3.on("end", function() {
          t2.end();
        }), e3.on("error", function(e4) {
          t2.error(e4);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return false;
        var e3 = this.isPaused = false;
        return this.generatedError && (this.error(this.generatedError), e3 = true), this.previous && this.previous.resume(), !e3;
      }, flush: function() {
      }, processChunk: function(e3) {
        this.push(e3);
      }, withStreamInfo: function(e3, t2) {
        return this.extraStreamInfo[e3] = t2, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var e3 in this.extraStreamInfo)
          Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e3) && (this.streamInfo[e3] = this.extraStreamInfo[e3]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = true, this.previous && this.previous.lock();
      }, toString: function() {
        var e3 = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + e3 : e3;
      } }, t.exports = n;
    }, {}], 29: [function(e2, t, r) {
      var h2 = e2("../utils"), i = e2("./ConvertWorker"), s = e2("./GenericWorker"), u = e2("../base64"), n = e2("../support"), a = e2("../external"), o = null;
      if (n.nodestream)
        try {
          o = e2("../nodejs/NodejsStreamOutputAdapter");
        } catch (e3) {
        }
      function l(e3, o2) {
        return new a.Promise(function(t2, r2) {
          var n2 = [], i2 = e3._internalType, s2 = e3._outputType, a2 = e3._mimeType;
          e3.on("data", function(e4, t3) {
            n2.push(e4), o2 && o2(t3);
          }).on("error", function(e4) {
            n2 = [], r2(e4);
          }).on("end", function() {
            try {
              var e4 = function(e5, t3, r3) {
                switch (e5) {
                  case "blob":
                    return h2.newBlob(h2.transformTo("arraybuffer", t3), r3);
                  case "base64":
                    return u.encode(t3);
                  default:
                    return h2.transformTo(e5, t3);
                }
              }(s2, function(e5, t3) {
                var r3, n3 = 0, i3 = null, s3 = 0;
                for (r3 = 0; r3 < t3.length; r3++)
                  s3 += t3[r3].length;
                switch (e5) {
                  case "string":
                    return t3.join("");
                  case "array":
                    return Array.prototype.concat.apply([], t3);
                  case "uint8array":
                    for (i3 = new Uint8Array(s3), r3 = 0; r3 < t3.length; r3++)
                      i3.set(t3[r3], n3), n3 += t3[r3].length;
                    return i3;
                  case "nodebuffer":
                    return Buffer.concat(t3);
                  default:
                    throw new Error("concat : unsupported type '" + e5 + "'");
                }
              }(i2, n2), a2);
              t2(e4);
            } catch (e5) {
              r2(e5);
            }
            n2 = [];
          }).resume();
        });
      }
      function f(e3, t2, r2) {
        var n2 = t2;
        switch (t2) {
          case "blob":
          case "arraybuffer":
            n2 = "uint8array";
            break;
          case "base64":
            n2 = "string";
        }
        try {
          this._internalType = n2, this._outputType = t2, this._mimeType = r2, h2.checkSupport(n2), this._worker = e3.pipe(new i(n2)), e3.lock();
        } catch (e4) {
          this._worker = new s("error"), this._worker.error(e4);
        }
      }
      f.prototype = { accumulate: function(e3) {
        return l(this, e3);
      }, on: function(e3, t2) {
        var r2 = this;
        return "data" === e3 ? this._worker.on(e3, function(e4) {
          t2.call(r2, e4.data, e4.meta);
        }) : this._worker.on(e3, function() {
          h2.delay(t2, arguments, r2);
        }), this;
      }, resume: function() {
        return h2.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(e3) {
        if (h2.checkSupport("nodestream"), "nodebuffer" !== this._outputType)
          throw new Error(this._outputType + " is not supported by this method");
        return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e3);
      } }, t.exports = f;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e2, t, r) {
      if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer)
        r.blob = false;
      else {
        var n = new ArrayBuffer(0);
        try {
          r.blob = 0 === new Blob([n], { type: "application/zip" }).size;
        } catch (e3) {
          try {
            var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            i.append(n), r.blob = 0 === i.getBlob("application/zip").size;
          } catch (e4) {
            r.blob = false;
          }
        }
      }
      try {
        r.nodestream = !!e2("readable-stream").Readable;
      } catch (e3) {
        r.nodestream = false;
      }
    }, { "readable-stream": 16 }], 31: [function(e2, t, s) {
      for (var o = e2("./utils"), h2 = e2("./support"), r = e2("./nodejsUtils"), n = e2("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++)
        u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
      u[254] = u[254] = 1;
      function a() {
        n.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function l() {
        n.call(this, "utf-8 encode");
      }
      s.utf8encode = function(e3) {
        return h2.nodebuffer ? r.newBufferFrom(e3, "utf-8") : function(e4) {
          var t2, r2, n2, i2, s2, a2 = e4.length, o2 = 0;
          for (i2 = 0; i2 < a2; i2++)
            55296 == (64512 & (r2 = e4.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e4.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
          for (t2 = h2.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++)
            55296 == (64512 & (r2 = e4.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e4.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
          return t2;
        }(e3);
      }, s.utf8decode = function(e3) {
        return h2.nodebuffer ? o.transformTo("nodebuffer", e3).toString("utf-8") : function(e4) {
          var t2, r2, n2, i2, s2 = e4.length, a2 = new Array(2 * s2);
          for (t2 = r2 = 0; t2 < s2; )
            if ((n2 = e4[t2++]) < 128)
              a2[r2++] = n2;
            else if (4 < (i2 = u[n2]))
              a2[r2++] = 65533, t2 += i2 - 1;
            else {
              for (n2 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t2 < s2; )
                n2 = n2 << 6 | 63 & e4[t2++], i2--;
              1 < i2 ? a2[r2++] = 65533 : n2 < 65536 ? a2[r2++] = n2 : (n2 -= 65536, a2[r2++] = 55296 | n2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n2);
            }
          return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
        }(e3 = o.transformTo(h2.uint8array ? "uint8array" : "array", e3));
      }, o.inherits(a, n), a.prototype.processChunk = function(e3) {
        var t2 = o.transformTo(h2.uint8array ? "uint8array" : "array", e3.data);
        if (this.leftOver && this.leftOver.length) {
          if (h2.uint8array) {
            var r2 = t2;
            (t2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t2.set(r2, this.leftOver.length);
          } else
            t2 = this.leftOver.concat(t2);
          this.leftOver = null;
        }
        var n2 = function(e4, t3) {
          var r3;
          for ((t3 = t3 || e4.length) > e4.length && (t3 = e4.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e4[r3]); )
            r3--;
          return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u[e4[r3]] > t3 ? r3 : t3;
        }(t2), i2 = t2;
        n2 !== t2.length && (h2.uint8array ? (i2 = t2.subarray(0, n2), this.leftOver = t2.subarray(n2, t2.length)) : (i2 = t2.slice(0, n2), this.leftOver = t2.slice(n2, t2.length))), this.push({ data: s.utf8decode(i2), meta: e3.meta });
      }, a.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e3) {
        this.push({ data: s.utf8encode(e3.data), meta: e3.meta });
      }, s.Utf8EncodeWorker = l;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e2, t, a) {
      var o = e2("./support"), h2 = e2("./base64"), r = e2("./nodejsUtils"), u = e2("./external");
      function n(e3) {
        return e3;
      }
      function l(e3, t2) {
        for (var r2 = 0; r2 < e3.length; ++r2)
          t2[r2] = 255 & e3.charCodeAt(r2);
        return t2;
      }
      e2("setimmediate"), a.newBlob = function(t2, r2) {
        a.checkSupport("blob");
        try {
          return new Blob([t2], { type: r2 });
        } catch (e3) {
          try {
            var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return n2.append(t2), n2.getBlob(r2);
          } catch (e4) {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var i = { stringifyByChunk: function(e3, t2, r2) {
        var n2 = [], i2 = 0, s2 = e3.length;
        if (s2 <= r2)
          return String.fromCharCode.apply(null, e3);
        for (; i2 < s2; )
          "array" === t2 || "nodebuffer" === t2 ? n2.push(String.fromCharCode.apply(null, e3.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e3.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
        return n2.join("");
      }, stringifyByChar: function(e3) {
        for (var t2 = "", r2 = 0; r2 < e3.length; r2++)
          t2 += String.fromCharCode(e3[r2]);
        return t2;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
        } catch (e3) {
          return false;
        }
      }(), nodebuffer: function() {
        try {
          return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
        } catch (e3) {
          return false;
        }
      }() } };
      function s(e3) {
        var t2 = 65536, r2 = a.getTypeOf(e3), n2 = true;
        if ("uint8array" === r2 ? n2 = i.applyCanBeUsed.uint8array : "nodebuffer" === r2 && (n2 = i.applyCanBeUsed.nodebuffer), n2)
          for (; 1 < t2; )
            try {
              return i.stringifyByChunk(e3, r2, t2);
            } catch (e4) {
              t2 = Math.floor(t2 / 2);
            }
        return i.stringifyByChar(e3);
      }
      function f(e3, t2) {
        for (var r2 = 0; r2 < e3.length; r2++)
          t2[r2] = e3[r2];
        return t2;
      }
      a.applyFromCharCode = s;
      var c = {};
      c.string = { string: n, array: function(e3) {
        return l(e3, new Array(e3.length));
      }, arraybuffer: function(e3) {
        return c.string.uint8array(e3).buffer;
      }, uint8array: function(e3) {
        return l(e3, new Uint8Array(e3.length));
      }, nodebuffer: function(e3) {
        return l(e3, r.allocBuffer(e3.length));
      } }, c.array = { string: s, array: n, arraybuffer: function(e3) {
        return new Uint8Array(e3).buffer;
      }, uint8array: function(e3) {
        return new Uint8Array(e3);
      }, nodebuffer: function(e3) {
        return r.newBufferFrom(e3);
      } }, c.arraybuffer = { string: function(e3) {
        return s(new Uint8Array(e3));
      }, array: function(e3) {
        return f(new Uint8Array(e3), new Array(e3.byteLength));
      }, arraybuffer: n, uint8array: function(e3) {
        return new Uint8Array(e3);
      }, nodebuffer: function(e3) {
        return r.newBufferFrom(new Uint8Array(e3));
      } }, c.uint8array = { string: s, array: function(e3) {
        return f(e3, new Array(e3.length));
      }, arraybuffer: function(e3) {
        return e3.buffer;
      }, uint8array: n, nodebuffer: function(e3) {
        return r.newBufferFrom(e3);
      } }, c.nodebuffer = { string: s, array: function(e3) {
        return f(e3, new Array(e3.length));
      }, arraybuffer: function(e3) {
        return c.nodebuffer.uint8array(e3).buffer;
      }, uint8array: function(e3) {
        return f(e3, new Uint8Array(e3.length));
      }, nodebuffer: n }, a.transformTo = function(e3, t2) {
        if (t2 = t2 || "", !e3)
          return t2;
        a.checkSupport(e3);
        var r2 = a.getTypeOf(t2);
        return c[r2][e3](t2);
      }, a.resolve = function(e3) {
        for (var t2 = e3.split("/"), r2 = [], n2 = 0; n2 < t2.length; n2++) {
          var i2 = t2[n2];
          "." === i2 || "" === i2 && 0 !== n2 && n2 !== t2.length - 1 || (".." === i2 ? r2.pop() : r2.push(i2));
        }
        return r2.join("/");
      }, a.getTypeOf = function(e3) {
        return "string" == typeof e3 ? "string" : "[object Array]" === Object.prototype.toString.call(e3) ? "array" : o.nodebuffer && r.isBuffer(e3) ? "nodebuffer" : o.uint8array && e3 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e3 instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, a.checkSupport = function(e3) {
        if (!o[e3.toLowerCase()])
          throw new Error(e3 + " is not supported by this platform");
      }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e3) {
        var t2, r2, n2 = "";
        for (r2 = 0; r2 < (e3 || "").length; r2++)
          n2 += "\\x" + ((t2 = e3.charCodeAt(r2)) < 16 ? "0" : "") + t2.toString(16).toUpperCase();
        return n2;
      }, a.delay = function(e3, t2, r2) {
        setImmediate(function() {
          e3.apply(r2 || null, t2 || []);
        });
      }, a.inherits = function(e3, t2) {
        function r2() {
        }
        r2.prototype = t2.prototype, e3.prototype = new r2();
      }, a.extend = function() {
        var e3, t2, r2 = {};
        for (e3 = 0; e3 < arguments.length; e3++)
          for (t2 in arguments[e3])
            Object.prototype.hasOwnProperty.call(arguments[e3], t2) && void 0 === r2[t2] && (r2[t2] = arguments[e3][t2]);
        return r2;
      }, a.prepareContent = function(r2, e3, n2, i2, s2) {
        return u.Promise.resolve(e3).then(function(n3) {
          return o.blob && (n3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3))) && "undefined" != typeof FileReader ? new u.Promise(function(t2, r3) {
            var e4 = new FileReader();
            e4.onload = function(e5) {
              t2(e5.target.result);
            }, e4.onerror = function(e5) {
              r3(e5.target.error);
            }, e4.readAsArrayBuffer(n3);
          }) : n3;
        }).then(function(e4) {
          var t2 = a.getTypeOf(e4);
          return t2 ? ("arraybuffer" === t2 ? e4 = a.transformTo("uint8array", e4) : "string" === t2 && (s2 ? e4 = h2.decode(e4) : n2 && true !== i2 && (e4 = function(e5) {
            return l(e5, o.uint8array ? new Uint8Array(e5.length) : new Array(e5.length));
          }(e4))), e4) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e2, t, r) {
      var n = e2("./reader/readerFor"), i = e2("./utils"), s = e2("./signature"), a = e2("./zipEntry"), o = e2("./support");
      function h2(e3) {
        this.files = [], this.loadOptions = e3;
      }
      h2.prototype = { checkSignature: function(e3) {
        if (!this.reader.readAndCheckSignature(e3)) {
          this.reader.index -= 4;
          var t2 = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t2) + ", expected " + i.pretty(e3) + ")");
        }
      }, isSignature: function(e3, t2) {
        var r2 = this.reader.index;
        this.reader.setIndex(e3);
        var n2 = this.reader.readString(4) === t2;
        return this.reader.setIndex(r2), n2;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var e3 = this.reader.readData(this.zipCommentLength), t2 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t2, e3);
        this.zipComment = this.loadOptions.decodeFileName(r2);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var e3, t2, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; )
          e3 = this.reader.readInt(2), t2 = this.reader.readInt(4), r2 = this.reader.readData(t2), this.zip64ExtensibleData[e3] = { id: e3, length: t2, value: r2 };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var e3, t2;
        for (e3 = 0; e3 < this.files.length; e3++)
          t2 = this.files[e3], this.reader.setIndex(t2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t2.readLocalPart(this.reader), t2.handleUTF8(), t2.processAttributes();
      }, readCentralDir: function() {
        var e3;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); )
          (e3 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e3);
        if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var e3 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
        if (e3 < 0)
          throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
        this.reader.setIndex(e3);
        var t2 = e3;
        if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
          if (this.zip64 = true, (e3 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(e3), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var r2 = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
        var n2 = t2 - r2;
        if (0 < n2)
          this.isSignature(t2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
        else if (n2 < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
      }, prepareReader: function(e3) {
        this.reader = n(e3);
      }, load: function(e3) {
        this.prepareReader(e3), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, t.exports = h2;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e2, t, r) {
      var n = e2("./reader/readerFor"), s = e2("./utils"), i = e2("./compressedObject"), a = e2("./crc32"), o = e2("./utf8"), h2 = e2("./compressions"), u = e2("./support");
      function l(e3, t2) {
        this.options = e3, this.loadOptions = t2;
      }
      l.prototype = { isEncrypted: function() {
        return 1 == (1 & this.bitFlag);
      }, useUTF8: function() {
        return 2048 == (2048 & this.bitFlag);
      }, readLocalPart: function(e3) {
        var t2, r2;
        if (e3.skip(22), this.fileNameLength = e3.readInt(2), r2 = e3.readInt(2), this.fileName = e3.readData(this.fileNameLength), e3.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if (null === (t2 = function(e4) {
          for (var t3 in h2)
            if (Object.prototype.hasOwnProperty.call(h2, t3) && h2[t3].magic === e4)
              return h2[t3];
          return null;
        }(this.compressionMethod)))
          throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
        this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t2, e3.readData(this.compressedSize));
      }, readCentralPart: function(e3) {
        this.versionMadeBy = e3.readInt(2), e3.skip(2), this.bitFlag = e3.readInt(2), this.compressionMethod = e3.readString(2), this.date = e3.readDate(), this.crc32 = e3.readInt(4), this.compressedSize = e3.readInt(4), this.uncompressedSize = e3.readInt(4);
        var t2 = e3.readInt(2);
        if (this.extraFieldsLength = e3.readInt(2), this.fileCommentLength = e3.readInt(2), this.diskNumberStart = e3.readInt(2), this.internalFileAttributes = e3.readInt(2), this.externalFileAttributes = e3.readInt(4), this.localHeaderOffset = e3.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        e3.skip(t2), this.readExtraFields(e3), this.parseZIP64ExtraField(e3), this.fileComment = e3.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var e3 = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), 0 == e3 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var e3 = n(this.extraFields[1].value);
          this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e3.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e3.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e3.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e3.readInt(4));
        }
      }, readExtraFields: function(e3) {
        var t2, r2, n2, i2 = e3.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); e3.index + 4 < i2; )
          t2 = e3.readInt(2), r2 = e3.readInt(2), n2 = e3.readData(r2), this.extraFields[t2] = { id: t2, length: r2, value: n2 };
        e3.setIndex(i2);
      }, handleUTF8: function() {
        var e3 = u.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
        else {
          var t2 = this.findExtraFieldUnicodePath();
          if (null !== t2)
            this.fileNameStr = t2;
          else {
            var r2 = s.transformTo(e3, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(r2);
          }
          var n2 = this.findExtraFieldUnicodeComment();
          if (null !== n2)
            this.fileCommentStr = n2;
          else {
            var i2 = s.transformTo(e3, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(i2);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var e3 = this.extraFields[28789];
        if (e3) {
          var t2 = n(e3.value);
          return 1 !== t2.readInt(1) ? null : a(this.fileName) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e3.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var e3 = this.extraFields[25461];
        if (e3) {
          var t2 = n(e3.value);
          return 1 !== t2.readInt(1) ? null : a(this.fileComment) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e3.length - 5));
        }
        return null;
      } }, t.exports = l;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e2, t, r) {
      function n(e3, t2, r2) {
        this.name = e3, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
      }
      var s = e2("./stream/StreamHelper"), i = e2("./stream/DataWorker"), a = e2("./utf8"), o = e2("./compressedObject"), h2 = e2("./stream/GenericWorker");
      n.prototype = { internalStream: function(e3) {
        var t2 = null, r2 = "string";
        try {
          if (!e3)
            throw new Error("No output type specified.");
          var n2 = "string" === (r2 = e3.toLowerCase()) || "text" === r2;
          "binarystring" !== r2 && "text" !== r2 || (r2 = "string"), t2 = this._decompressWorker();
          var i2 = !this._dataBinary;
          i2 && !n2 && (t2 = t2.pipe(new a.Utf8EncodeWorker())), !i2 && n2 && (t2 = t2.pipe(new a.Utf8DecodeWorker()));
        } catch (e4) {
          (t2 = new h2("error")).error(e4);
        }
        return new s(t2, r2, "");
      }, async: function(e3, t2) {
        return this.internalStream(e3).accumulate(t2);
      }, nodeStream: function(e3, t2) {
        return this.internalStream(e3 || "nodebuffer").toNodejsStream(t2);
      }, _compressWorker: function(e3, t2) {
        if (this._data instanceof o && this._data.compression.magic === e3.magic)
          return this._data.getCompressedWorker();
        var r2 = this._decompressWorker();
        return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e3, t2);
      }, _decompressWorker: function() {
        return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h2 ? this._data : new i(this._data);
      } };
      for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, f = 0; f < u.length; f++)
        n.prototype[u[f]] = l;
      t.exports = n;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e2, l, t) {
      (function(t2) {
        var r, n, e3 = t2.MutationObserver || t2.WebKitMutationObserver;
        if (e3) {
          var i = 0, s = new e3(u), a = t2.document.createTextNode("");
          s.observe(a, { characterData: true }), r = function() {
            a.data = i = ++i % 2;
          };
        } else if (t2.setImmediate || void 0 === t2.MessageChannel)
          r = "document" in t2 && "onreadystatechange" in t2.document.createElement("script") ? function() {
            var e4 = t2.document.createElement("script");
            e4.onreadystatechange = function() {
              u(), e4.onreadystatechange = null, e4.parentNode.removeChild(e4), e4 = null;
            }, t2.document.documentElement.appendChild(e4);
          } : function() {
            setTimeout(u, 0);
          };
        else {
          var o = new t2.MessageChannel();
          o.port1.onmessage = u, r = function() {
            o.port2.postMessage(0);
          };
        }
        var h2 = [];
        function u() {
          var e4, t3;
          n = true;
          for (var r2 = h2.length; r2; ) {
            for (t3 = h2, h2 = [], e4 = -1; ++e4 < r2; )
              t3[e4]();
            r2 = h2.length;
          }
          n = false;
        }
        l.exports = function(e4) {
          1 !== h2.push(e4) || n || r();
        };
      }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {}], 37: [function(e2, t, r) {
      var i = e2("immediate");
      function u() {
      }
      var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
      function o(e3) {
        if ("function" != typeof e3)
          throw new TypeError("resolver must be a function");
        this.state = n, this.queue = [], this.outcome = void 0, e3 !== u && d(this, e3);
      }
      function h2(e3, t2, r2) {
        this.promise = e3, "function" == typeof t2 && (this.onFulfilled = t2, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
      }
      function f(t2, r2, n2) {
        i(function() {
          var e3;
          try {
            e3 = r2(n2);
          } catch (e4) {
            return l.reject(t2, e4);
          }
          e3 === t2 ? l.reject(t2, new TypeError("Cannot resolve promise with itself")) : l.resolve(t2, e3);
        });
      }
      function c(e3) {
        var t2 = e3 && e3.then;
        if (e3 && ("object" == typeof e3 || "function" == typeof e3) && "function" == typeof t2)
          return function() {
            t2.apply(e3, arguments);
          };
      }
      function d(t2, e3) {
        var r2 = false;
        function n2(e4) {
          r2 || (r2 = true, l.reject(t2, e4));
        }
        function i2(e4) {
          r2 || (r2 = true, l.resolve(t2, e4));
        }
        var s2 = p2(function() {
          e3(i2, n2);
        });
        "error" === s2.status && n2(s2.value);
      }
      function p2(e3, t2) {
        var r2 = {};
        try {
          r2.value = e3(t2), r2.status = "success";
        } catch (e4) {
          r2.status = "error", r2.value = e4;
        }
        return r2;
      }
      (t.exports = o).prototype.finally = function(t2) {
        if ("function" != typeof t2)
          return this;
        var r2 = this.constructor;
        return this.then(function(e3) {
          return r2.resolve(t2()).then(function() {
            return e3;
          });
        }, function(e3) {
          return r2.resolve(t2()).then(function() {
            throw e3;
          });
        });
      }, o.prototype.catch = function(e3) {
        return this.then(null, e3);
      }, o.prototype.then = function(e3, t2) {
        if ("function" != typeof e3 && this.state === a || "function" != typeof t2 && this.state === s)
          return this;
        var r2 = new this.constructor(u);
        this.state !== n ? f(r2, this.state === a ? e3 : t2, this.outcome) : this.queue.push(new h2(r2, e3, t2));
        return r2;
      }, h2.prototype.callFulfilled = function(e3) {
        l.resolve(this.promise, e3);
      }, h2.prototype.otherCallFulfilled = function(e3) {
        f(this.promise, this.onFulfilled, e3);
      }, h2.prototype.callRejected = function(e3) {
        l.reject(this.promise, e3);
      }, h2.prototype.otherCallRejected = function(e3) {
        f(this.promise, this.onRejected, e3);
      }, l.resolve = function(e3, t2) {
        var r2 = p2(c, t2);
        if ("error" === r2.status)
          return l.reject(e3, r2.value);
        var n2 = r2.value;
        if (n2)
          d(e3, n2);
        else {
          e3.state = a, e3.outcome = t2;
          for (var i2 = -1, s2 = e3.queue.length; ++i2 < s2; )
            e3.queue[i2].callFulfilled(t2);
        }
        return e3;
      }, l.reject = function(e3, t2) {
        e3.state = s, e3.outcome = t2;
        for (var r2 = -1, n2 = e3.queue.length; ++r2 < n2; )
          e3.queue[r2].callRejected(t2);
        return e3;
      }, o.resolve = function(e3) {
        if (e3 instanceof this)
          return e3;
        return l.resolve(new this(u), e3);
      }, o.reject = function(e3) {
        var t2 = new this(u);
        return l.reject(t2, e3);
      }, o.all = function(e3) {
        var r2 = this;
        if ("[object Array]" !== Object.prototype.toString.call(e3))
          return this.reject(new TypeError("must be an array"));
        var n2 = e3.length, i2 = false;
        if (!n2)
          return this.resolve([]);
        var s2 = new Array(n2), a2 = 0, t2 = -1, o2 = new this(u);
        for (; ++t2 < n2; )
          h3(e3[t2], t2);
        return o2;
        function h3(e4, t3) {
          r2.resolve(e4).then(function(e5) {
            s2[t3] = e5, ++a2 !== n2 || i2 || (i2 = true, l.resolve(o2, s2));
          }, function(e5) {
            i2 || (i2 = true, l.reject(o2, e5));
          });
        }
      }, o.race = function(e3) {
        var t2 = this;
        if ("[object Array]" !== Object.prototype.toString.call(e3))
          return this.reject(new TypeError("must be an array"));
        var r2 = e3.length, n2 = false;
        if (!r2)
          return this.resolve([]);
        var i2 = -1, s2 = new this(u);
        for (; ++i2 < r2; )
          a2 = e3[i2], t2.resolve(a2).then(function(e4) {
            n2 || (n2 = true, l.resolve(s2, e4));
          }, function(e4) {
            n2 || (n2 = true, l.reject(s2, e4));
          });
        var a2;
        return s2;
      };
    }, { immediate: 36 }], 38: [function(e2, t, r) {
      var n = {};
      (0, e2("./lib/utils/common").assign)(n, e2("./lib/deflate"), e2("./lib/inflate"), e2("./lib/zlib/constants")), t.exports = n;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e2, t, r) {
      var a = e2("./zlib/deflate"), o = e2("./utils/common"), h2 = e2("./utils/strings"), i = e2("./zlib/messages"), s = e2("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;
      function p2(e3) {
        if (!(this instanceof p2))
          return new p2(e3);
        this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e3 || {});
        var t2 = this.options;
        t2.raw && 0 < t2.windowBits ? t2.windowBits = -t2.windowBits : t2.gzip && 0 < t2.windowBits && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
        var r2 = a.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
        if (r2 !== l)
          throw new Error(i[r2]);
        if (t2.header && a.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
          var n2;
          if (n2 = "string" == typeof t2.dictionary ? h2.string2buf(t2.dictionary) : "[object ArrayBuffer]" === u.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, (r2 = a.deflateSetDictionary(this.strm, n2)) !== l)
            throw new Error(i[r2]);
          this._dict_set = true;
        }
      }
      function n(e3, t2) {
        var r2 = new p2(t2);
        if (r2.push(e3, true), r2.err)
          throw r2.msg || i[r2.err];
        return r2.result;
      }
      p2.prototype.push = function(e3, t2) {
        var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;
        if (this.ended)
          return false;
        n2 = t2 === ~~t2 ? t2 : true === t2 ? 4 : 0, "string" == typeof e3 ? i2.input = h2.string2buf(e3) : "[object ArrayBuffer]" === u.call(e3) ? i2.input = new Uint8Array(e3) : i2.input = e3, i2.next_in = 0, i2.avail_in = i2.input.length;
        do {
          if (0 === i2.avail_out && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), 1 !== (r2 = a.deflate(i2, n2)) && r2 !== l)
            return this.onEnd(r2), !(this.ended = true);
          0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n2 && 2 !== n2) || ("string" === this.options.to ? this.onData(h2.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
        } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r2);
        return 4 === n2 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : 2 !== n2 || (this.onEnd(l), !(i2.avail_out = 0));
      }, p2.prototype.onData = function(e3) {
        this.chunks.push(e3);
      }, p2.prototype.onEnd = function(e3) {
        e3 === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
      }, r.Deflate = p2, r.deflate = n, r.deflateRaw = function(e3, t2) {
        return (t2 = t2 || {}).raw = true, n(e3, t2);
      }, r.gzip = function(e3, t2) {
        return (t2 = t2 || {}).gzip = true, n(e3, t2);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e2, t, r) {
      var c = e2("./zlib/inflate"), d = e2("./utils/common"), p2 = e2("./utils/strings"), m = e2("./zlib/constants"), n = e2("./zlib/messages"), i = e2("./zlib/zstream"), s = e2("./zlib/gzheader"), _ = Object.prototype.toString;
      function a(e3) {
        if (!(this instanceof a))
          return new a(e3);
        this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e3 || {});
        var t2 = this.options;
        t2.raw && 0 <= t2.windowBits && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(0 <= t2.windowBits && t2.windowBits < 16) || e3 && e3.windowBits || (t2.windowBits += 32), 15 < t2.windowBits && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
        var r2 = c.inflateInit2(this.strm, t2.windowBits);
        if (r2 !== m.Z_OK)
          throw new Error(n[r2]);
        this.header = new s(), c.inflateGetHeader(this.strm, this.header);
      }
      function o(e3, t2) {
        var r2 = new a(t2);
        if (r2.push(e3, true), r2.err)
          throw r2.msg || n[r2.err];
        return r2.result;
      }
      a.prototype.push = function(e3, t2) {
        var r2, n2, i2, s2, a2, o2, h2 = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
        if (this.ended)
          return false;
        n2 = t2 === ~~t2 ? t2 : true === t2 ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e3 ? h2.input = p2.binstring2buf(e3) : "[object ArrayBuffer]" === _.call(e3) ? h2.input = new Uint8Array(e3) : h2.input = e3, h2.next_in = 0, h2.avail_in = h2.input.length;
        do {
          if (0 === h2.avail_out && (h2.output = new d.Buf8(u), h2.next_out = 0, h2.avail_out = u), (r2 = c.inflate(h2, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = "string" == typeof l ? p2.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r2 = c.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && true === f && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK)
            return this.onEnd(r2), !(this.ended = true);
          h2.next_out && (0 !== h2.avail_out && r2 !== m.Z_STREAM_END && (0 !== h2.avail_in || n2 !== m.Z_FINISH && n2 !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = p2.utf8border(h2.output, h2.next_out), s2 = h2.next_out - i2, a2 = p2.buf2string(h2.output, i2), h2.next_out = s2, h2.avail_out = u - s2, s2 && d.arraySet(h2.output, h2.output, i2, s2, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h2.output, h2.next_out)))), 0 === h2.avail_in && 0 === h2.avail_out && (f = true);
        } while ((0 < h2.avail_in || 0 === h2.avail_out) && r2 !== m.Z_STREAM_END);
        return r2 === m.Z_STREAM_END && (n2 = m.Z_FINISH), n2 === m.Z_FINISH ? (r2 = c.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h2.avail_out = 0));
      }, a.prototype.onData = function(e3) {
        this.chunks.push(e3);
      }, a.prototype.onEnd = function(e3) {
        e3 === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
      }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e3, t2) {
        return (t2 = t2 || {}).raw = true, o(e3, t2);
      }, r.ungzip = o;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e2, t, r) {
      var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
      r.assign = function(e3) {
        for (var t2 = Array.prototype.slice.call(arguments, 1); t2.length; ) {
          var r2 = t2.shift();
          if (r2) {
            if ("object" != typeof r2)
              throw new TypeError(r2 + "must be non-object");
            for (var n2 in r2)
              r2.hasOwnProperty(n2) && (e3[n2] = r2[n2]);
          }
        }
        return e3;
      }, r.shrinkBuf = function(e3, t2) {
        return e3.length === t2 ? e3 : e3.subarray ? e3.subarray(0, t2) : (e3.length = t2, e3);
      };
      var i = { arraySet: function(e3, t2, r2, n2, i2) {
        if (t2.subarray && e3.subarray)
          e3.set(t2.subarray(r2, r2 + n2), i2);
        else
          for (var s2 = 0; s2 < n2; s2++)
            e3[i2 + s2] = t2[r2 + s2];
      }, flattenChunks: function(e3) {
        var t2, r2, n2, i2, s2, a;
        for (t2 = n2 = 0, r2 = e3.length; t2 < r2; t2++)
          n2 += e3[t2].length;
        for (a = new Uint8Array(n2), t2 = i2 = 0, r2 = e3.length; t2 < r2; t2++)
          s2 = e3[t2], a.set(s2, i2), i2 += s2.length;
        return a;
      } }, s = { arraySet: function(e3, t2, r2, n2, i2) {
        for (var s2 = 0; s2 < n2; s2++)
          e3[i2 + s2] = t2[r2 + s2];
      }, flattenChunks: function(e3) {
        return [].concat.apply([], e3);
      } };
      r.setTyped = function(e3) {
        e3 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
      }, r.setTyped(n);
    }, {}], 42: [function(e2, t, r) {
      var h2 = e2("./common"), i = true, s = true;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch (e3) {
        i = false;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (e3) {
        s = false;
      }
      for (var u = new h2.Buf8(256), n = 0; n < 256; n++)
        u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
      function l(e3, t2) {
        if (t2 < 65537 && (e3.subarray && s || !e3.subarray && i))
          return String.fromCharCode.apply(null, h2.shrinkBuf(e3, t2));
        for (var r2 = "", n2 = 0; n2 < t2; n2++)
          r2 += String.fromCharCode(e3[n2]);
        return r2;
      }
      u[254] = u[254] = 1, r.string2buf = function(e3) {
        var t2, r2, n2, i2, s2, a = e3.length, o = 0;
        for (i2 = 0; i2 < a; i2++)
          55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
        for (t2 = new h2.Buf8(o), i2 = s2 = 0; s2 < o; i2++)
          55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
        return t2;
      }, r.buf2binstring = function(e3) {
        return l(e3, e3.length);
      }, r.binstring2buf = function(e3) {
        for (var t2 = new h2.Buf8(e3.length), r2 = 0, n2 = t2.length; r2 < n2; r2++)
          t2[r2] = e3.charCodeAt(r2);
        return t2;
      }, r.buf2string = function(e3, t2) {
        var r2, n2, i2, s2, a = t2 || e3.length, o = new Array(2 * a);
        for (r2 = n2 = 0; r2 < a; )
          if ((i2 = e3[r2++]) < 128)
            o[n2++] = i2;
          else if (4 < (s2 = u[i2]))
            o[n2++] = 65533, r2 += s2 - 1;
          else {
            for (i2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r2 < a; )
              i2 = i2 << 6 | 63 & e3[r2++], s2--;
            1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
          }
        return l(o, n2);
      }, r.utf8border = function(e3, t2) {
        var r2;
        for ((t2 = t2 || e3.length) > e3.length && (t2 = e3.length), r2 = t2 - 1; 0 <= r2 && 128 == (192 & e3[r2]); )
          r2--;
        return r2 < 0 ? t2 : 0 === r2 ? t2 : r2 + u[e3[r2]] > t2 ? r2 : t2;
      };
    }, { "./common": 41 }], 43: [function(e2, t, r) {
      t.exports = function(e3, t2, r2, n) {
        for (var i = 65535 & e3 | 0, s = e3 >>> 16 & 65535 | 0, a = 0; 0 !== r2; ) {
          for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t2[n++] | 0) | 0, --a; )
            ;
          i %= 65521, s %= 65521;
        }
        return i | s << 16 | 0;
      };
    }, {}], 44: [function(e2, t, r) {
      t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(e2, t, r) {
      var o = function() {
        for (var e3, t2 = [], r2 = 0; r2 < 256; r2++) {
          e3 = r2;
          for (var n = 0; n < 8; n++)
            e3 = 1 & e3 ? 3988292384 ^ e3 >>> 1 : e3 >>> 1;
          t2[r2] = e3;
        }
        return t2;
      }();
      t.exports = function(e3, t2, r2, n) {
        var i = o, s = n + r2;
        e3 ^= -1;
        for (var a = n; a < s; a++)
          e3 = e3 >>> 8 ^ i[255 & (e3 ^ t2[a])];
        return -1 ^ e3;
      };
    }, {}], 46: [function(e2, t, r) {
      var h2, c = e2("../utils/common"), u = e2("./trees"), d = e2("./adler32"), p2 = e2("./crc32"), n = e2("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S2 = 258, z = S2 + x + 1, C = 42, E2 = 113, A = 1, I2 = 2, O = 3, B = 4;
      function R2(e3, t2) {
        return e3.msg = n[t2], t2;
      }
      function T2(e3) {
        return (e3 << 1) - (4 < e3 ? 9 : 0);
      }
      function D(e3) {
        for (var t2 = e3.length; 0 <= --t2; )
          e3[t2] = 0;
      }
      function F(e3) {
        var t2 = e3.state, r2 = t2.pending;
        r2 > e3.avail_out && (r2 = e3.avail_out), 0 !== r2 && (c.arraySet(e3.output, t2.pending_buf, t2.pending_out, r2, e3.next_out), e3.next_out += r2, t2.pending_out += r2, e3.total_out += r2, e3.avail_out -= r2, t2.pending -= r2, 0 === t2.pending && (t2.pending_out = 0));
      }
      function N(e3, t2) {
        u._tr_flush_block(e3, 0 <= e3.block_start ? e3.block_start : -1, e3.strstart - e3.block_start, t2), e3.block_start = e3.strstart, F(e3.strm);
      }
      function U(e3, t2) {
        e3.pending_buf[e3.pending++] = t2;
      }
      function P(e3, t2) {
        e3.pending_buf[e3.pending++] = t2 >>> 8 & 255, e3.pending_buf[e3.pending++] = 255 & t2;
      }
      function L2(e3, t2) {
        var r2, n2, i2 = e3.max_chain_length, s2 = e3.strstart, a2 = e3.prev_length, o2 = e3.nice_match, h3 = e3.strstart > e3.w_size - z ? e3.strstart - (e3.w_size - z) : 0, u2 = e3.window, l2 = e3.w_mask, f2 = e3.prev, c2 = e3.strstart + S2, d2 = u2[s2 + a2 - 1], p3 = u2[s2 + a2];
        e3.prev_length >= e3.good_match && (i2 >>= 2), o2 > e3.lookahead && (o2 = e3.lookahead);
        do {
          if (u2[(r2 = t2) + a2] === p3 && u2[r2 + a2 - 1] === d2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
            s2 += 2, r2++;
            do {
            } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c2);
            if (n2 = S2 - (c2 - s2), s2 = c2 - S2, a2 < n2) {
              if (e3.match_start = t2, o2 <= (a2 = n2))
                break;
              d2 = u2[s2 + a2 - 1], p3 = u2[s2 + a2];
            }
          }
        } while ((t2 = f2[t2 & l2]) > h3 && 0 != --i2);
        return a2 <= e3.lookahead ? a2 : e3.lookahead;
      }
      function j(e3) {
        var t2, r2, n2, i2, s2, a2, o2, h3, u2, l2, f2 = e3.w_size;
        do {
          if (i2 = e3.window_size - e3.lookahead - e3.strstart, e3.strstart >= f2 + (f2 - z)) {
            for (c.arraySet(e3.window, e3.window, f2, f2, 0), e3.match_start -= f2, e3.strstart -= f2, e3.block_start -= f2, t2 = r2 = e3.hash_size; n2 = e3.head[--t2], e3.head[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
              ;
            for (t2 = r2 = f2; n2 = e3.prev[--t2], e3.prev[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
              ;
            i2 += f2;
          }
          if (0 === e3.strm.avail_in)
            break;
          if (a2 = e3.strm, o2 = e3.window, h3 = e3.strstart + e3.lookahead, u2 = i2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = 0 === l2 ? 0 : (a2.avail_in -= l2, c.arraySet(o2, a2.input, a2.next_in, l2, h3), 1 === a2.state.wrap ? a2.adler = d(a2.adler, o2, l2, h3) : 2 === a2.state.wrap && (a2.adler = p2(a2.adler, o2, l2, h3)), a2.next_in += l2, a2.total_in += l2, l2), e3.lookahead += r2, e3.lookahead + e3.insert >= x)
            for (s2 = e3.strstart - e3.insert, e3.ins_h = e3.window[s2], e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[s2 + 1]) & e3.hash_mask; e3.insert && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[s2 + x - 1]) & e3.hash_mask, e3.prev[s2 & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = s2, s2++, e3.insert--, !(e3.lookahead + e3.insert < x)); )
              ;
        } while (e3.lookahead < z && 0 !== e3.strm.avail_in);
      }
      function Z(e3, t2) {
        for (var r2, n2; ; ) {
          if (e3.lookahead < z) {
            if (j(e3), e3.lookahead < z && t2 === l)
              return A;
            if (0 === e3.lookahead)
              break;
          }
          if (r2 = 0, e3.lookahead >= x && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x - 1]) & e3.hash_mask, r2 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), 0 !== r2 && e3.strstart - r2 <= e3.w_size - z && (e3.match_length = L2(e3, r2)), e3.match_length >= x)
            if (n2 = u._tr_tally(e3, e3.strstart - e3.match_start, e3.match_length - x), e3.lookahead -= e3.match_length, e3.match_length <= e3.max_lazy_match && e3.lookahead >= x) {
              for (e3.match_length--; e3.strstart++, e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x - 1]) & e3.hash_mask, r2 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart, 0 != --e3.match_length; )
                ;
              e3.strstart++;
            } else
              e3.strstart += e3.match_length, e3.match_length = 0, e3.ins_h = e3.window[e3.strstart], e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + 1]) & e3.hash_mask;
          else
            n2 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++;
          if (n2 && (N(e3, false), 0 === e3.strm.avail_out))
            return A;
        }
        return e3.insert = e3.strstart < x - 1 ? e3.strstart : x - 1, t2 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I2;
      }
      function W(e3, t2) {
        for (var r2, n2, i2; ; ) {
          if (e3.lookahead < z) {
            if (j(e3), e3.lookahead < z && t2 === l)
              return A;
            if (0 === e3.lookahead)
              break;
          }
          if (r2 = 0, e3.lookahead >= x && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x - 1]) & e3.hash_mask, r2 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), e3.prev_length = e3.match_length, e3.prev_match = e3.match_start, e3.match_length = x - 1, 0 !== r2 && e3.prev_length < e3.max_lazy_match && e3.strstart - r2 <= e3.w_size - z && (e3.match_length = L2(e3, r2), e3.match_length <= 5 && (1 === e3.strategy || e3.match_length === x && 4096 < e3.strstart - e3.match_start) && (e3.match_length = x - 1)), e3.prev_length >= x && e3.match_length <= e3.prev_length) {
            for (i2 = e3.strstart + e3.lookahead - x, n2 = u._tr_tally(e3, e3.strstart - 1 - e3.prev_match, e3.prev_length - x), e3.lookahead -= e3.prev_length - 1, e3.prev_length -= 2; ++e3.strstart <= i2 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x - 1]) & e3.hash_mask, r2 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), 0 != --e3.prev_length; )
              ;
            if (e3.match_available = 0, e3.match_length = x - 1, e3.strstart++, n2 && (N(e3, false), 0 === e3.strm.avail_out))
              return A;
          } else if (e3.match_available) {
            if ((n2 = u._tr_tally(e3, 0, e3.window[e3.strstart - 1])) && N(e3, false), e3.strstart++, e3.lookahead--, 0 === e3.strm.avail_out)
              return A;
          } else
            e3.match_available = 1, e3.strstart++, e3.lookahead--;
        }
        return e3.match_available && (n2 = u._tr_tally(e3, 0, e3.window[e3.strstart - 1]), e3.match_available = 0), e3.insert = e3.strstart < x - 1 ? e3.strstart : x - 1, t2 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I2;
      }
      function M(e3, t2, r2, n2, i2) {
        this.good_length = e3, this.max_lazy = t2, this.nice_length = r2, this.max_chain = n2, this.func = i2;
      }
      function H() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function G(e3) {
        var t2;
        return e3 && e3.state ? (e3.total_in = e3.total_out = 0, e3.data_type = i, (t2 = e3.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? C : E2, e3.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = l, u._tr_init(t2), m) : R2(e3, _);
      }
      function K(e3) {
        var t2 = G(e3);
        return t2 === m && function(e4) {
          e4.window_size = 2 * e4.w_size, D(e4.head), e4.max_lazy_match = h2[e4.level].max_lazy, e4.good_match = h2[e4.level].good_length, e4.nice_match = h2[e4.level].nice_length, e4.max_chain_length = h2[e4.level].max_chain, e4.strstart = 0, e4.block_start = 0, e4.lookahead = 0, e4.insert = 0, e4.match_length = e4.prev_length = x - 1, e4.match_available = 0, e4.ins_h = 0;
        }(e3.state), t2;
      }
      function Y2(e3, t2, r2, n2, i2, s2) {
        if (!e3)
          return _;
        var a2 = 1;
        if (t2 === g && (t2 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y < i2 || r2 !== v || n2 < 8 || 15 < n2 || t2 < 0 || 9 < t2 || s2 < 0 || b < s2)
          return R2(e3, _);
        8 === n2 && (n2 = 9);
        var o2 = new H();
        return (e3.state = o2).strm = e3, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t2, o2.strategy = s2, o2.method = r2, K(e3);
      }
      h2 = [new M(0, 0, 0, 0, function(e3, t2) {
        var r2 = 65535;
        for (r2 > e3.pending_buf_size - 5 && (r2 = e3.pending_buf_size - 5); ; ) {
          if (e3.lookahead <= 1) {
            if (j(e3), 0 === e3.lookahead && t2 === l)
              return A;
            if (0 === e3.lookahead)
              break;
          }
          e3.strstart += e3.lookahead, e3.lookahead = 0;
          var n2 = e3.block_start + r2;
          if ((0 === e3.strstart || e3.strstart >= n2) && (e3.lookahead = e3.strstart - n2, e3.strstart = n2, N(e3, false), 0 === e3.strm.avail_out))
            return A;
          if (e3.strstart - e3.block_start >= e3.w_size - z && (N(e3, false), 0 === e3.strm.avail_out))
            return A;
        }
        return e3.insert = 0, t2 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : (e3.strstart > e3.block_start && (N(e3, false), e3.strm.avail_out), A);
      }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(e3, t2) {
        return Y2(e3, t2, v, 15, 8, 0);
      }, r.deflateInit2 = Y2, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(e3, t2) {
        return e3 && e3.state ? 2 !== e3.state.wrap ? _ : (e3.state.gzhead = t2, m) : _;
      }, r.deflate = function(e3, t2) {
        var r2, n2, i2, s2;
        if (!e3 || !e3.state || 5 < t2 || t2 < 0)
          return e3 ? R2(e3, _) : _;
        if (n2 = e3.state, !e3.output || !e3.input && 0 !== e3.avail_in || 666 === n2.status && t2 !== f)
          return R2(e3, 0 === e3.avail_out ? -5 : _);
        if (n2.strm = e3, r2 = n2.last_flush, n2.last_flush = t2, n2.status === C)
          if (2 === n2.wrap)
            e3.adler = 0, U(n2, 31), U(n2, 139), U(n2, 8), n2.gzhead ? (U(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U(n2, 255 & n2.gzhead.time), U(n2, n2.gzhead.time >> 8 & 255), U(n2, n2.gzhead.time >> 16 & 255), U(n2, n2.gzhead.time >> 24 & 255), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U(n2, 255 & n2.gzhead.extra.length), U(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e3.adler = p2(e3.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 3), n2.status = E2);
          else {
            var a2 = v + (n2.w_bits - 8 << 4) << 8;
            a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E2, P(n2, a2), 0 !== n2.strstart && (P(n2, e3.adler >>> 16), P(n2, 65535 & e3.adler)), e3.adler = 1;
          }
        if (69 === n2.status)
          if (n2.gzhead.extra) {
            for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e3.adler = p2(e3.adler, n2.pending_buf, n2.pending - i2, i2)), F(e3), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); )
              U(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
            n2.gzhead.hcrc && n2.pending > i2 && (e3.adler = p2(e3.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
          } else
            n2.status = 73;
        if (73 === n2.status)
          if (n2.gzhead.name) {
            i2 = n2.pending;
            do {
              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e3.adler = p2(e3.adler, n2.pending_buf, n2.pending - i2, i2)), F(e3), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
            } while (0 !== s2);
            n2.gzhead.hcrc && n2.pending > i2 && (e3.adler = p2(e3.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.gzindex = 0, n2.status = 91);
          } else
            n2.status = 91;
        if (91 === n2.status)
          if (n2.gzhead.comment) {
            i2 = n2.pending;
            do {
              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e3.adler = p2(e3.adler, n2.pending_buf, n2.pending - i2, i2)), F(e3), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
            } while (0 !== s2);
            n2.gzhead.hcrc && n2.pending > i2 && (e3.adler = p2(e3.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.status = 103);
          } else
            n2.status = 103;
        if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F(e3), n2.pending + 2 <= n2.pending_buf_size && (U(n2, 255 & e3.adler), U(n2, e3.adler >> 8 & 255), e3.adler = 0, n2.status = E2)) : n2.status = E2), 0 !== n2.pending) {
          if (F(e3), 0 === e3.avail_out)
            return n2.last_flush = -1, m;
        } else if (0 === e3.avail_in && T2(t2) <= T2(r2) && t2 !== f)
          return R2(e3, -5);
        if (666 === n2.status && 0 !== e3.avail_in)
          return R2(e3, -5);
        if (0 !== e3.avail_in || 0 !== n2.lookahead || t2 !== l && 666 !== n2.status) {
          var o2 = 2 === n2.strategy ? function(e4, t3) {
            for (var r3; ; ) {
              if (0 === e4.lookahead && (j(e4), 0 === e4.lookahead)) {
                if (t3 === l)
                  return A;
                break;
              }
              if (e4.match_length = 0, r3 = u._tr_tally(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++, r3 && (N(e4, false), 0 === e4.strm.avail_out))
                return A;
            }
            return e4.insert = 0, t3 === f ? (N(e4, true), 0 === e4.strm.avail_out ? O : B) : e4.last_lit && (N(e4, false), 0 === e4.strm.avail_out) ? A : I2;
          }(n2, t2) : 3 === n2.strategy ? function(e4, t3) {
            for (var r3, n3, i3, s3, a3 = e4.window; ; ) {
              if (e4.lookahead <= S2) {
                if (j(e4), e4.lookahead <= S2 && t3 === l)
                  return A;
                if (0 === e4.lookahead)
                  break;
              }
              if (e4.match_length = 0, e4.lookahead >= x && 0 < e4.strstart && (n3 = a3[i3 = e4.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
                s3 = e4.strstart + S2;
                do {
                } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
                e4.match_length = S2 - (s3 - i3), e4.match_length > e4.lookahead && (e4.match_length = e4.lookahead);
              }
              if (e4.match_length >= x ? (r3 = u._tr_tally(e4, 1, e4.match_length - x), e4.lookahead -= e4.match_length, e4.strstart += e4.match_length, e4.match_length = 0) : (r3 = u._tr_tally(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++), r3 && (N(e4, false), 0 === e4.strm.avail_out))
                return A;
            }
            return e4.insert = 0, t3 === f ? (N(e4, true), 0 === e4.strm.avail_out ? O : B) : e4.last_lit && (N(e4, false), 0 === e4.strm.avail_out) ? A : I2;
          }(n2, t2) : h2[n2.level].func(n2, t2);
          if (o2 !== O && o2 !== B || (n2.status = 666), o2 === A || o2 === O)
            return 0 === e3.avail_out && (n2.last_flush = -1), m;
          if (o2 === I2 && (1 === t2 ? u._tr_align(n2) : 5 !== t2 && (u._tr_stored_block(n2, 0, 0, false), 3 === t2 && (D(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F(e3), 0 === e3.avail_out))
            return n2.last_flush = -1, m;
        }
        return t2 !== f ? m : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (U(n2, 255 & e3.adler), U(n2, e3.adler >> 8 & 255), U(n2, e3.adler >> 16 & 255), U(n2, e3.adler >> 24 & 255), U(n2, 255 & e3.total_in), U(n2, e3.total_in >> 8 & 255), U(n2, e3.total_in >> 16 & 255), U(n2, e3.total_in >> 24 & 255)) : (P(n2, e3.adler >>> 16), P(n2, 65535 & e3.adler)), F(e3), 0 < n2.wrap && (n2.wrap = -n2.wrap), 0 !== n2.pending ? m : 1);
      }, r.deflateEnd = function(e3) {
        var t2;
        return e3 && e3.state ? (t2 = e3.state.status) !== C && 69 !== t2 && 73 !== t2 && 91 !== t2 && 103 !== t2 && t2 !== E2 && 666 !== t2 ? R2(e3, _) : (e3.state = null, t2 === E2 ? R2(e3, -3) : m) : _;
      }, r.deflateSetDictionary = function(e3, t2) {
        var r2, n2, i2, s2, a2, o2, h3, u2, l2 = t2.length;
        if (!e3 || !e3.state)
          return _;
        if (2 === (s2 = (r2 = e3.state).wrap) || 1 === s2 && r2.status !== C || r2.lookahead)
          return _;
        for (1 === s2 && (e3.adler = d(e3.adler, t2, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (0 === s2 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c.Buf8(r2.w_size), c.arraySet(u2, t2, l2 - r2.w_size, r2.w_size, 0), t2 = u2, l2 = r2.w_size), a2 = e3.avail_in, o2 = e3.next_in, h3 = e3.input, e3.avail_in = l2, e3.next_in = 0, e3.input = t2, j(r2); r2.lookahead >= x; ) {
          for (n2 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; )
            ;
          r2.strstart = n2, r2.lookahead = x - 1, j(r2);
        }
        return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e3.next_in = o2, e3.input = h3, e3.avail_in = a2, r2.wrap = s2, m;
      }, r.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e2, t, r) {
      t.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
      };
    }, {}], 48: [function(e2, t, r) {
      t.exports = function(e3, t2) {
        var r2, n, i, s, a, o, h2, u, l, f, c, d, p2, m, _, g, b, v, y, w, k, x, S2, z, C;
        r2 = e3.state, n = e3.next_in, z = e3.input, i = n + (e3.avail_in - 5), s = e3.next_out, C = e3.output, a = s - (t2 - e3.avail_out), o = s + (e3.avail_out - 257), h2 = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c = r2.window, d = r2.hold, p2 = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
        e:
          do {
            p2 < 15 && (d += z[n++] << p2, p2 += 8, d += z[n++] << p2, p2 += 8), v = m[d & g];
            t:
              for (; ; ) {
                if (d >>>= y = v >>> 24, p2 -= y, 0 === (y = v >>> 16 & 255))
                  C[s++] = 65535 & v;
                else {
                  if (!(16 & y)) {
                    if (0 == (64 & y)) {
                      v = m[(65535 & v) + (d & (1 << y) - 1)];
                      continue t;
                    }
                    if (32 & y) {
                      r2.mode = 12;
                      break e;
                    }
                    e3.msg = "invalid literal/length code", r2.mode = 30;
                    break e;
                  }
                  w = 65535 & v, (y &= 15) && (p2 < y && (d += z[n++] << p2, p2 += 8), w += d & (1 << y) - 1, d >>>= y, p2 -= y), p2 < 15 && (d += z[n++] << p2, p2 += 8, d += z[n++] << p2, p2 += 8), v = _[d & b];
                  r:
                    for (; ; ) {
                      if (d >>>= y = v >>> 24, p2 -= y, !(16 & (y = v >>> 16 & 255))) {
                        if (0 == (64 & y)) {
                          v = _[(65535 & v) + (d & (1 << y) - 1)];
                          continue r;
                        }
                        e3.msg = "invalid distance code", r2.mode = 30;
                        break e;
                      }
                      if (k = 65535 & v, p2 < (y &= 15) && (d += z[n++] << p2, (p2 += 8) < y && (d += z[n++] << p2, p2 += 8)), h2 < (k += d & (1 << y) - 1)) {
                        e3.msg = "invalid distance too far back", r2.mode = 30;
                        break e;
                      }
                      if (d >>>= y, p2 -= y, (y = s - a) < k) {
                        if (l < (y = k - y) && r2.sane) {
                          e3.msg = "invalid distance too far back", r2.mode = 30;
                          break e;
                        }
                        if (S2 = c, (x = 0) === f) {
                          if (x += u - y, y < w) {
                            for (w -= y; C[s++] = c[x++], --y; )
                              ;
                            x = s - k, S2 = C;
                          }
                        } else if (f < y) {
                          if (x += u + f - y, (y -= f) < w) {
                            for (w -= y; C[s++] = c[x++], --y; )
                              ;
                            if (x = 0, f < w) {
                              for (w -= y = f; C[s++] = c[x++], --y; )
                                ;
                              x = s - k, S2 = C;
                            }
                          }
                        } else if (x += f - y, y < w) {
                          for (w -= y; C[s++] = c[x++], --y; )
                            ;
                          x = s - k, S2 = C;
                        }
                        for (; 2 < w; )
                          C[s++] = S2[x++], C[s++] = S2[x++], C[s++] = S2[x++], w -= 3;
                        w && (C[s++] = S2[x++], 1 < w && (C[s++] = S2[x++]));
                      } else {
                        for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); )
                          ;
                        w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (n < i && s < o);
        n -= w = p2 >> 3, d &= (1 << (p2 -= w << 3)) - 1, e3.next_in = n, e3.next_out = s, e3.avail_in = n < i ? i - n + 5 : 5 - (n - i), e3.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d, r2.bits = p2;
      };
    }, {}], 49: [function(e2, t, r) {
      var I2 = e2("../utils/common"), O = e2("./adler32"), B = e2("./crc32"), R2 = e2("./inffast"), T2 = e2("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n = 852, i = 592;
      function L2(e3) {
        return (e3 >>> 24 & 255) + (e3 >>> 8 & 65280) + ((65280 & e3) << 8) + ((255 & e3) << 24);
      }
      function s() {
        this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I2.Buf16(320), this.work = new I2.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function a(e3) {
        var t2;
        return e3 && e3.state ? (t2 = e3.state, e3.total_in = e3.total_out = t2.total = 0, e3.msg = "", t2.wrap && (e3.adler = 1 & t2.wrap), t2.mode = P, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new I2.Buf32(n), t2.distcode = t2.distdyn = new I2.Buf32(i), t2.sane = 1, t2.back = -1, N) : U;
      }
      function o(e3) {
        var t2;
        return e3 && e3.state ? ((t2 = e3.state).wsize = 0, t2.whave = 0, t2.wnext = 0, a(e3)) : U;
      }
      function h2(e3, t2) {
        var r2, n2;
        return e3 && e3.state ? (n2 = e3.state, t2 < 0 ? (r2 = 0, t2 = -t2) : (r2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || 15 < t2) ? U : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = r2, n2.wbits = t2, o(e3))) : U;
      }
      function u(e3, t2) {
        var r2, n2;
        return e3 ? (n2 = new s(), (e3.state = n2).window = null, (r2 = h2(e3, t2)) !== N && (e3.state = null), r2) : U;
      }
      var l, f, c = true;
      function j(e3) {
        if (c) {
          var t2;
          for (l = new I2.Buf32(512), f = new I2.Buf32(32), t2 = 0; t2 < 144; )
            e3.lens[t2++] = 8;
          for (; t2 < 256; )
            e3.lens[t2++] = 9;
          for (; t2 < 280; )
            e3.lens[t2++] = 7;
          for (; t2 < 288; )
            e3.lens[t2++] = 8;
          for (T2(D, e3.lens, 0, 288, l, 0, e3.work, { bits: 9 }), t2 = 0; t2 < 32; )
            e3.lens[t2++] = 5;
          T2(F, e3.lens, 0, 32, f, 0, e3.work, { bits: 5 }), c = false;
        }
        e3.lencode = l, e3.lenbits = 9, e3.distcode = f, e3.distbits = 5;
      }
      function Z(e3, t2, r2, n2) {
        var i2, s2 = e3.state;
        return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I2.Buf8(s2.wsize)), n2 >= s2.wsize ? (I2.arraySet(s2.window, t2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I2.arraySet(s2.window, t2, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I2.arraySet(s2.window, t2, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
      }
      r.inflateReset = o, r.inflateReset2 = h2, r.inflateResetKeep = a, r.inflateInit = function(e3) {
        return u(e3, 15);
      }, r.inflateInit2 = u, r.inflate = function(e3, t2) {
        var r2, n2, i2, s2, a2, o2, h3, u2, l2, f2, c2, d, p2, m, _, g, b, v, y, w, k, x, S2, z, C = 0, E2 = new I2.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!e3 || !e3.state || !e3.output || !e3.input && 0 !== e3.avail_in)
          return U;
        12 === (r2 = e3.state).mode && (r2.mode = 13), a2 = e3.next_out, i2 = e3.output, h3 = e3.avail_out, s2 = e3.next_in, n2 = e3.input, o2 = e3.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c2 = h3, x = N;
        e:
          for (; ; )
            switch (r2.mode) {
              case P:
                if (0 === r2.wrap) {
                  r2.mode = 13;
                  break;
                }
                for (; l2 < 16; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (2 & r2.wrap && 35615 === u2) {
                  E2[r2.check = 0] = 255 & u2, E2[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E2, 2, 0), l2 = u2 = 0, r2.mode = 2;
                  break;
                }
                if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                  e3.msg = "incorrect header check", r2.mode = 30;
                  break;
                }
                if (8 != (15 & u2)) {
                  e3.msg = "unknown compression method", r2.mode = 30;
                  break;
                }
                if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r2.wbits)
                  r2.wbits = k;
                else if (k > r2.wbits) {
                  e3.msg = "invalid window size", r2.mode = 30;
                  break;
                }
                r2.dmax = 1 << k, e3.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
                break;
              case 2:
                for (; l2 < 16; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (r2.flags = u2, 8 != (255 & r2.flags)) {
                  e3.msg = "unknown compression method", r2.mode = 30;
                  break;
                }
                if (57344 & r2.flags) {
                  e3.msg = "unknown header flags set", r2.mode = 30;
                  break;
                }
                r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E2[0] = 255 & u2, E2[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E2, 2, 0)), l2 = u2 = 0, r2.mode = 3;
              case 3:
                for (; l2 < 32; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                r2.head && (r2.head.time = u2), 512 & r2.flags && (E2[0] = 255 & u2, E2[1] = u2 >>> 8 & 255, E2[2] = u2 >>> 16 & 255, E2[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E2, 4, 0)), l2 = u2 = 0, r2.mode = 4;
              case 4:
                for (; l2 < 16; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E2[0] = 255 & u2, E2[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E2, 2, 0)), l2 = u2 = 0, r2.mode = 5;
              case 5:
                if (1024 & r2.flags) {
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E2[0] = 255 & u2, E2[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E2, 2, 0)), l2 = u2 = 0;
                } else
                  r2.head && (r2.head.extra = null);
                r2.mode = 6;
              case 6:
                if (1024 & r2.flags && (o2 < (d = r2.length) && (d = o2), d && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I2.arraySet(r2.head.extra, n2, s2, d, k)), 512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, r2.length -= d), r2.length))
                  break e;
                r2.length = 0, r2.mode = 7;
              case 7:
                if (2048 & r2.flags) {
                  if (0 === o2)
                    break e;
                  for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d < o2; )
                    ;
                  if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                    break e;
                } else
                  r2.head && (r2.head.name = null);
                r2.length = 0, r2.mode = 8;
              case 8:
                if (4096 & r2.flags) {
                  if (0 === o2)
                    break e;
                  for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d < o2; )
                    ;
                  if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                    break e;
                } else
                  r2.head && (r2.head.comment = null);
                r2.mode = 9;
              case 9:
                if (512 & r2.flags) {
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (u2 !== (65535 & r2.check)) {
                    e3.msg = "header crc mismatch", r2.mode = 30;
                    break;
                  }
                  l2 = u2 = 0;
                }
                r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e3.adler = r2.check = 0, r2.mode = 12;
                break;
              case 10:
                for (; l2 < 32; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                e3.adler = r2.check = L2(u2), l2 = u2 = 0, r2.mode = 11;
              case 11:
                if (0 === r2.havedict)
                  return e3.next_out = a2, e3.avail_out = h3, e3.next_in = s2, e3.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
                e3.adler = r2.check = 1, r2.mode = 12;
              case 12:
                if (5 === t2 || 6 === t2)
                  break e;
              case 13:
                if (r2.last) {
                  u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                  break;
                }
                for (; l2 < 3; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                  case 0:
                    r2.mode = 14;
                    break;
                  case 1:
                    if (j(r2), r2.mode = 20, 6 !== t2)
                      break;
                    u2 >>>= 2, l2 -= 2;
                    break e;
                  case 2:
                    r2.mode = 17;
                    break;
                  case 3:
                    e3.msg = "invalid block type", r2.mode = 30;
                }
                u2 >>>= 2, l2 -= 2;
                break;
              case 14:
                for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                  e3.msg = "invalid stored block lengths", r2.mode = 30;
                  break;
                }
                if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, 6 === t2)
                  break e;
              case 15:
                r2.mode = 16;
              case 16:
                if (d = r2.length) {
                  if (o2 < d && (d = o2), h3 < d && (d = h3), 0 === d)
                    break e;
                  I2.arraySet(i2, n2, s2, d, a2), o2 -= d, s2 += d, h3 -= d, a2 += d, r2.length -= d;
                  break;
                }
                r2.mode = 12;
                break;
              case 17:
                for (; l2 < 14; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                  e3.msg = "too many length or distance symbols", r2.mode = 30;
                  break;
                }
                r2.have = 0, r2.mode = 18;
              case 18:
                for (; r2.have < r2.ncode; ) {
                  for (; l2 < 3; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
                }
                for (; r2.have < 19; )
                  r2.lens[A[r2.have++]] = 0;
                if (r2.lencode = r2.lendyn, r2.lenbits = 7, S2 = { bits: r2.lenbits }, x = T2(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S2), r2.lenbits = S2.bits, x) {
                  e3.msg = "invalid code lengths set", r2.mode = 30;
                  break;
                }
                r2.have = 0, r2.mode = 19;
              case 19:
                for (; r2.have < r2.nlen + r2.ndist; ) {
                  for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (b < 16)
                    u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
                  else {
                    if (16 === b) {
                      for (z = _ + 2; l2 < z; ) {
                        if (0 === o2)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      if (u2 >>>= _, l2 -= _, 0 === r2.have) {
                        e3.msg = "invalid bit length repeat", r2.mode = 30;
                        break;
                      }
                      k = r2.lens[r2.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                    } else if (17 === b) {
                      for (z = _ + 3; l2 < z; ) {
                        if (0 === o2)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      l2 -= _, k = 0, d = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                    } else {
                      for (z = _ + 7; l2 < z; ) {
                        if (0 === o2)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      l2 -= _, k = 0, d = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                    }
                    if (r2.have + d > r2.nlen + r2.ndist) {
                      e3.msg = "invalid bit length repeat", r2.mode = 30;
                      break;
                    }
                    for (; d--; )
                      r2.lens[r2.have++] = k;
                  }
                }
                if (30 === r2.mode)
                  break;
                if (0 === r2.lens[256]) {
                  e3.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                  break;
                }
                if (r2.lenbits = 9, S2 = { bits: r2.lenbits }, x = T2(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S2), r2.lenbits = S2.bits, x) {
                  e3.msg = "invalid literal/lengths set", r2.mode = 30;
                  break;
                }
                if (r2.distbits = 6, r2.distcode = r2.distdyn, S2 = { bits: r2.distbits }, x = T2(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S2), r2.distbits = S2.bits, x) {
                  e3.msg = "invalid distances set", r2.mode = 30;
                  break;
                }
                if (r2.mode = 20, 6 === t2)
                  break e;
              case 20:
                r2.mode = 21;
              case 21:
                if (6 <= o2 && 258 <= h3) {
                  e3.next_out = a2, e3.avail_out = h3, e3.next_in = s2, e3.avail_in = o2, r2.hold = u2, r2.bits = l2, R2(e3, c2), a2 = e3.next_out, i2 = e3.output, h3 = e3.avail_out, s2 = e3.next_in, n2 = e3.input, o2 = e3.avail_in, u2 = r2.hold, l2 = r2.bits, 12 === r2.mode && (r2.back = -1);
                  break;
                }
                for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (g && 0 == (240 & g)) {
                  for (v = _, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  u2 >>>= v, l2 -= v, r2.back += v;
                }
                if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, 0 === g) {
                  r2.mode = 26;
                  break;
                }
                if (32 & g) {
                  r2.back = -1, r2.mode = 12;
                  break;
                }
                if (64 & g) {
                  e3.msg = "invalid literal/length code", r2.mode = 30;
                  break;
                }
                r2.extra = 15 & g, r2.mode = 22;
              case 22:
                if (r2.extra) {
                  for (z = r2.extra; l2 < z; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                }
                r2.was = r2.length, r2.mode = 23;
              case 23:
                for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (0 == (240 & g)) {
                  for (v = _, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  u2 >>>= v, l2 -= v, r2.back += v;
                }
                if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                  e3.msg = "invalid distance code", r2.mode = 30;
                  break;
                }
                r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
              case 24:
                if (r2.extra) {
                  for (z = r2.extra; l2 < z; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                }
                if (r2.offset > r2.dmax) {
                  e3.msg = "invalid distance too far back", r2.mode = 30;
                  break;
                }
                r2.mode = 25;
              case 25:
                if (0 === h3)
                  break e;
                if (d = c2 - h3, r2.offset > d) {
                  if ((d = r2.offset - d) > r2.whave && r2.sane) {
                    e3.msg = "invalid distance too far back", r2.mode = 30;
                    break;
                  }
                  p2 = d > r2.wnext ? (d -= r2.wnext, r2.wsize - d) : r2.wnext - d, d > r2.length && (d = r2.length), m = r2.window;
                } else
                  m = i2, p2 = a2 - r2.offset, d = r2.length;
                for (h3 < d && (d = h3), h3 -= d, r2.length -= d; i2[a2++] = m[p2++], --d; )
                  ;
                0 === r2.length && (r2.mode = 21);
                break;
              case 26:
                if (0 === h3)
                  break e;
                i2[a2++] = r2.length, h3--, r2.mode = 21;
                break;
              case 27:
                if (r2.wrap) {
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 |= n2[s2++] << l2, l2 += 8;
                  }
                  if (c2 -= h3, e3.total_out += c2, r2.total += c2, c2 && (e3.adler = r2.check = r2.flags ? B(r2.check, i2, c2, a2 - c2) : O(r2.check, i2, c2, a2 - c2)), c2 = h3, (r2.flags ? u2 : L2(u2)) !== r2.check) {
                    e3.msg = "incorrect data check", r2.mode = 30;
                    break;
                  }
                  l2 = u2 = 0;
                }
                r2.mode = 28;
              case 28:
                if (r2.wrap && r2.flags) {
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (u2 !== (4294967295 & r2.total)) {
                    e3.msg = "incorrect length check", r2.mode = 30;
                    break;
                  }
                  l2 = u2 = 0;
                }
                r2.mode = 29;
              case 29:
                x = 1;
                break e;
              case 30:
                x = -3;
                break e;
              case 31:
                return -4;
              case 32:
              default:
                return U;
            }
        return e3.next_out = a2, e3.avail_out = h3, e3.next_in = s2, e3.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c2 !== e3.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== t2)) && Z(e3, e3.output, e3.next_out, c2 - e3.avail_out) ? (r2.mode = 31, -4) : (f2 -= e3.avail_in, c2 -= e3.avail_out, e3.total_in += f2, e3.total_out += c2, r2.total += c2, r2.wrap && c2 && (e3.adler = r2.check = r2.flags ? B(r2.check, i2, c2, e3.next_out - c2) : O(r2.check, i2, c2, e3.next_out - c2)), e3.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f2 && 0 === c2 || 4 === t2) && x === N && (x = -5), x);
      }, r.inflateEnd = function(e3) {
        if (!e3 || !e3.state)
          return U;
        var t2 = e3.state;
        return t2.window && (t2.window = null), e3.state = null, N;
      }, r.inflateGetHeader = function(e3, t2) {
        var r2;
        return e3 && e3.state ? 0 == (2 & (r2 = e3.state).wrap) ? U : ((r2.head = t2).done = false, N) : U;
      }, r.inflateSetDictionary = function(e3, t2) {
        var r2, n2 = t2.length;
        return e3 && e3.state ? 0 !== (r2 = e3.state).wrap && 11 !== r2.mode ? U : 11 === r2.mode && O(1, t2, n2, 0) !== r2.check ? -3 : Z(e3, t2, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
      }, r.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e2, t, r) {
      var D = e2("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      t.exports = function(e3, t2, r2, n, i, s, a, o) {
        var h2, u, l, f, c, d, p2, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S2 = 0, z = 0, C = 0, E2 = 0, A = null, I2 = 0, O = new D.Buf16(16), B = new D.Buf16(16), R2 = null, T2 = 0;
        for (b = 0; b <= 15; b++)
          O[b] = 0;
        for (v = 0; v < n; v++)
          O[t2[r2 + v]]++;
        for (k = g, w = 15; 1 <= w && 0 === O[w]; w--)
          ;
        if (w < k && (k = w), 0 === w)
          return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
        for (y = 1; y < w && 0 === O[y]; y++)
          ;
        for (k < y && (k = y), b = z = 1; b <= 15; b++)
          if (z <<= 1, (z -= O[b]) < 0)
            return -1;
        if (0 < z && (0 === e3 || 1 !== w))
          return -1;
        for (B[1] = 0, b = 1; b < 15; b++)
          B[b + 1] = B[b] + O[b];
        for (v = 0; v < n; v++)
          0 !== t2[r2 + v] && (a[B[t2[r2 + v]]++] = v);
        if (d = 0 === e3 ? (A = R2 = a, 19) : 1 === e3 ? (A = F, I2 -= 257, R2 = N, T2 -= 257, 256) : (A = U, R2 = P, -1), b = y, c = s, S2 = v = E2 = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === e3 && 852 < C || 2 === e3 && 592 < C)
          return 1;
        for (; ; ) {
          for (p2 = b - S2, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R2[T2 + a[v]], A[I2 + a[v]]) : (m = 96, 0), h2 = 1 << b - S2, y = u = 1 << x; i[c + (E2 >> S2) + (u -= h2)] = p2 << 24 | m << 16 | _ | 0, 0 !== u; )
            ;
          for (h2 = 1 << b - 1; E2 & h2; )
            h2 >>= 1;
          if (0 !== h2 ? (E2 &= h2 - 1, E2 += h2) : E2 = 0, v++, 0 == --O[b]) {
            if (b === w)
              break;
            b = t2[r2 + a[v]];
          }
          if (k < b && (E2 & f) !== l) {
            for (0 === S2 && (S2 = k), c += y, z = 1 << (x = b - S2); x + S2 < w && !((z -= O[x + S2]) <= 0); )
              x++, z <<= 1;
            if (C += 1 << x, 1 === e3 && 852 < C || 2 === e3 && 592 < C)
              return 1;
            i[l = E2 & f] = k << 24 | x << 16 | c - s | 0;
          }
        }
        return 0 !== E2 && (i[c + E2] = b - S2 << 24 | 64 << 16 | 0), o.bits = k, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(e2, t, r) {
      t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(e2, t, r) {
      var i = e2("../utils/common"), o = 0, h2 = 1;
      function n(e3) {
        for (var t2 = e3.length; 0 <= --t2; )
          e3[t2] = 0;
      }
      var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p2 = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));
      n(z);
      var C = new Array(2 * f);
      n(C);
      var E2 = new Array(512);
      n(E2);
      var A = new Array(256);
      n(A);
      var I2 = new Array(a);
      n(I2);
      var O, B, R2, T2 = new Array(f);
      function D(e3, t2, r2, n2, i2) {
        this.static_tree = e3, this.extra_bits = t2, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e3 && e3.length;
      }
      function F(e3, t2) {
        this.dyn_tree = e3, this.max_code = 0, this.stat_desc = t2;
      }
      function N(e3) {
        return e3 < 256 ? E2[e3] : E2[256 + (e3 >>> 7)];
      }
      function U(e3, t2) {
        e3.pending_buf[e3.pending++] = 255 & t2, e3.pending_buf[e3.pending++] = t2 >>> 8 & 255;
      }
      function P(e3, t2, r2) {
        e3.bi_valid > d - r2 ? (e3.bi_buf |= t2 << e3.bi_valid & 65535, U(e3, e3.bi_buf), e3.bi_buf = t2 >> d - e3.bi_valid, e3.bi_valid += r2 - d) : (e3.bi_buf |= t2 << e3.bi_valid & 65535, e3.bi_valid += r2);
      }
      function L2(e3, t2, r2) {
        P(e3, r2[2 * t2], r2[2 * t2 + 1]);
      }
      function j(e3, t2) {
        for (var r2 = 0; r2 |= 1 & e3, e3 >>>= 1, r2 <<= 1, 0 < --t2; )
          ;
        return r2 >>> 1;
      }
      function Z(e3, t2, r2) {
        var n2, i2, s2 = new Array(g + 1), a2 = 0;
        for (n2 = 1; n2 <= g; n2++)
          s2[n2] = a2 = a2 + r2[n2 - 1] << 1;
        for (i2 = 0; i2 <= t2; i2++) {
          var o2 = e3[2 * i2 + 1];
          0 !== o2 && (e3[2 * i2] = j(s2[o2]++, o2));
        }
      }
      function W(e3) {
        var t2;
        for (t2 = 0; t2 < l; t2++)
          e3.dyn_ltree[2 * t2] = 0;
        for (t2 = 0; t2 < f; t2++)
          e3.dyn_dtree[2 * t2] = 0;
        for (t2 = 0; t2 < c; t2++)
          e3.bl_tree[2 * t2] = 0;
        e3.dyn_ltree[2 * m] = 1, e3.opt_len = e3.static_len = 0, e3.last_lit = e3.matches = 0;
      }
      function M(e3) {
        8 < e3.bi_valid ? U(e3, e3.bi_buf) : 0 < e3.bi_valid && (e3.pending_buf[e3.pending++] = e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0;
      }
      function H(e3, t2, r2, n2) {
        var i2 = 2 * t2, s2 = 2 * r2;
        return e3[i2] < e3[s2] || e3[i2] === e3[s2] && n2[t2] <= n2[r2];
      }
      function G(e3, t2, r2) {
        for (var n2 = e3.heap[r2], i2 = r2 << 1; i2 <= e3.heap_len && (i2 < e3.heap_len && H(t2, e3.heap[i2 + 1], e3.heap[i2], e3.depth) && i2++, !H(t2, n2, e3.heap[i2], e3.depth)); )
          e3.heap[r2] = e3.heap[i2], r2 = i2, i2 <<= 1;
        e3.heap[r2] = n2;
      }
      function K(e3, t2, r2) {
        var n2, i2, s2, a2, o2 = 0;
        if (0 !== e3.last_lit)
          for (; n2 = e3.pending_buf[e3.d_buf + 2 * o2] << 8 | e3.pending_buf[e3.d_buf + 2 * o2 + 1], i2 = e3.pending_buf[e3.l_buf + o2], o2++, 0 === n2 ? L2(e3, i2, t2) : (L2(e3, (s2 = A[i2]) + u + 1, t2), 0 !== (a2 = w[s2]) && P(e3, i2 -= I2[s2], a2), L2(e3, s2 = N(--n2), r2), 0 !== (a2 = k[s2]) && P(e3, n2 -= T2[s2], a2)), o2 < e3.last_lit; )
            ;
        L2(e3, m, t2);
      }
      function Y2(e3, t2) {
        var r2, n2, i2, s2 = t2.dyn_tree, a2 = t2.stat_desc.static_tree, o2 = t2.stat_desc.has_stree, h3 = t2.stat_desc.elems, u2 = -1;
        for (e3.heap_len = 0, e3.heap_max = _, r2 = 0; r2 < h3; r2++)
          0 !== s2[2 * r2] ? (e3.heap[++e3.heap_len] = u2 = r2, e3.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
        for (; e3.heap_len < 2; )
          s2[2 * (i2 = e3.heap[++e3.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e3.depth[i2] = 0, e3.opt_len--, o2 && (e3.static_len -= a2[2 * i2 + 1]);
        for (t2.max_code = u2, r2 = e3.heap_len >> 1; 1 <= r2; r2--)
          G(e3, s2, r2);
        for (i2 = h3; r2 = e3.heap[1], e3.heap[1] = e3.heap[e3.heap_len--], G(e3, s2, 1), n2 = e3.heap[1], e3.heap[--e3.heap_max] = r2, e3.heap[--e3.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e3.depth[i2] = (e3.depth[r2] >= e3.depth[n2] ? e3.depth[r2] : e3.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e3.heap[1] = i2++, G(e3, s2, 1), 2 <= e3.heap_len; )
          ;
        e3.heap[--e3.heap_max] = e3.heap[1], function(e4, t3) {
          var r3, n3, i3, s3, a3, o3, h4 = t3.dyn_tree, u3 = t3.max_code, l2 = t3.stat_desc.static_tree, f2 = t3.stat_desc.has_stree, c2 = t3.stat_desc.extra_bits, d2 = t3.stat_desc.extra_base, p3 = t3.stat_desc.max_length, m2 = 0;
          for (s3 = 0; s3 <= g; s3++)
            e4.bl_count[s3] = 0;
          for (h4[2 * e4.heap[e4.heap_max] + 1] = 0, r3 = e4.heap_max + 1; r3 < _; r3++)
            p3 < (s3 = h4[2 * h4[2 * (n3 = e4.heap[r3]) + 1] + 1] + 1) && (s3 = p3, m2++), h4[2 * n3 + 1] = s3, u3 < n3 || (e4.bl_count[s3]++, a3 = 0, d2 <= n3 && (a3 = c2[n3 - d2]), o3 = h4[2 * n3], e4.opt_len += o3 * (s3 + a3), f2 && (e4.static_len += o3 * (l2[2 * n3 + 1] + a3)));
          if (0 !== m2) {
            do {
              for (s3 = p3 - 1; 0 === e4.bl_count[s3]; )
                s3--;
              e4.bl_count[s3]--, e4.bl_count[s3 + 1] += 2, e4.bl_count[p3]--, m2 -= 2;
            } while (0 < m2);
            for (s3 = p3; 0 !== s3; s3--)
              for (n3 = e4.bl_count[s3]; 0 !== n3; )
                u3 < (i3 = e4.heap[--r3]) || (h4[2 * i3 + 1] !== s3 && (e4.opt_len += (s3 - h4[2 * i3 + 1]) * h4[2 * i3], h4[2 * i3 + 1] = s3), n3--);
          }
        }(e3, t2), Z(s2, u2, e3.bl_count);
      }
      function X2(e3, t2, r2) {
        var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h3 = 7, u2 = 4;
        for (0 === a2 && (h3 = 138, u2 = 3), t2[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++)
          i2 = a2, a2 = t2[2 * (n2 + 1) + 1], ++o2 < h3 && i2 === a2 || (o2 < u2 ? e3.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== s2 && e3.bl_tree[2 * i2]++, e3.bl_tree[2 * b]++) : o2 <= 10 ? e3.bl_tree[2 * v]++ : e3.bl_tree[2 * y]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h3 = 138, 3) : i2 === a2 ? (h3 = 6, 3) : (h3 = 7, 4));
      }
      function V(e3, t2, r2) {
        var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h3 = 7, u2 = 4;
        for (0 === a2 && (h3 = 138, u2 = 3), n2 = 0; n2 <= r2; n2++)
          if (i2 = a2, a2 = t2[2 * (n2 + 1) + 1], !(++o2 < h3 && i2 === a2)) {
            if (o2 < u2)
              for (; L2(e3, i2, e3.bl_tree), 0 != --o2; )
                ;
            else
              0 !== i2 ? (i2 !== s2 && (L2(e3, i2, e3.bl_tree), o2--), L2(e3, b, e3.bl_tree), P(e3, o2 - 3, 2)) : o2 <= 10 ? (L2(e3, v, e3.bl_tree), P(e3, o2 - 3, 3)) : (L2(e3, y, e3.bl_tree), P(e3, o2 - 11, 7));
            s2 = i2, u2 = (o2 = 0) === a2 ? (h3 = 138, 3) : i2 === a2 ? (h3 = 6, 3) : (h3 = 7, 4);
          }
      }
      n(T2);
      var q = false;
      function J(e3, t2, r2, n2) {
        P(e3, (s << 1) + (n2 ? 1 : 0), 3), function(e4, t3, r3, n3) {
          M(e4), n3 && (U(e4, r3), U(e4, ~r3)), i.arraySet(e4.pending_buf, e4.window, t3, r3, e4.pending), e4.pending += r3;
        }(e3, t2, r2, true);
      }
      r._tr_init = function(e3) {
        q || (function() {
          var e4, t2, r2, n2, i2, s2 = new Array(g + 1);
          for (n2 = r2 = 0; n2 < a - 1; n2++)
            for (I2[n2] = r2, e4 = 0; e4 < 1 << w[n2]; e4++)
              A[r2++] = n2;
          for (A[r2 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++)
            for (T2[n2] = i2, e4 = 0; e4 < 1 << k[n2]; e4++)
              E2[i2++] = n2;
          for (i2 >>= 7; n2 < f; n2++)
            for (T2[n2] = i2 << 7, e4 = 0; e4 < 1 << k[n2] - 7; e4++)
              E2[256 + i2++] = n2;
          for (t2 = 0; t2 <= g; t2++)
            s2[t2] = 0;
          for (e4 = 0; e4 <= 143; )
            z[2 * e4 + 1] = 8, e4++, s2[8]++;
          for (; e4 <= 255; )
            z[2 * e4 + 1] = 9, e4++, s2[9]++;
          for (; e4 <= 279; )
            z[2 * e4 + 1] = 7, e4++, s2[7]++;
          for (; e4 <= 287; )
            z[2 * e4 + 1] = 8, e4++, s2[8]++;
          for (Z(z, l + 1, s2), e4 = 0; e4 < f; e4++)
            C[2 * e4 + 1] = 5, C[2 * e4] = j(e4, 5);
          O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R2 = new D(new Array(0), x, 0, c, p2);
        }(), q = true), e3.l_desc = new F(e3.dyn_ltree, O), e3.d_desc = new F(e3.dyn_dtree, B), e3.bl_desc = new F(e3.bl_tree, R2), e3.bi_buf = 0, e3.bi_valid = 0, W(e3);
      }, r._tr_stored_block = J, r._tr_flush_block = function(e3, t2, r2, n2) {
        var i2, s2, a2 = 0;
        0 < e3.level ? (2 === e3.strm.data_type && (e3.strm.data_type = function(e4) {
          var t3, r3 = 4093624447;
          for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1)
            if (1 & r3 && 0 !== e4.dyn_ltree[2 * t3])
              return o;
          if (0 !== e4.dyn_ltree[18] || 0 !== e4.dyn_ltree[20] || 0 !== e4.dyn_ltree[26])
            return h2;
          for (t3 = 32; t3 < u; t3++)
            if (0 !== e4.dyn_ltree[2 * t3])
              return h2;
          return o;
        }(e3)), Y2(e3, e3.l_desc), Y2(e3, e3.d_desc), a2 = function(e4) {
          var t3;
          for (X2(e4, e4.dyn_ltree, e4.l_desc.max_code), X2(e4, e4.dyn_dtree, e4.d_desc.max_code), Y2(e4, e4.bl_desc), t3 = c - 1; 3 <= t3 && 0 === e4.bl_tree[2 * S2[t3] + 1]; t3--)
            ;
          return e4.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
        }(e3), i2 = e3.opt_len + 3 + 7 >>> 3, (s2 = e3.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && -1 !== t2 ? J(e3, t2, r2, n2) : 4 === e3.strategy || s2 === i2 ? (P(e3, 2 + (n2 ? 1 : 0), 3), K(e3, z, C)) : (P(e3, 4 + (n2 ? 1 : 0), 3), function(e4, t3, r3, n3) {
          var i3;
          for (P(e4, t3 - 257, 5), P(e4, r3 - 1, 5), P(e4, n3 - 4, 4), i3 = 0; i3 < n3; i3++)
            P(e4, e4.bl_tree[2 * S2[i3] + 1], 3);
          V(e4, e4.dyn_ltree, t3 - 1), V(e4, e4.dyn_dtree, r3 - 1);
        }(e3, e3.l_desc.max_code + 1, e3.d_desc.max_code + 1, a2 + 1), K(e3, e3.dyn_ltree, e3.dyn_dtree)), W(e3), n2 && M(e3);
      }, r._tr_tally = function(e3, t2, r2) {
        return e3.pending_buf[e3.d_buf + 2 * e3.last_lit] = t2 >>> 8 & 255, e3.pending_buf[e3.d_buf + 2 * e3.last_lit + 1] = 255 & t2, e3.pending_buf[e3.l_buf + e3.last_lit] = 255 & r2, e3.last_lit++, 0 === t2 ? e3.dyn_ltree[2 * r2]++ : (e3.matches++, t2--, e3.dyn_ltree[2 * (A[r2] + u + 1)]++, e3.dyn_dtree[2 * N(t2)]++), e3.last_lit === e3.lit_bufsize - 1;
      }, r._tr_align = function(e3) {
        P(e3, 2, 3), L2(e3, m, z), function(e4) {
          16 === e4.bi_valid ? (U(e4, e4.bi_buf), e4.bi_buf = 0, e4.bi_valid = 0) : 8 <= e4.bi_valid && (e4.pending_buf[e4.pending++] = 255 & e4.bi_buf, e4.bi_buf >>= 8, e4.bi_valid -= 8);
        }(e3);
      };
    }, { "../utils/common": 41 }], 53: [function(e2, t, r) {
      t.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(e2, t, r) {
      (function(e3) {
        !function(r2, n) {
          if (!r2.setImmediate) {
            var i, s, t2, a, o = 1, h2 = {}, u = false, l = r2.document, e4 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
            e4 = e4 && e4.setTimeout ? e4 : r2, i = "[object process]" === {}.toString.call(r2.process) ? function(e5) {
              process.nextTick(function() {
                c(e5);
              });
            } : function() {
              if (r2.postMessage && !r2.importScripts) {
                var e5 = true, t3 = r2.onmessage;
                return r2.onmessage = function() {
                  e5 = false;
                }, r2.postMessage("", "*"), r2.onmessage = t3, e5;
              }
            }() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d, false) : r2.attachEvent("onmessage", d), function(e5) {
              r2.postMessage(a + e5, "*");
            }) : r2.MessageChannel ? ((t2 = new MessageChannel()).port1.onmessage = function(e5) {
              c(e5.data);
            }, function(e5) {
              t2.port2.postMessage(e5);
            }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e5) {
              var t3 = l.createElement("script");
              t3.onreadystatechange = function() {
                c(e5), t3.onreadystatechange = null, s.removeChild(t3), t3 = null;
              }, s.appendChild(t3);
            }) : function(e5) {
              setTimeout(c, 0, e5);
            }, e4.setImmediate = function(e5) {
              "function" != typeof e5 && (e5 = new Function("" + e5));
              for (var t3 = new Array(arguments.length - 1), r3 = 0; r3 < t3.length; r3++)
                t3[r3] = arguments[r3 + 1];
              var n2 = { callback: e5, args: t3 };
              return h2[o] = n2, i(o), o++;
            }, e4.clearImmediate = f;
          }
          function f(e5) {
            delete h2[e5];
          }
          function c(e5) {
            if (u)
              setTimeout(c, 0, e5);
            else {
              var t3 = h2[e5];
              if (t3) {
                u = true;
                try {
                  !function(e6) {
                    var t4 = e6.callback, r3 = e6.args;
                    switch (r3.length) {
                      case 0:
                        t4();
                        break;
                      case 1:
                        t4(r3[0]);
                        break;
                      case 2:
                        t4(r3[0], r3[1]);
                        break;
                      case 3:
                        t4(r3[0], r3[1], r3[2]);
                        break;
                      default:
                        t4.apply(n, r3);
                    }
                  }(t3);
                } finally {
                  f(e5), u = false;
                }
              }
            }
          }
          function d(e5) {
            e5.source === r2 && "string" == typeof e5.data && 0 === e5.data.indexOf(a) && c(+e5.data.slice(a.length));
          }
        }("undefined" == typeof self ? void 0 === e3 ? this : e3 : self);
      }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(jszip_min);
var jszip_minExports = jszip_min.exports;
const JSZip = /* @__PURE__ */ getDefaultExportFromCjs(jszip_minExports);
var tinyEmitter = { exports: {} };
function E$1() {
}
E$1.prototype = {
  on: function(name, callback, ctx) {
    var e2 = this.e || (this.e = {});
    (e2[name] || (e2[name] = [])).push({
      fn: callback,
      ctx
    });
    return this;
  },
  once: function(name, callback, ctx) {
    var self2 = this;
    function listener() {
      self2.off(name, listener);
      callback.apply(ctx, arguments);
    }
    listener._ = callback;
    return this.on(name, listener, ctx);
  },
  emit: function(name) {
    var data = [].slice.call(arguments, 1);
    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
    var i = 0;
    var len = evtArr.length;
    for (i; i < len; i++) {
      evtArr[i].fn.apply(evtArr[i].ctx, data);
    }
    return this;
  },
  off: function(name, callback) {
    var e2 = this.e || (this.e = {});
    var evts = e2[name];
    var liveEvents = [];
    if (evts && callback) {
      for (var i = 0, len = evts.length; i < len; i++) {
        if (evts[i].fn !== callback && evts[i].fn._ !== callback)
          liveEvents.push(evts[i]);
      }
    }
    liveEvents.length ? e2[name] = liveEvents : delete e2[name];
    return this;
  }
};
tinyEmitter.exports = E$1;
tinyEmitter.exports.TinyEmitter = E$1;
var tinyEmitterExports = tinyEmitter.exports;
var E = tinyEmitterExports;
var instance = new E();
const emitter = /* @__PURE__ */ getDefaultExportFromCjs(instance);
function copy$2(o) {
  if (o) {
    return JSON.parse(JSON.stringify(o));
  }
  return o;
}
var __defProp$1 = Object.defineProperty;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
function isEmpty(value) {
  return value === null || value === void 0 || value === "" || Array.isArray(value) && value.length === 0 || !(value instanceof Date) && typeof value === "object" && Object.keys(value).length === 0;
}
function isFunction$2(value) {
  return !!(value && value.constructor && value.call && value.apply);
}
function isNotEmpty(value) {
  return !isEmpty(value);
}
function isObject$3(value, empty = true) {
  return value instanceof Object && value.constructor === Object && (empty || Object.keys(value).length !== 0);
}
function resolve$1(obj, ...params) {
  return isFunction$2(obj) ? obj(...params) : obj;
}
function isString$3(value, empty = true) {
  return typeof value === "string" && (empty || value !== "");
}
function isArray$5(value, empty = true) {
  return Array.isArray(value) && (empty || value.length !== 0);
}
function isNumber$1(value) {
  return isNotEmpty(value) && !isNaN(value);
}
function matchRegex(str, regex) {
  if (regex) {
    const match = regex.test(str);
    regex.lastIndex = 0;
    return match;
  }
  return false;
}
function mergeKeys(...args) {
  const _mergeKeys = (target = {}, source = {}) => {
    const mergedObj = __spreadValues$1({}, target);
    Object.keys(source).forEach((key) => {
      if (isObject$3(source[key]) && key in target && isObject$3(target[key])) {
        mergedObj[key] = _mergeKeys(target[key], source[key]);
      } else {
        mergedObj[key] = source[key];
      }
    });
    return mergedObj;
  };
  return args.reduce((acc, obj, i) => i === 0 ? obj : _mergeKeys(acc, obj), {});
}
function minifyCSS(css) {
  return css ? css.replace(/\/\*(?:(?!\*\/)[\s\S])*\*\/|[\r\n\t]+/g, "").replace(/ {2,}/g, " ").replace(/ ([{:}]) /g, "$1").replace(/([;,]) /g, "$1").replace(/ !/g, "!").replace(/: /g, ":") : css;
}
function toKebabCase(str) {
  return isString$3(str) ? str.replace(/(_)/g, "-").replace(/[A-Z]/g, (c, i) => i === 0 ? c : "-" + c.toLowerCase()).toLowerCase() : str;
}
function toTokenKey(str) {
  return isString$3(str) ? str.replace(/[A-Z]/g, (c, i) => i === 0 ? c : "." + c.toLowerCase()).toLowerCase() : str;
}
function EventBus() {
  const allHandlers = /* @__PURE__ */ new Map();
  return {
    on(type2, handler) {
      let handlers2 = allHandlers.get(type2);
      if (!handlers2)
        handlers2 = [handler];
      else
        handlers2.push(handler);
      allHandlers.set(type2, handlers2);
      return this;
    },
    off(type2, handler) {
      let handlers2 = allHandlers.get(type2);
      if (handlers2) {
        handlers2.splice(handlers2.indexOf(handler) >>> 0, 1);
      }
      return this;
    },
    emit(type2, evt) {
      let handlers2 = allHandlers.get(type2);
      if (handlers2) {
        handlers2.slice().map((handler) => {
          handler(evt);
        });
      }
    },
    clear() {
      allHandlers.clear();
    }
  };
}
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function definePreset(...presets) {
  return mergeKeys(...presets);
}
var ThemeService = EventBus();
var service_default = ThemeService;
function merge$1(value1, value2) {
  if (isArray$5(value1)) {
    value1.push(...value2 || []);
  } else if (isObject$3(value1)) {
    Object.assign(value1, value2);
  }
}
function toValue(value) {
  return isObject$3(value) && value.hasOwnProperty("value") && value.hasOwnProperty("type") ? value.value : value;
}
function toUnit(value, variable = "") {
  const excludedProperties = ["opacity", "z-index", "line-height", "font-weight", "flex", "flex-grow", "flex-shrink", "order"];
  if (!excludedProperties.some((property) => variable.endsWith(property))) {
    const val = `${value}`.trim();
    const valArr = val.split(" ");
    return valArr.map((v) => isNumber$1(v) ? `${v}px` : v).join(" ");
  }
  return value;
}
function toNormalizePrefix(prefix) {
  return prefix.replaceAll(/ /g, "").replace(/[^\w]/g, "-");
}
function toNormalizeVariable(prefix = "", variable = "") {
  return toNormalizePrefix(`${isString$3(prefix, false) && isString$3(variable, false) ? `${prefix}-` : prefix}${variable}`);
}
function getVariableName(prefix = "", variable = "") {
  return `--${toNormalizeVariable(prefix, variable)}`;
}
function getVariableValue(value, variable = "", prefix = "", excludedKeyRegexes = [], fallback) {
  if (isString$3(value)) {
    const regex = /{([^}]*)}/g;
    const val = value.trim();
    if (matchRegex(val, regex)) {
      const _val = val.replaceAll(regex, (v) => {
        const path = v.replace(/{|}/g, "");
        const keys = path.split(".").filter((_v) => !excludedKeyRegexes.some((_r) => matchRegex(_v, _r)));
        return `var(${getVariableName(prefix, toKebabCase(keys.join("-")))}${isNotEmpty(fallback) ? `, ${fallback}` : ""})`;
      });
      const calculationRegex = /(\d+\s+[\+\-\*\/]\s+\d+)/g;
      const cleanedVarRegex = /var\([^)]+\)/g;
      return matchRegex(_val.replace(cleanedVarRegex, "0"), calculationRegex) ? `calc(${_val})` : _val;
    }
    return toUnit(val, variable);
  } else if (isNumber$1(value)) {
    return toUnit(value, variable);
  }
  return void 0;
}
function setProperty(properties, key, value) {
  if (isString$3(key, false)) {
    properties.push(`${key}:${value};`);
  }
}
function getRule(selector, properties) {
  if (selector) {
    return `${selector}{${properties}}`;
  }
  return "";
}
function normalizeColor(color) {
  if (color.length === 4) {
    return `#${color[1]}${color[1]}${color[2]}${color[2]}${color[3]}${color[3]}`;
  }
  return color;
}
function hexToRgb(hex) {
  var bigint = parseInt(hex.substring(1), 16);
  var r = bigint >> 16 & 255;
  var g = bigint >> 8 & 255;
  var b = bigint & 255;
  return { r, g, b };
}
function rgbToHex(r, g, b) {
  return `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
}
var mix_default = (color1, color2, weight) => {
  color1 = normalizeColor(color1);
  color2 = normalizeColor(color2);
  var p2 = weight / 100;
  var w = p2 * 2 - 1;
  var w1 = (w + 1) / 2;
  var w2 = 1 - w1;
  var rgb1 = hexToRgb(color1);
  var rgb2 = hexToRgb(color2);
  var r = Math.round(rgb1.r * w1 + rgb2.r * w2);
  var g = Math.round(rgb1.g * w1 + rgb2.g * w2);
  var b = Math.round(rgb1.b * w1 + rgb2.b * w2);
  return rgbToHex(r, g, b);
};
var shade_default = (color, percent) => mix_default("#000000", color, percent);
var tint_default = (color, percent) => mix_default("#ffffff", color, percent);
var scales = [50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 950];
var palette_default = (color) => {
  if (/{([^}]*)}/g.test(color)) {
    const token = color.replace(/{|}/g, "");
    return scales.reduce((acc, scale) => (acc[scale] = `{${token}.${scale}}`, acc), {});
  }
  return typeof color === "string" ? scales.reduce((acc, scale, i) => (acc[scale] = i <= 5 ? tint_default(color, (5 - i) * 19) : shade_default(color, (i - 5) * 15), acc), {}) : color;
};
var dt = (...args) => {
  return dtwt(config_default.getTheme(), ...args);
};
var dtwt = (theme = {}, tokenPath, fallback, type2) => {
  if (tokenPath) {
    const { variable: VARIABLE, options: OPTIONS } = config_default.defaults || {};
    const { prefix, transform: transform5 } = (theme == null ? void 0 : theme.options) || OPTIONS || {};
    const regex = /{([^}]*)}/g;
    const token = matchRegex(tokenPath, regex) ? tokenPath : `{${tokenPath}}`;
    const isStrictTransform = type2 === "value" || isEmpty(type2) && transform5 === "strict";
    return isStrictTransform ? config_default.getTokenValue(tokenPath) : getVariableValue(token, void 0, prefix, [VARIABLE.excludedKeyRegex], fallback);
  }
  return "";
};
function toVariables_default(theme, options = {}) {
  const VARIABLE = config_default.defaults.variable;
  const { prefix = VARIABLE.prefix, selector = VARIABLE.selector, excludedKeyRegex = VARIABLE.excludedKeyRegex } = options;
  const _toVariables = (_theme, _prefix = "") => {
    return Object.entries(_theme).reduce(
      (acc, [key, value]) => {
        const px = matchRegex(key, excludedKeyRegex) ? toNormalizeVariable(_prefix) : toNormalizeVariable(_prefix, toKebabCase(key));
        const v = toValue(value);
        if (isObject$3(v)) {
          const { variables: variables2, tokens: tokens22 } = _toVariables(v, px);
          merge$1(acc["tokens"], tokens22);
          merge$1(acc["variables"], variables2);
        } else {
          acc["tokens"].push((prefix ? px.replace(`${prefix}-`, "") : px).replaceAll("-", "."));
          setProperty(acc["variables"], getVariableName(px), getVariableValue(v, px, prefix, [excludedKeyRegex]));
        }
        return acc;
      },
      { variables: [], tokens: [] }
    );
  };
  const { variables, tokens: tokens2 } = _toVariables(theme, prefix);
  return {
    value: variables,
    tokens: tokens2,
    declarations: variables.join(""),
    css: getRule(selector, variables.join(""))
  };
}
var themeUtils_default = {
  regex: {
    rules: {
      class: {
        pattern: /^\.([a-zA-Z][\w-]*)$/,
        resolve(value) {
          return { type: "class", selector: value, matched: this.pattern.test(value.trim()) };
        }
      },
      attr: {
        pattern: /^\[(.*)\]$/,
        resolve(value) {
          return { type: "attr", selector: `:root${value}`, matched: this.pattern.test(value.trim()) };
        }
      },
      media: {
        pattern: /^@media (.*)$/,
        resolve(value) {
          return { type: "media", selector: `${value}{:root{[CSS]}}`, matched: this.pattern.test(value.trim()) };
        }
      },
      system: {
        pattern: /^system$/,
        resolve(value) {
          return { type: "system", selector: "@media (prefers-color-scheme: dark){:root{[CSS]}}", matched: this.pattern.test(value.trim()) };
        }
      },
      custom: {
        resolve(value) {
          return { type: "custom", selector: value, matched: true };
        }
      }
    },
    resolve(value) {
      const rules = Object.keys(this.rules).filter((k) => k !== "custom").map((r) => this.rules[r]);
      return [value].flat().map((v) => {
        var _a;
        return (_a = rules.map((r) => r.resolve(v)).find((rr) => rr.matched)) != null ? _a : this.rules.custom.resolve(v);
      });
    }
  },
  _toVariables(theme, options) {
    return toVariables_default(theme, { prefix: options == null ? void 0 : options.prefix });
  },
  getCommon({ name = "", theme = {}, params, set: set2, defaults }) {
    var _e, _f, _g, _h, _i, _j, _k;
    const { preset, options } = theme;
    let primitive_css, primitive_tokens, semantic_css, semantic_tokens, global_css, global_tokens, style;
    if (isNotEmpty(preset) && options.transform !== "strict") {
      const { primitive, semantic, extend: extend2 } = preset;
      const _a = semantic || {}, { colorScheme } = _a, sRest = __objRest(_a, ["colorScheme"]);
      const _b = extend2 || {}, { colorScheme: eColorScheme } = _b, eRest = __objRest(_b, ["colorScheme"]);
      const _c = colorScheme || {}, { dark } = _c, csRest = __objRest(_c, ["dark"]);
      const _d = eColorScheme || {}, { dark: eDark } = _d, ecsRest = __objRest(_d, ["dark"]);
      const prim_var = isNotEmpty(primitive) ? this._toVariables({ primitive }, options) : {};
      const sRest_var = isNotEmpty(sRest) ? this._toVariables({ semantic: sRest }, options) : {};
      const csRest_var = isNotEmpty(csRest) ? this._toVariables({ light: csRest }, options) : {};
      const csDark_var = isNotEmpty(dark) ? this._toVariables({ dark }, options) : {};
      const eRest_var = isNotEmpty(eRest) ? this._toVariables({ semantic: eRest }, options) : {};
      const ecsRest_var = isNotEmpty(ecsRest) ? this._toVariables({ light: ecsRest }, options) : {};
      const ecsDark_var = isNotEmpty(eDark) ? this._toVariables({ dark: eDark }, options) : {};
      const [prim_css, prim_tokens] = [(_e = prim_var.declarations) != null ? _e : "", prim_var.tokens];
      const [sRest_css, sRest_tokens] = [(_f = sRest_var.declarations) != null ? _f : "", sRest_var.tokens || []];
      const [csRest_css, csRest_tokens] = [(_g = csRest_var.declarations) != null ? _g : "", csRest_var.tokens || []];
      const [csDark_css, csDark_tokens] = [(_h = csDark_var.declarations) != null ? _h : "", csDark_var.tokens || []];
      const [eRest_css, eRest_tokens] = [(_i = eRest_var.declarations) != null ? _i : "", eRest_var.tokens || []];
      const [ecsRest_css, ecsRest_tokens] = [(_j = ecsRest_var.declarations) != null ? _j : "", ecsRest_var.tokens || []];
      const [ecsDark_css, ecsDark_tokens] = [(_k = ecsDark_var.declarations) != null ? _k : "", ecsDark_var.tokens || []];
      primitive_css = this.transformCSS(name, prim_css, "light", "variable", options, set2, defaults);
      primitive_tokens = prim_tokens;
      const semantic_light_css = this.transformCSS(name, `${sRest_css}${csRest_css}`, "light", "variable", options, set2, defaults);
      const semantic_dark_css = this.transformCSS(name, `${csDark_css}`, "dark", "variable", options, set2, defaults);
      semantic_css = `${semantic_light_css}${semantic_dark_css}`;
      semantic_tokens = [.../* @__PURE__ */ new Set([...sRest_tokens, ...csRest_tokens, ...csDark_tokens])];
      const global_light_css = this.transformCSS(name, `${eRest_css}${ecsRest_css}color-scheme:light`, "light", "variable", options, set2, defaults);
      const global_dark_css = this.transformCSS(name, `${ecsDark_css}color-scheme:dark`, "dark", "variable", options, set2, defaults);
      global_css = `${global_light_css}${global_dark_css}`;
      global_tokens = [.../* @__PURE__ */ new Set([...eRest_tokens, ...ecsRest_tokens, ...ecsDark_tokens])];
      style = resolve$1(preset.css, { dt });
    }
    return {
      primitive: {
        css: primitive_css,
        tokens: primitive_tokens
      },
      semantic: {
        css: semantic_css,
        tokens: semantic_tokens
      },
      global: {
        css: global_css,
        tokens: global_tokens
      },
      style
    };
  },
  getPreset({ name = "", preset = {}, options, params, set: set2, defaults, selector }) {
    var _e, _f, _g;
    let p_css, p_tokens, p_style;
    if (isNotEmpty(preset) && options.transform !== "strict") {
      const _name = name.replace("-directive", "");
      const _a = preset, { colorScheme, extend: extend2, css: css2 } = _a, vRest = __objRest(_a, ["colorScheme", "extend", "css"]);
      const _b = extend2 || {}, { colorScheme: eColorScheme } = _b, evRest = __objRest(_b, ["colorScheme"]);
      const _c = colorScheme || {}, { dark } = _c, csRest = __objRest(_c, ["dark"]);
      const _d = eColorScheme || {}, { dark: ecsDark } = _d, ecsRest = __objRest(_d, ["dark"]);
      const vRest_var = isNotEmpty(vRest) ? this._toVariables({ [_name]: __spreadValues(__spreadValues({}, vRest), evRest) }, options) : {};
      const csRest_var = isNotEmpty(csRest) ? this._toVariables({ [_name]: __spreadValues(__spreadValues({}, csRest), ecsRest) }, options) : {};
      const csDark_var = isNotEmpty(dark) ? this._toVariables({ [_name]: __spreadValues(__spreadValues({}, dark), ecsDark) }, options) : {};
      const [vRest_css, vRest_tokens] = [(_e = vRest_var.declarations) != null ? _e : "", vRest_var.tokens || []];
      const [csRest_css, csRest_tokens] = [(_f = csRest_var.declarations) != null ? _f : "", csRest_var.tokens || []];
      const [csDark_css, csDark_tokens] = [(_g = csDark_var.declarations) != null ? _g : "", csDark_var.tokens || []];
      const light_variable_css = this.transformCSS(_name, `${vRest_css}${csRest_css}`, "light", "variable", options, set2, defaults, selector);
      const dark_variable_css = this.transformCSS(_name, csDark_css, "dark", "variable", options, set2, defaults, selector);
      p_css = `${light_variable_css}${dark_variable_css}`;
      p_tokens = [.../* @__PURE__ */ new Set([...vRest_tokens, ...csRest_tokens, ...csDark_tokens])];
      p_style = resolve$1(css2, { dt });
    }
    return {
      css: p_css,
      tokens: p_tokens,
      style: p_style
    };
  },
  getPresetC({ name = "", theme = {}, params, set: set2, defaults }) {
    var _a;
    const { preset, options } = theme;
    const cPreset = (_a = preset == null ? void 0 : preset.components) == null ? void 0 : _a[name];
    return this.getPreset({ name, preset: cPreset, options, params, set: set2, defaults });
  },
  getPresetD({ name = "", theme = {}, params, set: set2, defaults }) {
    var _a;
    const dName = name.replace("-directive", "");
    const { preset, options } = theme;
    const dPreset = (_a = preset == null ? void 0 : preset.directives) == null ? void 0 : _a[dName];
    return this.getPreset({ name: dName, preset: dPreset, options, params, set: set2, defaults });
  },
  applyDarkColorScheme(options) {
    return !(options.darkModeSelector === "none" || options.darkModeSelector === false);
  },
  getColorSchemeOption(options, defaults) {
    var _a;
    return this.applyDarkColorScheme(options) ? this.regex.resolve(options.darkModeSelector === true ? defaults.options.darkModeSelector : (_a = options.darkModeSelector) != null ? _a : defaults.options.darkModeSelector) : [];
  },
  getLayerOrder(name, options = {}, params, defaults) {
    const { cssLayer } = options;
    if (cssLayer) {
      const order = resolve$1(cssLayer.order || "primeui", params);
      return `@layer ${order}`;
    }
    return "";
  },
  getCommonStyleSheet({ name = "", theme = {}, params, props = {}, set: set2, defaults }) {
    const common2 = this.getCommon({ name, theme, params, set: set2, defaults });
    const _props = Object.entries(props).reduce((acc, [k, v]) => acc.push(`${k}="${v}"`) && acc, []).join(" ");
    return Object.entries(common2 || {}).reduce((acc, [key, value]) => {
      if (value == null ? void 0 : value.css) {
        const _css = minifyCSS(value == null ? void 0 : value.css);
        const id = `${key}-variables`;
        acc.push(`<style type="text/css" data-primevue-style-id="${id}" ${_props}>${_css}</style>`);
      }
      return acc;
    }, []).join("");
  },
  getStyleSheet({ name = "", theme = {}, params, props = {}, set: set2, defaults }) {
    var _a;
    const options = { name, theme, params, set: set2, defaults };
    const preset_css = (_a = name.includes("-directive") ? this.getPresetD(options) : this.getPresetC(options)) == null ? void 0 : _a.css;
    const _props = Object.entries(props).reduce((acc, [k, v]) => acc.push(`${k}="${v}"`) && acc, []).join(" ");
    return preset_css ? `<style type="text/css" data-primevue-style-id="${name}-variables" ${_props}>${minifyCSS(preset_css)}</style>` : "";
  },
  createTokens(obj = {}, defaults, parentKey = "", parentPath = "", tokens2 = {}) {
    Object.entries(obj).forEach(([key, value]) => {
      const currentKey = matchRegex(key, defaults.variable.excludedKeyRegex) ? parentKey : parentKey ? `${parentKey}.${toTokenKey(key)}` : toTokenKey(key);
      const currentPath = parentPath ? `${parentPath}.${key}` : key;
      if (isObject$3(value)) {
        this.createTokens(value, defaults, currentKey, currentPath, tokens2);
      } else {
        tokens2[currentKey] || (tokens2[currentKey] = {
          paths: [],
          computed(colorScheme, tokenPathMap = {}) {
            var _a, _b;
            if (this.paths.length === 1) {
              return (_a = this.paths[0]) == null ? void 0 : _a.computed(this.paths[0].scheme, tokenPathMap["binding"]);
            } else if (colorScheme && colorScheme !== "none") {
              return (_b = this.paths.find((p2) => p2.scheme === colorScheme)) == null ? void 0 : _b.computed(colorScheme, tokenPathMap["binding"]);
            }
            return this.paths.map((p2) => p2.computed(p2.scheme, tokenPathMap[p2.scheme]));
          }
        });
        tokens2[currentKey].paths.push({
          path: currentPath,
          value,
          scheme: currentPath.includes("colorScheme.light") ? "light" : currentPath.includes("colorScheme.dark") ? "dark" : "none",
          computed(colorScheme, tokenPathMap = {}) {
            const regex = /{([^}]*)}/g;
            let computedValue = value;
            tokenPathMap["name"] = this.path;
            tokenPathMap["binding"] || (tokenPathMap["binding"] = {});
            if (matchRegex(value, regex)) {
              const val = value.trim();
              const _val = val.replaceAll(regex, (v) => {
                var _a;
                const path = v.replace(/{|}/g, "");
                const computed2 = (_a = tokens2[path]) == null ? void 0 : _a.computed(colorScheme, tokenPathMap);
                return isArray$5(computed2) && computed2.length === 2 ? `light-dark(${computed2[0].value},${computed2[1].value})` : computed2 == null ? void 0 : computed2.value;
              });
              const calculationRegex = /(\d+\w*\s+[\+\-\*\/]\s+\d+\w*)/g;
              const cleanedVarRegex = /var\([^)]+\)/g;
              computedValue = matchRegex(_val.replace(cleanedVarRegex, "0"), calculationRegex) ? `calc(${_val})` : _val;
            }
            isEmpty(tokenPathMap["binding"]) && delete tokenPathMap["binding"];
            return {
              colorScheme,
              path: this.path,
              paths: tokenPathMap,
              value: computedValue.includes("undefined") ? void 0 : computedValue
            };
          }
        });
      }
    });
    return tokens2;
  },
  getTokenValue(tokens2, path, defaults) {
    var _a;
    const normalizePath = (str) => {
      const strArr = str.split(".");
      return strArr.filter((s) => !matchRegex(s.toLowerCase(), defaults.variable.excludedKeyRegex)).join(".");
    };
    const token = normalizePath(path);
    const colorScheme = path.includes("colorScheme.light") ? "light" : path.includes("colorScheme.dark") ? "dark" : void 0;
    const computedValues = [(_a = tokens2[token]) == null ? void 0 : _a.computed(colorScheme)].flat().filter((computed2) => computed2);
    return computedValues.length === 1 ? computedValues[0].value : computedValues.reduce((acc = {}, computed2) => {
      const _a2 = computed2, { colorScheme: cs } = _a2, rest = __objRest(_a2, ["colorScheme"]);
      acc[cs] = rest;
      return acc;
    }, void 0);
  },
  getSelectorRule(selector1, selector2, type2, css2) {
    return type2 === "class" || type2 === "attr" ? getRule(isNotEmpty(selector2) ? `${selector1}${selector2},${selector1} ${selector2}` : selector1, css2) : getRule(selector1, isNotEmpty(selector2) ? getRule(selector2, css2) : css2);
  },
  transformCSS(name, css2, mode, type2, options = {}, set2, defaults, selector) {
    if (isNotEmpty(css2)) {
      const { cssLayer } = options;
      if (type2 !== "style") {
        const colorSchemeOption = this.getColorSchemeOption(options, defaults);
        css2 = mode === "dark" ? colorSchemeOption.reduce((acc, { type: type22, selector: _selector }) => {
          if (isNotEmpty(_selector)) {
            acc += _selector.includes("[CSS]") ? _selector.replace("[CSS]", css2) : this.getSelectorRule(_selector, selector, type22, css2);
          }
          return acc;
        }, "") : getRule(selector != null ? selector : ":root", css2);
      }
      if (cssLayer) {
        const layerOptions = {
          name: "primeui",
          order: "primeui"
        };
        isObject$3(cssLayer) && (layerOptions.name = resolve$1(cssLayer.name, { name, type: type2 }));
        if (isNotEmpty(layerOptions.name)) {
          css2 = getRule(`@layer ${layerOptions.name}`, css2);
          set2 == null ? void 0 : set2.layerNames(layerOptions.name);
        }
      }
      return css2;
    }
    return "";
  }
};
var config_default = {
  defaults: {
    variable: {
      prefix: "p",
      selector: ":root",
      excludedKeyRegex: /^(primitive|semantic|components|directives|variables|colorscheme|light|dark|common|root|states|extend|css)$/gi
    },
    options: {
      prefix: "p",
      darkModeSelector: "system",
      cssLayer: false
    }
  },
  _theme: void 0,
  _layerNames: /* @__PURE__ */ new Set(),
  _loadedStyleNames: /* @__PURE__ */ new Set(),
  _loadingStyles: /* @__PURE__ */ new Set(),
  _tokens: {},
  update(newValues = {}) {
    const { theme } = newValues;
    if (theme) {
      this._theme = __spreadProps(__spreadValues({}, theme), {
        options: __spreadValues(__spreadValues({}, this.defaults.options), theme.options)
      });
      this._tokens = themeUtils_default.createTokens(this.preset, this.defaults);
      this.clearLoadedStyleNames();
    }
  },
  get theme() {
    return this._theme;
  },
  get preset() {
    var _a;
    return ((_a = this.theme) == null ? void 0 : _a.preset) || {};
  },
  get options() {
    var _a;
    return ((_a = this.theme) == null ? void 0 : _a.options) || {};
  },
  get tokens() {
    return this._tokens;
  },
  getTheme() {
    return this.theme;
  },
  setTheme(newValue) {
    this.update({ theme: newValue });
    service_default.emit("theme:change", newValue);
  },
  getPreset() {
    return this.preset;
  },
  setPreset(newValue) {
    this._theme = __spreadProps(__spreadValues({}, this.theme), { preset: newValue });
    this._tokens = themeUtils_default.createTokens(newValue, this.defaults);
    this.clearLoadedStyleNames();
    service_default.emit("preset:change", newValue);
    service_default.emit("theme:change", this.theme);
  },
  getOptions() {
    return this.options;
  },
  setOptions(newValue) {
    this._theme = __spreadProps(__spreadValues({}, this.theme), { options: newValue });
    this.clearLoadedStyleNames();
    service_default.emit("options:change", newValue);
    service_default.emit("theme:change", this.theme);
  },
  getLayerNames() {
    return [...this._layerNames];
  },
  setLayerNames(layerName) {
    this._layerNames.add(layerName);
  },
  getLoadedStyleNames() {
    return this._loadedStyleNames;
  },
  isStyleNameLoaded(name) {
    return this._loadedStyleNames.has(name);
  },
  setLoadedStyleName(name) {
    this._loadedStyleNames.add(name);
  },
  deleteLoadedStyleName(name) {
    this._loadedStyleNames.delete(name);
  },
  clearLoadedStyleNames() {
    this._loadedStyleNames.clear();
  },
  getTokenValue(tokenPath) {
    return themeUtils_default.getTokenValue(this.tokens, tokenPath, this.defaults);
  },
  getCommon(name = "", params) {
    return themeUtils_default.getCommon({ name, theme: this.theme, params, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } });
  },
  getComponent(name = "", params) {
    const options = { name, theme: this.theme, params, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } };
    return themeUtils_default.getPresetC(options);
  },
  getDirective(name = "", params) {
    const options = { name, theme: this.theme, params, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } };
    return themeUtils_default.getPresetD(options);
  },
  getCustomPreset(name = "", preset, selector, params) {
    const options = { name, preset, options: this.options, selector, params, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } };
    return themeUtils_default.getPreset(options);
  },
  getLayerOrderCSS(name = "") {
    return themeUtils_default.getLayerOrder(name, this.options, { names: this.getLayerNames() }, this.defaults);
  },
  transformCSS(name = "", css2, type2 = "style", mode) {
    return themeUtils_default.transformCSS(name, css2, mode, type2, this.options, { layerNames: this.setLayerNames.bind(this) }, this.defaults);
  },
  getCommonStyleSheet(name = "", params, props = {}) {
    return themeUtils_default.getCommonStyleSheet({ name, theme: this.theme, params, props, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } });
  },
  getStyleSheet(name, params, props = {}) {
    return themeUtils_default.getStyleSheet({ name, theme: this.theme, params, props, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } });
  },
  onStyleMounted(name) {
    this._loadingStyles.add(name);
  },
  onStyleUpdated(name) {
    this._loadingStyles.add(name);
  },
  onStyleLoaded(event, { name }) {
    if (this._loadingStyles.size) {
      this._loadingStyles.delete(name);
      service_default.emit(`theme:${name}:load`, event);
      !this._loadingStyles.size && service_default.emit("theme:load");
    }
  }
};
function updatePreset(...presets) {
  const newPreset = mergeKeys(config_default.getPreset(), ...presets);
  config_default.setPreset(newPreset);
  return newPreset;
}
/**
* @vue/shared v3.5.11
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function makeMap(str) {
  const map = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(","))
    map[key] = 1;
  return (val) => val in map;
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
const hasOwn$1 = (val, key) => hasOwnProperty$2.call(val, key);
const isArray$4 = Array.isArray;
const isMap = (val) => toTypeString$1(val) === "[object Map]";
const isSet = (val) => toTypeString$1(val) === "[object Set]";
const isDate$1 = (val) => toTypeString$1(val) === "[object Date]";
const isFunction$1 = (val) => typeof val === "function";
const isString$2 = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$2 = (val) => val !== null && typeof val === "object";
const isPromise$1 = (val) => {
  return (isObject$2(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
};
const objectToString$1 = Object.prototype.toString;
const toTypeString$1 = (value) => objectToString$1.call(value);
const toRawType = (value) => {
  return toTypeString$1(value).slice(8, -1);
};
const isPlainObject$3 = (val) => toTypeString$1(val) === "[object Object]";
const isIntegerKey = (key) => isString$2(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache2[str];
    return hit || (cache2[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction(
  (str) => {
    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
  }
);
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize$1 = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction(
  (str) => {
    const s = str ? `on${capitalize$1(str)}` : ``;
    return s;
  }
);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, ...arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](...arg);
  }
};
const def = (obj, key, value, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString$2(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis$1;
const getGlobalThis$1 = () => {
  return _globalThis$1 || (_globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function normalizeStyle(value) {
  if (isArray$4(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString$2(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$2(value) || isObject$2(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$2(value)) {
    res = value;
  } else if (isArray$4(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$2(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function looseCompareArrays(a, b) {
  if (a.length !== b.length)
    return false;
  let equal2 = true;
  for (let i = 0; equal2 && i < a.length; i++) {
    equal2 = looseEqual(a[i], b[i]);
  }
  return equal2;
}
function looseEqual(a, b) {
  if (a === b)
    return true;
  let aValidType = isDate$1(a);
  let bValidType = isDate$1(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray$4(a);
  bValidType = isArray$4(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject$2(a);
  bValidType = isObject$2(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const isRef$1 = (val) => {
  return !!(val && val["__v_isRef"] === true);
};
const toDisplayString$1 = (val) => {
  return isString$2(val) ? val : val == null ? "" : isArray$4(val) || isObject$2(val) && (val.toString === objectToString$1 || !isFunction$1(val.toString)) ? isRef$1(val) ? toDisplayString$1(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (isRef$1(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
    };
  } else if (isSymbol(val)) {
    return stringifySymbol(val);
  } else if (isObject$2(val) && !isArray$4(val) && !isPlainObject$3(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v, i = "") => {
  var _a;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v
  );
};
/**
* @vue/reactivity v3.5.11
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this._isPaused = false;
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = true;
      let i, l;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].pause();
        }
      }
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].pause();
      }
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active) {
      if (this._isPaused) {
        this._isPaused = false;
        let i, l;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].resume();
          }
        }
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].resume();
        }
      }
    }
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn, failSilently = false) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
let activeSub;
const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
class ReactiveEffect {
  constructor(fn) {
    this.fn = fn;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 1 | 4;
    this.next = void 0;
    this.cleanup = void 0;
    this.scheduler = void 0;
    if (activeEffectScope && activeEffectScope.active) {
      activeEffectScope.effects.push(this);
    }
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    if (this.flags & 64) {
      this.flags &= ~64;
      if (pausedQueueEffects.has(this)) {
        pausedQueueEffects.delete(this);
        this.trigger();
      }
    }
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags & 2 && !(this.flags & 32)) {
      return;
    }
    if (!(this.flags & 8)) {
      batch(this);
    }
  }
  run() {
    if (!(this.flags & 1)) {
      return this.fn();
    }
    this.flags |= 2;
    cleanupEffect(this);
    prepareDeps(this);
    const prevEffect = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = this;
    shouldTrack = true;
    try {
      return this.fn();
    } finally {
      cleanupDeps(this);
      activeSub = prevEffect;
      shouldTrack = prevShouldTrack;
      this.flags &= ~2;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let link2 = this.deps; link2; link2 = link2.nextDep) {
        removeSub(link2);
      }
      this.deps = this.depsTail = void 0;
      cleanupEffect(this);
      this.onStop && this.onStop();
      this.flags &= ~1;
    }
  }
  trigger() {
    if (this.flags & 64) {
      pausedQueueEffects.add(this);
    } else if (this.scheduler) {
      this.scheduler();
    } else {
      this.runIfDirty();
    }
  }
  /**
   * @internal
   */
  runIfDirty() {
    if (isDirty(this)) {
      this.run();
    }
  }
  get dirty() {
    return isDirty(this);
  }
}
let batchDepth = 0;
let batchedSub;
let batchedComputed;
function batch(sub2, isComputed2 = false) {
  sub2.flags |= 8;
  if (isComputed2) {
    sub2.next = batchedComputed;
    batchedComputed = sub2;
    return;
  }
  sub2.next = batchedSub;
  batchedSub = sub2;
}
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  if (batchedComputed) {
    let e2 = batchedComputed;
    batchedComputed = void 0;
    while (e2) {
      const next = e2.next;
      e2.next = void 0;
      e2.flags &= ~8;
      e2 = next;
    }
  }
  let error;
  while (batchedSub) {
    let e2 = batchedSub;
    batchedSub = void 0;
    while (e2) {
      const next = e2.next;
      e2.next = void 0;
      e2.flags &= ~8;
      if (e2.flags & 1) {
        try {
          ;
          e2.trigger();
        } catch (err) {
          if (!error)
            error = err;
        }
      }
      e2 = next;
    }
  }
  if (error)
    throw error;
}
function prepareDeps(sub2) {
  for (let link2 = sub2.deps; link2; link2 = link2.nextDep) {
    link2.version = -1;
    link2.prevActiveLink = link2.dep.activeLink;
    link2.dep.activeLink = link2;
  }
}
function cleanupDeps(sub2) {
  let head;
  let tail = sub2.depsTail;
  let link2 = tail;
  while (link2) {
    const prev = link2.prevDep;
    if (link2.version === -1) {
      if (link2 === tail)
        tail = prev;
      removeSub(link2);
      removeDep(link2);
    } else {
      head = link2;
    }
    link2.dep.activeLink = link2.prevActiveLink;
    link2.prevActiveLink = void 0;
    link2 = prev;
  }
  sub2.deps = head;
  sub2.depsTail = tail;
}
function isDirty(sub2) {
  for (let link2 = sub2.deps; link2; link2 = link2.nextDep) {
    if (link2.dep.version !== link2.version || link2.dep.computed && (refreshComputed(link2.dep.computed) || link2.dep.version !== link2.version)) {
      return true;
    }
  }
  if (sub2._dirty) {
    return true;
  }
  return false;
}
function refreshComputed(computed2) {
  if (computed2.flags & 4 && !(computed2.flags & 16)) {
    return;
  }
  computed2.flags &= ~16;
  if (computed2.globalVersion === globalVersion) {
    return;
  }
  computed2.globalVersion = globalVersion;
  const dep = computed2.dep;
  computed2.flags |= 2;
  if (dep.version > 0 && !computed2.isSSR && computed2.deps && !isDirty(computed2)) {
    computed2.flags &= ~2;
    return;
  }
  const prevSub = activeSub;
  const prevShouldTrack = shouldTrack;
  activeSub = computed2;
  shouldTrack = true;
  try {
    prepareDeps(computed2);
    const value = computed2.fn(computed2._value);
    if (dep.version === 0 || hasChanged(value, computed2._value)) {
      computed2._value = value;
      dep.version++;
    }
  } catch (err) {
    dep.version++;
    throw err;
  } finally {
    activeSub = prevSub;
    shouldTrack = prevShouldTrack;
    cleanupDeps(computed2);
    computed2.flags &= ~2;
  }
}
function removeSub(link2, soft = false) {
  const { dep, prevSub, nextSub } = link2;
  if (prevSub) {
    prevSub.nextSub = nextSub;
    link2.prevSub = void 0;
  }
  if (nextSub) {
    nextSub.prevSub = prevSub;
    link2.nextSub = void 0;
  }
  if (dep.subs === link2) {
    dep.subs = prevSub;
  }
  if (!dep.subs && dep.computed) {
    dep.computed.flags &= ~4;
    for (let l = dep.computed.deps; l; l = l.nextDep) {
      removeSub(l, true);
    }
  }
  if (!soft && !--dep.sc && dep.map) {
    dep.map.delete(dep.key);
  }
}
function removeDep(link2) {
  const { prevDep, nextDep } = link2;
  if (prevDep) {
    prevDep.nextDep = nextDep;
    link2.prevDep = void 0;
  }
  if (nextDep) {
    nextDep.prevDep = prevDep;
    link2.nextDep = void 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function cleanupEffect(e2) {
  const { cleanup } = e2;
  e2.cleanup = void 0;
  if (cleanup) {
    const prevSub = activeSub;
    activeSub = void 0;
    try {
      cleanup();
    } finally {
      activeSub = prevSub;
    }
  }
}
let globalVersion = 0;
class Link {
  constructor(sub2, dep) {
    this.sub = sub2;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Dep {
  constructor(computed2) {
    this.computed = computed2;
    this.version = 0;
    this.activeLink = void 0;
    this.subs = void 0;
    this.map = void 0;
    this.key = void 0;
    this.sc = 0;
  }
  track(debugInfo) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }
    let link2 = this.activeLink;
    if (link2 === void 0 || link2.sub !== activeSub) {
      link2 = this.activeLink = new Link(activeSub, this);
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link2;
      } else {
        link2.prevDep = activeSub.depsTail;
        activeSub.depsTail.nextDep = link2;
        activeSub.depsTail = link2;
      }
      addSub(link2);
    } else if (link2.version === -1) {
      link2.version = this.version;
      if (link2.nextDep) {
        const next = link2.nextDep;
        next.prevDep = link2.prevDep;
        if (link2.prevDep) {
          link2.prevDep.nextDep = next;
        }
        link2.prevDep = activeSub.depsTail;
        link2.nextDep = void 0;
        activeSub.depsTail.nextDep = link2;
        activeSub.depsTail = link2;
        if (activeSub.deps === link2) {
          activeSub.deps = next;
        }
      }
    }
    return link2;
  }
  trigger(debugInfo) {
    this.version++;
    globalVersion++;
    this.notify(debugInfo);
  }
  notify(debugInfo) {
    startBatch();
    try {
      if (false)
        ;
      for (let link2 = this.subs; link2; link2 = link2.prevSub) {
        if (link2.sub.notify()) {
          ;
          link2.sub.dep.notify();
        }
      }
    } finally {
      endBatch();
    }
  }
}
function addSub(link2) {
  link2.dep.sc++;
  if (link2.sub.flags & 4) {
    const computed2 = link2.dep.computed;
    if (computed2 && !link2.dep.subs) {
      computed2.flags |= 4 | 16;
      for (let l = computed2.deps; l; l = l.nextDep) {
        addSub(l);
      }
    }
    const currentTail = link2.dep.subs;
    if (currentTail !== link2) {
      link2.prevSub = currentTail;
      if (currentTail)
        currentTail.nextSub = link2;
    }
    link2.dep.subs = link2;
  }
}
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol(
  ""
);
const MAP_KEY_ITERATE_KEY = Symbol(
  ""
);
const ARRAY_ITERATE_KEY = Symbol(
  ""
);
function track(target, type2, key) {
  if (shouldTrack && activeSub) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Dep());
      dep.map = depsMap;
      dep.key = key;
    }
    {
      dep.track();
    }
  }
}
function trigger(target, type2, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;
    return;
  }
  const run = (dep) => {
    if (dep) {
      {
        dep.trigger();
      }
    }
  };
  startBatch();
  if (type2 === "clear") {
    depsMap.forEach(run);
  } else {
    const targetIsArray = isArray$4(target);
    const isArrayIndex = targetIsArray && isIntegerKey(key);
    if (targetIsArray && key === "length") {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
          run(dep);
        }
      });
    } else {
      if (key !== void 0) {
        run(depsMap.get(key));
      }
      if (isArrayIndex) {
        run(depsMap.get(ARRAY_ITERATE_KEY));
      }
      switch (type2) {
        case "add":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isArrayIndex) {
            run(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            run(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
  }
  endBatch();
}
function getDepFromReactive(object, key) {
  const depMap = targetMap.get(object);
  return depMap && depMap.get(key);
}
function reactiveReadArray(array) {
  const raw = toRaw(array);
  if (raw === array)
    return raw;
  track(raw, "iterate", ARRAY_ITERATE_KEY);
  return isShallow(array) ? raw : raw.map(toReactive);
}
function shallowReadArray(arr) {
  track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
  return arr;
}
const arrayInstrumentations = {
  __proto__: null,
  [Symbol.iterator]() {
    return iterator(this, Symbol.iterator, toReactive);
  },
  concat(...args) {
    return reactiveReadArray(this).concat(
      ...args.map((x) => isArray$4(x) ? reactiveReadArray(x) : x)
    );
  },
  entries() {
    return iterator(this, "entries", (value) => {
      value[1] = toReactive(value[1]);
      return value;
    });
  },
  every(fn, thisArg) {
    return apply$1(this, "every", fn, thisArg, void 0, arguments);
  },
  filter(fn, thisArg) {
    return apply$1(this, "filter", fn, thisArg, (v) => v.map(toReactive), arguments);
  },
  find(fn, thisArg) {
    return apply$1(this, "find", fn, thisArg, toReactive, arguments);
  },
  findIndex(fn, thisArg) {
    return apply$1(this, "findIndex", fn, thisArg, void 0, arguments);
  },
  findLast(fn, thisArg) {
    return apply$1(this, "findLast", fn, thisArg, toReactive, arguments);
  },
  findLastIndex(fn, thisArg) {
    return apply$1(this, "findLastIndex", fn, thisArg, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(fn, thisArg) {
    return apply$1(this, "forEach", fn, thisArg, void 0, arguments);
  },
  includes(...args) {
    return searchProxy(this, "includes", args);
  },
  indexOf(...args) {
    return searchProxy(this, "indexOf", args);
  },
  join(separator) {
    return reactiveReadArray(this).join(separator);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...args) {
    return searchProxy(this, "lastIndexOf", args);
  },
  map(fn, thisArg) {
    return apply$1(this, "map", fn, thisArg, void 0, arguments);
  },
  pop() {
    return noTracking(this, "pop");
  },
  push(...args) {
    return noTracking(this, "push", args);
  },
  reduce(fn, ...args) {
    return reduce(this, "reduce", fn, args);
  },
  reduceRight(fn, ...args) {
    return reduce(this, "reduceRight", fn, args);
  },
  shift() {
    return noTracking(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(fn, thisArg) {
    return apply$1(this, "some", fn, thisArg, void 0, arguments);
  },
  splice(...args) {
    return noTracking(this, "splice", args);
  },
  toReversed() {
    return reactiveReadArray(this).toReversed();
  },
  toSorted(comparer) {
    return reactiveReadArray(this).toSorted(comparer);
  },
  toSpliced(...args) {
    return reactiveReadArray(this).toSpliced(...args);
  },
  unshift(...args) {
    return noTracking(this, "unshift", args);
  },
  values() {
    return iterator(this, "values", toReactive);
  }
};
function iterator(self2, method, wrapValue) {
  const arr = shallowReadArray(self2);
  const iter = arr[method]();
  if (arr !== self2 && !isShallow(self2)) {
    iter._next = iter.next;
    iter.next = () => {
      const result = iter._next();
      if (result.value) {
        result.value = wrapValue(result.value);
      }
      return result;
    };
  }
  return iter;
}
const arrayProto = Array.prototype;
function apply$1(self2, method, fn, thisArg, wrappedRetFn, args) {
  const arr = shallowReadArray(self2);
  const needsWrap = arr !== self2 && !isShallow(self2);
  const methodFn = arr[method];
  if (methodFn !== arrayProto[method]) {
    const result2 = methodFn.apply(self2, args);
    return needsWrap ? toReactive(result2) : result2;
  }
  let wrappedFn = fn;
  if (arr !== self2) {
    if (needsWrap) {
      wrappedFn = function(item, index2) {
        return fn.call(this, toReactive(item), index2, self2);
      };
    } else if (fn.length > 2) {
      wrappedFn = function(item, index2) {
        return fn.call(this, item, index2, self2);
      };
    }
  }
  const result = methodFn.call(arr, wrappedFn, thisArg);
  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce(self2, method, fn, args) {
  const arr = shallowReadArray(self2);
  let wrappedFn = fn;
  if (arr !== self2) {
    if (!isShallow(self2)) {
      wrappedFn = function(acc, item, index2) {
        return fn.call(this, acc, toReactive(item), index2, self2);
      };
    } else if (fn.length > 3) {
      wrappedFn = function(acc, item, index2) {
        return fn.call(this, acc, item, index2, self2);
      };
    }
  }
  return arr[method](wrappedFn, ...args);
}
function searchProxy(self2, method, args) {
  const arr = toRaw(self2);
  track(arr, "iterate", ARRAY_ITERATE_KEY);
  const res = arr[method](...args);
  if ((res === -1 || res === false) && isProxy(args[0])) {
    args[0] = toRaw(args[0]);
    return arr[method](...args);
  }
  return res;
}
function noTracking(self2, method, args = []) {
  pauseTracking();
  startBatch();
  const res = toRaw(self2)[method].apply(self2, args);
  endBatch();
  resetTracking();
  return res;
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
function hasOwnProperty$1(key) {
  if (!isSymbol(key))
    key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray$4(target);
    if (!isReadonly2) {
      let fn;
      if (targetIsArray && (fn = arrayInstrumentations[key])) {
        return fn;
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$1;
      }
    }
    const res = Reflect.get(
      target,
      key,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      isRef(target) ? target : receiver
    );
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$2(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray$4(target) && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArray$4(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn$1(target, key);
    const result = Reflect.set(
      target,
      key,
      value,
      isRef(target) ? target : receiver
    );
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn$1(target, key);
    target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray$4(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    return true;
  }
  deleteProperty(target, key) {
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get$2(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add$1(value, _isShallow = false) {
  if (!_isShallow && !isShallow(value) && !isReadonly(value)) {
    value = toRaw(value);
  }
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set(key, value, _isShallow = false) {
  if (!_isShallow && !isShallow(value) && !isReadonly(value)) {
    value = toRaw(value);
  }
  const target = toRaw(this);
  const { has: has2, get: get22 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get22.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get22 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get22 ? get22.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type2) {
  return function(...args) {
    return type2 === "delete" ? false : type2 === "clear" ? void 0 : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$2(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add: add$1,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$2(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add(value) {
      return add$1.call(this, value, true);
    },
    set(key, value) {
      return set.call(this, key, value, true);
    },
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$2(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$2(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn$1(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$2(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return value ? !!value["__v_raw"] : false;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  if (!hasOwn$1(value, "__v_skip") && Object.isExtensible(value)) {
    def(value, "__v_skip", true);
  }
  return value;
}
const toReactive = (value) => isObject$2(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$2(value) ? readonly(value) : value;
function isRef(r) {
  return r ? r["__v_isRef"] === true : false;
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, isShallow2) {
    this.dep = new Dep();
    this["__v_isRef"] = true;
    this["__v_isShallow"] = false;
    this._rawValue = isShallow2 ? value : toRaw(value);
    this._value = isShallow2 ? value : toReactive(value);
    this["__v_isShallow"] = isShallow2;
  }
  get value() {
    {
      this.dep.track();
    }
    return this._value;
  }
  set value(newValue) {
    const oldValue = this._rawValue;
    const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
    newValue = useDirectValue ? newValue : toRaw(newValue);
    if (hasChanged(newValue, oldValue)) {
      this._rawValue = newValue;
      this._value = useDirectValue ? newValue : toReactive(newValue);
      {
        this.dep.trigger();
      }
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
function toRefs(object) {
  const ret = isArray$4(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this["__v_isRef"] = true;
    this._value = void 0;
  }
  get value() {
    const val = this._object[this._key];
    return this._value = val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
class ComputedRefImpl {
  constructor(fn, setter, isSSR) {
    this.fn = fn;
    this.setter = setter;
    this._value = void 0;
    this.dep = new Dep(this);
    this.__v_isRef = true;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 16;
    this.globalVersion = globalVersion - 1;
    this.next = void 0;
    this.effect = this;
    this["__v_isReadonly"] = !setter;
    this.isSSR = isSSR;
  }
  /**
   * @internal
   */
  notify() {
    this.flags |= 16;
    if (!(this.flags & 8) && // avoid infinite self recursion
    activeSub !== this) {
      batch(this, true);
      return true;
    }
  }
  get value() {
    const link2 = this.dep.track();
    refreshComputed(this);
    if (link2) {
      link2.version = this.dep.version;
    }
    return this._value;
  }
  set value(newValue) {
    if (this.setter) {
      this.setter(newValue);
    }
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  if (isFunction$1(getterOrOptions)) {
    getter = getterOrOptions;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, isSSR);
  return cRef;
}
const INITIAL_WATCHER_VALUE = {};
const cleanupMap = /* @__PURE__ */ new WeakMap();
let activeWatcher = void 0;
function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
  if (owner) {
    let cleanups = cleanupMap.get(owner);
    if (!cleanups)
      cleanupMap.set(owner, cleanups = []);
    cleanups.push(cleanupFn);
  }
}
function watch$1(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, once, scheduler, augmentJob, call } = options;
  const reactiveGetter = (source2) => {
    if (deep)
      return source2;
    if (isShallow(source2) || deep === false || deep === 0)
      return traverse$2(source2, 1);
    return traverse$2(source2);
  };
  let effect2;
  let getter;
  let cleanup;
  let boundCleanup;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray$4(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if (isFunction$1(s)) {
        return call ? call(s, 2) : s();
      } else
        ;
    });
  } else if (isFunction$1(source)) {
    if (cb) {
      getter = call ? () => call(source, 2) : source;
    } else {
      getter = () => {
        if (cleanup) {
          pauseTracking();
          try {
            cleanup();
          } finally {
            resetTracking();
          }
        }
        const currentEffect = activeWatcher;
        activeWatcher = effect2;
        try {
          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
        } finally {
          activeWatcher = currentEffect;
        }
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    const depth = deep === true ? Infinity : deep;
    getter = () => traverse$2(baseGetter(), depth);
  }
  const scope = getCurrentScope();
  const watchHandle = () => {
    effect2.stop();
    if (scope) {
      remove(scope.effects, effect2);
    }
  };
  if (once && cb) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      watchHandle();
    };
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = (immediateFirstRun) => {
    if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
        if (cleanup) {
          cleanup();
        }
        const currentWatcher = activeWatcher;
        activeWatcher = effect2;
        try {
          const args = [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            boundCleanup
          ];
          call ? call(cb, 3, args) : (
            // @ts-expect-error
            cb(...args)
          );
          oldValue = newValue;
        } finally {
          activeWatcher = currentWatcher;
        }
      }
    } else {
      effect2.run();
    }
  };
  if (augmentJob) {
    augmentJob(job);
  }
  effect2 = new ReactiveEffect(getter);
  effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
  cleanup = effect2.onStop = () => {
    const cleanups = cleanupMap.get(effect2);
    if (cleanups) {
      if (call) {
        call(cleanups, 4);
      } else {
        for (const cleanup2 of cleanups)
          cleanup2();
      }
      cleanupMap.delete(effect2);
    }
  };
  if (cb) {
    if (immediate) {
      job(true);
    } else {
      oldValue = effect2.run();
    }
  } else if (scheduler) {
    scheduler(job.bind(null, true), true);
  } else {
    effect2.run();
  }
  watchHandle.pause = effect2.pause.bind(effect2);
  watchHandle.resume = effect2.resume.bind(effect2);
  watchHandle.stop = watchHandle;
  return watchHandle;
}
function traverse$2(value, depth = Infinity, seen2) {
  if (depth <= 0 || !isObject$2(value) || value["__v_skip"]) {
    return value;
  }
  seen2 = seen2 || /* @__PURE__ */ new Set();
  if (seen2.has(value)) {
    return value;
  }
  seen2.add(value);
  depth--;
  if (isRef(value)) {
    traverse$2(value.value, depth, seen2);
  } else if (isArray$4(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse$2(value[i], depth, seen2);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse$2(v, depth, seen2);
    });
  } else if (isPlainObject$3(value)) {
    for (const key in value) {
      traverse$2(value[key], depth, seen2);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      if (Object.prototype.propertyIsEnumerable.call(value, key)) {
        traverse$2(value[key], depth, seen2);
      }
    }
  }
  return value;
}
/**
* @vue/runtime-core v3.5.11
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const stack$1 = [];
let isWarning = false;
function warn$1(msg, ...args) {
  if (isWarning)
    return;
  isWarning = true;
  pauseTracking();
  const instance2 = stack$1.length ? stack$1[stack$1.length - 1].component : null;
  const appWarnHandler = instance2 && instance2.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance2,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a) => {
          var _a, _b;
          return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
        }).join(""),
        instance2 && instance2.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance2, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
  isWarning = false;
}
function getComponentTrace() {
  let currentVNode = stack$1[stack$1.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString$2(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction$1(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function callWithErrorHandling(fn, instance2, type2, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance2, type2);
  }
}
function callWithAsyncErrorHandling(fn, instance2, type2, args) {
  if (isFunction$1(fn)) {
    const res = callWithErrorHandling(fn, instance2, type2, args);
    if (res && isPromise$1(res)) {
      res.catch((err) => {
        handleError(err, instance2, type2);
      });
    }
    return res;
  }
  if (isArray$4(fn)) {
    const values = [];
    for (let i = 0; i < fn.length; i++) {
      values.push(callWithAsyncErrorHandling(fn[i], instance2, type2, args));
    }
    return values;
  }
}
function handleError(err, instance2, type2, throwInDev = true) {
  const contextVNode = instance2 ? instance2.vnode : null;
  const { errorHandler, throwUnhandledErrorInProduction } = instance2 && instance2.appContext.config || EMPTY_OBJ;
  if (instance2) {
    let cur = instance2.parent;
    const exposedInstance = instance2.proxy;
    const errorInfo = `https://vuejs.org/error-reference/#runtime-${type2}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    if (errorHandler) {
      pauseTracking();
      callWithErrorHandling(errorHandler, null, 10, [
        err,
        exposedInstance,
        errorInfo
      ]);
      resetTracking();
      return;
    }
  }
  logError(err, type2, contextVNode, throwInDev, throwUnhandledErrorInProduction);
}
function logError(err, type2, contextVNode, throwInDev = true, throwInProd = false) {
  if (throwInProd) {
    throw err;
  } else {
    console.error(err);
  }
}
const queue = [];
let flushIndex = -1;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!(job.flags & 1)) {
    const jobId = getId(job);
    const lastJob = queue[queue.length - 1];
    if (!lastJob || // fast path when the job id is larger than the tail
    !(job.flags & 2) && jobId >= getId(lastJob)) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(jobId), 0, job);
    }
    job.flags |= 1;
    queueFlush();
  }
}
function queueFlush() {
  if (!currentFlushPromise) {
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$4(cb)) {
    if (activePostFlushCbs && cb.id === -1) {
      activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
    } else if (!(cb.flags & 1)) {
      pendingPostFlushCbs.push(cb);
      cb.flags |= 1;
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance2, seen2, i = flushIndex + 1) {
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.flags & 2) {
      if (instance2 && cb.id !== instance2.uid) {
        continue;
      }
      queue.splice(i, 1);
      i--;
      if (cb.flags & 4) {
        cb.flags &= ~1;
      }
      cb();
      if (!(cb.flags & 4)) {
        cb.flags &= ~1;
      }
    }
  }
}
function flushPostFlushCbs(seen2) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a, b) => getId(a) - getId(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb = activePostFlushCbs[postFlushIndex];
      if (cb.flags & 4) {
        cb.flags &= ~1;
      }
      if (!(cb.flags & 8))
        cb();
      cb.flags &= ~1;
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
function flushJobs(seen2) {
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && !(job.flags & 8)) {
        if (false)
          ;
        if (job.flags & 4) {
          job.flags &= ~1;
        }
        callWithErrorHandling(
          job,
          job.i,
          job.i ? 15 : 14
        );
        if (!(job.flags & 4)) {
          job.flags &= ~1;
        }
      }
    }
  } finally {
    for (; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job) {
        job.flags &= ~1;
      }
    }
    flushIndex = -1;
    queue.length = 0;
    flushPostFlushCbs();
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance2) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance2;
  currentScopeId = instance2 && instance2.type.__scopeId || null;
  return prev;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function withDirectives(vnode, directives2) {
  if (currentRenderingInstance === null) {
    return vnode;
  }
  const instance2 = getComponentPublicInstance(currentRenderingInstance);
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives2.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives2[i];
    if (dir) {
      if (isFunction$1(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse$2(value);
      }
      bindings.push({
        dir,
        instance: instance2,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance2, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance2, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const TeleportEndKey = Symbol("_vte");
const isTeleport = (type2) => type2.__isTeleport;
const leaveCbKey = Symbol("_leaveCb");
const enterCbKey$1 = Symbol("_enterCb");
function useTransitionState() {
  const state2 = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state2.isMounted = true;
  });
  onBeforeUnmount(() => {
    state2.isUnmounting = true;
  });
  return state2;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const recursiveGetSubtree = (instance2) => {
  const subTree = instance2.subTree;
  return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance2 = getCurrentInstance();
    const state2 = useTransitionState();
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      const child = findNonCommentChild(children);
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state2.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getInnerChild$1(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      let enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state2,
        instance2,
        // #11061, ensure enterHooks is fresh after clone
        (hooks) => enterHooks = hooks
      );
      if (innerChild.type !== Comment) {
        setTransitionHooks(innerChild, enterHooks);
      }
      const oldChild = instance2.subTree;
      const oldInnerChild = oldChild && getInnerChild$1(oldChild);
      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance2).type !== Comment) {
        const leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state2,
          instance2
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in" && innerChild.type !== Comment) {
          state2.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state2.isLeaving = false;
            if (!(instance2.job.flags & 8)) {
              instance2.update();
            }
            delete leavingHooks.afterLeave;
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state2,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
function findNonCommentChild(children) {
  let child = children[0];
  if (children.length > 1) {
    for (const c of children) {
      if (c.type !== Comment) {
        child = c;
        break;
      }
    }
  }
  return child;
}
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state2, vnode) {
  const { leavingVNodes } = state2;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state2, instance2, postClone) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state2, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance2,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$4(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state2.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state2.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey$1] = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey$1] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el[enterCbKey$1]) {
        el[enterCbKey$1](
          true
          /* cancelled */
        );
      }
      if (state2.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      const hooks2 = resolveTransitionHooks(
        vnode2,
        props,
        state2,
        instance2,
        postClone
      );
      if (postClone)
        postClone(hooks2);
      return hooks2;
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getInnerChild$1(vnode) {
  if (!isKeepAlive(vnode)) {
    if (isTeleport(vnode.type) && vnode.children) {
      return findNonCommentChild(vnode.children);
    }
    return vnode;
  }
  const { shapeFlag, children } = vnode;
  if (children) {
    if (shapeFlag & 16) {
      return children[0];
    }
    if (shapeFlag & 32 && isFunction$1(children.default)) {
      return children.default();
    }
  }
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    vnode.transition = hooks;
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return isFunction$1(options) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
function markAsyncBoundary(instance2) {
  instance2.ids = [instance2.ids[0] + instance2.ids[2]++ + "-", 0, 0];
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$4(rawRef)) {
    rawRef.forEach(
      (r, i) => setRef(
        r,
        oldRawRef && (isArray$4(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref3 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  const rawSetupState = toRaw(setupState);
  const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
    return hasOwn$1(rawSetupState, key);
  };
  if (oldRef != null && oldRef !== ref3) {
    if (isString$2(oldRef)) {
      refs[oldRef] = null;
      if (canSetSetupRef(oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$1(ref3)) {
    callWithErrorHandling(ref3, owner, 12, [value, refs]);
  } else {
    const _isString = isString$2(ref3);
    const _isRef = isRef(ref3);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
          if (isUnmount) {
            isArray$4(existing) && remove(existing, refValue);
          } else {
            if (!isArray$4(existing)) {
              if (_isString) {
                refs[ref3] = [refValue];
                if (canSetSetupRef(ref3)) {
                  setupState[ref3] = refs[ref3];
                }
              } else {
                ref3.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref3.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref3] = value;
          if (canSetSetupRef(ref3)) {
            setupState[ref3] = value;
          }
        } else if (_isRef) {
          ref3.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type2, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type2, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type2, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type2, target, keepAliveRoot) {
  const injected = injectHook(
    type2,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type2], injected);
  }, target);
}
function injectHook(type2, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type2] || (target[type2] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      pauseTracking();
      const reset2 = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type2, args);
      reset2();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => {
  if (!isInSSRComponentSetup || lifecycle === "sp") {
    injectHook(lifecycle, (...args) => hook(...args), target);
  }
};
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook(
  "bu"
);
const onUpdated = createHook("u");
const onBeforeUnmount = createHook(
  "bum"
);
const onUnmounted = createHook("um");
const onServerPrefetch = createHook(
  "sp"
);
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const COMPONENTS = "components";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString$2(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveAsset(type2, name, warnMissing = true, maybeSelfReference = false) {
  const instance2 = currentRenderingInstance || currentInstance;
  if (instance2) {
    const Component = instance2.type;
    if (type2 === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$1(camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance2[type2] || Component[type2], name) || // global registration
      resolve(instance2.appContext[type2], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
}
function renderList(source, renderItem, cache2, index2) {
  let ret;
  const cached = cache2 && cache2[index2];
  const sourceIsArray = isArray$4(source);
  if (sourceIsArray || isString$2(source)) {
    const sourceIsReactiveArray = sourceIsArray && isReactive(source);
    let needsWrap = false;
    if (sourceIsReactiveArray) {
      needsWrap = !isShallow(source);
      source = shallowReadArray(source);
    }
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(
        needsWrap ? toReactive(source[i]) : source[i],
        i,
        void 0,
        cached && cached[i]
      );
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (isObject$2(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached && cached[i])
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache2) {
    cache2[index2] = ret;
  }
  return ret;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
    if (name !== "default")
      props.name = name;
    return openBlock(), createBlock(
      Fragment,
      null,
      [createVNode("slot", props, fallback && fallback())],
      64
    );
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(
    Fragment,
    {
      key: (props.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      validSlotContent && validSlotContent.key || `_${name}`) + // #7256 force differentiate fallback content from actual content
      (!validSlotContent && fallback ? "_fb" : "")
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode$1(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getComponentPublicInstance(i);
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $host: (i) => i.ce,
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => {
      queueJob(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i)
  })
);
const hasSetupBinding = (state2, key) => state2 !== EMPTY_OBJ && !state2.__isScriptSetup && hasOwn$1(state2, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance2 }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data, props, accessCache, type: type2, appContext } = instance2;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn$1(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance2.propsOptions[0]) && hasOwn$1(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance2.attrs, "get", "");
      }
      return publicGetter(instance2);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type2.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn$1(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance2 }, key, value) {
    const { data, setupState, ctx } = instance2;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn$1(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn$1(instance2.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance2) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn$1(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$1(normalizedProps, key) || hasOwn$1(ctx, key) || hasOwn$1(publicPropertiesMap, key) || hasOwn$1(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn$1(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
function normalizePropsOrEmits(props) {
  return isArray$4(props) ? props.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props;
}
let shouldCacheAccess = true;
function applyOptions(instance2) {
  const options = resolveMergedOptions(instance2);
  const publicThis = instance2.proxy;
  const ctx = instance2.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance2, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives: directives2,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$1(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$2(data))
      ;
    else {
      instance2.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get4 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c = computed({
        get: get4,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance2, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$4(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$4(expose)) {
    if (expose.length) {
      const exposed = instance2.exposed || (instance2.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance2.exposed) {
      instance2.exposed = {};
    }
  }
  if (render && instance2.render === NOOP) {
    instance2.render = render;
  }
  if (inheritAttrs != null) {
    instance2.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance2.components = components;
  if (directives2)
    instance2.directives = directives2;
  if (serverPrefetch) {
    markAsyncBoundary(instance2);
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray$4(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$2(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance2, type2) {
  callWithAsyncErrorHandling(
    isArray$4(hook) ? hook.map((h2) => h2.bind(instance2.proxy)) : hook.bind(instance2.proxy),
    instance2,
    type2
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$2(raw)) {
    const handler = ctx[raw];
    if (isFunction$1(handler)) {
      {
        watch(getter, handler);
      }
    }
  } else if (isFunction$1(raw)) {
    {
      watch(getter, raw.bind(publicThis));
    }
  } else if (isObject$2(raw)) {
    if (isArray$4(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$1(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance2) {
  const base = instance2.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache2,
    config: { optionMergeStrategies }
  } = instance2.appContext;
  const cached = cache2.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject$2(base)) {
    cache2.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions(to, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend(
      isFunction$1(to) ? to.call(this, this) : to,
      isFunction$1(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$4(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray$4(to) && isArray$4(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$1(rootComponent)) {
      rootComponent = extend({}, rootComponent);
    }
    if (rootProps != null && !isObject$2(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    const pluginCleanupFns = [];
    let isMounted = false;
    const app2 = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version$2,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction$1(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app2, ...options);
        } else if (isFunction$1(plugin)) {
          installedPlugins.add(plugin);
          plugin(app2, ...options);
        } else
          ;
        return app2;
      },
      mixin(mixin2) {
        {
          if (!context.mixins.includes(mixin2)) {
            context.mixins.push(mixin2);
          }
        }
        return app2;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app2;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app2;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          const vnode = app2._ceVNode || createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app2._container = rootContainer;
          rootContainer.__vue_app__ = app2;
          return getComponentPublicInstance(vnode.component);
        }
      },
      onUnmount(cleanupFn) {
        pluginCleanupFns.push(cleanupFn);
      },
      unmount() {
        if (isMounted) {
          callWithAsyncErrorHandling(
            pluginCleanupFns,
            app2._instance,
            16
          );
          render(null, app2._container);
          delete app2._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app2;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app2;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app2;
  };
}
let currentApp = null;
function provide(key, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance2 = currentInstance || currentRenderingInstance;
  if (instance2 || currentApp) {
    const provides = currentApp ? currentApp._context.provides : instance2 ? instance2.parent == null ? instance2.vnode.appContext && instance2.vnode.appContext.provides : instance2.parent.provides : void 0;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance2 && instance2.proxy) : defaultValue;
    } else
      ;
  }
}
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp);
}
const internalObjectProto = {};
const createInternalObject = () => Object.create(internalObjectProto);
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
function initProps(instance2, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = createInternalObject();
  instance2.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance2, rawProps, props, attrs);
  for (const key in instance2.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance2.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance2.type.props) {
      instance2.props = attrs;
    } else {
      instance2.props = props;
    }
  }
  instance2.attrs = attrs;
}
function updateProps(instance2, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance2;
  const rawCurrentProps = toRaw(props);
  const [options] = instance2.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance2.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance2.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn$1(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance2,
              false
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance2, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn$1(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn$1(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance2,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn$1(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance2.attrs, "set", "");
  }
}
function setFullProps(instance2, rawProps, props, attrs) {
  const [options, needCastKeys] = instance2.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn$1(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance2.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance2,
        !hasOwn$1(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance2, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn$1(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
        const { propsDefaults } = instance2;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          const reset2 = setCurrentInstance(instance2);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset2();
        }
      } else {
        value = defaultValue;
      }
      if (instance2.ce) {
        instance2.ce._setProp(key, value);
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
const mixinPropsCache = /* @__PURE__ */ new WeakMap();
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache2 = asMixin ? mixinPropsCache : appContext.propsCache;
  const cached = cache2.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys)
        needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$2(comp)) {
      cache2.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$4(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$4(opt) || isFunction$1(opt) ? { type: opt } : extend({}, opt);
        const propType = prop.type;
        let shouldCast = false;
        let shouldCastTrue = true;
        if (isArray$4(propType)) {
          for (let index2 = 0; index2 < propType.length; ++index2) {
            const type2 = propType[index2];
            const typeName = isFunction$1(type2) && type2.name;
            if (typeName === "Boolean") {
              shouldCast = true;
              break;
            } else if (typeName === "String") {
              shouldCastTrue = false;
            }
          }
        } else {
          shouldCast = isFunction$1(propType) && propType.name === "Boolean";
        }
        prop[
          0
          /* shouldCast */
        ] = shouldCast;
        prop[
          1
          /* shouldCastTrue */
        ] = shouldCastTrue;
        if (shouldCast || hasOwn$1(prop, "default")) {
          needCastKeys.push(normalizedKey);
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$2(comp)) {
    cache2.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  }
  return false;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray$4(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false)
      ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance2) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction$1(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance2, children) => {
  const normalized = normalizeSlotValue(children);
  instance2.slots.default = () => normalized;
};
const assignSlots = (slots, children, optimized) => {
  for (const key in children) {
    if (optimized || key !== "_") {
      slots[key] = children[key];
    }
  }
};
const initSlots = (instance2, children, optimized) => {
  const slots = instance2.slots = createInternalObject();
  if (instance2.vnode.shapeFlag & 32) {
    const type2 = children._;
    if (type2) {
      assignSlots(slots, children, optimized);
      if (optimized) {
        def(slots, "_", type2, true);
      }
    } else {
      normalizeObjectSlots(children, slots);
    }
  } else if (children) {
    normalizeVNodeSlots(instance2, children);
  }
};
const updateSlots = (instance2, children, optimized) => {
  const { vnode, slots } = instance2;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type2 = children._;
    if (type2) {
      if (optimized && type2 === 1) {
        needDeletionCheck = false;
      } else {
        assignSlots(slots, children, optimized);
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance2, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis$1();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type: type2, ref: ref3, shapeFlag } = n2;
    switch (type2) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type2.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type2.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else
          ;
    }
    if (ref3 != null && parentComponent) {
      setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace = "svg";
    } else if (n2.type === "math") {
      namespace = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el, key, null, props[key], namespace, parentComponent);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
      hostSetElementText(el, "");
    }
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, namespace, parentComponent);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, oldProps, newProps, parentComponent, namespace);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace,
              parentComponent
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, namespace, parentComponent);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance2 = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance2.ctx.renderer = internals;
    }
    {
      setupComponent(instance2, false, optimized);
    }
    if (instance2.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance2, setupRenderEffect, optimized);
      if (!initialVNode.el) {
        const placeholder = instance2.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
    } else {
      setupRenderEffect(
        instance2,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance2 = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance2.asyncDep && !instance2.asyncResolved) {
        updateComponentPreRender(instance2, n2, optimized);
        return;
      } else {
        instance2.next = n2;
        instance2.update();
      }
    } else {
      n2.el = n1.el;
      instance2.vnode = n2;
    }
  };
  const setupRenderEffect = (instance2, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = () => {
      if (!instance2.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent, root, type: type2 } = instance2;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance2, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance2, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance2.subTree = renderComponentRoot(instance2);
            hydrateNode(
              el,
              instance2.subTree,
              instance2,
              parentSuspense,
              null
            );
          };
          if (isAsyncWrapperVNode && type2.__asyncHydrate) {
            type2.__asyncHydrate(
              el,
              instance2,
              hydrateSubTree
            );
          } else {
            hydrateSubTree();
          }
        } else {
          if (root.ce) {
            root.ce._injectChildStyle(type2);
          }
          const subTree = instance2.subTree = renderComponentRoot(instance2);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance2,
            parentSuspense,
            namespace
          );
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance2.a && queuePostRenderEffect(instance2.a, parentSuspense);
        }
        instance2.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance2;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance2);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance2, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance2.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance2, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance2, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance2, true);
        const nextTree = renderComponentRoot(instance2);
        const prevTree = instance2.subTree;
        instance2.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance2,
          parentSuspense,
          namespace
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance2, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    instance2.scope.on();
    const effect2 = instance2.effect = new ReactiveEffect(componentUpdateFn);
    instance2.scope.off();
    const update = instance2.update = effect2.run.bind(effect2);
    const job = instance2.job = effect2.runIfDirty.bind(effect2);
    job.i = instance2;
    job.id = instance2.uid;
    effect2.scheduler = () => queueJob(job);
    toggleRecurse(instance2, true);
    update();
  };
  const updateComponentPreRender = (instance2, nextVNode, optimized) => {
    nextVNode.component = instance2;
    const prevProps = instance2.vnode.props;
    instance2.vnode = nextVNode;
    instance2.next = null;
    updateProps(instance2, nextVNode.props, prevProps, optimized);
    updateSlots(instance2, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(instance2);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved2 = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved2 = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved2 ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved2) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type: type2, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type2.move(vnode, container, anchor, internals);
      return;
    }
    if (type2 === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type2 === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type: type2,
      props,
      ref: ref3,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
      cacheIndex
    } = vnode;
    if (patchFlag === -2) {
      optimized = false;
    }
    if (ref3 != null) {
      setRef(ref3, null, parentSuspense, vnode, true);
    }
    if (cacheIndex != null) {
      parentComponent.renderCache[cacheIndex] = void 0;
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type2 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type2 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type: type2, el, anchor, transition } = vnode;
    if (type2 === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type2 === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance2, parentSuspense, doRemove) => {
    const { bum, scope, job, subTree, um, m, a } = instance2;
    invalidateMount(m);
    invalidateMount(a);
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (job) {
      job.flags |= 8;
      unmount(subTree, instance2, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance2.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance2.asyncDep && !instance2.asyncResolved && instance2.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    const el = hostNextSibling(vnode.anchor || vnode.el);
    const teleportEnd = el && el[TeleportEndKey];
    return teleportEnd ? hostNextSibling(teleportEnd) : el;
  };
  let isFlushing = false;
  const render = (vnode, container, namespace) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    container._vnode = vnode;
    if (!isFlushing) {
      isFlushing = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing = false;
    }
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function resolveChildrenNamespace({ type: type2, props }, currentNamespace) {
  return currentNamespace === "svg" && type2 === "foreignObject" || currentNamespace === "mathml" && type2 === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect: effect2, job }, allowed) {
  if (allowed) {
    effect2.flags |= 32;
    job.flags |= 4;
  } else {
    effect2.flags &= ~32;
    job.flags &= ~4;
  }
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$4(ch1) && isArray$4(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow && c2.patchFlag !== -2)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p2[v];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance2) {
  const subComponent = instance2.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
function invalidateMount(hooks) {
  if (hooks) {
    for (let i = 0; i < hooks.length; i++)
      hooks[i].flags |= 8;
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
function watchEffect(effect2, options) {
  return doWatch(effect2, null, options);
}
function watchPostEffect(effect2, options) {
  return doWatch(
    effect2,
    null,
    { flush: "post" }
  );
}
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, flush, once } = options;
  const baseWatchOptions = extend({}, options);
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else if (!cb || immediate) {
      baseWatchOptions.once = true;
    } else {
      const watchStopHandle = () => {
      };
      watchStopHandle.stop = NOOP;
      watchStopHandle.resume = NOOP;
      watchStopHandle.pause = NOOP;
      return watchStopHandle;
    }
  }
  const instance2 = currentInstance;
  baseWatchOptions.call = (fn, type2, args) => callWithAsyncErrorHandling(fn, instance2, type2, args);
  let isPre = false;
  if (flush === "post") {
    baseWatchOptions.scheduler = (job) => {
      queuePostRenderEffect(job, instance2 && instance2.suspense);
    };
  } else if (flush !== "sync") {
    isPre = true;
    baseWatchOptions.scheduler = (job, isFirstRun) => {
      if (isFirstRun) {
        job();
      } else {
        queueJob(job);
      }
    };
  }
  baseWatchOptions.augmentJob = (job) => {
    if (cb) {
      job.flags |= 4;
    }
    if (isPre) {
      job.flags |= 2;
      if (instance2) {
        job.id = instance2.uid;
        job.i = instance2;
      }
    }
  };
  const watchHandle = watch$1(source, cb, baseWatchOptions);
  if (ssrCleanup)
    ssrCleanup.push(watchHandle);
  return watchHandle;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString$2(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$1(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const reset2 = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset2();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
const getModelModifiers = (props, modelName) => {
  return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
};
function emit(instance2, event, ...rawArgs) {
  if (instance2.isUnmounted)
    return;
  const props = instance2.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
  if (modifiers) {
    if (modifiers.trim) {
      args = rawArgs.map((a) => isString$2(a) ? a.trim() : a);
    }
    if (modifiers.number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance2,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance2.emitted) {
      instance2.emitted = {};
    } else if (instance2.emitted[handlerName]) {
      return;
    }
    instance2.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance2,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.emitsCache;
  const cached = cache2.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$2(comp)) {
      cache2.set(comp, null);
    }
    return null;
  }
  if (isArray$4(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject$2(comp)) {
    cache2.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn$1(options, key[0].toLowerCase() + key.slice(1)) || hasOwn$1(options, hyphenate(key)) || hasOwn$1(options, key);
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance2) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render,
    renderCache,
    props,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance2;
  const prev = setCurrentRenderingInstance(instance2);
  let result;
  let fallthroughAttrs;
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy = false ? new Proxy(proxyToUse, {
        get(target, key, receiver) {
          warn$1(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target, key, receiver);
        }
      }) : proxyToUse;
      result = normalizeVNode(
        render.call(
          thisProxy,
          proxyToUse,
          renderCache,
          false ? shallowReadonly(props) : props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (false)
        ;
      result = normalizeVNode(
        render2.length > 1 ? render2(
          false ? shallowReadonly(props) : props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return shallowReadonly(attrs);
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render2(
          false ? shallowReadonly(props) : props,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance2, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs, false, true);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root, null, false, true);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    setTransitionHooks(root, vnode.transition);
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root = parent.subTree;
    if (root.suspense && root.suspense.activeBranch === vnode) {
      root.el = vnode.el;
    }
    if (root === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}
const isSuspense = (type2) => type2.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$4(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
  if (value < 0 && currentBlock) {
    currentBlock.hasOnce = true;
  }
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type2, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type2,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type2, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type2,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode$1(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref3,
  ref_key,
  ref_for
}) => {
  if (typeof ref3 === "number") {
    ref3 = "" + ref3;
  }
  return ref3 != null ? isString$2(ref3) || isRef(ref3) || isFunction$1(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
};
function createBaseVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type2 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type: type2,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type2.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$2(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type2 || type2 === NULL_DYNAMIC_COMPONENT) {
    type2 = Comment;
  }
  if (isVNode$1(type2)) {
    const cloned = cloneVNode(
      type2,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type2)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type2)) {
    type2 = type2.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString$2(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$2(style)) {
      if (isProxy(style) && !isArray$4(style)) {
        style = extend({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString$2(type2) ? 1 : isSuspense(type2) ? 128 : isTeleport(type2) ? 64 : isObject$2(type2) ? 4 : isFunction$1(type2) ? 2 : 0;
  return createBaseVNode(
    type2,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref: ref3, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref3 ? isArray$4(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref3,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetStart: vnode.targetStart,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$4(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (isVNode$1(child)) {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type2 = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$4(children)) {
    type2 = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type2 = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$1(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type2 = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type2 = 16;
      children = [createTextVNode(children)];
    } else {
      type2 = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type2;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$4(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance2, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance2, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type2 = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance2 = {
    uid: uid++,
    vnode,
    type: type2,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    ids: parent ? parent.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type2, appContext),
    emitsOptions: normalizeEmitsOptions(type2, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type2.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance2.ctx = { _: instance2 };
  }
  instance2.root = parent ? parent.root : instance2;
  instance2.emit = emit.bind(null, instance2);
  if (vnode.ce) {
    vnode.ce(instance2);
  }
  return instance2;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g = getGlobalThis$1();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g[key]))
      setters = g[key] = [];
    setters.push(setter);
    return (v) => {
      if (setters.length > 1)
        setters.forEach((set2) => set2(v));
      else
        setters[0](v);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v) => currentInstance = v
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v) => isInSSRComponentSetup = v
  );
}
const setCurrentInstance = (instance2) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance2);
  instance2.scope.on();
  return () => {
    instance2.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance2) {
  return instance2.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance2, isSSR = false, optimized = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance2.vnode;
  const isStateful = isStatefulComponent(instance2);
  initProps(instance2, props, isStateful, isSSR);
  initSlots(instance2, children, optimized);
  const setupResult = isStateful ? setupStatefulComponent(instance2, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance2, isSSR) {
  const Component = instance2.type;
  instance2.accessCache = /* @__PURE__ */ Object.create(null);
  instance2.proxy = new Proxy(instance2.ctx, PublicInstanceProxyHandlers);
  const { setup: setup2 } = Component;
  if (setup2) {
    const setupContext = instance2.setupContext = setup2.length > 1 ? createSetupContext(instance2) : null;
    const reset2 = setCurrentInstance(instance2);
    pauseTracking();
    const setupResult = callWithErrorHandling(
      setup2,
      instance2,
      0,
      [
        instance2.props,
        setupContext
      ]
    );
    resetTracking();
    reset2();
    if (isPromise$1(setupResult)) {
      if (!isAsyncWrapper(instance2))
        markAsyncBoundary(instance2);
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance2, resolvedResult, isSSR);
        }).catch((e2) => {
          handleError(e2, instance2, 0);
        });
      } else {
        instance2.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance2, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance2, isSSR);
  }
}
function handleSetupResult(instance2, setupResult, isSSR) {
  if (isFunction$1(setupResult)) {
    if (instance2.type.__ssrInlineRender) {
      instance2.ssrRender = setupResult;
    } else {
      instance2.render = setupResult;
    }
  } else if (isObject$2(setupResult)) {
    instance2.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance2, isSSR);
}
let compile$1;
function finishComponentSetup(instance2, isSSR, skipOptions) {
  const Component = instance2.type;
  if (!instance2.render) {
    if (!isSSR && compile$1 && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance2).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance2.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend(
          extend(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile$1(template, finalCompilerOptions);
      }
    }
    instance2.render = Component.render || NOOP;
  }
  {
    const reset2 = setCurrentInstance(instance2);
    pauseTracking();
    try {
      applyOptions(instance2);
    } finally {
      resetTracking();
      reset2();
    }
  }
}
const attrsProxyHandlers = {
  get(target, key) {
    track(target, "get", "");
    return target[key];
  }
};
function createSetupContext(instance2) {
  const expose = (exposed) => {
    instance2.exposed = exposed || {};
  };
  {
    return {
      attrs: new Proxy(instance2.attrs, attrsProxyHandlers),
      slots: instance2.slots,
      emit: instance2.emit,
      expose
    };
  }
}
function getComponentPublicInstance(instance2) {
  if (instance2.exposed) {
    return instance2.exposeProxy || (instance2.exposeProxy = new Proxy(proxyRefs(markRaw(instance2.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance2);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  } else {
    return instance2.proxy;
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance2, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance2 && instance2.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(
      instance2.components || instance2.parent.type.components
    ) || inferFromRegistry(instance2.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction$1(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  return c;
};
function h(type2, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject$2(propsOrChildren) && !isArray$4(propsOrChildren)) {
      if (isVNode$1(propsOrChildren)) {
        return createVNode(type2, null, [propsOrChildren]);
      }
      return createVNode(type2, propsOrChildren);
    } else {
      return createVNode(type2, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode$1(children)) {
      children = [children];
    }
    return createVNode(type2, propsOrChildren, children);
  }
}
const version$2 = "3.5.11";
/**
* @vue/runtime-dom v3.5.11
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let policy = void 0;
const tt = typeof window !== "undefined" && window.trustedTypes;
if (tt) {
  try {
    policy = /* @__PURE__ */ tt.createPolicy("vue", {
      createHTML: (val) => val
    });
  } catch (e2) {
  }
}
const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, namespace, is, props) => {
    const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, namespace, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = unsafeToTrustedHTML(
        namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
      );
      const template = templateContainer.content;
      if (namespace === "svg" || namespace === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
const TRANSITION = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = /* @__PURE__ */ extend(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const decorate$1 = (t) => {
  t.displayName = "Transition";
  t.props = TransitionPropsValidators;
  return t;
};
const Transition = /* @__PURE__ */ decorate$1(
  (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots)
);
const callHook = (hook, args = []) => {
  if (isArray$4(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$4(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type: type2,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve2]);
      nextFrame$2(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type2, enterDuration, resolve2);
        }
      });
    };
  };
  return extend(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve2 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      addTransitionClass(el, leaveActiveClass);
      forceReflow();
      nextFrame$2(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type2, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$2(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
function nextFrame$2(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout != null) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type: type2, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type2) {
    return resolve2();
  }
  const endEvent = type2 + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e2) => {
    if (e2.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type2 = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type2 = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type2 = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type2 = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type2 ? type2 === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type2 === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type: type2,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  if (s === "auto")
    return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
function patchClass(el, value, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue)
      return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el[vShowOriginalDisplay] : "none";
  el[vShowHidden] = !value;
}
const CSS_VAR_TEXT = Symbol("");
function useCssVars(getter) {
  const instance2 = getCurrentInstance();
  if (!instance2) {
    return;
  }
  const updateTeleports = instance2.ut = (vars = getter(instance2.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${instance2.uid}"]`)
    ).forEach((node) => setVarsOnNode(node, vars));
  };
  const setVars = () => {
    const vars = getter(instance2.proxy);
    if (instance2.ce) {
      setVarsOnNode(instance2.ce, vars);
    } else {
      setVarsOnVNode(instance2.subTree, vars);
    }
    updateTeleports(vars);
  };
  onBeforeMount(() => {
    watchPostEffect(setVars);
  });
  onMounted(() => {
    const ob = new MutationObserver(setVars);
    ob.observe(instance2.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c) => setVarsOnVNode(c, vars));
  } else if (vnode.type === Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor)
        break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style = el.style;
    let cssText = "";
    for (const key in vars) {
      style.setProperty(`--${key}`, vars[key]);
      cssText += `--${key}: ${vars[key]};`;
    }
    style[CSS_VAR_TEXT] = cssText;
  }
}
const displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString$2(next);
  let hasControlledDisplay = false;
  if (next && !isCssString) {
    if (prev) {
      if (!isString$2(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      } else {
        for (const prevStyle of prev.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
    }
    for (const key in next) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style, key, next[key]);
    }
  } else {
    if (isCssString) {
      if (prev !== next) {
        const cssVarText = style[CSS_VAR_TEXT];
        if (cssVarText) {
          next += ";" + cssVarText;
        }
        style.cssText = next;
        hasControlledDisplay = displayRE.test(next);
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
    if (el[vShowHidden]) {
      style.display = "none";
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray$4(val)) {
    val.forEach((v) => setStyle(style, name, v));
  } else {
    if (val == null)
      val = "";
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize$1(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance2, isBoolean2 = isSpecialBooleanAttr(key)) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(
        key,
        isBoolean2 ? "" : isSymbol(value) ? String(value) : value
      );
    }
  }
}
function patchDOMProp(el, key, value, parentComponent) {
  if (key === "innerHTML" || key === "textContent") {
    if (value != null) {
      el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
    }
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      el.type === "checkbox" ? "on" : ""
    ) : String(value);
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    el._value = value;
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type2 = typeof el[key];
    if (type2 === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type2 === "string") {
      value = "";
      needRemove = true;
    } else if (type2 === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e2) {
  }
  needRemove && el.removeAttribute(key);
}
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance2 = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(
        nextValue,
        instance2
      );
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance2) {
  const invoker = (e2) => {
    if (!e2._vts) {
      e2._vts = Date.now();
    } else if (e2._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e2, invoker.value),
      instance2,
      5,
      [e2]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e2, value) {
  if (isArray$4(value)) {
    const originalStop = e2.stopImmediatePropagation;
    e2.stopImmediatePropagation = () => {
      originalStop.call(e2);
      e2._stopped = true;
    };
    return value.map(
      (fn) => (e22) => !e22._stopped && fn && fn(e22)
    );
  } else {
    return value;
  }
}
const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
  const isSVG = namespace === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue);
    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
      patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
    }
  } else if (
    // #11081 force set props for possible async custom element
    el._isVueCE && (/[A-Z]/.test(key) || !isString$2(nextValue))
  ) {
    patchDOMProp(el, camelize(key), nextValue);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && isFunction$1(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && isString$2(value)) {
    return false;
  }
  return key in el;
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const moveCbKey = Symbol("_moveCb");
const enterCbKey = Symbol("_enterCb");
const decorate = (t) => {
  delete t.props.mode;
  return t;
};
const TransitionGroupImpl = /* @__PURE__ */ decorate({
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance2 = getCurrentInstance();
    const state2 = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance2.vnode.el,
        moveClass
      )) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c) => {
        const el = c.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el[moveCbKey] = (e2) => {
          if (e2 && e2.target !== el) {
            return;
          }
          if (!e2 || /transform$/.test(e2.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el[moveCbKey] = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = [];
      if (children) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child.el && child.el instanceof Element) {
            prevChildren.push(child);
            setTransitionHooks(
              child,
              resolveTransitionHooks(
                child,
                cssTransitionProps,
                state2,
                instance2
              )
            );
            positionMap.set(
              child,
              child.el.getBoundingClientRect()
            );
          }
        }
      }
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state2, instance2)
          );
        }
      }
      return createVNode(tag, null, children);
    };
  }
});
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el = c.el;
  if (el[moveCbKey]) {
    el[moveCbKey]();
  }
  if (el[enterCbKey]) {
    el[enterCbKey]();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone3 = el.cloneNode();
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone3.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone3.classList.add(c));
  clone3.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone3);
  const { hasTransform } = getTransitionInfo(clone3);
  container.removeChild(clone3);
  return hasTransform;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray$4(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
function onCompositionStart(e2) {
  e2.target.composing = true;
}
function onCompositionEnd(e2) {
  const target = e2.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const assignKey = Symbol("_assign");
const vModelText = {
  created(el, { modifiers: { lazy, trim, number: number2 } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    const castToNumber = number2 || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", (e2) => {
      if (e2.target.composing)
        return;
      let domValue = el.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = looseToNumber(domValue);
      }
      el[assignKey](domValue);
    });
    if (trim) {
      addEventListener(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim, number: number2 } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (el.composing)
      return;
    const elValue = (number2 || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
    const newValue = value == null ? "" : value;
    if (elValue === newValue) {
      return;
    }
    if (document.activeElement === el && el.type !== "range") {
      if (lazy && value === oldValue) {
        return;
      }
      if (trim && el.value.trim() === newValue) {
        return;
      }
    }
    el.value = newValue;
  }
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, { value, modifiers: { number: number2 } }, vnode) {
    const isSetModel = isSet(value);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
        (o) => number2 ? looseToNumber(getValue(o)) : getValue(o)
      );
      el[assignKey](
        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
      );
      el._assigning = true;
      nextTick(() => {
        el._assigning = false;
      });
    });
    el[assignKey] = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
  },
  updated(el, { value }) {
    if (!el._assigning) {
      setSelected(el, value);
    }
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  const isArrayValue = isArray$4(value);
  if (isMultiple && !isArrayValue && !isSet(value)) {
    return;
  }
  for (let i = 0, l = el.options.length; i < l; i++) {
    const option = el.options[i];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArrayValue) {
        const optionType = typeof optionValue;
        if (optionType === "string" || optionType === "number") {
          option.selected = value.some((v) => String(v) === String(optionValue));
        } else {
          option.selected = looseIndexOf(value, optionValue) > -1;
        }
      } else {
        option.selected = value.has(optionValue);
      }
    } else if (looseEqual(getValue(option), value)) {
      if (el.selectedIndex !== i)
        el.selectedIndex = i;
      return;
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e2) => e2.stopPropagation(),
  prevent: (e2) => e2.preventDefault(),
  self: (e2) => e2.target !== e2.currentTarget,
  ctrl: (e2) => !e2.ctrlKey,
  shift: (e2) => !e2.shiftKey,
  alt: (e2) => !e2.altKey,
  meta: (e2) => !e2.metaKey,
  left: (e2) => "button" in e2 && e2.button !== 0,
  middle: (e2) => "button" in e2 && e2.button !== 1,
  right: (e2) => "button" in e2 && e2.button !== 2,
  exact: (e2, modifiers) => systemModifiers.some((m) => e2[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  const cache2 = fn._withMods || (fn._withMods = {});
  const cacheKey = modifiers.join(".");
  return cache2[cacheKey] || (cache2[cacheKey] = (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers))
        return;
    }
    return fn(event, ...args);
  });
};
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app2 = ensureRenderer().createApp(...args);
  const { mount } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app2._component;
    if (!isFunction$1(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    if (container.nodeType === 1) {
      container.textContent = "";
    }
    const proxy = mount(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app2;
};
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function normalizeContainer(container) {
  if (isString$2(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
/*!
 * pinia v2.2.2
 * (c) 2024 Eduardo San Martin Morote
 * @license MIT
 */
let activePinia$1;
const setActivePinia$1 = (pinia) => activePinia$1 = pinia;
const piniaSymbol$2 = (
  /* istanbul ignore next */
  Symbol()
);
function isPlainObject$2(o) {
  return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
}
var MutationType$2;
(function(MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType$2 || (MutationType$2 = {}));
const noop$1 = () => {
};
function addSubscription$1(subscriptions, callback, detached, onCleanup = noop$1) {
  subscriptions.push(callback);
  const removeSubscription = () => {
    const idx = subscriptions.indexOf(callback);
    if (idx > -1) {
      subscriptions.splice(idx, 1);
      onCleanup();
    }
  };
  if (!detached && getCurrentScope()) {
    onScopeDispose(removeSubscription);
  }
  return removeSubscription;
}
function triggerSubscriptions$1(subscriptions, ...args) {
  subscriptions.slice().forEach((callback) => {
    callback(...args);
  });
}
const fallbackRunWithContext$1 = (fn) => fn();
const ACTION_MARKER$1 = Symbol();
const ACTION_NAME$1 = Symbol();
function mergeReactiveObjects$1(target, patchToApply) {
  if (target instanceof Map && patchToApply instanceof Map) {
    patchToApply.forEach((value, key) => target.set(key, value));
  } else if (target instanceof Set && patchToApply instanceof Set) {
    patchToApply.forEach(target.add, target);
  }
  for (const key in patchToApply) {
    if (!patchToApply.hasOwnProperty(key))
      continue;
    const subPatch = patchToApply[key];
    const targetValue = target[key];
    if (isPlainObject$2(targetValue) && isPlainObject$2(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
      target[key] = mergeReactiveObjects$1(targetValue, subPatch);
    } else {
      target[key] = subPatch;
    }
  }
  return target;
}
const skipHydrateSymbol$1 = (
  /* istanbul ignore next */
  Symbol()
);
function shouldHydrate$1(obj) {
  return !isPlainObject$2(obj) || !obj.hasOwnProperty(skipHydrateSymbol$1);
}
const { assign: assign$3 } = Object;
function isComputed$1(o) {
  return !!(isRef(o) && o.effect);
}
function createOptionsStore$1(id, options, pinia, hot) {
  const { state: state2, actions, getters } = options;
  const initialState = pinia.state.value[id];
  let store;
  function setup2() {
    if (!initialState && true) {
      {
        pinia.state.value[id] = state2 ? state2() : {};
      }
    }
    const localState = toRefs(pinia.state.value[id]);
    return assign$3(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
      computedGetters[name] = markRaw(computed(() => {
        setActivePinia$1(pinia);
        const store2 = pinia._s.get(id);
        return getters[name].call(store2, store2);
      }));
      return computedGetters;
    }, {}));
  }
  store = createSetupStore$1(id, setup2, options, pinia, hot, true);
  return store;
}
function createSetupStore$1($id, setup2, options = {}, pinia, hot, isOptionsStore) {
  let scope;
  const optionsForPlugin = assign$3({ actions: {} }, options);
  const $subscribeOptions = { deep: true };
  let isListening;
  let isSyncListening;
  let subscriptions = [];
  let actionSubscriptions = [];
  let debuggerEvents;
  const initialState = pinia.state.value[$id];
  if (!isOptionsStore && !initialState && true) {
    {
      pinia.state.value[$id] = {};
    }
  }
  ref({});
  let activeListener;
  function $patch(partialStateOrMutator) {
    let subscriptionMutation;
    isListening = isSyncListening = false;
    if (typeof partialStateOrMutator === "function") {
      partialStateOrMutator(pinia.state.value[$id]);
      subscriptionMutation = {
        type: MutationType$2.patchFunction,
        storeId: $id,
        events: debuggerEvents
      };
    } else {
      mergeReactiveObjects$1(pinia.state.value[$id], partialStateOrMutator);
      subscriptionMutation = {
        type: MutationType$2.patchObject,
        payload: partialStateOrMutator,
        storeId: $id,
        events: debuggerEvents
      };
    }
    const myListenerId = activeListener = Symbol();
    nextTick().then(() => {
      if (activeListener === myListenerId) {
        isListening = true;
      }
    });
    isSyncListening = true;
    triggerSubscriptions$1(subscriptions, subscriptionMutation, pinia.state.value[$id]);
  }
  const $reset = isOptionsStore ? function $reset2() {
    const { state: state2 } = options;
    const newState = state2 ? state2() : {};
    this.$patch(($state) => {
      assign$3($state, newState);
    });
  } : (
    /* istanbul ignore next */
    noop$1
  );
  function $dispose() {
    scope.stop();
    subscriptions = [];
    actionSubscriptions = [];
    pinia._s.delete($id);
  }
  const action = (fn, name = "") => {
    if (ACTION_MARKER$1 in fn) {
      fn[ACTION_NAME$1] = name;
      return fn;
    }
    const wrappedAction = function() {
      setActivePinia$1(pinia);
      const args = Array.from(arguments);
      const afterCallbackList = [];
      const onErrorCallbackList = [];
      function after(callback) {
        afterCallbackList.push(callback);
      }
      function onError(callback) {
        onErrorCallbackList.push(callback);
      }
      triggerSubscriptions$1(actionSubscriptions, {
        args,
        name: wrappedAction[ACTION_NAME$1],
        store,
        after,
        onError
      });
      let ret;
      try {
        ret = fn.apply(this && this.$id === $id ? this : store, args);
      } catch (error) {
        triggerSubscriptions$1(onErrorCallbackList, error);
        throw error;
      }
      if (ret instanceof Promise) {
        return ret.then((value) => {
          triggerSubscriptions$1(afterCallbackList, value);
          return value;
        }).catch((error) => {
          triggerSubscriptions$1(onErrorCallbackList, error);
          return Promise.reject(error);
        });
      }
      triggerSubscriptions$1(afterCallbackList, ret);
      return ret;
    };
    wrappedAction[ACTION_MARKER$1] = true;
    wrappedAction[ACTION_NAME$1] = name;
    return wrappedAction;
  };
  const partialStore = {
    _p: pinia,
    // _s: scope,
    $id,
    $onAction: addSubscription$1.bind(null, actionSubscriptions),
    $patch,
    $reset,
    $subscribe(callback, options2 = {}) {
      const removeSubscription = addSubscription$1(subscriptions, callback, options2.detached, () => stopWatcher());
      const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state2) => {
        if (options2.flush === "sync" ? isSyncListening : isListening) {
          callback({
            storeId: $id,
            type: MutationType$2.direct,
            events: debuggerEvents
          }, state2);
        }
      }, assign$3({}, $subscribeOptions, options2)));
      return removeSubscription;
    },
    $dispose
  };
  const store = reactive(partialStore);
  pinia._s.set($id, store);
  const runWithContext = pinia._a && pinia._a.runWithContext || fallbackRunWithContext$1;
  const setupStore = runWithContext(() => pinia._e.run(() => (scope = effectScope()).run(() => setup2({ action }))));
  for (const key in setupStore) {
    const prop = setupStore[key];
    if (isRef(prop) && !isComputed$1(prop) || isReactive(prop)) {
      if (!isOptionsStore) {
        if (initialState && shouldHydrate$1(prop)) {
          if (isRef(prop)) {
            prop.value = initialState[key];
          } else {
            mergeReactiveObjects$1(prop, initialState[key]);
          }
        }
        {
          pinia.state.value[$id][key] = prop;
        }
      }
    } else if (typeof prop === "function") {
      const actionValue = action(prop, key);
      {
        setupStore[key] = actionValue;
      }
      optionsForPlugin.actions[key] = prop;
    } else
      ;
  }
  {
    assign$3(store, setupStore);
    assign$3(toRaw(store), setupStore);
  }
  Object.defineProperty(store, "$state", {
    get: () => pinia.state.value[$id],
    set: (state2) => {
      $patch(($state) => {
        assign$3($state, state2);
      });
    }
  });
  pinia._p.forEach((extender) => {
    {
      assign$3(store, scope.run(() => extender({
        store,
        app: pinia._a,
        pinia,
        options: optionsForPlugin
      })));
    }
  });
  if (initialState && isOptionsStore && options.hydrate) {
    options.hydrate(store.$state, initialState);
  }
  isListening = true;
  isSyncListening = true;
  return store;
}
// @__NO_SIDE_EFFECTS__
function defineStore$1(idOrOptions, setup2, setupOptions) {
  let id;
  let options;
  const isSetupStore = typeof setup2 === "function";
  if (typeof idOrOptions === "string") {
    id = idOrOptions;
    options = isSetupStore ? setupOptions : setup2;
  } else {
    options = idOrOptions;
    id = idOrOptions.id;
  }
  function useStore(pinia, hot) {
    const hasContext = hasInjectionContext();
    pinia = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    pinia || (hasContext ? inject(piniaSymbol$2, null) : null);
    if (pinia)
      setActivePinia$1(pinia);
    pinia = activePinia$1;
    if (!pinia._s.has(id)) {
      if (isSetupStore) {
        createSetupStore$1(id, setup2, options, pinia);
      } else {
        createOptionsStore$1(id, options, pinia);
      }
    }
    const store = pinia._s.get(id);
    return store;
  }
  useStore.$id = id;
  return useStore;
}
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = "162";
const UVMapping = 300;
const RepeatWrapping = 1e3;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const LinearFilter = 1006;
const LinearMipmapLinearFilter = 1008;
const UnsignedByteType = 1009;
const UnsignedIntType = 1014;
const UnsignedInt248Type = 1020;
const RGBAFormat = 1023;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const NoColorSpace = "";
const SRGBColorSpace = "srgb";
const LinearSRGBColorSpace = "srgb-linear";
const DisplayP3ColorSpace = "display-p3";
const LinearDisplayP3ColorSpace = "display-p3-linear";
const LinearTransfer = "linear";
const SRGBTransfer = "srgb";
const Rec709Primaries = "rec709";
const P3Primaries = "p3";
const LessEqualCompare = 515;
const WebGLCoordinateSystem = 2e3;
const WebGPUCoordinateSystem = 2001;
class EventDispatcher {
  addEventListener(type2, listener) {
    if (this._listeners === void 0)
      this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type2] === void 0) {
      listeners[type2] = [];
    }
    if (listeners[type2].indexOf(listener) === -1) {
      listeners[type2].push(listener);
    }
  }
  hasEventListener(type2, listener) {
    if (this._listeners === void 0)
      return false;
    const listeners = this._listeners;
    return listeners[type2] !== void 0 && listeners[type2].indexOf(listener) !== -1;
  }
  removeEventListener(type2, listener) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[type2];
    if (listenerArray !== void 0) {
      const index2 = listenerArray.indexOf(listener);
      if (index2 !== -1) {
        listenerArray.splice(index2, 1);
      }
    }
  }
  dispatchEvent(event) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
      event.target = null;
    }
  }
}
const _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toLowerCase();
}
function clamp(value, min2, max2) {
  return Math.max(min2, Math.min(max2, value));
}
function euclideanModulo(n, m) {
  return (n % m + m) % m;
}
function lerp(x, y, t) {
  return (1 - t) * x + t * y;
}
class Vector2 {
  constructor(x = 0, y = 0) {
    Vector2.prototype.isVector2 = true;
    this.x = x;
    this.y = y;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setComponent(index2, value) {
    switch (index2) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index2);
    }
    return this;
  }
  getComponent(index2) {
    switch (index2) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index2);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  }
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m) {
    const x = this.x, y = this.y;
    const e2 = m.elements;
    this.x = e2[0] * x + e2[3] * y + e2[6];
    this.y = e2[1] * x + e2[4] * y + e2[7];
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  }
  clamp(min2, max2) {
    this.x = Math.max(min2.x, Math.min(max2.x, this.x));
    this.y = Math.max(min2.y, Math.min(max2.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min2, max2) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min2, Math.min(max2, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  cross(v) {
    return this.x * v.y - this.y * v.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0)
      return Math.PI / 2;
    const theta = this.dot(v) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y;
  }
  fromArray(array, offset2 = 0) {
    this.x = array[offset2];
    this.y = array[offset2 + 1];
    return this;
  }
  toArray(array = [], offset2 = 0) {
    array[offset2] = this.x;
    array[offset2 + 1] = this.y;
    return array;
  }
  fromBufferAttribute(attribute, index2) {
    this.x = attribute.getX(index2);
    this.y = attribute.getY(index2);
    return this;
  }
  rotateAround(center, angle) {
    const c = Math.cos(angle), s = Math.sin(angle);
    const x = this.x - center.x;
    const y = this.y - center.y;
    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }
}
class Matrix3 {
  constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    Matrix3.prototype.isMatrix3 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    );
    return this;
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m) {
    const me = m.elements;
    this.set(
      me[0],
      me[4],
      me[8],
      me[1],
      me[5],
      me[9],
      me[2],
      me[6],
      me[10]
    );
    return this;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[3], a13 = ae[6];
    const a21 = ae[1], a22 = ae[4], a23 = ae[7];
    const a31 = ae[2], a32 = ae[5], a33 = ae[8];
    const b11 = be[0], b12 = be[3], b13 = be[6];
    const b21 = be[1], b22 = be[4], b23 = be[7];
    const b31 = be[2], b32 = be[5], b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const a = te[0], b = te[1], c = te[2], d = te[3], e2 = te[4], f = te[5], g = te[6], h2 = te[7], i = te[8];
    return a * e2 * i - a * f * h2 - b * d * i + b * f * g + c * d * h2 - c * e2 * g;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp;
    const m = this.elements;
    tmp = m[1];
    m[1] = m[3];
    m[3] = tmp;
    tmp = m[2];
    m[2] = m[6];
    m[6] = tmp;
    tmp = m[5];
    m[5] = m[7];
    m[7] = tmp;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r) {
    const m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c = Math.cos(rotation);
    const s = Math.sin(rotation);
    this.set(
      sx * c,
      sx * s,
      -sx * (c * cx + s * cy) + cx + tx,
      -sy * s,
      sy * c,
      -sy * (-s * cx + c * cy) + cy + ty,
      0,
      0,
      1
    );
    return this;
  }
  //
  scale(sx, sy) {
    this.premultiply(_m3.makeScale(sx, sy));
    return this;
  }
  rotate(theta) {
    this.premultiply(_m3.makeRotation(-theta));
    return this;
  }
  translate(tx, ty) {
    this.premultiply(_m3.makeTranslation(tx, ty));
    return this;
  }
  // for 2D Transforms
  makeTranslation(x, y) {
    if (x.isVector2) {
      this.set(
        1,
        0,
        x.x,
        0,
        1,
        x.y,
        0,
        0,
        1
      );
    } else {
      this.set(
        1,
        0,
        x,
        0,
        1,
        y,
        0,
        0,
        1
      );
    }
    return this;
  }
  makeRotation(theta) {
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    this.set(
      c,
      -s,
      0,
      s,
      c,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeScale(x, y) {
    this.set(
      x,
      0,
      0,
      0,
      y,
      0,
      0,
      0,
      1
    );
    return this;
  }
  //
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 9; i++) {
      if (te[i] !== me[i])
        return false;
    }
    return true;
  }
  fromArray(array, offset2 = 0) {
    for (let i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset2];
    }
    return this;
  }
  toArray(array = [], offset2 = 0) {
    const te = this.elements;
    array[offset2] = te[0];
    array[offset2 + 1] = te[1];
    array[offset2 + 2] = te[2];
    array[offset2 + 3] = te[3];
    array[offset2 + 4] = te[4];
    array[offset2 + 5] = te[5];
    array[offset2 + 6] = te[6];
    array[offset2 + 7] = te[7];
    array[offset2 + 8] = te[8];
    return array;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const _m3 = /* @__PURE__ */ new Matrix3();
function createElementNS(name) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", name);
}
const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = /* @__PURE__ */ new Matrix3().set(
  0.8224621,
  0.177538,
  0,
  0.0331941,
  0.9668058,
  0,
  0.0170827,
  0.0723974,
  0.9105199
);
const LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = /* @__PURE__ */ new Matrix3().set(
  1.2249401,
  -0.2249404,
  0,
  -0.0420569,
  1.0420571,
  0,
  -0.0196376,
  -0.0786361,
  1.0982735
);
const COLOR_SPACES = {
  [LinearSRGBColorSpace]: {
    transfer: LinearTransfer,
    primaries: Rec709Primaries,
    toReference: (color) => color,
    fromReference: (color) => color
  },
  [SRGBColorSpace]: {
    transfer: SRGBTransfer,
    primaries: Rec709Primaries,
    toReference: (color) => color.convertSRGBToLinear(),
    fromReference: (color) => color.convertLinearToSRGB()
  },
  [LinearDisplayP3ColorSpace]: {
    transfer: LinearTransfer,
    primaries: P3Primaries,
    toReference: (color) => color.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
    fromReference: (color) => color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3)
  },
  [DisplayP3ColorSpace]: {
    transfer: SRGBTransfer,
    primaries: P3Primaries,
    toReference: (color) => color.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
    fromReference: (color) => color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB()
  }
};
const SUPPORTED_WORKING_COLOR_SPACES = /* @__PURE__ */ new Set([LinearSRGBColorSpace, LinearDisplayP3ColorSpace]);
const ColorManagement = {
  enabled: true,
  _workingColorSpace: LinearSRGBColorSpace,
  get workingColorSpace() {
    return this._workingColorSpace;
  },
  set workingColorSpace(colorSpace) {
    if (!SUPPORTED_WORKING_COLOR_SPACES.has(colorSpace)) {
      throw new Error(`Unsupported working color space, "${colorSpace}".`);
    }
    this._workingColorSpace = colorSpace;
  },
  convert: function(color, sourceColorSpace, targetColorSpace) {
    if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
      return color;
    }
    const sourceToReference = COLOR_SPACES[sourceColorSpace].toReference;
    const targetFromReference = COLOR_SPACES[targetColorSpace].fromReference;
    return targetFromReference(sourceToReference(color));
  },
  fromWorkingColorSpace: function(color, targetColorSpace) {
    return this.convert(color, this._workingColorSpace, targetColorSpace);
  },
  toWorkingColorSpace: function(color, sourceColorSpace) {
    return this.convert(color, sourceColorSpace, this._workingColorSpace);
  },
  getPrimaries: function(colorSpace) {
    return COLOR_SPACES[colorSpace].primaries;
  },
  getTransfer: function(colorSpace) {
    if (colorSpace === NoColorSpace)
      return LinearTransfer;
    return COLOR_SPACES[colorSpace].transfer;
  }
};
function SRGBToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
  return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
let _canvas;
class ImageUtils {
  static getDataURL(image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement === "undefined") {
      return image.src;
    }
    let canvas2;
    if (image instanceof HTMLCanvasElement) {
      canvas2 = image;
    } else {
      if (_canvas === void 0)
        _canvas = createElementNS("canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas2 = _canvas;
    }
    if (canvas2.width > 2048 || canvas2.height > 2048) {
      console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
      return canvas2.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas2.toDataURL("image/png");
    }
  }
  static sRGBToLinear(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      const canvas2 = createElementNS("canvas");
      canvas2.width = image.width;
      canvas2.height = image.height;
      const context = canvas2.getContext("2d");
      context.drawImage(image, 0, 0, image.width, image.height);
      const imageData = context.getImageData(0, 0, image.width, image.height);
      const data = imageData.data;
      for (let i = 0; i < data.length; i++) {
        data[i] = SRGBToLinear(data[i] / 255) * 255;
      }
      context.putImageData(imageData, 0, 0);
      return canvas2;
    } else if (image.data) {
      const data = image.data.slice(0);
      for (let i = 0; i < data.length; i++) {
        if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
          data[i] = Math.floor(SRGBToLinear(data[i] / 255) * 255);
        } else {
          data[i] = SRGBToLinear(data[i]);
        }
      }
      return {
        data,
        width: image.width,
        height: image.height
      };
    } else {
      console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
      return image;
    }
  }
}
let _sourceId = 0;
class Source {
  constructor(data = null) {
    this.isSource = true;
    Object.defineProperty(this, "id", { value: _sourceId++ });
    this.uuid = generateUUID();
    this.data = data;
    this.dataReady = true;
    this.version = 0;
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.images[this.uuid] !== void 0) {
      return meta.images[this.uuid];
    }
    const output = {
      uuid: this.uuid,
      url: ""
    };
    const data = this.data;
    if (data !== null) {
      let url;
      if (Array.isArray(data)) {
        url = [];
        for (let i = 0, l = data.length; i < l; i++) {
          if (data[i].isDataTexture) {
            url.push(serializeImage(data[i].image));
          } else {
            url.push(serializeImage(data[i]));
          }
        }
      } else {
        url = serializeImage(data);
      }
      output.url = url;
    }
    if (!isRootObject) {
      meta.images[this.uuid] = output;
    }
    return output;
  }
}
function serializeImage(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.from(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
let _textureId = 0;
class Texture extends EventDispatcher {
  constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format2 = RGBAFormat, type2 = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {
    super();
    this.isTexture = true;
    Object.defineProperty(this, "id", { value: _textureId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.source = new Source(image);
    this.mipmaps = [];
    this.mapping = mapping;
    this.channel = 0;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format2;
    this.internalFormat = null;
    this.type = type2;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.colorSpace = colorSpace;
    this.userData = {};
    this.version = 0;
    this.onUpdate = null;
    this.isRenderTargetTexture = false;
    this.needsPMREMUpdate = false;
  }
  get image() {
    return this.source.data;
  }
  set image(value = null) {
    this.source.data = value;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.source = source.source;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.channel = source.channel;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.colorSpace = source.colorSpace;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    this.needsUpdate = true;
    return this;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(meta).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (Object.keys(this.userData).length > 0)
      output.userData = this.userData;
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(uv) {
    if (this.mapping !== UVMapping)
      return uv;
    uv.applyMatrix3(this.matrix);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
    return uv;
  }
  set needsUpdate(value) {
    if (value === true) {
      this.version++;
      this.source.needsUpdate = true;
    }
  }
}
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.DEFAULT_ANISOTROPY = 1;
class Quaternion {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.isQuaternion = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (t === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s = 1 - t;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t = Math.sin(t * len) / sin;
      }
      const tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir;
      if (s === 1 - t) {
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update = true) {
    const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x / 2);
    const c2 = cos(y / 2);
    const c3 = cos(z / 2);
    const s1 = sin(x / 2);
    const s2 = sin(y / 2);
    const s3 = sin(z / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update === true)
      this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m) {
    const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    let r = vFrom.dot(vTo) + 1;
    if (r < Number.EPSILON) {
      r = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }
    return this.normalize();
  }
  angleTo(q) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
  }
  rotateTowards(q, step) {
    const angle = this.angleTo(q);
    if (angle === 0)
      return this;
    const t = Math.min(1, step / angle);
    this.slerp(q, t);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l = this.length();
    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q) {
    return this.multiplyQuaternions(this, q);
  }
  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }
  multiplyQuaternions(a, b) {
    const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(qb);
    const x = this._x, y = this._y, z = this._z, w = this._w;
    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t;
      this._w = s * w + t * this._w;
      this._x = s * x + t * this._x;
      this._y = s * y + t * this._y;
      this._z = s * z + t * this._z;
      this.normalize();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  slerpQuaternions(qa, qb, t) {
    return this.copy(qa).slerp(qb, t);
  }
  random() {
    const theta1 = 2 * Math.PI * Math.random();
    const theta2 = 2 * Math.PI * Math.random();
    const x0 = Math.random();
    const r1 = Math.sqrt(1 - x0);
    const r2 = Math.sqrt(x0);
    return this.set(
      r1 * Math.sin(theta1),
      r1 * Math.cos(theta1),
      r2 * Math.sin(theta2),
      r2 * Math.cos(theta2)
    );
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array, offset2 = 0) {
    this._x = array[offset2];
    this._y = array[offset2 + 1];
    this._z = array[offset2 + 2];
    this._w = array[offset2 + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset2 = 0) {
    array[offset2] = this._x;
    array[offset2 + 1] = this._y;
    array[offset2 + 2] = this._z;
    array[offset2 + 3] = this._w;
    return array;
  }
  fromBufferAttribute(attribute, index2) {
    this._x = attribute.getX(index2);
    this._y = attribute.getY(index2);
    this._z = attribute.getZ(index2);
    this._w = attribute.getW(index2);
    this._onChangeCallback();
    return this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._w;
  }
}
class Vector3 {
  constructor(x = 0, y = 0, z = 0) {
    Vector3.prototype.isVector3 = true;
    this.x = x;
    this.y = y;
    this.z = z;
  }
  set(x, y, z) {
    if (z === void 0)
      z = this.z;
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setComponent(index2, value) {
    switch (index2) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index2);
    }
    return this;
  }
  getComponent(index2) {
    switch (index2) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index2);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  }
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  }
  applyEuler(euler) {
    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m) {
    const x = this.x, y = this.y, z = this.z;
    const e2 = m.elements;
    this.x = e2[0] * x + e2[3] * y + e2[6] * z;
    this.y = e2[1] * x + e2[4] * y + e2[7] * z;
    this.z = e2[2] * x + e2[5] * y + e2[8] * z;
    return this;
  }
  applyNormalMatrix(m) {
    return this.applyMatrix3(m).normalize();
  }
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z;
    const e2 = m.elements;
    const w = 1 / (e2[3] * x + e2[7] * y + e2[11] * z + e2[15]);
    this.x = (e2[0] * x + e2[4] * y + e2[8] * z + e2[12]) * w;
    this.y = (e2[1] * x + e2[5] * y + e2[9] * z + e2[13]) * w;
    this.z = (e2[2] * x + e2[6] * y + e2[10] * z + e2[14]) * w;
    return this;
  }
  applyQuaternion(q) {
    const vx = this.x, vy = this.y, vz = this.z;
    const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
    const tx = 2 * (qy * vz - qz * vy);
    const ty = 2 * (qz * vx - qx * vz);
    const tz = 2 * (qx * vy - qy * vx);
    this.x = vx + qw * tx + qy * tz - qz * ty;
    this.y = vy + qw * ty + qz * tx - qx * tz;
    this.z = vz + qw * tz + qx * ty - qy * tx;
    return this;
  }
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }
  transformDirection(m) {
    const x = this.x, y = this.y, z = this.z;
    const e2 = m.elements;
    this.x = e2[0] * x + e2[4] * y + e2[8] * z;
    this.y = e2[1] * x + e2[5] * y + e2[9] * z;
    this.z = e2[2] * x + e2[6] * y + e2[10] * z;
    return this.normalize();
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  }
  clamp(min2, max2) {
    this.x = Math.max(min2.x, Math.min(max2.x, this.x));
    this.y = Math.max(min2.y, Math.min(max2.y, this.y));
    this.z = Math.max(min2.z, Math.min(max2.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min2, max2) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min2, Math.min(max2, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  cross(v) {
    return this.crossVectors(this, v);
  }
  crossVectors(a, b) {
    const ax = a.x, ay = a.y, az = a.z;
    const bx = b.x, by = b.y, bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v) {
    const denominator = v.lengthSq();
    if (denominator === 0)
      return this.set(0, 0, 0);
    const scalar = v.dot(this) / denominator;
    return this.copy(v).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector$c.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$c);
  }
  reflect(normal) {
    return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0)
      return Math.PI / 2;
    const theta = this.dot(v) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  }
  setFromSpherical(s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  }
  setFromCylindricalCoords(radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m) {
    const e2 = m.elements;
    this.x = e2[12];
    this.y = e2[13];
    this.z = e2[14];
    return this;
  }
  setFromMatrixScale(m) {
    const sx = this.setFromMatrixColumn(m, 0).length();
    const sy = this.setFromMatrixColumn(m, 1).length();
    const sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m, index2) {
    return this.fromArray(m.elements, index2 * 4);
  }
  setFromMatrix3Column(m, index2) {
    return this.fromArray(m.elements, index2 * 3);
  }
  setFromEuler(e2) {
    this.x = e2._x;
    this.y = e2._y;
    this.z = e2._z;
    return this;
  }
  setFromColor(c) {
    this.x = c.r;
    this.y = c.g;
    this.z = c.b;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  }
  fromArray(array, offset2 = 0) {
    this.x = array[offset2];
    this.y = array[offset2 + 1];
    this.z = array[offset2 + 2];
    return this;
  }
  toArray(array = [], offset2 = 0) {
    array[offset2] = this.x;
    array[offset2 + 1] = this.y;
    array[offset2 + 2] = this.z;
    return array;
  }
  fromBufferAttribute(attribute, index2) {
    this.x = attribute.getX(index2);
    this.y = attribute.getY(index2);
    this.z = attribute.getZ(index2);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
  randomDirection() {
    const theta = Math.random() * Math.PI * 2;
    const u = Math.random() * 2 - 1;
    const c = Math.sqrt(1 - u * u);
    this.x = c * Math.cos(theta);
    this.y = u;
    this.z = c * Math.sin(theta);
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }
}
const _vector$c = /* @__PURE__ */ new Vector3();
const _quaternion$4 = /* @__PURE__ */ new Quaternion();
class Matrix4 {
  constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    Matrix4.prototype.isMatrix4 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
    }
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }
  copyPosition(m) {
    const te = this.elements, me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }
  setFromMatrix3(m) {
    const me = m.elements;
    this.set(
      me[0],
      me[3],
      me[6],
      0,
      me[1],
      me[4],
      me[7],
      0,
      me[2],
      me[5],
      me[8],
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(
      xAxis.x,
      yAxis.x,
      zAxis.x,
      0,
      xAxis.y,
      yAxis.y,
      zAxis.y,
      0,
      xAxis.z,
      yAxis.z,
      zAxis.z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractRotation(m) {
    const te = this.elements;
    const me = m.elements;
    const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
    const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    const te = this.elements;
    const x = euler.x, y = euler.y, z = euler.z;
    const a = Math.cos(x), b = Math.sin(x);
    const c = Math.cos(y), d = Math.sin(y);
    const e2 = Math.cos(z), f = Math.sin(z);
    if (euler.order === "XYZ") {
      const ae = a * e2, af = a * f, be = b * e2, bf = b * f;
      te[0] = c * e2;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === "YXZ") {
      const ce = c * e2, cf = c * f, de = d * e2, df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e2;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === "ZXY") {
      const ce = c * e2, cf = c * f, de = d * e2, df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e2;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === "ZYX") {
      const ae = a * e2, af = a * f, be = b * e2, bf = b * f;
      te[0] = c * e2;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === "YZX") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e2;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e2;
      te[9] = -b * e2;
      te[2] = -d * e2;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === "XZY") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e2;
      te[4] = -f;
      te[8] = d * e2;
      te[1] = ac * f + bd;
      te[5] = a * e2;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e2;
      te[10] = bd * f + ac;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one);
  }
  lookAt(eye, target, up) {
    const te = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te = this.elements;
    let tmp;
    tmp = te[1];
    te[1] = te[4];
    te[4] = tmp;
    tmp = te[2];
    te[2] = te[8];
    te[8] = tmp;
    tmp = te[6];
    te[6] = te[9];
    te[9] = tmp;
    tmp = te[3];
    te[3] = te[12];
    te[12] = tmp;
    tmp = te[7];
    te[7] = te[13];
    te[13] = tmp;
    tmp = te[11];
    te[11] = te[14];
    te[14] = tmp;
    return this;
  }
  setPosition(x, y, z) {
    const te = this.elements;
    if (x.isVector3) {
      te[12] = x.x;
      te[13] = x.y;
      te[14] = x.z;
    } else {
      te[12] = x;
      te[13] = y;
      te[14] = z;
    }
    return this;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v) {
    const te = this.elements;
    const x = v.x, y = v.y, z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  }
  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x, y, z) {
    if (x.isVector3) {
      this.set(
        1,
        0,
        0,
        x.x,
        0,
        1,
        0,
        x.y,
        0,
        0,
        1,
        x.z,
        0,
        0,
        0,
        1
      );
    } else {
      this.set(
        1,
        0,
        0,
        x,
        0,
        1,
        0,
        y,
        0,
        0,
        1,
        z,
        0,
        0,
        0,
        1
      );
    }
    return this;
  }
  makeRotationX(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      1,
      0,
      0,
      0,
      0,
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationY(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      c,
      0,
      s,
      0,
      0,
      1,
      0,
      0,
      -s,
      0,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationZ(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationAxis(axis, angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c;
    const x = axis.x, y = axis.y, z = axis.z;
    const tx = t * x, ty = t * y;
    this.set(
      tx * x + c,
      tx * y - s * z,
      tx * z + s * y,
      0,
      tx * y + s * z,
      ty * y + c,
      ty * z - s * x,
      0,
      tx * z - s * y,
      ty * z + s * x,
      t * z * z + c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeScale(x, y, z) {
    this.set(
      x,
      0,
      0,
      0,
      0,
      y,
      0,
      0,
      0,
      0,
      z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(
      1,
      yx,
      zx,
      0,
      xy,
      1,
      zy,
      0,
      xz,
      yz,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  compose(position, quaternion, scale) {
    const te = this.elements;
    const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
    const x2 = x + x, y2 = y + y, z2 = z + z;
    const xx = x * x2, xy = x * y2, xz = x * z2;
    const yy2 = y * y2, yz = y * z2, zz = z * z2;
    const wx = w * x2, wy = w * y2, wz = w * z2;
    const sx = scale.x, sy = scale.y, sz = scale.z;
    te[0] = (1 - (yy2 + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy2)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }
  decompose(position, quaternion, scale) {
    const te = this.elements;
    let sx = _v1$5.set(te[0], te[1], te[2]).length();
    const sy = _v1$5.set(te[4], te[5], te[6]).length();
    const sz = _v1$5.set(te[8], te[9], te[10]).length();
    const det = this.determinant();
    if (det < 0)
      sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14];
    _m1$4.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1$4.elements[0] *= invSX;
    _m1$4.elements[1] *= invSX;
    _m1$4.elements[2] *= invSX;
    _m1$4.elements[4] *= invSY;
    _m1$4.elements[5] *= invSY;
    _m1$4.elements[6] *= invSY;
    _m1$4.elements[8] *= invSZ;
    _m1$4.elements[9] *= invSZ;
    _m1$4.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1$4);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
    const te = this.elements;
    const x = 2 * near / (right - left);
    const y = 2 * near / (top - bottom);
    const a = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    let c, d;
    if (coordinateSystem === WebGLCoordinateSystem) {
      c = -(far + near) / (far - near);
      d = -2 * far * near / (far - near);
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      c = -far / (far - near);
      d = -far * near / (far - near);
    } else {
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);
    }
    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
    const te = this.elements;
    const w = 1 / (right - left);
    const h2 = 1 / (top - bottom);
    const p2 = 1 / (far - near);
    const x = (right + left) * w;
    const y = (top + bottom) * h2;
    let z, zInv;
    if (coordinateSystem === WebGLCoordinateSystem) {
      z = (far + near) * p2;
      zInv = -2 * p2;
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      z = near * p2;
      zInv = -1 * p2;
    } else {
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);
    }
    te[0] = 2 * w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h2;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = zInv;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 16; i++) {
      if (te[i] !== me[i])
        return false;
    }
    return true;
  }
  fromArray(array, offset2 = 0) {
    for (let i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset2];
    }
    return this;
  }
  toArray(array = [], offset2 = 0) {
    const te = this.elements;
    array[offset2] = te[0];
    array[offset2 + 1] = te[1];
    array[offset2 + 2] = te[2];
    array[offset2 + 3] = te[3];
    array[offset2 + 4] = te[4];
    array[offset2 + 5] = te[5];
    array[offset2 + 6] = te[6];
    array[offset2 + 7] = te[7];
    array[offset2 + 8] = te[8];
    array[offset2 + 9] = te[9];
    array[offset2 + 10] = te[10];
    array[offset2 + 11] = te[11];
    array[offset2 + 12] = te[12];
    array[offset2 + 13] = te[13];
    array[offset2 + 14] = te[14];
    array[offset2 + 15] = te[15];
    return array;
  }
}
const _v1$5 = /* @__PURE__ */ new Vector3();
const _m1$4 = /* @__PURE__ */ new Matrix4();
const _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
const _one = /* @__PURE__ */ new Vector3(1, 1, 1);
const _x = /* @__PURE__ */ new Vector3();
const _y = /* @__PURE__ */ new Vector3();
const _z = /* @__PURE__ */ new Vector3();
const _matrix$2 = /* @__PURE__ */ new Matrix4();
const _quaternion$3 = /* @__PURE__ */ new Quaternion();
class Euler {
  constructor(x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {
    this.isEuler = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x, y, z, order = this._order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m, order = this._order, update = true) {
    const te = m.elements;
    const m11 = te[0], m12 = te[4], m13 = te[8];
    const m21 = te[1], m22 = te[5], m23 = te[9];
    const m31 = te[2], m32 = te[6], m33 = te[10];
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update === true)
      this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q, order, update) {
    _matrix$2.makeRotationFromQuaternion(q);
    return this.setFromRotationMatrix(_matrix$2, order, update);
  }
  setFromVector3(v, order = this._order) {
    return this.set(v.x, v.y, v.z, order);
  }
  reorder(newOrder) {
    _quaternion$3.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$3, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0)
      this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset2 = 0) {
    array[offset2] = this._x;
    array[offset2 + 1] = this._y;
    array[offset2 + 2] = this._z;
    array[offset2 + 3] = this._order;
    return array;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._order;
  }
}
Euler.DEFAULT_ORDER = "XYZ";
class Layers {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel) {
    this.mask = (1 << channel | 0) >>> 0;
  }
  enable(channel) {
    this.mask |= 1 << channel | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }
  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
  isEnabled(channel) {
    return (this.mask & (1 << channel | 0)) !== 0;
  }
}
let _object3DId = 0;
const _v1$4 = /* @__PURE__ */ new Vector3();
const _q1 = /* @__PURE__ */ new Quaternion();
const _m1$3 = /* @__PURE__ */ new Matrix4();
const _target = /* @__PURE__ */ new Vector3();
const _position$3 = /* @__PURE__ */ new Vector3();
const _scale$2 = /* @__PURE__ */ new Vector3();
const _quaternion$2 = /* @__PURE__ */ new Quaternion();
const _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
const _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
const _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
const _addedEvent = { type: "added" };
const _removedEvent = { type: "removed" };
const _childaddedEvent = { type: "childadded", child: null };
const _childremovedEvent = { type: "childremoved", child: null };
class Object3D extends EventDispatcher {
  constructor() {
    super();
    this.isObject3D = true;
    Object.defineProperty(this, "id", { value: _object3DId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = Object3D.DEFAULT_UP.clone();
    const position = new Vector3();
    const rotation = new Euler();
    const quaternion = new Quaternion();
    const scale = new Vector3(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, void 0, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
    this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(q) {
    this.quaternion.premultiply(q);
    return this;
  }
  setRotationFromAxisAngle(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  }
  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }
  setRotationFromMatrix(m) {
    this.quaternion.setFromRotationMatrix(m);
  }
  setRotationFromQuaternion(q) {
    this.quaternion.copy(q);
  }
  rotateOnAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  }
  rotateOnWorldAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  }
  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  }
  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  }
  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  }
  translateOnAxis(axis, distance2) {
    _v1$4.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$4.multiplyScalar(distance2));
    return this;
  }
  translateX(distance2) {
    return this.translateOnAxis(_xAxis, distance2);
  }
  translateY(distance2) {
    return this.translateOnAxis(_yAxis, distance2);
  }
  translateZ(distance2) {
    return this.translateOnAxis(_zAxis, distance2);
  }
  localToWorld(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(_m1$3.copy(this.matrixWorld).invert());
  }
  lookAt(x, y, z) {
    if (x.isVector3) {
      _target.copy(x);
    } else {
      _target.set(x, y, z);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position$3.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$3.lookAt(_position$3, _target, this.up);
    } else {
      _m1$3.lookAt(_target, _position$3, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$3);
    if (parent) {
      _m1$3.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$3);
      this.quaternion.premultiply(_q1.invert());
    }
  }
  add(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }
      return this;
    }
    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
      _childaddedEvent.child = object;
      this.dispatchEvent(_childaddedEvent);
      _childaddedEvent.child = null;
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  }
  remove(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }
      return this;
    }
    const index2 = this.children.indexOf(object);
    if (index2 !== -1) {
      object.parent = null;
      this.children.splice(index2, 1);
      object.dispatchEvent(_removedEvent);
      _childremovedEvent.child = object;
      this.dispatchEvent(_childremovedEvent);
      _childremovedEvent.child = null;
    }
    return this;
  }
  removeFromParent() {
    const parent = this.parent;
    if (parent !== null) {
      parent.remove(this);
    }
    return this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(object) {
    this.updateWorldMatrix(true, false);
    _m1$3.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$3.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$3);
    this.add(object);
    object.updateWorldMatrix(false, true);
    return this;
  }
  getObjectById(id) {
    return this.getObjectByProperty("id", id);
  }
  getObjectByName(name) {
    return this.getObjectByProperty("name", name);
  }
  getObjectByProperty(name, value) {
    if (this[name] === value)
      return this;
    for (let i = 0, l = this.children.length; i < l; i++) {
      const child = this.children[i];
      const object = child.getObjectByProperty(name, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  }
  getObjectsByProperty(name, value, result = []) {
    if (this[name] === value)
      result.push(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].getObjectsByProperty(name, value, result);
    }
    return result;
  }
  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, target, _scale$2);
    return target;
  }
  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, _quaternion$2, target);
    return target;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e2 = this.matrixWorld.elements;
    return target.set(e2[8], e2[9], e2[10]).normalize();
  }
  raycast() {
  }
  traverse(callback) {
    callback(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback);
    }
  }
  traverseVisible(callback) {
    if (this.visible === false)
      return;
    callback(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback);
    }
  }
  traverseAncestors(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      const child = children[i];
      if (child.matrixWorldAutoUpdate === true || force === true) {
        child.updateMatrixWorld(force);
      }
    }
  }
  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        const child = children[i];
        if (child.matrixWorldAutoUpdate === true) {
          child.updateWorldMatrix(false, true);
        }
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      };
      output.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "")
      object.name = this.name;
    if (this.castShadow === true)
      object.castShadow = true;
    if (this.receiveShadow === true)
      object.receiveShadow = true;
    if (this.visible === false)
      object.visible = false;
    if (this.frustumCulled === false)
      object.frustumCulled = false;
    if (this.renderOrder !== 0)
      object.renderOrder = this.renderOrder;
    if (Object.keys(this.userData).length > 0)
      object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    object.up = this.up.toArray();
    if (this.matrixAutoUpdate === false)
      object.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object.type = "InstancedMesh";
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null)
        object.instanceColor = this.instanceColor.toJSON();
    }
    if (this.isBatchedMesh) {
      object.type = "BatchedMesh";
      object.perObjectFrustumCulled = this.perObjectFrustumCulled;
      object.sortObjects = this.sortObjects;
      object.drawRanges = this._drawRanges;
      object.reservedRanges = this._reservedRanges;
      object.visibility = this._visibility;
      object.active = this._active;
      object.bounds = this._bounds.map((bound) => ({
        boxInitialized: bound.boxInitialized,
        boxMin: bound.box.min.toArray(),
        boxMax: bound.box.max.toArray(),
        sphereInitialized: bound.sphereInitialized,
        sphereRadius: bound.sphere.radius,
        sphereCenter: bound.sphere.center.toArray()
      }));
      object.maxGeometryCount = this._maxGeometryCount;
      object.maxVertexCount = this._maxVertexCount;
      object.maxIndexCount = this._maxIndexCount;
      object.geometryInitialized = this._geometryInitialized;
      object.geometryCount = this._geometryCount;
      object.matricesTexture = this._matricesTexture.toJSON(meta);
      if (this.boundingSphere !== null) {
        object.boundingSphere = {
          center: object.boundingSphere.center.toArray(),
          radius: object.boundingSphere.radius
        };
      }
      if (this.boundingBox !== null) {
        object.boundingBox = {
          min: object.boundingBox.min.toArray(),
          max: object.boundingBox.max.toArray()
        };
      }
    }
    function serialize(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object.background = this.background.toJSON(meta).uuid;
        }
      }
      if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
        object.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i = 0, l = shapes.length; i < l; i++) {
            const shape = shapes[i];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i = 0, l = this.material.length; i < l; i++) {
          uuids.push(serialize(meta.materials, this.material[i]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (let i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object.animations = [];
      for (let i = 0; i < this.animations.length; i++) {
        const animation = this.animations[i];
        object.animations.push(serialize(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      const nodes = extractFromCache(meta.nodes);
      if (geometries.length > 0)
        output.geometries = geometries;
      if (materials.length > 0)
        output.materials = materials;
      if (textures.length > 0)
        output.textures = textures;
      if (images.length > 0)
        output.images = images;
      if (shapes.length > 0)
        output.shapes = shapes;
      if (skeletons.length > 0)
        output.skeletons = skeletons;
      if (animations.length > 0)
        output.animations = animations;
      if (nodes.length > 0)
        output.nodes = nodes;
    }
    output.object = object;
    return output;
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data = cache2[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  }
  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }
  copy(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.animations = source.animations.slice();
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i = 0; i < source.children.length; i++) {
        const child = source.children[i];
        this.add(child.clone());
      }
    }
    return this;
  }
}
Object3D.DEFAULT_UP = /* @__PURE__ */ new Vector3(0, 1, 0);
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
const _colorKeywords = {
  "aliceblue": 15792383,
  "antiquewhite": 16444375,
  "aqua": 65535,
  "aquamarine": 8388564,
  "azure": 15794175,
  "beige": 16119260,
  "bisque": 16770244,
  "black": 0,
  "blanchedalmond": 16772045,
  "blue": 255,
  "blueviolet": 9055202,
  "brown": 10824234,
  "burlywood": 14596231,
  "cadetblue": 6266528,
  "chartreuse": 8388352,
  "chocolate": 13789470,
  "coral": 16744272,
  "cornflowerblue": 6591981,
  "cornsilk": 16775388,
  "crimson": 14423100,
  "cyan": 65535,
  "darkblue": 139,
  "darkcyan": 35723,
  "darkgoldenrod": 12092939,
  "darkgray": 11119017,
  "darkgreen": 25600,
  "darkgrey": 11119017,
  "darkkhaki": 12433259,
  "darkmagenta": 9109643,
  "darkolivegreen": 5597999,
  "darkorange": 16747520,
  "darkorchid": 10040012,
  "darkred": 9109504,
  "darksalmon": 15308410,
  "darkseagreen": 9419919,
  "darkslateblue": 4734347,
  "darkslategray": 3100495,
  "darkslategrey": 3100495,
  "darkturquoise": 52945,
  "darkviolet": 9699539,
  "deeppink": 16716947,
  "deepskyblue": 49151,
  "dimgray": 6908265,
  "dimgrey": 6908265,
  "dodgerblue": 2003199,
  "firebrick": 11674146,
  "floralwhite": 16775920,
  "forestgreen": 2263842,
  "fuchsia": 16711935,
  "gainsboro": 14474460,
  "ghostwhite": 16316671,
  "gold": 16766720,
  "goldenrod": 14329120,
  "gray": 8421504,
  "green": 32768,
  "greenyellow": 11403055,
  "grey": 8421504,
  "honeydew": 15794160,
  "hotpink": 16738740,
  "indianred": 13458524,
  "indigo": 4915330,
  "ivory": 16777200,
  "khaki": 15787660,
  "lavender": 15132410,
  "lavenderblush": 16773365,
  "lawngreen": 8190976,
  "lemonchiffon": 16775885,
  "lightblue": 11393254,
  "lightcoral": 15761536,
  "lightcyan": 14745599,
  "lightgoldenrodyellow": 16448210,
  "lightgray": 13882323,
  "lightgreen": 9498256,
  "lightgrey": 13882323,
  "lightpink": 16758465,
  "lightsalmon": 16752762,
  "lightseagreen": 2142890,
  "lightskyblue": 8900346,
  "lightslategray": 7833753,
  "lightslategrey": 7833753,
  "lightsteelblue": 11584734,
  "lightyellow": 16777184,
  "lime": 65280,
  "limegreen": 3329330,
  "linen": 16445670,
  "magenta": 16711935,
  "maroon": 8388608,
  "mediumaquamarine": 6737322,
  "mediumblue": 205,
  "mediumorchid": 12211667,
  "mediumpurple": 9662683,
  "mediumseagreen": 3978097,
  "mediumslateblue": 8087790,
  "mediumspringgreen": 64154,
  "mediumturquoise": 4772300,
  "mediumvioletred": 13047173,
  "midnightblue": 1644912,
  "mintcream": 16121850,
  "mistyrose": 16770273,
  "moccasin": 16770229,
  "navajowhite": 16768685,
  "navy": 128,
  "oldlace": 16643558,
  "olive": 8421376,
  "olivedrab": 7048739,
  "orange": 16753920,
  "orangered": 16729344,
  "orchid": 14315734,
  "palegoldenrod": 15657130,
  "palegreen": 10025880,
  "paleturquoise": 11529966,
  "palevioletred": 14381203,
  "papayawhip": 16773077,
  "peachpuff": 16767673,
  "peru": 13468991,
  "pink": 16761035,
  "plum": 14524637,
  "powderblue": 11591910,
  "purple": 8388736,
  "rebeccapurple": 6697881,
  "red": 16711680,
  "rosybrown": 12357519,
  "royalblue": 4286945,
  "saddlebrown": 9127187,
  "salmon": 16416882,
  "sandybrown": 16032864,
  "seagreen": 3050327,
  "seashell": 16774638,
  "sienna": 10506797,
  "silver": 12632256,
  "skyblue": 8900331,
  "slateblue": 6970061,
  "slategray": 7372944,
  "slategrey": 7372944,
  "snow": 16775930,
  "springgreen": 65407,
  "steelblue": 4620980,
  "tan": 13808780,
  "teal": 32896,
  "thistle": 14204888,
  "tomato": 16737095,
  "turquoise": 4251856,
  "violet": 15631086,
  "wheat": 16113331,
  "white": 16777215,
  "whitesmoke": 16119285,
  "yellow": 16776960,
  "yellowgreen": 10145074
};
const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(p2, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p2 + (q - p2) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p2 + (q - p2) * 6 * (2 / 3 - t);
  return p2;
}
let Color$1 = class Color {
  constructor(r, g, b) {
    this.isColor = true;
    this.r = 1;
    this.g = 1;
    this.b = 1;
    return this.set(r, g, b);
  }
  set(r, g, b) {
    if (g === void 0 && b === void 0) {
      const value = r;
      if (value && value.isColor) {
        this.copy(value);
      } else if (typeof value === "number") {
        this.setHex(value);
      } else if (typeof value === "string") {
        this.setStyle(value);
      }
    } else {
      this.setRGB(r, g, b);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex, colorSpace = SRGBColorSpace) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {
    this.r = r;
    this.g = g;
    this.b = b;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setHSL(h2, s, l, colorSpace = ColorManagement.workingColorSpace) {
    h2 = euclideanModulo(h2, 1);
    s = clamp(s, 0, 1);
    l = clamp(l, 0, 1);
    if (s === 0) {
      this.r = this.g = this.b = l;
    } else {
      const p2 = l <= 0.5 ? l * (1 + s) : l + s - l * s;
      const q = 2 * l - p2;
      this.r = hue2rgb(q, p2, h2 + 1 / 3);
      this.g = hue2rgb(q, p2, h2);
      this.b = hue2rgb(q, p2, h2 - 1 / 3);
    }
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setStyle(style, colorSpace = SRGBColorSpace) {
    function handleAlpha(string) {
      if (string === void 0)
        return;
      if (parseFloat(string) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    let m;
    if (m = /^(\w+)\(([^\)]*)\)/.exec(style)) {
      let color;
      const name = m[1];
      const components = m[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color[4]);
            return this.setRGB(
              Math.min(255, parseInt(color[1], 10)) / 255,
              Math.min(255, parseInt(color[2], 10)) / 255,
              Math.min(255, parseInt(color[3], 10)) / 255,
              colorSpace
            );
          }
          if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color[4]);
            return this.setRGB(
              Math.min(100, parseInt(color[1], 10)) / 100,
              Math.min(100, parseInt(color[2], 10)) / 100,
              Math.min(100, parseInt(color[3], 10)) / 100,
              colorSpace
            );
          }
          break;
        case "hsl":
        case "hsla":
          if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color[4]);
            return this.setHSL(
              parseFloat(color[1]) / 360,
              parseFloat(color[2]) / 100,
              parseFloat(color[3]) / 100,
              colorSpace
            );
          }
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + style);
      }
    } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex = m[1];
      const size2 = hex.length;
      if (size2 === 3) {
        return this.setRGB(
          parseInt(hex.charAt(0), 16) / 15,
          parseInt(hex.charAt(1), 16) / 15,
          parseInt(hex.charAt(2), 16) / 15,
          colorSpace
        );
      } else if (size2 === 6) {
        return this.setHex(parseInt(hex, 16), colorSpace);
      } else {
        console.warn("THREE.Color: Invalid hex color " + style);
      }
    } else if (style && style.length > 0) {
      return this.setColorName(style, colorSpace);
    }
    return this;
  }
  setColorName(style, colorSpace = SRGBColorSpace) {
    const hex = _colorKeywords[style.toLowerCase()];
    if (hex !== void 0) {
      this.setHex(hex, colorSpace);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  }
  copySRGBToLinear(color) {
    this.r = SRGBToLinear(color.r);
    this.g = SRGBToLinear(color.g);
    this.b = SRGBToLinear(color.b);
    return this;
  }
  copyLinearToSRGB(color) {
    this.r = LinearToSRGB(color.r);
    this.g = LinearToSRGB(color.g);
    this.b = LinearToSRGB(color.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));
  }
  getHexString(colorSpace = SRGBColorSpace) {
    return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
  }
  getHSL(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    const r = _color.r, g = _color.g, b = _color.b;
    const max2 = Math.max(r, g, b);
    const min2 = Math.min(r, g, b);
    let hue, saturation;
    const lightness = (min2 + max2) / 2;
    if (min2 === max2) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max2 - min2;
      saturation = lightness <= 0.5 ? delta / (max2 + min2) : delta / (2 - max2 - min2);
      switch (max2) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;
        case g:
          hue = (b - r) / delta + 2;
          break;
        case b:
          hue = (r - g) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  getRGB(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    target.r = _color.r;
    target.g = _color.g;
    target.b = _color.b;
    return target;
  }
  getStyle(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    const r = _color.r, g = _color.g, b = _color.b;
    if (colorSpace !== SRGBColorSpace) {
      return `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;
    }
    return `rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * 255)})`;
  }
  offsetHSL(h2, s, l) {
    this.getHSL(_hslA);
    return this.setHSL(_hslA.h + h2, _hslA.s + s, _hslA.l + l);
  }
  add(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  }
  sub(color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  }
  multiply(color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  }
  multiplyScalar(s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  }
  lerp(color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  }
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  lerpHSL(color, alpha) {
    this.getHSL(_hslA);
    color.getHSL(_hslB);
    const h2 = lerp(_hslA.h, _hslB.h, alpha);
    const s = lerp(_hslA.s, _hslB.s, alpha);
    const l = lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h2, s, l);
    return this;
  }
  setFromVector3(v) {
    this.r = v.x;
    this.g = v.y;
    this.b = v.z;
    return this;
  }
  applyMatrix3(m) {
    const r = this.r, g = this.g, b = this.b;
    const e2 = m.elements;
    this.r = e2[0] * r + e2[3] * g + e2[6] * b;
    this.g = e2[1] * r + e2[4] * g + e2[7] * b;
    this.b = e2[2] * r + e2[5] * g + e2[8] * b;
    return this;
  }
  equals(c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  }
  fromArray(array, offset2 = 0) {
    this.r = array[offset2];
    this.g = array[offset2 + 1];
    this.b = array[offset2 + 2];
    return this;
  }
  toArray(array = [], offset2 = 0) {
    array[offset2] = this.r;
    array[offset2 + 1] = this.g;
    array[offset2 + 2] = this.b;
    return array;
  }
  fromBufferAttribute(attribute, index2) {
    this.r = attribute.getX(index2);
    this.g = attribute.getY(index2);
    this.b = attribute.getZ(index2);
    return this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r;
    yield this.g;
    yield this.b;
  }
};
const _color = /* @__PURE__ */ new Color$1();
Color$1.NAMES = _colorKeywords;
class DepthTexture extends Texture {
  constructor(width, height, type2, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format2) {
    format2 = format2 !== void 0 ? format2 : DepthFormat;
    if (format2 !== DepthFormat && format2 !== DepthStencilFormat) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    if (type2 === void 0 && format2 === DepthFormat)
      type2 = UnsignedIntType;
    if (type2 === void 0 && format2 === DepthStencilFormat)
      type2 = UnsignedInt248Type;
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format2, type2, anisotropy);
    this.isDepthTexture = true;
    this.image = { width, height };
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
    this.compareFunction = null;
  }
  copy(source) {
    super.copy(source);
    this.compareFunction = source.compareFunction;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.compareFunction !== null)
      data.compareFunction = this.compareFunction;
    return data;
  }
}
const emptyShadowTexture = /* @__PURE__ */ new DepthTexture(1, 1);
emptyShadowTexture.compareFunction = LessEqualCompare;
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
    revision: REVISION
  } }));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}
function invertLum(color) {
  let vector = null;
  if (color instanceof Color$1) {
    vector = color.clone();
  } else {
    vector = new Color$1(color);
  }
  const hsl = { h: 0, s: 0, l: 0 };
  vector.getHSL(hsl);
  [vector.r, vector.g, vector.b, vector.a];
  if (hsl.l >= 0.5) {
    vector.offsetHSL(0, 0, -0.5);
  } else {
    vector.offsetHSL(0, 0, 0.5);
  }
  return vector;
}
function lerpColors(label, color1, color2) {
  const rootVars = {};
  if (!color2) {
    color2 = invertLum(color1);
  }
  rootVars[`--${label}`] = `#${color1.getHexString()}`;
  if (label !== "text") {
    rootVars[`--${label}_text`] = `#${color2.getHexString()}`;
  }
  const gradient = 100;
  const step = 10;
  for (let x = step; x < gradient; x += step) {
    const intermediate = color1.clone();
    intermediate.lerp(color2, x / gradient);
    rootVars[`--${label}_${x}`] = `#${intermediate.getHexString()}`;
    if (label !== "text") {
      rootVars[`--${label}_text_${x}`] = `#${invertLum(intermediate).getHexString()}`;
    }
  }
  return rootVars;
}
var index$1p = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  panel: {
    borderWidth: "0 0 1px 0",
    borderColor: "{content.border.color}"
  },
  header: {
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    activeColor: "{text.color}",
    padding: "1.125rem",
    fontWeight: "600",
    borderRadius: "0",
    borderWidth: "0",
    borderColor: "{content.border.color}",
    background: "{content.background}",
    hoverBackground: "{content.background}",
    activeBackground: "{content.background}",
    activeHoverBackground: "{content.background}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    },
    toggleIcon: {
      color: "{text.muted.color}",
      hoverColor: "{text.color}",
      activeColor: "{text.color}",
      activeHoverColor: "{text.color}"
    },
    first: {
      topBorderRadius: "{content.border.radius}",
      borderWidth: "0"
    },
    last: {
      bottomBorderRadius: "{content.border.radius}",
      activeBottomBorderRadius: "0"
    }
  },
  content: {
    borderWidth: "0",
    borderColor: "{content.border.color}",
    background: "{content.background}",
    color: "{text.color}",
    padding: "0 1.125rem 1.125rem 1.125rem"
  }
};
var index$1o = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledHoverBackground: "{form.field.filled.hover.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  overlay: {
    background: "{overlay.select.background}",
    borderColor: "{overlay.select.border.color}",
    borderRadius: "{overlay.select.border.radius}",
    color: "{overlay.select.color}",
    shadow: "{overlay.select.shadow}"
  },
  list: {
    padding: "{list.padding}",
    gap: "{list.gap}"
  },
  option: {
    focusBackground: "{list.option.focus.background}",
    selectedBackground: "{list.option.selected.background}",
    selectedFocusBackground: "{list.option.selected.focus.background}",
    color: "{list.option.color}",
    focusColor: "{list.option.focus.color}",
    selectedColor: "{list.option.selected.color}",
    selectedFocusColor: "{list.option.selected.focus.color}",
    padding: "{list.option.padding}",
    borderRadius: "{list.option.border.radius}"
  },
  optionGroup: {
    background: "{list.option.group.background}",
    color: "{list.option.group.color}",
    fontWeight: "{list.option.group.font.weight}",
    padding: "{list.option.group.padding}"
  },
  dropdown: {
    width: "2.5rem",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.border.color}",
    activeBorderColor: "{form.field.border.color}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  chip: {
    borderRadius: "{border.radius.sm}"
  },
  emptyMessage: {
    padding: "{list.option.padding}"
  },
  colorScheme: {
    light: {
      chip: {
        focusBackground: "{surface.200}",
        color: "{surface.800}"
      },
      dropdown: {
        background: "{surface.100}",
        hoverBackground: "{surface.200}",
        activeBackground: "{surface.300}",
        color: "{surface.600}",
        hoverColor: "{surface.700}",
        activeColor: "{surface.800}"
      }
    },
    dark: {
      chip: {
        focusBackground: "{surface.700}",
        color: "{surface.0}"
      },
      dropdown: {
        background: "{surface.800}",
        hoverBackground: "{surface.700}",
        activeBackground: "{surface.600}",
        color: "{surface.300}",
        hoverColor: "{surface.200}",
        activeColor: "{surface.100}"
      }
    }
  }
};
var index$1n = {
  root: {
    width: "2rem",
    height: "2rem",
    fontSize: "1rem",
    background: "{content.border.color}",
    borderRadius: "{content.border.radius}"
  },
  group: {
    borderColor: "{content.background}",
    offset: "-1rem"
  },
  lg: {
    width: "3rem",
    height: "3rem",
    fontSize: "1.5rem"
  },
  xl: {
    width: "4rem",
    height: "4rem",
    fontSize: "2rem"
  }
};
var index$1m = {
  root: {
    borderRadius: "{border.radius.md}",
    padding: "0 0.5rem",
    fontSize: "0.75rem",
    fontWeight: "700",
    minWidth: "1.5rem",
    height: "1.5rem"
  },
  dot: {
    size: "0.5rem"
  },
  sm: {
    fontSize: "0.625rem",
    minWidth: "1.25rem",
    height: "1.25rem"
  },
  lg: {
    fontSize: "0.875rem",
    minWidth: "1.75rem",
    height: "1.75rem"
  },
  xl: {
    fontSize: "1rem",
    minWidth: "2rem",
    height: "2rem"
  },
  colorScheme: {
    light: {
      primary: {
        background: "{primary.color}",
        color: "{primary.contrast.color}"
      },
      secondary: {
        background: "{surface.100}",
        color: "{surface.600}"
      },
      success: {
        background: "{green.500}",
        color: "{surface.0}"
      },
      info: {
        background: "{sky.500}",
        color: "{surface.0}"
      },
      warn: {
        background: "{orange.500}",
        color: "{surface.0}"
      },
      danger: {
        background: "{red.500}",
        color: "{surface.0}"
      },
      contrast: {
        background: "{surface.950}",
        color: "{surface.0}"
      }
    },
    dark: {
      primary: {
        background: "{primary.color}",
        color: "{primary.contrast.color}"
      },
      secondary: {
        background: "{surface.800}",
        color: "{surface.300}"
      },
      success: {
        background: "{green.400}",
        color: "{green.950}"
      },
      info: {
        background: "{sky.400}",
        color: "{sky.950}"
      },
      warn: {
        background: "{orange.400}",
        color: "{orange.950}"
      },
      danger: {
        background: "{red.400}",
        color: "{red.950}"
      },
      contrast: {
        background: "{surface.0}",
        color: "{surface.950}"
      }
    }
  }
};
var index$1l = {
  primitive: {
    borderRadius: {
      none: "0",
      xs: "2px",
      sm: "4px",
      md: "6px",
      lg: "8px",
      xl: "12px"
    },
    emerald: {
      50: "#ecfdf5",
      100: "#d1fae5",
      200: "#a7f3d0",
      300: "#6ee7b7",
      400: "#34d399",
      500: "#10b981",
      600: "#059669",
      700: "#047857",
      800: "#065f46",
      900: "#064e3b",
      950: "#022c22"
    },
    green: {
      50: "#f0fdf4",
      100: "#dcfce7",
      200: "#bbf7d0",
      300: "#86efac",
      400: "#4ade80",
      500: "#22c55e",
      600: "#16a34a",
      700: "#15803d",
      800: "#166534",
      900: "#14532d",
      950: "#052e16"
    },
    lime: {
      50: "#f7fee7",
      100: "#ecfccb",
      200: "#d9f99d",
      300: "#bef264",
      400: "#a3e635",
      500: "#84cc16",
      600: "#65a30d",
      700: "#4d7c0f",
      800: "#3f6212",
      900: "#365314",
      950: "#1a2e05"
    },
    red: {
      50: "#fef2f2",
      100: "#fee2e2",
      200: "#fecaca",
      300: "#fca5a5",
      400: "#f87171",
      500: "#ef4444",
      600: "#dc2626",
      700: "#b91c1c",
      800: "#991b1b",
      900: "#7f1d1d",
      950: "#450a0a"
    },
    orange: {
      50: "#fff7ed",
      100: "#ffedd5",
      200: "#fed7aa",
      300: "#fdba74",
      400: "#fb923c",
      500: "#f97316",
      600: "#ea580c",
      700: "#c2410c",
      800: "#9a3412",
      900: "#7c2d12",
      950: "#431407"
    },
    amber: {
      50: "#fffbeb",
      100: "#fef3c7",
      200: "#fde68a",
      300: "#fcd34d",
      400: "#fbbf24",
      500: "#f59e0b",
      600: "#d97706",
      700: "#b45309",
      800: "#92400e",
      900: "#78350f",
      950: "#451a03"
    },
    yellow: {
      50: "#fefce8",
      100: "#fef9c3",
      200: "#fef08a",
      300: "#fde047",
      400: "#facc15",
      500: "#eab308",
      600: "#ca8a04",
      700: "#a16207",
      800: "#854d0e",
      900: "#713f12",
      950: "#422006"
    },
    teal: {
      50: "#f0fdfa",
      100: "#ccfbf1",
      200: "#99f6e4",
      300: "#5eead4",
      400: "#2dd4bf",
      500: "#14b8a6",
      600: "#0d9488",
      700: "#0f766e",
      800: "#115e59",
      900: "#134e4a",
      950: "#042f2e"
    },
    cyan: {
      50: "#ecfeff",
      100: "#cffafe",
      200: "#a5f3fc",
      300: "#67e8f9",
      400: "#22d3ee",
      500: "#06b6d4",
      600: "#0891b2",
      700: "#0e7490",
      800: "#155e75",
      900: "#164e63",
      950: "#083344"
    },
    sky: {
      50: "#f0f9ff",
      100: "#e0f2fe",
      200: "#bae6fd",
      300: "#7dd3fc",
      400: "#38bdf8",
      500: "#0ea5e9",
      600: "#0284c7",
      700: "#0369a1",
      800: "#075985",
      900: "#0c4a6e",
      950: "#082f49"
    },
    blue: {
      50: "#eff6ff",
      100: "#dbeafe",
      200: "#bfdbfe",
      300: "#93c5fd",
      400: "#60a5fa",
      500: "#3b82f6",
      600: "#2563eb",
      700: "#1d4ed8",
      800: "#1e40af",
      900: "#1e3a8a",
      950: "#172554"
    },
    indigo: {
      50: "#eef2ff",
      100: "#e0e7ff",
      200: "#c7d2fe",
      300: "#a5b4fc",
      400: "#818cf8",
      500: "#6366f1",
      600: "#4f46e5",
      700: "#4338ca",
      800: "#3730a3",
      900: "#312e81",
      950: "#1e1b4b"
    },
    violet: {
      50: "#f5f3ff",
      100: "#ede9fe",
      200: "#ddd6fe",
      300: "#c4b5fd",
      400: "#a78bfa",
      500: "#8b5cf6",
      600: "#7c3aed",
      700: "#6d28d9",
      800: "#5b21b6",
      900: "#4c1d95",
      950: "#2e1065"
    },
    purple: {
      50: "#faf5ff",
      100: "#f3e8ff",
      200: "#e9d5ff",
      300: "#d8b4fe",
      400: "#c084fc",
      500: "#a855f7",
      600: "#9333ea",
      700: "#7e22ce",
      800: "#6b21a8",
      900: "#581c87",
      950: "#3b0764"
    },
    fuchsia: {
      50: "#fdf4ff",
      100: "#fae8ff",
      200: "#f5d0fe",
      300: "#f0abfc",
      400: "#e879f9",
      500: "#d946ef",
      600: "#c026d3",
      700: "#a21caf",
      800: "#86198f",
      900: "#701a75",
      950: "#4a044e"
    },
    pink: {
      50: "#fdf2f8",
      100: "#fce7f3",
      200: "#fbcfe8",
      300: "#f9a8d4",
      400: "#f472b6",
      500: "#ec4899",
      600: "#db2777",
      700: "#be185d",
      800: "#9d174d",
      900: "#831843",
      950: "#500724"
    },
    rose: {
      50: "#fff1f2",
      100: "#ffe4e6",
      200: "#fecdd3",
      300: "#fda4af",
      400: "#fb7185",
      500: "#f43f5e",
      600: "#e11d48",
      700: "#be123c",
      800: "#9f1239",
      900: "#881337",
      950: "#4c0519"
    },
    slate: {
      50: "#f8fafc",
      100: "#f1f5f9",
      200: "#e2e8f0",
      300: "#cbd5e1",
      400: "#94a3b8",
      500: "#64748b",
      600: "#475569",
      700: "#334155",
      800: "#1e293b",
      900: "#0f172a",
      950: "#020617"
    },
    gray: {
      50: "#f9fafb",
      100: "#f3f4f6",
      200: "#e5e7eb",
      300: "#d1d5db",
      400: "#9ca3af",
      500: "#6b7280",
      600: "#4b5563",
      700: "#374151",
      800: "#1f2937",
      900: "#111827",
      950: "#030712"
    },
    zinc: {
      50: "#fafafa",
      100: "#f4f4f5",
      200: "#e4e4e7",
      300: "#d4d4d8",
      400: "#a1a1aa",
      500: "#71717a",
      600: "#52525b",
      700: "#3f3f46",
      800: "#27272a",
      900: "#18181b",
      950: "#09090b"
    },
    neutral: {
      50: "#fafafa",
      100: "#f5f5f5",
      200: "#e5e5e5",
      300: "#d4d4d4",
      400: "#a3a3a3",
      500: "#737373",
      600: "#525252",
      700: "#404040",
      800: "#262626",
      900: "#171717",
      950: "#0a0a0a"
    },
    stone: {
      50: "#fafaf9",
      100: "#f5f5f4",
      200: "#e7e5e4",
      300: "#d6d3d1",
      400: "#a8a29e",
      500: "#78716c",
      600: "#57534e",
      700: "#44403c",
      800: "#292524",
      900: "#1c1917",
      950: "#0c0a09"
    }
  },
  semantic: {
    transitionDuration: "0.2s",
    focusRing: {
      width: "1px",
      style: "solid",
      color: "{primary.color}",
      offset: "2px",
      shadow: "none"
    },
    disabledOpacity: "0.6",
    iconSize: "1rem",
    anchorGutter: "2px",
    primary: {
      50: "{emerald.50}",
      100: "{emerald.100}",
      200: "{emerald.200}",
      300: "{emerald.300}",
      400: "{emerald.400}",
      500: "{emerald.500}",
      600: "{emerald.600}",
      700: "{emerald.700}",
      800: "{emerald.800}",
      900: "{emerald.900}",
      950: "{emerald.950}"
    },
    formField: {
      paddingX: "0.75rem",
      paddingY: "0.5rem",
      borderRadius: "{border.radius.md}",
      focusRing: {
        width: "0",
        style: "none",
        color: "transparent",
        offset: "0",
        shadow: "none"
      },
      transitionDuration: "{transition.duration}"
    },
    list: {
      padding: "0.25rem 0.25rem",
      gap: "2px",
      header: {
        padding: "0.5rem 1rem 0.25rem 1rem"
      },
      option: {
        padding: "0.5rem 0.75rem",
        borderRadius: "{border.radius.sm}"
      },
      optionGroup: {
        padding: "0.5rem 0.75rem",
        fontWeight: "600"
      }
    },
    content: {
      borderRadius: "{border.radius.md}"
    },
    mask: {
      transitionDuration: "0.15s"
    },
    navigation: {
      list: {
        padding: "0.25rem 0.25rem",
        gap: "2px"
      },
      item: {
        padding: "0.5rem 0.75rem",
        borderRadius: "{border.radius.sm}",
        gap: "0.5rem"
      },
      submenuLabel: {
        padding: "0.5rem 0.75rem",
        fontWeight: "600"
      },
      submenuIcon: {
        size: "0.875rem"
      }
    },
    overlay: {
      select: {
        borderRadius: "{border.radius.md}",
        shadow: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1)"
      },
      popover: {
        borderRadius: "{border.radius.md}",
        padding: "0.75rem",
        shadow: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1)"
      },
      modal: {
        borderRadius: "{border.radius.xl}",
        padding: "1.25rem",
        shadow: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1)"
      },
      navigation: {
        shadow: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1)"
      }
    },
    colorScheme: {
      light: {
        surface: {
          0: "#ffffff",
          50: "{slate.50}",
          100: "{slate.100}",
          200: "{slate.200}",
          300: "{slate.300}",
          400: "{slate.400}",
          500: "{slate.500}",
          600: "{slate.600}",
          700: "{slate.700}",
          800: "{slate.800}",
          900: "{slate.900}",
          950: "{slate.950}"
        },
        primary: {
          color: "{primary.500}",
          contrastColor: "#ffffff",
          hoverColor: "{primary.600}",
          activeColor: "{primary.700}"
        },
        highlight: {
          background: "{primary.50}",
          focusBackground: "{primary.100}",
          color: "{primary.700}",
          focusColor: "{primary.800}"
        },
        mask: {
          background: "rgba(0,0,0,0.4)",
          color: "{surface.200}"
        },
        formField: {
          background: "{surface.0}",
          disabledBackground: "{surface.200}",
          filledBackground: "{surface.50}",
          filledHoverBackground: "{surface.50}",
          filledFocusBackground: "{surface.50}",
          borderColor: "{surface.300}",
          hoverBorderColor: "{surface.400}",
          focusBorderColor: "{primary.color}",
          invalidBorderColor: "{red.400}",
          color: "{surface.700}",
          disabledColor: "{surface.500}",
          placeholderColor: "{surface.500}",
          floatLabelColor: "{surface.500}",
          floatLabelFocusColor: "{primary.600}",
          floatLabelActiveColor: "{surface.500}",
          floatLabelInvalidColor: "{red.400}",
          iconColor: "{surface.400}",
          shadow: "0 0 #0000, 0 0 #0000, 0 1px 2px 0 rgba(18, 18, 23, 0.05)"
        },
        text: {
          color: "{surface.700}",
          hoverColor: "{surface.800}",
          mutedColor: "{surface.500}",
          hoverMutedColor: "{surface.600}"
        },
        content: {
          background: "{surface.0}",
          hoverBackground: "{surface.100}",
          borderColor: "{surface.200}",
          color: "{text.color}",
          hoverColor: "{text.hover.color}"
        },
        overlay: {
          select: {
            background: "{surface.0}",
            borderColor: "{surface.200}",
            color: "{text.color}"
          },
          popover: {
            background: "{surface.0}",
            borderColor: "{surface.200}",
            color: "{text.color}"
          },
          modal: {
            background: "{surface.0}",
            borderColor: "{surface.200}",
            color: "{text.color}"
          }
        },
        list: {
          option: {
            focusBackground: "{surface.100}",
            selectedBackground: "{highlight.background}",
            selectedFocusBackground: "{highlight.focus.background}",
            color: "{text.color}",
            focusColor: "{text.hover.color}",
            selectedColor: "{highlight.color}",
            selectedFocusColor: "{highlight.focus.color}",
            icon: {
              color: "{surface.400}",
              focusColor: "{surface.500}"
            }
          },
          optionGroup: {
            background: "transparent",
            color: "{text.muted.color}"
          }
        },
        navigation: {
          item: {
            focusBackground: "{surface.100}",
            activeBackground: "{surface.100}",
            color: "{text.color}",
            focusColor: "{text.hover.color}",
            activeColor: "{text.hover.color}",
            icon: {
              color: "{surface.400}",
              focusColor: "{surface.500}",
              activeColor: "{surface.500}"
            }
          },
          submenuLabel: {
            background: "transparent",
            color: "{text.muted.color}"
          },
          submenuIcon: {
            color: "{surface.400}",
            focusColor: "{surface.500}",
            activeColor: "{surface.500}"
          }
        }
      },
      dark: {
        surface: {
          0: "#ffffff",
          50: "{zinc.50}",
          100: "{zinc.100}",
          200: "{zinc.200}",
          300: "{zinc.300}",
          400: "{zinc.400}",
          500: "{zinc.500}",
          600: "{zinc.600}",
          700: "{zinc.700}",
          800: "{zinc.800}",
          900: "{zinc.900}",
          950: "{zinc.950}"
        },
        primary: {
          color: "{primary.400}",
          contrastColor: "{surface.900}",
          hoverColor: "{primary.300}",
          activeColor: "{primary.200}"
        },
        highlight: {
          background: "color-mix(in srgb, {primary.400}, transparent 84%)",
          focusBackground: "color-mix(in srgb, {primary.400}, transparent 76%)",
          color: "rgba(255,255,255,.87)",
          focusColor: "rgba(255,255,255,.87)"
        },
        mask: {
          background: "rgba(0,0,0,0.6)",
          color: "{surface.200}"
        },
        formField: {
          background: "{surface.950}",
          disabledBackground: "{surface.700}",
          filledBackground: "{surface.800}",
          filledHoverBackground: "{surface.800}",
          filledFocusBackground: "{surface.800}",
          borderColor: "{surface.700}",
          hoverBorderColor: "{surface.600}",
          focusBorderColor: "{primary.color}",
          invalidBorderColor: "{red.300}",
          color: "{surface.0}",
          disabledColor: "{surface.400}",
          placeholderColor: "{surface.400}",
          floatLabelColor: "{surface.400}",
          floatLabelFocusColor: "{primary.color}",
          floatLabelActiveColor: "{surface.400}",
          floatLabelInvalidColor: "{red.300}",
          iconColor: "{surface.400}",
          shadow: "0 0 #0000, 0 0 #0000, 0 1px 2px 0 rgba(18, 18, 23, 0.05)"
        },
        text: {
          color: "{surface.0}",
          hoverColor: "{surface.0}",
          mutedColor: "{surface.400}",
          hoverMutedColor: "{surface.300}"
        },
        content: {
          background: "{surface.900}",
          hoverBackground: "{surface.800}",
          borderColor: "{surface.700}",
          color: "{text.color}",
          hoverColor: "{text.hover.color}"
        },
        overlay: {
          select: {
            background: "{surface.900}",
            borderColor: "{surface.700}",
            color: "{text.color}"
          },
          popover: {
            background: "{surface.900}",
            borderColor: "{surface.700}",
            color: "{text.color}"
          },
          modal: {
            background: "{surface.900}",
            borderColor: "{surface.700}",
            color: "{text.color}"
          }
        },
        list: {
          option: {
            focusBackground: "{surface.800}",
            selectedBackground: "{highlight.background}",
            selectedFocusBackground: "{highlight.focus.background}",
            color: "{text.color}",
            focusColor: "{text.hover.color}",
            selectedColor: "{highlight.color}",
            selectedFocusColor: "{highlight.focus.color}",
            icon: {
              color: "{surface.500}",
              focusColor: "{surface.400}"
            }
          },
          optionGroup: {
            background: "transparent",
            color: "{text.muted.color}"
          }
        },
        navigation: {
          item: {
            focusBackground: "{surface.800}",
            activeBackground: "{surface.800}",
            color: "{text.color}",
            focusColor: "{text.hover.color}",
            activeColor: "{text.hover.color}",
            icon: {
              color: "{surface.500}",
              focusColor: "{surface.400}",
              activeColor: "{surface.400}"
            }
          },
          submenuLabel: {
            background: "transparent",
            color: "{text.muted.color}"
          },
          submenuIcon: {
            color: "{surface.500}",
            focusColor: "{surface.400}",
            activeColor: "{surface.400}"
          }
        }
      }
    }
  }
};
var index$1k = {
  root: {
    borderRadius: "{content.border.radius}"
  }
};
var index$1j = {
  root: {
    padding: "1rem",
    background: "{content.background}",
    gap: "0.5rem",
    transitionDuration: "{transition.duration}"
  },
  item: {
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    borderRadius: "{content.border.radius}",
    gap: "{navigation.item.gap}",
    icon: {
      color: "{navigation.item.icon.color}",
      hoverColor: "{navigation.item.icon.focus.color}"
    },
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  separator: {
    color: "{navigation.item.icon.color}"
  }
};
var index$1i = {
  root: {
    borderRadius: "{form.field.border.radius}",
    roundedBorderRadius: "2rem",
    gap: "0.5rem",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    iconOnlyWidth: "2.5rem",
    sm: {
      fontSize: "0.875rem",
      paddingX: "0.625rem",
      paddingY: "0.375rem"
    },
    lg: {
      fontSize: "1.125rem",
      paddingX: "0.875rem",
      paddingY: "0.625rem"
    },
    label: {
      fontWeight: "500"
    },
    raisedShadow: "0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      offset: "{focus.ring.offset}"
    },
    badgeSize: "1rem",
    transitionDuration: "{form.field.transition.duration}"
  },
  colorScheme: {
    light: {
      root: {
        primary: {
          background: "{primary.color}",
          hoverBackground: "{primary.hover.color}",
          activeBackground: "{primary.active.color}",
          borderColor: "{primary.color}",
          hoverBorderColor: "{primary.hover.color}",
          activeBorderColor: "{primary.active.color}",
          color: "{primary.contrast.color}",
          hoverColor: "{primary.contrast.color}",
          activeColor: "{primary.contrast.color}",
          focusRing: {
            color: "{primary.color}",
            shadow: "none"
          }
        },
        secondary: {
          background: "{surface.100}",
          hoverBackground: "{surface.200}",
          activeBackground: "{surface.300}",
          borderColor: "{surface.100}",
          hoverBorderColor: "{surface.200}",
          activeBorderColor: "{surface.300}",
          color: "{surface.600}",
          hoverColor: "{surface.700}",
          activeColor: "{surface.800}",
          focusRing: {
            color: "{surface.600}",
            shadow: "none"
          }
        },
        info: {
          background: "{sky.500}",
          hoverBackground: "{sky.600}",
          activeBackground: "{sky.700}",
          borderColor: "{sky.500}",
          hoverBorderColor: "{sky.600}",
          activeBorderColor: "{sky.700}",
          color: "#ffffff",
          hoverColor: "#ffffff",
          activeColor: "#ffffff",
          focusRing: {
            color: "{sky.500}",
            shadow: "none"
          }
        },
        success: {
          background: "{green.500}",
          hoverBackground: "{green.600}",
          activeBackground: "{green.700}",
          borderColor: "{green.500}",
          hoverBorderColor: "{green.600}",
          activeBorderColor: "{green.700}",
          color: "#ffffff",
          hoverColor: "#ffffff",
          activeColor: "#ffffff",
          focusRing: {
            color: "{green.500}",
            shadow: "none"
          }
        },
        warn: {
          background: "{orange.500}",
          hoverBackground: "{orange.600}",
          activeBackground: "{orange.700}",
          borderColor: "{orange.500}",
          hoverBorderColor: "{orange.600}",
          activeBorderColor: "{orange.700}",
          color: "#ffffff",
          hoverColor: "#ffffff",
          activeColor: "#ffffff",
          focusRing: {
            color: "{orange.500}",
            shadow: "none"
          }
        },
        help: {
          background: "{purple.500}",
          hoverBackground: "{purple.600}",
          activeBackground: "{purple.700}",
          borderColor: "{purple.500}",
          hoverBorderColor: "{purple.600}",
          activeBorderColor: "{purple.700}",
          color: "#ffffff",
          hoverColor: "#ffffff",
          activeColor: "#ffffff",
          focusRing: {
            color: "{purple.500}",
            shadow: "none"
          }
        },
        danger: {
          background: "{red.500}",
          hoverBackground: "{red.600}",
          activeBackground: "{red.700}",
          borderColor: "{red.500}",
          hoverBorderColor: "{red.600}",
          activeBorderColor: "{red.700}",
          color: "#ffffff",
          hoverColor: "#ffffff",
          activeColor: "#ffffff",
          focusRing: {
            color: "{red.500}",
            shadow: "none"
          }
        },
        contrast: {
          background: "{surface.950}",
          hoverBackground: "{surface.900}",
          activeBackground: "{surface.800}",
          borderColor: "{surface.950}",
          hoverBorderColor: "{surface.900}",
          activeBorderColor: "{surface.800}",
          color: "{surface.0}",
          hoverColor: "{surface.0}",
          activeColor: "{surface.0}",
          focusRing: {
            color: "{surface.950}",
            shadow: "none"
          }
        }
      },
      outlined: {
        primary: {
          hoverBackground: "{primary.50}",
          activeBackground: "{primary.100}",
          borderColor: "{primary.200}",
          color: "{primary.color}"
        },
        secondary: {
          hoverBackground: "{surface.50}",
          activeBackground: "{surface.100}",
          borderColor: "{surface.200}",
          color: "{surface.500}"
        },
        success: {
          hoverBackground: "{green.50}",
          activeBackground: "{green.100}",
          borderColor: "{green.200}",
          color: "{green.500}"
        },
        info: {
          hoverBackground: "{sky.50}",
          activeBackground: "{sky.100}",
          borderColor: "{sky.200}",
          color: "{sky.500}"
        },
        warn: {
          hoverBackground: "{orange.50}",
          activeBackground: "{orange.100}",
          borderColor: "{orange.200}",
          color: "{orange.500}"
        },
        help: {
          hoverBackground: "{purple.50}",
          activeBackground: "{purple.100}",
          borderColor: "{purple.200}",
          color: "{purple.500}"
        },
        danger: {
          hoverBackground: "{red.50}",
          activeBackground: "{red.100}",
          borderColor: "{red.200}",
          color: "{red.500}"
        },
        contrast: {
          hoverBackground: "{surface.50}",
          activeBackground: "{surface.100}",
          borderColor: "{surface.700}",
          color: "{surface.950}"
        },
        plain: {
          hoverBackground: "{surface.50}",
          activeBackground: "{surface.100}",
          borderColor: "{surface.200}",
          color: "{surface.700}"
        }
      },
      text: {
        primary: {
          hoverBackground: "{primary.50}",
          activeBackground: "{primary.100}",
          color: "{primary.color}"
        },
        secondary: {
          hoverBackground: "{surface.50}",
          activeBackground: "{surface.100}",
          color: "{surface.500}"
        },
        success: {
          hoverBackground: "{green.50}",
          activeBackground: "{green.100}",
          color: "{green.500}"
        },
        info: {
          hoverBackground: "{sky.50}",
          activeBackground: "{sky.100}",
          color: "{sky.500}"
        },
        warn: {
          hoverBackground: "{orange.50}",
          activeBackground: "{orange.100}",
          color: "{orange.500}"
        },
        help: {
          hoverBackground: "{purple.50}",
          activeBackground: "{purple.100}",
          color: "{purple.500}"
        },
        danger: {
          hoverBackground: "{red.50}",
          activeBackground: "{red.100}",
          color: "{red.500}"
        },
        plain: {
          hoverBackground: "{surface.50}",
          activeBackground: "{surface.100}",
          color: "{surface.700}"
        }
      },
      link: {
        color: "{primary.color}",
        hoverColor: "{primary.color}",
        activeColor: "{primary.color}"
      }
    },
    dark: {
      root: {
        primary: {
          background: "{primary.color}",
          hoverBackground: "{primary.hover.color}",
          activeBackground: "{primary.active.color}",
          borderColor: "{primary.color}",
          hoverBorderColor: "{primary.hover.color}",
          activeBorderColor: "{primary.active.color}",
          color: "{primary.contrast.color}",
          hoverColor: "{primary.contrast.color}",
          activeColor: "{primary.contrast.color}",
          focusRing: {
            color: "{primary.color}",
            shadow: "none"
          }
        },
        secondary: {
          background: "{surface.800}",
          hoverBackground: "{surface.700}",
          activeBackground: "{surface.600}",
          borderColor: "{surface.800}",
          hoverBorderColor: "{surface.700}",
          activeBorderColor: "{surface.600}",
          color: "{surface.300}",
          hoverColor: "{surface.200}",
          activeColor: "{surface.100}",
          focusRing: {
            color: "{surface.300}",
            shadow: "none"
          }
        },
        info: {
          background: "{sky.400}",
          hoverBackground: "{sky.300}",
          activeBackground: "{sky.200}",
          borderColor: "{sky.400}",
          hoverBorderColor: "{sky.300}",
          activeBorderColor: "{sky.200}",
          color: "{sky.950}",
          hoverColor: "{sky.950}",
          activeColor: "{sky.950}",
          focusRing: {
            color: "{sky.400}",
            shadow: "none"
          }
        },
        success: {
          background: "{green.400}",
          hoverBackground: "{green.300}",
          activeBackground: "{green.200}",
          borderColor: "{green.400}",
          hoverBorderColor: "{green.300}",
          activeBorderColor: "{green.200}",
          color: "{green.950}",
          hoverColor: "{green.950}",
          activeColor: "{green.950}",
          focusRing: {
            color: "{green.400}",
            shadow: "none"
          }
        },
        warn: {
          background: "{orange.400}",
          hoverBackground: "{orange.300}",
          activeBackground: "{orange.200}",
          borderColor: "{orange.400}",
          hoverBorderColor: "{orange.300}",
          activeBorderColor: "{orange.200}",
          color: "{orange.950}",
          hoverColor: "{orange.950}",
          activeColor: "{orange.950}",
          focusRing: {
            color: "{orange.400}",
            shadow: "none"
          }
        },
        help: {
          background: "{purple.400}",
          hoverBackground: "{purple.300}",
          activeBackground: "{purple.200}",
          borderColor: "{purple.400}",
          hoverBorderColor: "{purple.300}",
          activeBorderColor: "{purple.200}",
          color: "{purple.950}",
          hoverColor: "{purple.950}",
          activeColor: "{purple.950}",
          focusRing: {
            color: "{purple.400}",
            shadow: "none"
          }
        },
        danger: {
          background: "{red.400}",
          hoverBackground: "{red.300}",
          activeBackground: "{red.200}",
          borderColor: "{red.400}",
          hoverBorderColor: "{red.300}",
          activeBorderColor: "{red.200}",
          color: "{red.950}",
          hoverColor: "{red.950}",
          activeColor: "{red.950}",
          focusRing: {
            color: "{red.400}",
            shadow: "none"
          }
        },
        contrast: {
          background: "{surface.0}",
          hoverBackground: "{surface.100}",
          activeBackground: "{surface.200}",
          borderColor: "{surface.0}",
          hoverBorderColor: "{surface.100}",
          activeBorderColor: "{surface.200}",
          color: "{surface.950}",
          hoverColor: "{surface.950}",
          activeColor: "{surface.950}",
          focusRing: {
            color: "{surface.0}",
            shadow: "none"
          }
        }
      },
      outlined: {
        primary: {
          hoverBackground: "color-mix(in srgb, {primary.color}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {primary.color}, transparent 84%)",
          borderColor: "{primary.700}",
          color: "{primary.color}"
        },
        secondary: {
          hoverBackground: "rgba(255,255,255,0.04)",
          activeBackground: "rgba(255,255,255,0.16)",
          borderColor: "{surface.700}",
          color: "{surface.400}"
        },
        success: {
          hoverBackground: "color-mix(in srgb, {green.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {green.400}, transparent 84%)",
          borderColor: "{green.700}",
          color: "{green.400}"
        },
        info: {
          hoverBackground: "color-mix(in srgb, {sky.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {sky.400}, transparent 84%)",
          borderColor: "{sky.700}",
          color: "{sky.400}"
        },
        warn: {
          hoverBackground: "color-mix(in srgb, {orange.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {orange.400}, transparent 84%)",
          borderColor: "{orange.700}",
          color: "{orange.400}"
        },
        help: {
          hoverBackground: "color-mix(in srgb, {purple.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {purple.400}, transparent 84%)",
          borderColor: "{purple.700}",
          color: "{purple.400}"
        },
        danger: {
          hoverBackground: "color-mix(in srgb, {red.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {red.400}, transparent 84%)",
          borderColor: "{red.700}",
          color: "{red.400}"
        },
        contrast: {
          hoverBackground: "{surface.800}",
          activeBackground: "{surface.700}",
          borderColor: "{surface.500}",
          color: "{surface.0}"
        },
        plain: {
          hoverBackground: "{surface.800}",
          activeBackground: "{surface.700}",
          borderColor: "{surface.600}",
          color: "{surface.0}"
        }
      },
      text: {
        primary: {
          hoverBackground: "color-mix(in srgb, {primary.color}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {primary.color}, transparent 84%)",
          color: "{primary.color}"
        },
        secondary: {
          hoverBackground: "{surface.800}",
          activeBackground: "{surface.700}",
          color: "{surface.400}"
        },
        success: {
          hoverBackground: "color-mix(in srgb, {green.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {green.400}, transparent 84%)",
          color: "{green.400}"
        },
        info: {
          hoverBackground: "color-mix(in srgb, {sky.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {sky.400}, transparent 84%)",
          color: "{sky.400}"
        },
        warn: {
          hoverBackground: "color-mix(in srgb, {orange.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {orange.400}, transparent 84%)",
          color: "{orange.400}"
        },
        help: {
          hoverBackground: "color-mix(in srgb, {purple.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {purple.400}, transparent 84%)",
          color: "{purple.400}"
        },
        danger: {
          hoverBackground: "color-mix(in srgb, {red.400}, transparent 96%)",
          activeBackground: "color-mix(in srgb, {red.400}, transparent 84%)",
          color: "{red.400}"
        },
        plain: {
          hoverBackground: "{surface.800}",
          activeBackground: "{surface.700}",
          color: "{surface.0}"
        }
      },
      link: {
        color: "{primary.color}",
        hoverColor: "{primary.color}",
        activeColor: "{primary.color}"
      }
    }
  }
};
var index$1h = {
  root: {
    background: "{content.background}",
    borderRadius: "{border.radius.xl}",
    color: "{content.color}",
    shadow: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1)"
  },
  body: {
    padding: "1.25rem",
    gap: "0.5rem"
  },
  caption: {
    gap: "0.5rem"
  },
  title: {
    fontSize: "1.25rem",
    fontWeight: "500"
  },
  subtitle: {
    color: "{text.muted.color}"
  }
};
var index$1g = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  content: {
    gap: "0.25rem"
  },
  indicatorList: {
    padding: "1rem",
    gap: "0.5rem"
  },
  indicator: {
    width: "2rem",
    height: "0.5rem",
    borderRadius: "{content.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  colorScheme: {
    light: {
      indicator: {
        background: "{surface.200}",
        hoverBackground: "{surface.300}",
        activeBackground: "{primary.color}"
      }
    },
    dark: {
      indicator: {
        background: "{surface.700}",
        hoverBackground: "{surface.600}",
        activeBackground: "{primary.color}"
      }
    }
  }
};
var index$1f = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledHoverBackground: "{form.field.filled.hover.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  dropdown: {
    width: "2.5rem",
    color: "{form.field.icon.color}"
  },
  overlay: {
    background: "{overlay.select.background}",
    borderColor: "{overlay.select.border.color}",
    borderRadius: "{overlay.select.border.radius}",
    color: "{overlay.select.color}",
    shadow: "{overlay.select.shadow}"
  },
  list: {
    padding: "{list.padding}",
    gap: "{list.gap}",
    mobileIndent: "1rem"
  },
  option: {
    focusBackground: "{list.option.focus.background}",
    selectedBackground: "{list.option.selected.background}",
    selectedFocusBackground: "{list.option.selected.focus.background}",
    color: "{list.option.color}",
    focusColor: "{list.option.focus.color}",
    selectedColor: "{list.option.selected.color}",
    selectedFocusColor: "{list.option.selected.focus.color}",
    padding: "{list.option.padding}",
    borderRadius: "{list.option.border.radius}",
    icon: {
      color: "{list.option.icon.color}",
      focusColor: "{list.option.icon.focus.color}",
      size: "0.875rem"
    }
  }
};
var index$1e = {
  root: {
    borderRadius: "{border.radius.sm}",
    width: "1.25rem",
    height: "1.25rem",
    background: "{form.field.background}",
    checkedBackground: "{primary.color}",
    checkedHoverBackground: "{primary.hover.color}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.border.color}",
    checkedBorderColor: "{primary.color}",
    checkedHoverBorderColor: "{primary.hover.color}",
    checkedFocusBorderColor: "{primary.color}",
    checkedDisabledBorderColor: "{form.field.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    shadow: "{form.field.shadow}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  icon: {
    size: "0.875rem",
    color: "{form.field.color}",
    checkedColor: "{primary.contrast.color}",
    checkedHoverColor: "{primary.contrast.color}",
    disabledColor: "{form.field.disabled.color}"
  }
};
var index$1d = {
  root: {
    borderRadius: "16px",
    paddingX: "0.75rem",
    paddingY: "0.5rem",
    gap: "0.5rem",
    transitionDuration: "{transition.duration}"
  },
  image: {
    width: "2rem",
    height: "2rem"
  },
  icon: {
    size: "1rem"
  },
  removeIcon: {
    size: "1rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    }
  },
  colorScheme: {
    light: {
      root: {
        background: "{surface.100}",
        color: "{surface.800}"
      },
      icon: {
        color: "{surface.800}"
      },
      removeIcon: {
        color: "{surface.800}"
      }
    },
    dark: {
      root: {
        background: "{surface.800}",
        color: "{surface.0}"
      },
      icon: {
        color: "{surface.0}"
      },
      removeIcon: {
        color: "{surface.0}"
      }
    }
  }
};
var index$1c = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  preview: {
    width: "1.5rem",
    height: "1.5rem",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  panel: {
    shadow: "{overlay.popover.shadow}",
    borderRadius: "{overlay.popover.borderRadius}"
  },
  colorScheme: {
    light: {
      panel: {
        background: "{surface.800}",
        borderColor: "{surface.900}"
      },
      handle: {
        color: "{surface.0}"
      }
    },
    dark: {
      panel: {
        background: "{surface.900}",
        borderColor: "{surface.700}"
      },
      handle: {
        color: "{surface.0}"
      }
    }
  }
};
var index$1b = {
  icon: {
    size: "2rem",
    color: "{overlay.modal.color}"
  },
  content: {
    gap: "1rem"
  }
};
var index$1a = {
  root: {
    background: "{overlay.popover.background}",
    borderColor: "{overlay.popover.border.color}",
    color: "{overlay.popover.color}",
    borderRadius: "{overlay.popover.border.radius}",
    shadow: "{overlay.popover.shadow}",
    gutter: "10px",
    arrowOffset: "1.25rem"
  },
  content: {
    padding: "{overlay.popover.padding}",
    gap: "1rem"
  },
  icon: {
    size: "1.5rem",
    color: "{overlay.popover.color}"
  },
  footer: {
    gap: "0.5rem",
    padding: "0 {overlay.popover.padding} {overlay.popover.padding} {overlay.popover.padding}"
  }
};
var index$19 = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}",
    shadow: "{overlay.navigation.shadow}",
    transitionDuration: "{transition.duration}"
  },
  list: {
    padding: "{navigation.list.padding}",
    gap: "{navigation.list.gap}"
  },
  item: {
    focusBackground: "{navigation.item.focus.background}",
    activeBackground: "{navigation.item.active.background}",
    color: "{navigation.item.color}",
    focusColor: "{navigation.item.focus.color}",
    activeColor: "{navigation.item.active.color}",
    padding: "{navigation.item.padding}",
    borderRadius: "{navigation.item.border.radius}",
    gap: "{navigation.item.gap}",
    icon: {
      color: "{navigation.item.icon.color}",
      focusColor: "{navigation.item.icon.focus.color}",
      activeColor: "{navigation.item.icon.active.color}"
    }
  },
  submenu: {
    mobileIndent: "1rem"
  },
  submenuIcon: {
    size: "{navigation.submenu.icon.size}",
    color: "{navigation.submenu.icon.color}",
    focusColor: "{navigation.submenu.icon.focus.color}",
    activeColor: "{navigation.submenu.icon.active.color}"
  },
  separator: {
    borderColor: "{content.border.color}"
  }
};
var index$18 = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  header: {
    background: "{content.background}",
    borderColor: "{datatable.border.color}",
    color: "{content.color}",
    borderWidth: "0 0 1px 0",
    padding: "0.75rem 1rem"
  },
  headerCell: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    borderColor: "{datatable.border.color}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    selectedColor: "{highlight.color}",
    gap: "0.5rem",
    padding: "0.75rem 1rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    }
  },
  columnTitle: {
    fontWeight: "600"
  },
  row: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    selectedColor: "{highlight.color}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    }
  },
  bodyCell: {
    borderColor: "{datatable.border.color}",
    padding: "0.75rem 1rem"
  },
  footerCell: {
    background: "{content.background}",
    borderColor: "{datatable.border.color}",
    color: "{content.color}",
    padding: "0.75rem 1rem"
  },
  columnFooter: {
    fontWeight: "600"
  },
  footer: {
    background: "{content.background}",
    borderColor: "{datatable.border.color}",
    color: "{content.color}",
    borderWidth: "0 0 1px 0",
    padding: "0.75rem 1rem"
  },
  dropPoint: {
    color: "{primary.color}"
  },
  columnResizerWidth: "0.5rem",
  resizeIndicator: {
    width: "1px",
    color: "{primary.color}"
  },
  sortIcon: {
    color: "{text.muted.color}",
    hoverColor: "{text.hover.muted.color}",
    size: "0.875rem"
  },
  loadingIcon: {
    size: "2rem"
  },
  rowToggleButton: {
    hoverBackground: "{content.hover.background}",
    selectedHoverBackground: "{content.background}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    selectedHoverColor: "{primary.color}",
    size: "1.75rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  filter: {
    inlineGap: "0.5rem",
    overlaySelect: {
      background: "{overlay.select.background}",
      borderColor: "{overlay.select.border.color}",
      borderRadius: "{overlay.select.border.radius}",
      color: "{overlay.select.color}",
      shadow: "{overlay.select.shadow}"
    },
    overlayPopover: {
      background: "{overlay.popover.background}",
      borderColor: "{overlay.popover.border.color}",
      borderRadius: "{overlay.popover.border.radius}",
      color: "{overlay.popover.color}",
      shadow: "{overlay.popover.shadow}",
      padding: "{overlay.popover.padding}",
      gap: "0.5rem"
    },
    rule: {
      borderColor: "{content.border.color}"
    },
    constraintList: {
      padding: "{list.padding}",
      gap: "{list.gap}"
    },
    constraint: {
      focusBackground: "{list.option.focus.background}",
      selectedBackground: "{list.option.selected.background}",
      selectedFocusBackground: "{list.option.selected.focus.background}",
      color: "{list.option.color}",
      focusColor: "{list.option.focus.color}",
      selectedColor: "{list.option.selected.color}",
      selectedFocusColor: "{list.option.selected.focus.color}",
      separator: {
        borderColor: "{content.border.color}"
      },
      padding: "{list.option.padding}",
      borderRadius: "{list.option.border.radius}"
    }
  },
  paginatorTop: {
    borderColor: "{datatable.border.color}",
    borderWidth: "0 0 1px 0"
  },
  paginatorBottom: {
    borderColor: "{datatable.border.color}",
    borderWidth: "0 0 1px 0"
  },
  colorScheme: {
    light: {
      root: {
        borderColor: "{content.border.color}"
      },
      row: {
        stripedBackground: "{surface.50}"
      },
      bodyCell: {
        selectedBorderColor: "{primary.100}"
      }
    },
    dark: {
      root: {
        borderColor: "{surface.800}"
      },
      row: {
        stripedBackground: "{surface.950}"
      },
      bodyCell: {
        selectedBorderColor: "{primary.900}"
      }
    }
  }
};
var index$17 = {
  root: {
    borderColor: "transparent",
    borderWidth: "0",
    borderRadius: "0",
    padding: "0"
  },
  header: {
    background: "{content.background}",
    color: "{content.color}",
    borderColor: "{content.border.color}",
    borderWidth: "0 0 1px 0",
    padding: "0.75rem 1rem",
    borderRadius: "0"
  },
  content: {
    background: "{content.background}",
    color: "{content.color}",
    borderColor: "transparent",
    borderWidth: "0",
    padding: "0",
    borderRadius: "0"
  },
  footer: {
    background: "{content.background}",
    color: "{content.color}",
    borderColor: "{content.border.color}",
    borderWidth: "1px 0 0 0",
    padding: "0.75rem 1rem",
    borderRadius: "0"
  },
  paginatorTop: {
    borderColor: "{content.border.color}",
    borderWidth: "0 0 1px 0"
  },
  paginatorBottom: {
    borderColor: "{content.border.color}",
    borderWidth: "1px 0 0 0"
  }
};
var index$16 = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  panel: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}",
    shadow: "{overlay.popover.shadow}",
    padding: "{overlay.popover.padding}"
  },
  header: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    padding: "0 0 0.5rem 0",
    fontWeight: "500",
    gap: "0.5rem"
  },
  title: {
    gap: "0.5rem",
    fontWeight: "500"
  },
  dropdown: {
    width: "2.5rem",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.border.color}",
    activeBorderColor: "{form.field.border.color}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  inputIcon: {
    color: "{form.field.icon.color}"
  },
  selectMonth: {
    hoverBackground: "{content.hover.background}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    padding: "0.25rem 0.5rem",
    borderRadius: "{content.border.radius}"
  },
  selectYear: {
    hoverBackground: "{content.hover.background}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    padding: "0.25rem 0.5rem",
    borderRadius: "{content.border.radius}"
  },
  group: {
    borderColor: "{content.border.color}",
    gap: "{overlay.popover.padding}"
  },
  dayView: {
    margin: "0.5rem 0 0 0"
  },
  weekDay: {
    padding: "0.25rem",
    fontWeight: "500",
    color: "{content.color}"
  },
  date: {
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{primary.color}",
    rangeSelectedBackground: "{highlight.background}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    selectedColor: "{primary.contrast.color}",
    rangeSelectedColor: "{highlight.color}",
    width: "2rem",
    height: "2rem",
    borderRadius: "50%",
    padding: "0.25rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  monthView: {
    margin: "0.5rem 0 0 0"
  },
  month: {
    padding: "0.375rem",
    borderRadius: "{content.border.radius}"
  },
  yearView: {
    margin: "0.5rem 0 0 0"
  },
  year: {
    padding: "0.375rem",
    borderRadius: "{content.border.radius}"
  },
  buttonbar: {
    padding: "0.5rem 0 0 0",
    borderColor: "{content.border.color}"
  },
  timePicker: {
    padding: "0.5rem 0 0 0",
    borderColor: "{content.border.color}",
    gap: "0.5rem",
    buttonGap: "0.25rem"
  },
  colorScheme: {
    light: {
      dropdown: {
        background: "{surface.100}",
        hoverBackground: "{surface.200}",
        activeBackground: "{surface.300}",
        color: "{surface.600}",
        hoverColor: "{surface.700}",
        activeColor: "{surface.800}"
      },
      today: {
        background: "{surface.200}",
        color: "{surface.900}"
      }
    },
    dark: {
      dropdown: {
        background: "{surface.800}",
        hoverBackground: "{surface.700}",
        activeBackground: "{surface.600}",
        color: "{surface.300}",
        hoverColor: "{surface.200}",
        activeColor: "{surface.100}"
      },
      today: {
        background: "{surface.700}",
        color: "{surface.0}"
      }
    }
  }
};
var index$15 = {
  root: {
    background: "{overlay.modal.background}",
    borderColor: "{overlay.modal.border.color}",
    color: "{overlay.modal.color}",
    borderRadius: "{overlay.modal.border.radius}",
    shadow: "{overlay.modal.shadow}"
  },
  header: {
    padding: "{overlay.modal.padding}",
    gap: "0.5rem"
  },
  title: {
    fontSize: "1.25rem",
    fontWeight: "600"
  },
  content: {
    padding: "0 {overlay.modal.padding} {overlay.modal.padding} {overlay.modal.padding}"
  },
  footer: {
    padding: "0 {overlay.modal.padding} {overlay.modal.padding} {overlay.modal.padding}",
    gap: "0.5rem"
  }
};
var index$14 = {
  root: {
    borderColor: "{content.border.color}"
  },
  content: {
    background: "{content.background}",
    color: "{text.color}"
  },
  horizontal: {
    margin: "1rem 0",
    padding: "0 1rem",
    content: {
      padding: "0 0.5rem"
    }
  },
  vertical: {
    margin: "0 1rem",
    padding: "0.5rem 0",
    content: {
      padding: "0.5rem 0"
    }
  }
};
var index$13 = {
  root: {
    background: "rgba(255, 255, 255, 0.1)",
    borderColor: "rgba(255, 255, 255, 0.2)",
    padding: "0.5rem",
    borderRadius: "{border.radius.xl}"
  },
  item: {
    borderRadius: "{content.border.radius}",
    padding: "0.5rem",
    size: "3rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  }
};
var index$12 = {
  root: {
    background: "{overlay.modal.background}",
    borderColor: "{overlay.modal.border.color}",
    color: "{overlay.modal.color}",
    borderRadius: "{overlay.modal.border.radius}",
    shadow: "{overlay.modal.shadow}"
  },
  header: {
    padding: "{overlay.modal.padding}"
  },
  title: {
    fontSize: "1.5rem",
    fontWeight: "600"
  },
  content: {
    padding: "0 {overlay.modal.padding} {overlay.modal.padding} {overlay.modal.padding}"
  }
};
var index$11 = {
  toolbar: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}"
  },
  toolbarItem: {
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    activeColor: "{primary.color}"
  },
  overlay: {
    background: "{overlay.select.background}",
    borderColor: "{overlay.select.border.color}",
    borderRadius: "{overlay.select.border.radius}",
    color: "{overlay.select.color}",
    shadow: "{overlay.select.shadow}",
    padding: "{list.padding}"
  },
  overlayOption: {
    focusBackground: "{list.option.focus.background}",
    color: "{list.option.color}",
    focusColor: "{list.option.focus.color}",
    padding: "{list.option.padding}",
    borderRadius: "{list.option.border.radius}"
  },
  content: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}"
  }
};
var index$10 = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    color: "{content.color}",
    padding: "0 1.125rem 1.125rem 1.125rem",
    transitionDuration: "{transition.duration}"
  },
  legend: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    borderRadius: "{content.border.radius}",
    borderWidth: "1px",
    borderColor: "transparent",
    padding: "0.5rem 0.75rem",
    gap: "0.5rem",
    fontWeight: "600",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  toggleIcon: {
    color: "{text.muted.color}",
    hoverColor: "{text.hover.muted.color}"
  },
  content: {
    padding: "0"
  }
};
var index$$ = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}",
    transitionDuration: "{transition.duration}"
  },
  header: {
    background: "transparent",
    color: "{text.color}",
    padding: "1.125rem",
    borderWidth: "0",
    borderRadius: "0",
    gap: "0.5rem"
  },
  content: {
    highlightBorderColor: "{primary.color}",
    padding: "0 1.125rem 1.125rem 1.125rem"
  },
  file: {
    padding: "1rem",
    gap: "1rem",
    borderColor: "{content.border.color}",
    info: {
      gap: "0.5rem"
    }
  },
  progressbar: {
    height: "0.25rem"
  },
  basic: {
    gap: "0.5rem"
  }
};
var index$_ = {
  root: {
    color: "{form.field.float.label.color}",
    focusColor: "{form.field.float.label.focus.color}",
    activeColor: "{form.field.float.label.active.color}",
    invalidColor: "{form.field.float.label.invalid.color}",
    transitionDuration: "0.2s",
    positionX: "{form.field.padding.x}",
    positionY: "{form.field.padding.y}",
    fontWeight: "500",
    active: {
      fontSize: "0.75rem",
      fontWeight: "400"
    }
  },
  over: {
    active: {
      top: "-1.25rem"
    }
  },
  "in": {
    input: {
      paddingTop: "1.5rem",
      paddingBottom: "{form.field.padding.y}"
    },
    active: {
      top: "{form.field.padding.y}"
    }
  },
  on: {
    borderRadius: "{border.radius.xs}",
    active: {
      background: "{form.field.background}",
      padding: "0 0.125rem"
    }
  }
};
var index$Z = {
  root: {
    borderWidth: "1px",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    transitionDuration: "{transition.duration}"
  },
  navButton: {
    background: "rgba(255, 255, 255, 0.1)",
    hoverBackground: "rgba(255, 255, 255, 0.2)",
    color: "{surface.100}",
    hoverColor: "{surface.0}",
    size: "3rem",
    gutter: "0.5rem",
    prev: {
      borderRadius: "50%"
    },
    next: {
      borderRadius: "50%"
    },
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  navIcon: {
    size: "1.5rem"
  },
  thumbnailsContent: {
    background: "{content.background}",
    padding: "1rem 0.25rem"
  },
  thumbnailNavButton: {
    size: "2rem",
    borderRadius: "{content.border.radius}",
    gutter: "0.5rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  thumbnailNavButtonIcon: {
    size: "1rem"
  },
  caption: {
    background: "rgba(0, 0, 0, 0.5)",
    color: "{surface.100}",
    padding: "1rem"
  },
  indicatorList: {
    gap: "0.5rem",
    padding: "1rem"
  },
  indicatorButton: {
    width: "1rem",
    height: "1rem",
    activeBackground: "{primary.color}",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  insetIndicatorList: {
    background: "rgba(0, 0, 0, 0.5)"
  },
  insetIndicatorButton: {
    background: "rgba(255, 255, 255, 0.4)",
    hoverBackground: "rgba(255, 255, 255, 0.6)",
    activeBackground: "rgba(255, 255, 255, 0.9)"
  },
  mask: {
    background: "{mask.background}",
    color: "{mask.color}"
  },
  closeButton: {
    size: "3rem",
    gutter: "0.5rem",
    background: "rgba(255, 255, 255, 0.1)",
    hoverBackground: "rgba(255, 255, 255, 0.2)",
    color: "{surface.50}",
    hoverColor: "{surface.0}",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  closeButtonIcon: {
    size: "1.5rem"
  },
  colorScheme: {
    light: {
      thumbnailNavButton: {
        hoverBackground: "{surface.100}",
        color: "{surface.600}",
        hoverColor: "{surface.700}"
      },
      indicatorButton: {
        background: "{surface.200}",
        hoverBackground: "{surface.300}"
      }
    },
    dark: {
      thumbnailNavButton: {
        hoverBackground: "{surface.700}",
        color: "{surface.400}",
        hoverColor: "{surface.0}"
      },
      indicatorButton: {
        background: "{surface.700}",
        hoverBackground: "{surface.600}"
      }
    }
  }
};
var index$Y = {
  icon: {
    color: "{form.field.icon.color}"
  }
};
var index$X = {
  root: {
    color: "{form.field.float.label.color}",
    focusColor: "{form.field.float.label.focus.color}",
    invalidColor: "{form.field.float.label.invalid.color}",
    transitionDuration: "0.2s",
    positionX: "{form.field.padding.x}",
    top: "{form.field.padding.y}",
    fontSize: "0.75rem",
    fontWeight: "400"
  },
  input: {
    paddingTop: "1.5rem",
    paddingBottom: "{form.field.padding.y}"
  }
};
var index$W = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  preview: {
    icon: {
      size: "1.5rem"
    },
    mask: {
      background: "{mask.background}",
      color: "{mask.color}"
    }
  },
  toolbar: {
    position: {
      left: "auto",
      right: "1rem",
      top: "1rem",
      bottom: "auto"
    },
    blur: "8px",
    background: "rgba(255,255,255,0.1)",
    borderColor: "rgba(255,255,255,0.2)",
    borderWidth: "1px",
    borderRadius: "30px",
    padding: ".5rem",
    gap: "0.5rem"
  },
  action: {
    hoverBackground: "rgba(255,255,255,0.1)",
    color: "{surface.50}",
    hoverColor: "{surface.0}",
    size: "3rem",
    iconSize: "1.5rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  }
};
var index$V = {
  handle: {
    size: "15px",
    hoverSize: "30px",
    background: "rgba(255,255,255,0.3)",
    hoverBackground: "rgba(255,255,255,0.3)",
    borderColor: "unset",
    hoverBorderColor: "unset",
    borderWidth: "0",
    borderRadius: "50%",
    transitionDuration: "{transition.duration}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "rgba(255,255,255,0.3)",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  }
};
var index$U = {
  root: {
    padding: "{form.field.padding.y} {form.field.padding.x}",
    borderRadius: "{content.border.radius}",
    gap: "0.5rem"
  },
  text: {
    fontWeight: "500"
  },
  icon: {
    size: "1rem"
  },
  colorScheme: {
    light: {
      info: {
        background: "color-mix(in srgb, {blue.50}, transparent 5%)",
        borderColor: "{blue.200}",
        color: "{blue.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)"
      },
      success: {
        background: "color-mix(in srgb, {green.50}, transparent 5%)",
        borderColor: "{green.200}",
        color: "{green.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)"
      },
      warn: {
        background: "color-mix(in srgb,{yellow.50}, transparent 5%)",
        borderColor: "{yellow.200}",
        color: "{yellow.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)"
      },
      error: {
        background: "color-mix(in srgb, {red.50}, transparent 5%)",
        borderColor: "{red.200}",
        color: "{red.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)"
      },
      secondary: {
        background: "{surface.100}",
        borderColor: "{surface.200}",
        color: "{surface.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)"
      },
      contrast: {
        background: "{surface.900}",
        borderColor: "{surface.950}",
        color: "{surface.50}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)"
      }
    },
    dark: {
      info: {
        background: "color-mix(in srgb, {blue.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {blue.700}, transparent 64%)",
        color: "{blue.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)"
      },
      success: {
        background: "color-mix(in srgb, {green.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {green.700}, transparent 64%)",
        color: "{green.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)"
      },
      warn: {
        background: "color-mix(in srgb, {yellow.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {yellow.700}, transparent 64%)",
        color: "{yellow.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)"
      },
      error: {
        background: "color-mix(in srgb, {red.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {red.700}, transparent 64%)",
        color: "{red.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)"
      },
      secondary: {
        background: "{surface.800}",
        borderColor: "{surface.700}",
        color: "{surface.300}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)"
      },
      contrast: {
        background: "{surface.0}",
        borderColor: "{surface.100}",
        color: "{surface.950}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)"
      }
    }
  }
};
var index$T = {
  root: {
    padding: "{form.field.padding.y} {form.field.padding.x}",
    borderRadius: "{content.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    transitionDuration: "{transition.duration}"
  },
  display: {
    hoverBackground: "{content.hover.background}",
    hoverColor: "{content.hover.color}"
  }
};
var index$S = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  chip: {
    borderRadius: "{border.radius.sm}"
  },
  colorScheme: {
    light: {
      chip: {
        focusBackground: "{surface.200}",
        color: "{surface.800}"
      }
    },
    dark: {
      chip: {
        focusBackground: "{surface.700}",
        color: "{surface.0}"
      }
    }
  }
};
var index$R = {
  addon: {
    background: "{form.field.background}",
    borderColor: "{form.field.border.color}",
    color: "{form.field.icon.color}",
    borderRadius: "{form.field.border.radius}",
    padding: "0.5rem",
    minWidth: "2.5rem"
  }
};
var index$Q = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  button: {
    width: "2.5rem",
    borderRadius: "{form.field.border.radius}",
    verticalPadding: "{form.field.padding.y}"
  },
  colorScheme: {
    light: {
      button: {
        background: "transparent",
        hoverBackground: "{surface.100}",
        activeBackground: "{surface.200}",
        borderColor: "{form.field.border.color}",
        hoverBorderColor: "{form.field.border.color}",
        activeBorderColor: "{form.field.border.color}",
        color: "{surface.400}",
        hoverColor: "{surface.500}",
        activeColor: "{surface.600}"
      }
    },
    dark: {
      button: {
        background: "transparent",
        hoverBackground: "{surface.800}",
        activeBackground: "{surface.700}",
        borderColor: "{form.field.border.color}",
        hoverBorderColor: "{form.field.border.color}",
        activeBorderColor: "{form.field.border.color}",
        color: "{surface.400}",
        hoverColor: "{surface.300}",
        activeColor: "{surface.200}"
      }
    }
  }
};
var index$P = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledHoverBackground: "{form.field.filled.hover.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}",
    sm: {
      fontSize: "0.875rem",
      paddingX: "0.625rem",
      paddingY: "0.375rem"
    },
    lg: {
      fontSize: "1.125rem",
      paddingX: "0.875rem",
      paddingY: "0.625rem"
    }
  }
};
var index$O = {
  root: {
    transitionDuration: "{transition.duration}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  value: {
    background: "{primary.color}"
  },
  range: {
    background: "{content.border.color}"
  },
  text: {
    color: "{text.muted.color}"
  }
};
var index$N = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    shadow: "{form.field.shadow}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  list: {
    padding: "{list.padding}",
    gap: "{list.gap}",
    header: {
      padding: "{list.header.padding}"
    }
  },
  option: {
    focusBackground: "{list.option.focus.background}",
    selectedBackground: "{list.option.selected.background}",
    selectedFocusBackground: "{list.option.selected.focus.background}",
    color: "{list.option.color}",
    focusColor: "{list.option.focus.color}",
    selectedColor: "{list.option.selected.color}",
    selectedFocusColor: "{list.option.selected.focus.color}",
    padding: "{list.option.padding}",
    borderRadius: "{list.option.border.radius}"
  },
  optionGroup: {
    background: "{list.option.group.background}",
    color: "{list.option.group.color}",
    fontWeight: "{list.option.group.font.weight}",
    padding: "{list.option.group.padding}"
  },
  checkmark: {
    color: "{list.option.color}",
    gutterStart: "-0.375rem",
    gutterEnd: "0.375rem"
  },
  emptyMessage: {
    padding: "{list.option.padding}"
  },
  colorScheme: {
    light: {
      option: {
        stripedBackground: "{surface.50}"
      }
    },
    dark: {
      option: {
        stripedBackground: "{surface.900}"
      }
    }
  }
};
var index$M = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    color: "{content.color}",
    gap: "0.5rem",
    verticalOrientation: {
      padding: "{navigation.list.padding}",
      gap: "{navigation.list.gap}"
    },
    horizontalOrientation: {
      padding: "0.5rem 0.75rem",
      gap: "0.5rem"
    },
    transitionDuration: "{transition.duration}"
  },
  baseItem: {
    borderRadius: "{content.border.radius}",
    padding: "{navigation.item.padding}"
  },
  item: {
    focusBackground: "{navigation.item.focus.background}",
    activeBackground: "{navigation.item.active.background}",
    color: "{navigation.item.color}",
    focusColor: "{navigation.item.focus.color}",
    activeColor: "{navigation.item.active.color}",
    padding: "{navigation.item.padding}",
    borderRadius: "{navigation.item.border.radius}",
    gap: "{navigation.item.gap}",
    icon: {
      color: "{navigation.item.icon.color}",
      focusColor: "{navigation.item.icon.focus.color}",
      activeColor: "{navigation.item.icon.active.color}"
    }
  },
  overlay: {
    padding: "0",
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    color: "{content.color}",
    shadow: "{overlay.navigation.shadow}",
    gap: "0.5rem"
  },
  submenu: {
    padding: "{navigation.list.padding}",
    gap: "{navigation.list.gap}"
  },
  submenuLabel: {
    padding: "{navigation.submenu.label.padding}",
    fontWeight: "{navigation.submenu.label.font.weight}",
    background: "{navigation.submenu.label.background.}",
    color: "{navigation.submenu.label.color}"
  },
  submenuIcon: {
    size: "{navigation.submenu.icon.size}",
    color: "{navigation.submenu.icon.color}",
    focusColor: "{navigation.submenu.icon.focus.color}",
    activeColor: "{navigation.submenu.icon.active.color}"
  },
  separator: {
    borderColor: "{content.border.color}"
  },
  mobileButton: {
    borderRadius: "50%",
    size: "1.75rem",
    color: "{text.muted.color}",
    hoverColor: "{text.muted.hover.color}",
    hoverBackground: "{content.hover.background}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  }
};
var index$L = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}",
    shadow: "{overlay.navigation.shadow}",
    transitionDuration: "{transition.duration}"
  },
  list: {
    padding: "{navigation.list.padding}",
    gap: "{navigation.list.gap}"
  },
  item: {
    focusBackground: "{navigation.item.focus.background}",
    color: "{navigation.item.color}",
    focusColor: "{navigation.item.focus.color}",
    padding: "{navigation.item.padding}",
    borderRadius: "{navigation.item.border.radius}",
    gap: "{navigation.item.gap}",
    icon: {
      color: "{navigation.item.icon.color}",
      focusColor: "{navigation.item.icon.focus.color}"
    }
  },
  submenuLabel: {
    padding: "{navigation.submenu.label.padding}",
    fontWeight: "{navigation.submenu.label.font.weight}",
    background: "{navigation.submenu.label.background}",
    color: "{navigation.submenu.label.color}"
  },
  separator: {
    borderColor: "{content.border.color}"
  }
};
var index$K = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    color: "{content.color}",
    gap: "0.5rem",
    padding: "0.5rem 0.75rem",
    transitionDuration: "{transition.duration}"
  },
  baseItem: {
    borderRadius: "{content.border.radius}",
    padding: "{navigation.item.padding}"
  },
  item: {
    focusBackground: "{navigation.item.focus.background}",
    activeBackground: "{navigation.item.active.background}",
    color: "{navigation.item.color}",
    focusColor: "{navigation.item.focus.color}",
    activeColor: "{navigation.item.active.color}",
    padding: "{navigation.item.padding}",
    borderRadius: "{navigation.item.border.radius}",
    gap: "{navigation.item.gap}",
    icon: {
      color: "{navigation.item.icon.color}",
      focusColor: "{navigation.item.icon.focus.color}",
      activeColor: "{navigation.item.icon.active.color}"
    }
  },
  submenu: {
    padding: "{navigation.list.padding}",
    gap: "{navigation.list.gap}",
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    shadow: "{overlay.navigation.shadow}",
    mobileIndent: "1rem"
  },
  submenuIcon: {
    size: "{navigation.submenu.icon.size}",
    color: "{navigation.submenu.icon.color}",
    focusColor: "{navigation.submenu.icon.focus.color}",
    activeColor: "{navigation.submenu.icon.active.color}"
  },
  separator: {
    borderColor: "{content.border.color}"
  },
  mobileButton: {
    borderRadius: "50%",
    size: "1.75rem",
    color: "{text.muted.color}",
    hoverColor: "{text.muted.hover.color}",
    hoverBackground: "{content.hover.background}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  }
};
var index$J = {
  root: {
    borderRadius: "{content.border.radius}",
    borderWidth: "1px",
    transitionDuration: "{transition.duration}"
  },
  content: {
    padding: "0.5rem 0.75rem",
    gap: "0.5rem"
  },
  text: {
    fontSize: "1rem",
    fontWeight: "500"
  },
  icon: {
    size: "1.125rem"
  },
  closeButton: {
    width: "1.75rem",
    height: "1.75rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      offset: "{focus.ring.offset}"
    }
  },
  closeIcon: {
    size: "1rem"
  },
  colorScheme: {
    light: {
      info: {
        background: "color-mix(in srgb, {blue.50}, transparent 5%)",
        borderColor: "{blue.200}",
        color: "{blue.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{blue.100}",
          focusRing: {
            color: "{blue.600}",
            shadow: "none"
          }
        }
      },
      success: {
        background: "color-mix(in srgb, {green.50}, transparent 5%)",
        borderColor: "{green.200}",
        color: "{green.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{green.100}",
          focusRing: {
            color: "{green.600}",
            shadow: "none"
          }
        }
      },
      warn: {
        background: "color-mix(in srgb,{yellow.50}, transparent 5%)",
        borderColor: "{yellow.200}",
        color: "{yellow.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{yellow.100}",
          focusRing: {
            color: "{yellow.600}",
            shadow: "none"
          }
        }
      },
      error: {
        background: "color-mix(in srgb, {red.50}, transparent 5%)",
        borderColor: "{red.200}",
        color: "{red.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{red.100}",
          focusRing: {
            color: "{red.600}",
            shadow: "none"
          }
        }
      },
      secondary: {
        background: "{surface.100}",
        borderColor: "{surface.200}",
        color: "{surface.600}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.200}",
          focusRing: {
            color: "{surface.600}",
            shadow: "none"
          }
        }
      },
      contrast: {
        background: "{surface.900}",
        borderColor: "{surface.950}",
        color: "{surface.50}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.800}",
          focusRing: {
            color: "{surface.50}",
            shadow: "none"
          }
        }
      }
    },
    dark: {
      info: {
        background: "color-mix(in srgb, {blue.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {blue.700}, transparent 64%)",
        color: "{blue.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{blue.500}",
            shadow: "none"
          }
        }
      },
      success: {
        background: "color-mix(in srgb, {green.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {green.700}, transparent 64%)",
        color: "{green.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{green.500}",
            shadow: "none"
          }
        }
      },
      warn: {
        background: "color-mix(in srgb, {yellow.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {yellow.700}, transparent 64%)",
        color: "{yellow.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{yellow.500}",
            shadow: "none"
          }
        }
      },
      error: {
        background: "color-mix(in srgb, {red.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {red.700}, transparent 64%)",
        color: "{red.500}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{red.500}",
            shadow: "none"
          }
        }
      },
      secondary: {
        background: "{surface.800}",
        borderColor: "{surface.700}",
        color: "{surface.300}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.700}",
          focusRing: {
            color: "{surface.300}",
            shadow: "none"
          }
        }
      },
      contrast: {
        background: "{surface.0}",
        borderColor: "{surface.100}",
        color: "{surface.950}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.100}",
          focusRing: {
            color: "{surface.950}",
            shadow: "none"
          }
        }
      }
    }
  }
};
var index$I = {
  root: {
    borderRadius: "{content.border.radius}",
    gap: "1rem"
  },
  meters: {
    background: "{content.border.color}",
    size: "0.5rem"
  },
  label: {
    gap: "0.5rem"
  },
  labelMarker: {
    size: "0.5rem"
  },
  labelIcon: {
    size: "1rem"
  },
  labelList: {
    verticalGap: "0.5rem",
    horizontalGap: "1rem"
  }
};
var index$H = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledHoverBackground: "{form.field.filled.hover.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  dropdown: {
    width: "2.5rem",
    color: "{form.field.icon.color}"
  },
  overlay: {
    background: "{overlay.select.background}",
    borderColor: "{overlay.select.border.color}",
    borderRadius: "{overlay.select.border.radius}",
    color: "{overlay.select.color}",
    shadow: "{overlay.select.shadow}"
  },
  list: {
    padding: "{list.padding}",
    gap: "{list.gap}",
    header: {
      padding: "{list.header.padding}"
    }
  },
  option: {
    focusBackground: "{list.option.focus.background}",
    selectedBackground: "{list.option.selected.background}",
    selectedFocusBackground: "{list.option.selected.focus.background}",
    color: "{list.option.color}",
    focusColor: "{list.option.focus.color}",
    selectedColor: "{list.option.selected.color}",
    selectedFocusColor: "{list.option.selected.focus.color}",
    padding: "{list.option.padding}",
    borderRadius: "{list.option.border.radius}",
    gap: "0.5rem"
  },
  optionGroup: {
    background: "{list.option.group.background}",
    color: "{list.option.group.color}",
    fontWeight: "{list.option.group.font.weight}",
    padding: "{list.option.group.padding}"
  },
  chip: {
    borderRadius: "{border.radius.sm}"
  },
  emptyMessage: {
    padding: "{list.option.padding}"
  }
};
var index$G = {
  root: {
    gap: "1.125rem"
  },
  controls: {
    gap: "0.5rem"
  }
};
var index$F = {
  root: {
    gutter: "0.75rem",
    transitionDuration: "{transition.duration}"
  },
  node: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    selectedColor: "{highlight.color}",
    hoverColor: "{content.hover.color}",
    padding: "0.75rem 1rem",
    toggleablePadding: "0.75rem 1rem 1.25rem 1rem",
    borderRadius: "{content.border.radius}"
  },
  nodeToggleButton: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    borderColor: "{content.border.color}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    size: "1.5rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  connector: {
    color: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    height: "24px"
  }
};
var index$E = {
  root: {
    outline: {
      width: "2px",
      color: "{content.background}"
    }
  }
};
var index$D = {
  root: {
    padding: "0.5rem 1rem",
    gap: "0.25rem",
    borderRadius: "{content.border.radius}",
    background: "{content.background}",
    color: "{content.color}",
    transitionDuration: "{transition.duration}"
  },
  navButton: {
    background: "transparent",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    color: "{text.muted.color}",
    hoverColor: "{text.hover.muted.color}",
    selectedColor: "{highlight.color}",
    width: "2.5rem",
    height: "2.5rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  currentPageReport: {
    color: "{text.muted.color}"
  },
  jumpToPageInput: {
    maxWidth: "2.5rem"
  }
};
var index$C = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}"
  },
  header: {
    background: "transparent",
    color: "{text.color}",
    padding: "1.125rem",
    borderColor: "{content.border.color}",
    borderWidth: "0",
    borderRadius: "0"
  },
  toggleableHeader: {
    padding: "0.375rem 1.125rem"
  },
  title: {
    fontWeight: "600"
  },
  content: {
    padding: "0 1.125rem 1.125rem 1.125rem"
  },
  footer: {
    padding: "0 1.125rem 1.125rem 1.125rem"
  }
};
var index$B = {
  root: {
    gap: "0.5rem",
    transitionDuration: "{transition.duration}"
  },
  panel: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderWidth: "1px",
    color: "{content.color}",
    padding: "0.25rem 0.25rem",
    borderRadius: "{content.border.radius}",
    first: {
      borderWidth: "1px",
      topBorderRadius: "{content.border.radius}"
    },
    last: {
      borderWidth: "1px",
      bottomBorderRadius: "{content.border.radius}"
    }
  },
  item: {
    focusBackground: "{navigation.item.focus.background}",
    color: "{navigation.item.color}",
    focusColor: "{navigation.item.focus.color}",
    gap: "0.5rem",
    padding: "{navigation.item.padding}",
    borderRadius: "{content.border.radius}",
    icon: {
      color: "{navigation.item.icon.color}",
      focusColor: "{navigation.item.icon.focus.color}"
    }
  },
  submenu: {
    indent: "1rem"
  },
  submenuIcon: {
    color: "{navigation.submenu.icon.color}",
    focusColor: "{navigation.submenu.icon.focus.color}"
  }
};
var index$A = {
  meter: {
    background: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    height: ".75rem"
  },
  icon: {
    color: "{form.field.icon.color}"
  },
  overlay: {
    background: "{overlay.popover.background}",
    borderColor: "{overlay.popover.border.color}",
    borderRadius: "{overlay.popover.border.radius}",
    color: "{overlay.popover.color}",
    padding: "{overlay.popover.padding}",
    shadow: "{overlay.popover.shadow}"
  },
  content: {
    gap: "0.5rem"
  },
  colorScheme: {
    light: {
      strength: {
        weakBackground: "{red.500}",
        mediumBackground: "{amber.500}",
        strongBackground: "{green.500}"
      }
    },
    dark: {
      strength: {
        weakBackground: "{red.400}",
        mediumBackground: "{amber.400}",
        strongBackground: "{green.400}"
      }
    }
  }
};
var index$z = {
  root: {
    gap: "1.125rem"
  },
  controls: {
    gap: "0.5rem"
  }
};
var index$y = {
  root: {
    background: "{overlay.popover.background}",
    borderColor: "{overlay.popover.border.color}",
    color: "{overlay.popover.color}",
    borderRadius: "{overlay.popover.border.radius}",
    shadow: "{overlay.popover.shadow}",
    gutter: "10px",
    arrowOffset: "1.25rem"
  },
  content: {
    padding: "{overlay.popover.padding}"
  }
};
var index$x = {
  root: {
    background: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    height: "1.25rem"
  },
  value: {
    background: "{primary.color}"
  },
  label: {
    color: "{primary.contrast.color}",
    fontSize: "0.75rem",
    fontWeight: "600"
  }
};
var index$w = {
  colorScheme: {
    light: {
      root: {
        "color.1": "{red.500}",
        "color.2": "{blue.500}",
        "color.3": "{green.500}",
        "color.4": "{yellow.500}"
      }
    },
    dark: {
      root: {
        "color.1": "{red.400}",
        "color.2": "{blue.400}",
        "color.3": "{green.400}",
        "color.4": "{yellow.400}"
      }
    }
  }
};
var index$v = {
  root: {
    width: "1.25rem",
    height: "1.25rem",
    background: "{form.field.background}",
    checkedBackground: "{primary.color}",
    checkedHoverBackground: "{primary.hover.color}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.border.color}",
    checkedBorderColor: "{primary.color}",
    checkedHoverBorderColor: "{primary.hover.color}",
    checkedFocusBorderColor: "{primary.color}",
    checkedDisabledBorderColor: "{form.field.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    shadow: "{form.field.shadow}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  icon: {
    size: "0.75rem",
    checkedColor: "{primary.contrast.color}",
    checkedHoverColor: "{primary.contrast.color}",
    disabledColor: "{form.field.disabled.color}"
  }
};
var index$u = {
  root: {
    gap: "0.25rem",
    transitionDuration: "{transition.duration}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  icon: {
    size: "1rem",
    color: "{text.muted.color}",
    hoverColor: "{primary.color}",
    activeColor: "{primary.color}"
  }
};
var index$t = {
  colorScheme: {
    light: {
      root: {
        background: "rgba(0,0,0,0.1)"
      }
    },
    dark: {
      root: {
        background: "rgba(255,255,255,0.3)"
      }
    }
  }
};
var index$s = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  bar: {
    size: "9px",
    borderRadius: "{border.radius.sm}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  colorScheme: {
    light: {
      bar: {
        background: "{surface.100}"
      }
    },
    dark: {
      bar: {
        background: "{surface.800}"
      }
    }
  }
};
var index$r = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledHoverBackground: "{form.field.filled.hover.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  dropdown: {
    width: "2.5rem",
    color: "{form.field.icon.color}"
  },
  overlay: {
    background: "{overlay.select.background}",
    borderColor: "{overlay.select.border.color}",
    borderRadius: "{overlay.select.border.radius}",
    color: "{overlay.select.color}",
    shadow: "{overlay.select.shadow}"
  },
  list: {
    padding: "{list.padding}",
    gap: "{list.gap}",
    header: {
      padding: "{list.header.padding}"
    }
  },
  option: {
    focusBackground: "{list.option.focus.background}",
    selectedBackground: "{list.option.selected.background}",
    selectedFocusBackground: "{list.option.selected.focus.background}",
    color: "{list.option.color}",
    focusColor: "{list.option.focus.color}",
    selectedColor: "{list.option.selected.color}",
    selectedFocusColor: "{list.option.selected.focus.color}",
    padding: "{list.option.padding}",
    borderRadius: "{list.option.border.radius}"
  },
  optionGroup: {
    background: "{list.option.group.background}",
    color: "{list.option.group.color}",
    fontWeight: "{list.option.group.font.weight}",
    padding: "{list.option.group.padding}"
  },
  clearIcon: {
    color: "{form.field.icon.color}"
  },
  checkmark: {
    color: "{list.option.color}",
    gutterStart: "-0.375rem",
    gutterEnd: "0.375rem"
  },
  emptyMessage: {
    padding: "{list.option.padding}"
  }
};
var index$q = {
  root: {
    borderRadius: "{form.field.border.radius}"
  },
  colorScheme: {
    light: {
      root: {
        invalidBorderColor: "{form.field.invalid.border.color}"
      }
    },
    dark: {
      root: {
        invalidBorderColor: "{form.field.invalid.border.color}"
      }
    }
  }
};
var index$p = {
  root: {
    borderRadius: "{content.border.radius}"
  },
  colorScheme: {
    light: {
      root: {
        background: "{surface.200}",
        animationBackground: "rgba(255,255,255,0.4)"
      }
    },
    dark: {
      root: {
        background: "rgba(255, 255, 255, 0.06)",
        animationBackground: "rgba(255, 255, 255, 0.04)"
      }
    }
  }
};
var index$o = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  track: {
    background: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    size: "3px"
  },
  range: {
    background: "{primary.color}"
  },
  handle: {
    width: "20px",
    height: "20px",
    borderRadius: "50%",
    background: "{content.border.color}",
    hoverBackground: "{content.border.color}",
    content: {
      borderRadius: "50%",
      hoverBackground: "{content.background}",
      width: "16px",
      height: "16px",
      shadow: "0px 0.5px 0px 0px rgba(0, 0, 0, 0.08), 0px 1px 1px 0px rgba(0, 0, 0, 0.14)"
    },
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  colorScheme: {
    light: {
      handle: {
        contentBackground: "{surface.0}"
      }
    },
    dark: {
      handle: {
        contentBackground: "{surface.950}"
      }
    }
  }
};
var index$n = {
  root: {
    gap: "0.5rem",
    transitionDuration: "{transition.duration}"
  }
};
var index$m = {
  root: {
    borderRadius: "{form.field.border.radius}",
    roundedBorderRadius: "2rem",
    raisedShadow: "0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)"
  }
};
var index$l = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    transitionDuration: "{transition.duration}"
  },
  gutter: {
    background: "{content.border.color}"
  },
  handle: {
    size: "24px",
    background: "transparent",
    borderRadius: "{content.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  }
};
var index$k = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  separator: {
    background: "{content.border.color}",
    activeBackground: "{primary.color}",
    margin: "0 0 0 1.625rem",
    size: "2px"
  },
  step: {
    padding: "0.5rem",
    gap: "1rem"
  },
  stepHeader: {
    padding: "0",
    borderRadius: "{content.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    gap: "0.5rem"
  },
  stepTitle: {
    color: "{text.muted.color}",
    activeColor: "{primary.color}",
    fontWeight: "500"
  },
  stepNumber: {
    background: "{content.background}",
    activeBackground: "{content.background}",
    borderColor: "{content.border.color}",
    activeBorderColor: "{content.border.color}",
    color: "{text.muted.color}",
    activeColor: "{primary.color}",
    size: "2rem",
    fontSize: "1.143rem",
    fontWeight: "500",
    borderRadius: "50%",
    shadow: "0px 0.5px 0px 0px rgba(0, 0, 0, 0.06), 0px 1px 1px 0px rgba(0, 0, 0, 0.12)"
  },
  steppanels: {
    padding: "0.875rem 0.5rem 1.125rem 0.5rem"
  },
  steppanel: {
    background: "{content.background}",
    color: "{content.color}",
    padding: "0 0 0 1rem"
  }
};
var index$j = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  separator: {
    background: "{content.border.color}"
  },
  itemLink: {
    borderRadius: "{content.border.radius}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    gap: "0.5rem"
  },
  itemLabel: {
    color: "{text.muted.color}",
    activeColor: "{primary.color}",
    fontWeight: "500"
  },
  itemNumber: {
    background: "{content.background}",
    activeBackground: "{content.background}",
    borderColor: "{content.border.color}",
    activeBorderColor: "{content.border.color}",
    color: "{text.muted.color}",
    activeColor: "{primary.color}",
    size: "2rem",
    fontSize: "1.143rem",
    fontWeight: "500",
    borderRadius: "50%",
    shadow: "0px 0.5px 0px 0px rgba(0, 0, 0, 0.06), 0px 1px 1px 0px rgba(0, 0, 0, 0.12)"
  }
};
var index$i = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  tablist: {
    borderWidth: "0 0 1px 0",
    background: "{content.background}",
    borderColor: "{content.border.color}"
  },
  item: {
    background: "transparent",
    hoverBackground: "transparent",
    activeBackground: "transparent",
    borderWidth: "0 0 1px 0",
    borderColor: "{content.border.color}",
    hoverBorderColor: "{content.border.color}",
    activeBorderColor: "{primary.color}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    activeColor: "{primary.color}",
    padding: "1rem 1.125rem",
    fontWeight: "600",
    margin: "0 0 -1px 0",
    gap: "0.5rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  itemIcon: {
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    activeColor: "{primary.color}"
  },
  activeBar: {
    height: "1px",
    bottom: "-1px",
    background: "{primary.color}"
  }
};
var index$h = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  tablist: {
    borderWidth: "0 0 1px 0",
    background: "{content.background}",
    borderColor: "{content.border.color}"
  },
  tab: {
    background: "transparent",
    hoverBackground: "transparent",
    activeBackground: "transparent",
    borderWidth: "0 0 1px 0",
    borderColor: "{content.border.color}",
    hoverBorderColor: "{content.border.color}",
    activeBorderColor: "{primary.color}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    activeColor: "{primary.color}",
    padding: "1rem 1.125rem",
    fontWeight: "600",
    margin: "0 0 -1px 0",
    gap: "0.5rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    }
  },
  tabpanel: {
    background: "{content.background}",
    color: "{content.color}",
    padding: "0.875rem 1.125rem 1.125rem 1.125rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "inset {focus.ring.shadow}"
    }
  },
  navButton: {
    background: "{content.background}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    width: "2.5rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    }
  },
  activeBar: {
    height: "1px",
    bottom: "-1px",
    background: "{primary.color}"
  },
  colorScheme: {
    light: {
      navButton: {
        shadow: "0px 0px 10px 50px rgba(255, 255, 255, 0.6)"
      }
    },
    dark: {
      navButton: {
        shadow: "0px 0px 10px 50px color-mix(in srgb, {content.background}, transparent 50%)"
      }
    }
  }
};
var index$g = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  tabList: {
    background: "{content.background}",
    borderColor: "{content.border.color}"
  },
  tab: {
    borderColor: "{content.border.color}",
    activeBorderColor: "{primary.color}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    activeColor: "{primary.color}"
  },
  tabPanel: {
    background: "{content.background}",
    color: "{content.color}"
  },
  navButton: {
    background: "{content.background}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}"
  },
  colorScheme: {
    light: {
      navButton: {
        shadow: "0px 0px 10px 50px rgba(255, 255, 255, 0.6)"
      }
    },
    dark: {
      navButton: {
        shadow: "0px 0px 10px 50px color-mix(in srgb, {content.background}, transparent 50%)"
      }
    }
  }
};
var index$f = {
  root: {
    fontSize: "0.875rem",
    fontWeight: "700",
    padding: "0.25rem 0.5rem",
    gap: "0.25rem",
    borderRadius: "{content.border.radius}",
    roundedBorderRadius: "{border.radius.xl}"
  },
  icon: {
    size: "0.75rem"
  },
  colorScheme: {
    light: {
      primary: {
        background: "{primary.100}",
        color: "{primary.700}"
      },
      secondary: {
        background: "{surface.100}",
        color: "{surface.600}"
      },
      success: {
        background: "{green.100}",
        color: "{green.700}"
      },
      info: {
        background: "{sky.100}",
        color: "{sky.700}"
      },
      warn: {
        background: "{orange.100}",
        color: "{orange.700}"
      },
      danger: {
        background: "{red.100}",
        color: "{red.700}"
      },
      contrast: {
        background: "{surface.950}",
        color: "{surface.0}"
      }
    },
    dark: {
      primary: {
        background: "color-mix(in srgb, {primary.500}, transparent 84%)",
        color: "{primary.300}"
      },
      secondary: {
        background: "{surface.800}",
        color: "{surface.300}"
      },
      success: {
        background: "color-mix(in srgb, {green.500}, transparent 84%)",
        color: "{green.300}"
      },
      info: {
        background: "color-mix(in srgb, {sky.500}, transparent 84%)",
        color: "{sky.300}"
      },
      warn: {
        background: "color-mix(in srgb, {orange.500}, transparent 84%)",
        color: "{orange.300}"
      },
      danger: {
        background: "color-mix(in srgb, {red.500}, transparent 84%)",
        color: "{red.300}"
      },
      contrast: {
        background: "{surface.0}",
        color: "{surface.950}"
      }
    }
  }
};
var index$e = {
  root: {
    background: "{form.field.background}",
    borderColor: "{form.field.border.color}",
    color: "{form.field.color}",
    height: "18rem",
    padding: "{form.field.padding.y} {form.field.padding.x}",
    borderRadius: "{form.field.border.radius}"
  },
  prompt: {
    gap: "0.25rem"
  },
  commandResponse: {
    margin: "2px 0"
  }
};
var index$d = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  }
};
var index$c = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    color: "{content.color}",
    borderRadius: "{content.border.radius}",
    shadow: "{overlay.navigation.shadow}",
    transitionDuration: "{transition.duration}"
  },
  list: {
    padding: "{navigation.list.padding}",
    gap: "{navigation.list.gap}"
  },
  item: {
    focusBackground: "{navigation.item.focus.background}",
    activeBackground: "{navigation.item.active.background}",
    color: "{navigation.item.color}",
    focusColor: "{navigation.item.focus.color}",
    activeColor: "{navigation.item.active.color}",
    padding: "{navigation.item.padding}",
    borderRadius: "{navigation.item.border.radius}",
    gap: "{navigation.item.gap}",
    icon: {
      color: "{navigation.item.icon.color}",
      focusColor: "{navigation.item.icon.focus.color}",
      activeColor: "{navigation.item.icon.active.color}"
    }
  },
  submenu: {
    mobileIndent: "1rem"
  },
  submenuLabel: {
    padding: "{navigation.submenu.label.padding}",
    fontWeight: "{navigation.submenu.label.font.weight}",
    background: "{navigation.submenu.label.background.}",
    color: "{navigation.submenu.label.color}"
  },
  submenuIcon: {
    size: "{navigation.submenu.icon.size}",
    color: "{navigation.submenu.icon.color}",
    focusColor: "{navigation.submenu.icon.focus.color}",
    activeColor: "{navigation.submenu.icon.active.color}"
  },
  separator: {
    borderColor: "{content.border.color}"
  }
};
var index$b = {
  event: {
    minHeight: "5rem"
  },
  horizontal: {
    eventContent: {
      padding: "1rem 0"
    }
  },
  vertical: {
    eventContent: {
      padding: "0 1rem"
    }
  },
  eventMarker: {
    size: "1.125rem",
    borderRadius: "50%",
    borderWidth: "2px",
    background: "{content.background}",
    borderColor: "{content.border.color}",
    content: {
      borderRadius: "50%",
      size: "0.375rem",
      background: "{primary.color}",
      insetShadow: "0px 0.5px 0px 0px rgba(0, 0, 0, 0.06), 0px 1px 1px 0px rgba(0, 0, 0, 0.12)"
    }
  },
  eventConnector: {
    color: "{content.border.color}",
    size: "2px"
  }
};
var index$a = {
  root: {
    width: "25rem",
    borderRadius: "{content.border.radius}",
    borderWidth: "1px",
    transitionDuration: "{transition.duration}"
  },
  icon: {
    size: "1.125rem"
  },
  content: {
    padding: "{overlay.popover.padding}",
    gap: "0.5rem"
  },
  text: {
    gap: "0.5rem"
  },
  summary: {
    fontWeight: "500",
    fontSize: "1rem"
  },
  detail: {
    fontWeight: "500",
    fontSize: "0.875rem"
  },
  closeButton: {
    width: "1.75rem",
    height: "1.75rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      offset: "{focus.ring.offset}"
    }
  },
  closeIcon: {
    size: "1rem"
  },
  colorScheme: {
    light: {
      blur: "1.5px",
      info: {
        background: "color-mix(in srgb, {blue.50}, transparent 5%)",
        borderColor: "{blue.200}",
        color: "{blue.600}",
        detailColor: "{surface.700}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{blue.100}",
          focusRing: {
            color: "{blue.600}",
            shadow: "none"
          }
        }
      },
      success: {
        background: "color-mix(in srgb, {green.50}, transparent 5%)",
        borderColor: "{green.200}",
        color: "{green.600}",
        detailColor: "{surface.700}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{green.100}",
          focusRing: {
            color: "{green.600}",
            shadow: "none"
          }
        }
      },
      warn: {
        background: "color-mix(in srgb,{yellow.50}, transparent 5%)",
        borderColor: "{yellow.200}",
        color: "{yellow.600}",
        detailColor: "{surface.700}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{yellow.100}",
          focusRing: {
            color: "{yellow.600}",
            shadow: "none"
          }
        }
      },
      error: {
        background: "color-mix(in srgb, {red.50}, transparent 5%)",
        borderColor: "{red.200}",
        color: "{red.600}",
        detailColor: "{surface.700}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{red.100}",
          focusRing: {
            color: "{red.600}",
            shadow: "none"
          }
        }
      },
      secondary: {
        background: "{surface.100}",
        borderColor: "{surface.200}",
        color: "{surface.600}",
        detailColor: "{surface.700}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.200}",
          focusRing: {
            color: "{surface.600}",
            shadow: "none"
          }
        }
      },
      contrast: {
        background: "{surface.900}",
        borderColor: "{surface.950}",
        color: "{surface.50}",
        detailColor: "{surface.0}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.800}",
          focusRing: {
            color: "{surface.50}",
            shadow: "none"
          }
        }
      }
    },
    dark: {
      blur: "10px",
      info: {
        background: "color-mix(in srgb, {blue.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {blue.700}, transparent 64%)",
        color: "{blue.500}",
        detailColor: "{surface.0}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{blue.500}",
            shadow: "none"
          }
        }
      },
      success: {
        background: "color-mix(in srgb, {green.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {green.700}, transparent 64%)",
        color: "{green.500}",
        detailColor: "{surface.0}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{green.500}",
            shadow: "none"
          }
        }
      },
      warn: {
        background: "color-mix(in srgb, {yellow.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {yellow.700}, transparent 64%)",
        color: "{yellow.500}",
        detailColor: "{surface.0}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{yellow.500}",
            shadow: "none"
          }
        }
      },
      error: {
        background: "color-mix(in srgb, {red.500}, transparent 84%)",
        borderColor: "color-mix(in srgb, {red.700}, transparent 64%)",
        color: "{red.500}",
        detailColor: "{surface.0}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "rgba(255, 255, 255, 0.05)",
          focusRing: {
            color: "{red.500}",
            shadow: "none"
          }
        }
      },
      secondary: {
        background: "{surface.800}",
        borderColor: "{surface.700}",
        color: "{surface.300}",
        detailColor: "{surface.0}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.700}",
          focusRing: {
            color: "{surface.300}",
            shadow: "none"
          }
        }
      },
      contrast: {
        background: "{surface.0}",
        borderColor: "{surface.100}",
        color: "{surface.950}",
        detailColor: "{surface.950}",
        shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)",
        closeButton: {
          hoverBackground: "{surface.100}",
          focusRing: {
            color: "{surface.950}",
            shadow: "none"
          }
        }
      }
    }
  }
};
var index$9 = {
  root: {
    padding: "0.5rem 1rem",
    borderRadius: "{content.border.radius}",
    gap: "0.5rem",
    fontWeight: "500",
    disabledBackground: "{form.field.disabled.background}",
    disabledBorderColor: "{form.field.disabled.background}",
    disabledColor: "{form.field.disabled.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  icon: {
    disabledColor: "{form.field.disabled.color}"
  },
  content: {
    left: "0.25rem",
    top: "0.25rem",
    checkedShadow: "0px 1px 2px 0px rgba(0, 0, 0, 0.02), 0px 1px 2px 0px rgba(0, 0, 0, 0.04)"
  },
  colorScheme: {
    light: {
      root: {
        background: "{surface.100}",
        checkedBackground: "{surface.100}",
        hoverBackground: "{surface.100}",
        borderColor: "{surface.100}",
        color: "{surface.500}",
        hoverColor: "{surface.700}",
        checkedColor: "{surface.900}",
        checkedBorderColor: "{surface.100}"
      },
      content: {
        checkedBackground: "{surface.0}"
      },
      icon: {
        color: "{surface.500}",
        hoverColor: "{surface.700}",
        checkedColor: "{surface.900}"
      }
    },
    dark: {
      root: {
        background: "{surface.950}",
        checkedBackground: "{surface.950}",
        hoverBackground: "{surface.950}",
        borderColor: "{surface.950}",
        color: "{surface.400}",
        hoverColor: "{surface.300}",
        checkedColor: "{surface.0}",
        checkedBorderColor: "{surface.950}"
      },
      content: {
        checkedBackground: "{surface.800}"
      },
      icon: {
        color: "{surface.400}",
        hoverColor: "{surface.300}",
        checkedColor: "{surface.0}"
      }
    }
  }
};
var index$8 = {
  root: {
    width: "2.5rem",
    height: "1.5rem",
    borderRadius: "30px",
    gap: "0.25rem",
    shadow: "{form.field.shadow}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    },
    borderWidth: "1px",
    borderColor: "transparent",
    hoverBorderColor: "transparent",
    checkedBorderColor: "transparent",
    checkedHoverBorderColor: "transparent",
    invalidBorderColor: "{form.field.invalid.border.color}",
    transitionDuration: "{form.field.transition.duration}",
    slideDuration: "0.2s"
  },
  handle: {
    borderRadius: "50%",
    size: "1rem"
  },
  colorScheme: {
    light: {
      root: {
        background: "{surface.300}",
        disabledBackground: "{form.field.disabled.background}",
        hoverBackground: "{surface.400}",
        checkedBackground: "{primary.color}",
        checkedHoverBackground: "{primary.hover.color}"
      },
      handle: {
        background: "{surface.0}",
        disabledBackground: "{form.field.disabled.color}",
        hoverBackground: "{surface.0}",
        checkedBackground: "{surface.0}",
        checkedHoverBackground: "{surface.0}",
        color: "{text.muted.color}",
        hoverColor: "{text.color}",
        checkedColor: "{primary.color}",
        checkedHoverColor: "{primary.hover.color}"
      }
    },
    dark: {
      root: {
        background: "{surface.700}",
        disabledBackground: "{surface.600}",
        hoverBackground: "{surface.600}",
        checkedBackground: "{primary.color}",
        checkedHoverBackground: "{primary.hover.color}"
      },
      handle: {
        background: "{surface.400}",
        disabledBackground: "{surface.900}",
        hoverBackground: "{surface.300}",
        checkedBackground: "{surface.900}",
        checkedHoverBackground: "{surface.900}",
        color: "{surface.900}",
        hoverColor: "{surface.800}",
        checkedColor: "{primary.color}",
        checkedHoverColor: "{primary.hover.color}"
      }
    }
  }
};
var index$7 = {
  root: {
    background: "{content.background}",
    borderColor: "{content.border.color}",
    borderRadius: "{content.border.radius}",
    color: "{content.color}",
    gap: "0.5rem",
    padding: "0.75rem"
  }
};
var index$6 = {
  root: {
    maxWidth: "12.5rem",
    gutter: "0.25rem",
    shadow: "{overlay.popover.shadow}",
    padding: "0.5rem 0.75rem",
    borderRadius: "{overlay.popover.border.radius}"
  },
  colorScheme: {
    light: {
      root: {
        background: "{surface.700}",
        color: "{surface.0}"
      }
    },
    dark: {
      root: {
        background: "{surface.700}",
        color: "{surface.0}"
      }
    }
  }
};
var index$5 = {
  root: {
    background: "{content.background}",
    color: "{content.color}",
    padding: "1rem",
    gap: "2px",
    indent: "1rem",
    transitionDuration: "{transition.duration}"
  },
  node: {
    padding: "0.25rem 0.5rem",
    borderRadius: "{content.border.radius}",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    color: "{text.color}",
    hoverColor: "{text.hover.color}",
    selectedColor: "{highlight.color}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    },
    gap: "0.25rem"
  },
  nodeIcon: {
    color: "{text.muted.color}",
    hoverColor: "{text.hover.muted.color}",
    selectedColor: "{highlight.color}"
  },
  nodeToggleButton: {
    borderRadius: "50%",
    size: "1.75rem",
    hoverBackground: "{content.hover.background}",
    selectedHoverBackground: "{content.background}",
    color: "{text.muted.color}",
    hoverColor: "{text.hover.muted.color}",
    selectedHoverColor: "{primary.color}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  loadingIcon: {
    size: "2rem"
  },
  filter: {
    margin: "0 0 0.5rem 0"
  }
};
var index$4 = {
  root: {
    background: "{form.field.background}",
    disabledBackground: "{form.field.disabled.background}",
    filledBackground: "{form.field.filled.background}",
    filledHoverBackground: "{form.field.filled.hover.background}",
    filledFocusBackground: "{form.field.filled.focus.background}",
    borderColor: "{form.field.border.color}",
    hoverBorderColor: "{form.field.hover.border.color}",
    focusBorderColor: "{form.field.focus.border.color}",
    invalidBorderColor: "{form.field.invalid.border.color}",
    color: "{form.field.color}",
    disabledColor: "{form.field.disabled.color}",
    placeholderColor: "{form.field.placeholder.color}",
    shadow: "{form.field.shadow}",
    paddingX: "{form.field.padding.x}",
    paddingY: "{form.field.padding.y}",
    borderRadius: "{form.field.border.radius}",
    focusRing: {
      width: "{form.field.focus.ring.width}",
      style: "{form.field.focus.ring.style}",
      color: "{form.field.focus.ring.color}",
      offset: "{form.field.focus.ring.offset}",
      shadow: "{form.field.focus.ring.shadow}"
    },
    transitionDuration: "{form.field.transition.duration}"
  },
  dropdown: {
    width: "2.5rem",
    color: "{form.field.icon.color}"
  },
  overlay: {
    background: "{overlay.select.background}",
    borderColor: "{overlay.select.border.color}",
    borderRadius: "{overlay.select.border.radius}",
    color: "{overlay.select.color}",
    shadow: "{overlay.select.shadow}"
  },
  tree: {
    padding: "{list.padding}"
  },
  emptyMessage: {
    padding: "{list.option.padding}"
  },
  chip: {
    borderRadius: "{border.radius.sm}"
  }
};
var index$3 = {
  root: {
    transitionDuration: "{transition.duration}"
  },
  header: {
    background: "{content.background}",
    borderColor: "{treetable.border.color}",
    color: "{content.color}",
    borderWidth: "0 0 1px 0",
    padding: "0.75rem 1rem"
  },
  headerCell: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    borderColor: "{treetable.border.color}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    selectedColor: "{highlight.color}",
    gap: "0.5rem",
    padding: "0.75rem 1rem",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    }
  },
  columnTitle: {
    fontWeight: "600"
  },
  row: {
    background: "{content.background}",
    hoverBackground: "{content.hover.background}",
    selectedBackground: "{highlight.background}",
    color: "{content.color}",
    hoverColor: "{content.hover.color}",
    selectedColor: "{highlight.color}",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "-1px",
      shadow: "{focus.ring.shadow}"
    }
  },
  bodyCell: {
    borderColor: "{treetable.border.color}",
    padding: "0.75rem 1rem",
    gap: "0.5rem"
  },
  footerCell: {
    background: "{content.background}",
    borderColor: "{treetable.border.color}",
    color: "{content.color}",
    padding: "0.75rem 1rem"
  },
  columnFooter: {
    fontWeight: "600"
  },
  footer: {
    background: "{content.background}",
    borderColor: "{treetable.border.color}",
    color: "{content.color}",
    borderWidth: "0 0 1px 0",
    padding: "0.75rem 1rem"
  },
  columnResizerWidth: "0.5rem",
  resizeIndicator: {
    width: "1px",
    color: "{primary.color}"
  },
  sortIcon: {
    color: "{text.muted.color}",
    hoverColor: "{text.hover.muted.color}",
    size: "0.875rem"
  },
  loadingIcon: {
    size: "2rem"
  },
  nodeToggleButton: {
    hoverBackground: "{content.hover.background}",
    selectedHoverBackground: "{content.background}",
    color: "{text.muted.color}",
    hoverColor: "{text.color}",
    selectedHoverColor: "{primary.color}",
    size: "1.75rem",
    borderRadius: "50%",
    focusRing: {
      width: "{focus.ring.width}",
      style: "{focus.ring.style}",
      color: "{focus.ring.color}",
      offset: "{focus.ring.offset}",
      shadow: "{focus.ring.shadow}"
    }
  },
  paginatorTop: {
    borderColor: "{content.border.color}",
    borderWidth: "0 0 1px 0"
  },
  paginatorBottom: {
    borderColor: "{content.border.color}",
    borderWidth: "0 0 1px 0"
  },
  colorScheme: {
    light: {
      root: {
        borderColor: "{content.border.color}"
      },
      bodyCell: {
        selectedBorderColor: "{primary.100}"
      }
    },
    dark: {
      root: {
        borderColor: "{surface.800}"
      },
      bodyCell: {
        selectedBorderColor: "{primary.900}"
      }
    }
  }
};
var index$2 = {
  loader: {
    mask: {
      background: "{content.background}",
      color: "{text.muted.color}"
    },
    icon: {
      size: "2rem"
    }
  }
};
function _typeof$1(o) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$1(o);
}
function ownKeys(e2, r) {
  var t = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e2, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e2) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e2, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e2, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e2;
}
function _defineProperty(e2, r, t) {
  return (r = _toPropertyKey(r)) in e2 ? Object.defineProperty(e2, r, { value: t, enumerable: true, configurable: true, writable: true }) : e2[r] = t, e2;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof$1(i) ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != _typeof$1(t) || !t)
    return t;
  var e2 = t[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t, r || "default");
    if ("object" != _typeof$1(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var index$1 = _objectSpread(_objectSpread({}, index$1l), {}, {
  components: {
    accordion: index$1p,
    autocomplete: index$1o,
    avatar: index$1n,
    badge: index$1m,
    blockui: index$1k,
    breadcrumb: index$1j,
    button: index$1i,
    datepicker: index$16,
    card: index$1h,
    carousel: index$1g,
    cascadeselect: index$1f,
    checkbox: index$1e,
    chip: index$1d,
    colorpicker: index$1c,
    confirmdialog: index$1b,
    confirmpopup: index$1a,
    contextmenu: index$19,
    dataview: index$17,
    datatable: index$18,
    dialog: index$15,
    divider: index$14,
    dock: index$13,
    drawer: index$12,
    editor: index$11,
    fieldset: index$10,
    fileupload: index$$,
    iftalabel: index$X,
    floatlabel: index$_,
    galleria: index$Z,
    iconfield: index$Y,
    image: index$W,
    imagecompare: index$V,
    inlinemessage: index$U,
    inplace: index$T,
    inputchips: index$S,
    inputgroup: index$R,
    inputnumber: index$Q,
    inputtext: index$P,
    knob: index$O,
    listbox: index$N,
    megamenu: index$M,
    menu: index$L,
    menubar: index$K,
    message: index$J,
    metergroup: index$I,
    multiselect: index$H,
    orderlist: index$G,
    organizationchart: index$F,
    overlaybadge: index$E,
    popover: index$y,
    paginator: index$D,
    password: index$A,
    panel: index$C,
    panelmenu: index$B,
    picklist: index$z,
    progressbar: index$x,
    progressspinner: index$w,
    radiobutton: index$v,
    rating: index$u,
    scrollpanel: index$s,
    select: index$r,
    selectbutton: index$q,
    skeleton: index$p,
    slider: index$o,
    speeddial: index$n,
    splitter: index$l,
    splitbutton: index$m,
    stepper: index$k,
    steps: index$j,
    tabmenu: index$i,
    tabs: index$h,
    tabview: index$g,
    textarea: index$d,
    tieredmenu: index$c,
    tag: index$f,
    terminal: index$e,
    timeline: index$b,
    togglebutton: index$9,
    toggleswitch: index$8,
    tree: index$5,
    treeselect: index$4,
    treetable: index$3,
    toast: index$a,
    toolbar: index$7,
    virtualscroller: index$2
  },
  directives: {
    tooltip: index$6,
    ripple: index$t
  }
});
const MorphosisPreset = definePreset(index$1, {});
var diffMatchPatch = { exports: {} };
(function(module) {
  var diff_match_patch2 = function() {
    this.Diff_Timeout = 1;
    this.Diff_EditCost = 4;
    this.Match_Threshold = 0.5;
    this.Match_Distance = 1e3;
    this.Patch_DeleteThreshold = 0.5;
    this.Patch_Margin = 4;
    this.Match_MaxBits = 32;
  };
  var DIFF_DELETE = -1;
  var DIFF_INSERT = 1;
  var DIFF_EQUAL = 0;
  diff_match_patch2.Diff = function(op, text) {
    return [op, text];
  };
  diff_match_patch2.prototype.diff_main = function(text1, text2, opt_checklines, opt_deadline) {
    if (typeof opt_deadline == "undefined") {
      if (this.Diff_Timeout <= 0) {
        opt_deadline = Number.MAX_VALUE;
      } else {
        opt_deadline = (/* @__PURE__ */ new Date()).getTime() + this.Diff_Timeout * 1e3;
      }
    }
    var deadline = opt_deadline;
    if (text1 == null || text2 == null) {
      throw new Error("Null input. (diff_main)");
    }
    if (text1 == text2) {
      if (text1) {
        return [new diff_match_patch2.Diff(DIFF_EQUAL, text1)];
      }
      return [];
    }
    if (typeof opt_checklines == "undefined") {
      opt_checklines = true;
    }
    var checklines = opt_checklines;
    var commonlength = this.diff_commonPrefix(text1, text2);
    var commonprefix = text1.substring(0, commonlength);
    text1 = text1.substring(commonlength);
    text2 = text2.substring(commonlength);
    commonlength = this.diff_commonSuffix(text1, text2);
    var commonsuffix = text1.substring(text1.length - commonlength);
    text1 = text1.substring(0, text1.length - commonlength);
    text2 = text2.substring(0, text2.length - commonlength);
    var diffs = this.diff_compute_(text1, text2, checklines, deadline);
    if (commonprefix) {
      diffs.unshift(new diff_match_patch2.Diff(DIFF_EQUAL, commonprefix));
    }
    if (commonsuffix) {
      diffs.push(new diff_match_patch2.Diff(DIFF_EQUAL, commonsuffix));
    }
    this.diff_cleanupMerge(diffs);
    return diffs;
  };
  diff_match_patch2.prototype.diff_compute_ = function(text1, text2, checklines, deadline) {
    var diffs;
    if (!text1) {
      return [new diff_match_patch2.Diff(DIFF_INSERT, text2)];
    }
    if (!text2) {
      return [new diff_match_patch2.Diff(DIFF_DELETE, text1)];
    }
    var longtext = text1.length > text2.length ? text1 : text2;
    var shorttext = text1.length > text2.length ? text2 : text1;
    var i = longtext.indexOf(shorttext);
    if (i != -1) {
      diffs = [
        new diff_match_patch2.Diff(DIFF_INSERT, longtext.substring(0, i)),
        new diff_match_patch2.Diff(DIFF_EQUAL, shorttext),
        new diff_match_patch2.Diff(
          DIFF_INSERT,
          longtext.substring(i + shorttext.length)
        )
      ];
      if (text1.length > text2.length) {
        diffs[0][0] = diffs[2][0] = DIFF_DELETE;
      }
      return diffs;
    }
    if (shorttext.length == 1) {
      return [
        new diff_match_patch2.Diff(DIFF_DELETE, text1),
        new diff_match_patch2.Diff(DIFF_INSERT, text2)
      ];
    }
    var hm = this.diff_halfMatch_(text1, text2);
    if (hm) {
      var text1_a = hm[0];
      var text1_b = hm[1];
      var text2_a = hm[2];
      var text2_b = hm[3];
      var mid_common = hm[4];
      var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
      var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
      return diffs_a.concat(
        [new diff_match_patch2.Diff(DIFF_EQUAL, mid_common)],
        diffs_b
      );
    }
    if (checklines && text1.length > 100 && text2.length > 100) {
      return this.diff_lineMode_(text1, text2, deadline);
    }
    return this.diff_bisect_(text1, text2, deadline);
  };
  diff_match_patch2.prototype.diff_lineMode_ = function(text1, text2, deadline) {
    var a = this.diff_linesToChars_(text1, text2);
    text1 = a.chars1;
    text2 = a.chars2;
    var linearray = a.lineArray;
    var diffs = this.diff_main(text1, text2, false, deadline);
    this.diff_charsToLines_(diffs, linearray);
    this.diff_cleanupSemantic(diffs);
    diffs.push(new diff_match_patch2.Diff(DIFF_EQUAL, ""));
    var pointer = 0;
    var count_delete = 0;
    var count_insert = 0;
    var text_delete = "";
    var text_insert = "";
    while (pointer < diffs.length) {
      switch (diffs[pointer][0]) {
        case DIFF_INSERT:
          count_insert++;
          text_insert += diffs[pointer][1];
          break;
        case DIFF_DELETE:
          count_delete++;
          text_delete += diffs[pointer][1];
          break;
        case DIFF_EQUAL:
          if (count_delete >= 1 && count_insert >= 1) {
            diffs.splice(
              pointer - count_delete - count_insert,
              count_delete + count_insert
            );
            pointer = pointer - count_delete - count_insert;
            var subDiff = this.diff_main(text_delete, text_insert, false, deadline);
            for (var j = subDiff.length - 1; j >= 0; j--) {
              diffs.splice(pointer, 0, subDiff[j]);
            }
            pointer = pointer + subDiff.length;
          }
          count_insert = 0;
          count_delete = 0;
          text_delete = "";
          text_insert = "";
          break;
      }
      pointer++;
    }
    diffs.pop();
    return diffs;
  };
  diff_match_patch2.prototype.diff_bisect_ = function(text1, text2, deadline) {
    var text1_length = text1.length;
    var text2_length = text2.length;
    var max_d = Math.ceil((text1_length + text2_length) / 2);
    var v_offset = max_d;
    var v_length = 2 * max_d;
    var v1 = new Array(v_length);
    var v2 = new Array(v_length);
    for (var x = 0; x < v_length; x++) {
      v1[x] = -1;
      v2[x] = -1;
    }
    v1[v_offset + 1] = 0;
    v2[v_offset + 1] = 0;
    var delta = text1_length - text2_length;
    var front = delta % 2 != 0;
    var k1start = 0;
    var k1end = 0;
    var k2start = 0;
    var k2end = 0;
    for (var d = 0; d < max_d; d++) {
      if ((/* @__PURE__ */ new Date()).getTime() > deadline) {
        break;
      }
      for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
        var k1_offset = v_offset + k1;
        var x1;
        if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
          x1 = v1[k1_offset + 1];
        } else {
          x1 = v1[k1_offset - 1] + 1;
        }
        var y1 = x1 - k1;
        while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {
          x1++;
          y1++;
        }
        v1[k1_offset] = x1;
        if (x1 > text1_length) {
          k1end += 2;
        } else if (y1 > text2_length) {
          k1start += 2;
        } else if (front) {
          var k2_offset = v_offset + delta - k1;
          if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
            var x2 = text1_length - v2[k2_offset];
            if (x1 >= x2) {
              return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
            }
          }
        }
      }
      for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
        var k2_offset = v_offset + k2;
        var x2;
        if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
          x2 = v2[k2_offset + 1];
        } else {
          x2 = v2[k2_offset - 1] + 1;
        }
        var y2 = x2 - k2;
        while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text2.charAt(text2_length - y2 - 1)) {
          x2++;
          y2++;
        }
        v2[k2_offset] = x2;
        if (x2 > text1_length) {
          k2end += 2;
        } else if (y2 > text2_length) {
          k2start += 2;
        } else if (!front) {
          var k1_offset = v_offset + delta - k2;
          if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
            var x1 = v1[k1_offset];
            var y1 = v_offset + x1 - k1_offset;
            x2 = text1_length - x2;
            if (x1 >= x2) {
              return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
            }
          }
        }
      }
    }
    return [
      new diff_match_patch2.Diff(DIFF_DELETE, text1),
      new diff_match_patch2.Diff(DIFF_INSERT, text2)
    ];
  };
  diff_match_patch2.prototype.diff_bisectSplit_ = function(text1, text2, x, y, deadline) {
    var text1a = text1.substring(0, x);
    var text2a = text2.substring(0, y);
    var text1b = text1.substring(x);
    var text2b = text2.substring(y);
    var diffs = this.diff_main(text1a, text2a, false, deadline);
    var diffsb = this.diff_main(text1b, text2b, false, deadline);
    return diffs.concat(diffsb);
  };
  diff_match_patch2.prototype.diff_linesToChars_ = function(text1, text2) {
    var lineArray = [];
    var lineHash = {};
    lineArray[0] = "";
    function diff_linesToCharsMunge_(text) {
      var chars = "";
      var lineStart = 0;
      var lineEnd = -1;
      var lineArrayLength = lineArray.length;
      while (lineEnd < text.length - 1) {
        lineEnd = text.indexOf("\n", lineStart);
        if (lineEnd == -1) {
          lineEnd = text.length - 1;
        }
        var line = text.substring(lineStart, lineEnd + 1);
        if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) {
          chars += String.fromCharCode(lineHash[line]);
        } else {
          if (lineArrayLength == maxLines) {
            line = text.substring(lineStart);
            lineEnd = text.length;
          }
          chars += String.fromCharCode(lineArrayLength);
          lineHash[line] = lineArrayLength;
          lineArray[lineArrayLength++] = line;
        }
        lineStart = lineEnd + 1;
      }
      return chars;
    }
    var maxLines = 4e4;
    var chars1 = diff_linesToCharsMunge_(text1);
    maxLines = 65535;
    var chars2 = diff_linesToCharsMunge_(text2);
    return { chars1, chars2, lineArray };
  };
  diff_match_patch2.prototype.diff_charsToLines_ = function(diffs, lineArray) {
    for (var i = 0; i < diffs.length; i++) {
      var chars = diffs[i][1];
      var text = [];
      for (var j = 0; j < chars.length; j++) {
        text[j] = lineArray[chars.charCodeAt(j)];
      }
      diffs[i][1] = text.join("");
    }
  };
  diff_match_patch2.prototype.diff_commonPrefix = function(text1, text2) {
    if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
      return 0;
    }
    var pointermin = 0;
    var pointermax = Math.min(text1.length, text2.length);
    var pointermid = pointermax;
    var pointerstart = 0;
    while (pointermin < pointermid) {
      if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
        pointermin = pointermid;
        pointerstart = pointermin;
      } else {
        pointermax = pointermid;
      }
      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    }
    return pointermid;
  };
  diff_match_patch2.prototype.diff_commonSuffix = function(text1, text2) {
    if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
      return 0;
    }
    var pointermin = 0;
    var pointermax = Math.min(text1.length, text2.length);
    var pointermid = pointermax;
    var pointerend = 0;
    while (pointermin < pointermid) {
      if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
        pointermin = pointermid;
        pointerend = pointermin;
      } else {
        pointermax = pointermid;
      }
      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    }
    return pointermid;
  };
  diff_match_patch2.prototype.diff_commonOverlap_ = function(text1, text2) {
    var text1_length = text1.length;
    var text2_length = text2.length;
    if (text1_length == 0 || text2_length == 0) {
      return 0;
    }
    if (text1_length > text2_length) {
      text1 = text1.substring(text1_length - text2_length);
    } else if (text1_length < text2_length) {
      text2 = text2.substring(0, text1_length);
    }
    var text_length = Math.min(text1_length, text2_length);
    if (text1 == text2) {
      return text_length;
    }
    var best = 0;
    var length = 1;
    while (true) {
      var pattern = text1.substring(text_length - length);
      var found = text2.indexOf(pattern);
      if (found == -1) {
        return best;
      }
      length += found;
      if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {
        best = length;
        length++;
      }
    }
  };
  diff_match_patch2.prototype.diff_halfMatch_ = function(text1, text2) {
    if (this.Diff_Timeout <= 0) {
      return null;
    }
    var longtext = text1.length > text2.length ? text1 : text2;
    var shorttext = text1.length > text2.length ? text2 : text1;
    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
      return null;
    }
    var dmp2 = this;
    function diff_halfMatchI_(longtext2, shorttext2, i) {
      var seed2 = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
      var j = -1;
      var best_common = "";
      var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
      while ((j = shorttext2.indexOf(seed2, j + 1)) != -1) {
        var prefixLength = dmp2.diff_commonPrefix(
          longtext2.substring(i),
          shorttext2.substring(j)
        );
        var suffixLength = dmp2.diff_commonSuffix(
          longtext2.substring(0, i),
          shorttext2.substring(0, j)
        );
        if (best_common.length < suffixLength + prefixLength) {
          best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
          best_longtext_a = longtext2.substring(0, i - suffixLength);
          best_longtext_b = longtext2.substring(i + prefixLength);
          best_shorttext_a = shorttext2.substring(0, j - suffixLength);
          best_shorttext_b = shorttext2.substring(j + prefixLength);
        }
      }
      if (best_common.length * 2 >= longtext2.length) {
        return [
          best_longtext_a,
          best_longtext_b,
          best_shorttext_a,
          best_shorttext_b,
          best_common
        ];
      } else {
        return null;
      }
    }
    var hm1 = diff_halfMatchI_(
      longtext,
      shorttext,
      Math.ceil(longtext.length / 4)
    );
    var hm2 = diff_halfMatchI_(
      longtext,
      shorttext,
      Math.ceil(longtext.length / 2)
    );
    var hm;
    if (!hm1 && !hm2) {
      return null;
    } else if (!hm2) {
      hm = hm1;
    } else if (!hm1) {
      hm = hm2;
    } else {
      hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
    }
    var text1_a, text1_b, text2_a, text2_b;
    if (text1.length > text2.length) {
      text1_a = hm[0];
      text1_b = hm[1];
      text2_a = hm[2];
      text2_b = hm[3];
    } else {
      text2_a = hm[0];
      text2_b = hm[1];
      text1_a = hm[2];
      text1_b = hm[3];
    }
    var mid_common = hm[4];
    return [text1_a, text1_b, text2_a, text2_b, mid_common];
  };
  diff_match_patch2.prototype.diff_cleanupSemantic = function(diffs) {
    var changes = false;
    var equalities = [];
    var equalitiesLength = 0;
    var lastEquality = null;
    var pointer = 0;
    var length_insertions1 = 0;
    var length_deletions1 = 0;
    var length_insertions2 = 0;
    var length_deletions2 = 0;
    while (pointer < diffs.length) {
      if (diffs[pointer][0] == DIFF_EQUAL) {
        equalities[equalitiesLength++] = pointer;
        length_insertions1 = length_insertions2;
        length_deletions1 = length_deletions2;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastEquality = diffs[pointer][1];
      } else {
        if (diffs[pointer][0] == DIFF_INSERT) {
          length_insertions2 += diffs[pointer][1].length;
        } else {
          length_deletions2 += diffs[pointer][1].length;
        }
        if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(
          length_insertions2,
          length_deletions2
        )) {
          diffs.splice(
            equalities[equalitiesLength - 1],
            0,
            new diff_match_patch2.Diff(DIFF_DELETE, lastEquality)
          );
          diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
          equalitiesLength--;
          equalitiesLength--;
          pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
          length_insertions1 = 0;
          length_deletions1 = 0;
          length_insertions2 = 0;
          length_deletions2 = 0;
          lastEquality = null;
          changes = true;
        }
      }
      pointer++;
    }
    if (changes) {
      this.diff_cleanupMerge(diffs);
    }
    this.diff_cleanupSemanticLossless(diffs);
    pointer = 1;
    while (pointer < diffs.length) {
      if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {
        var deletion = diffs[pointer - 1][1];
        var insertion = diffs[pointer][1];
        var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
        var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
        if (overlap_length1 >= overlap_length2) {
          if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
            diffs.splice(pointer, 0, new diff_match_patch2.Diff(
              DIFF_EQUAL,
              insertion.substring(0, overlap_length1)
            ));
            diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
            diffs[pointer + 1][1] = insertion.substring(overlap_length1);
            pointer++;
          }
        } else {
          if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
            diffs.splice(pointer, 0, new diff_match_patch2.Diff(
              DIFF_EQUAL,
              deletion.substring(0, overlap_length2)
            ));
            diffs[pointer - 1][0] = DIFF_INSERT;
            diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
            diffs[pointer + 1][0] = DIFF_DELETE;
            diffs[pointer + 1][1] = deletion.substring(overlap_length2);
            pointer++;
          }
        }
        pointer++;
      }
      pointer++;
    }
  };
  diff_match_patch2.prototype.diff_cleanupSemanticLossless = function(diffs) {
    function diff_cleanupSemanticScore_(one, two) {
      if (!one || !two) {
        return 6;
      }
      var char1 = one.charAt(one.length - 1);
      var char2 = two.charAt(0);
      var nonAlphaNumeric1 = char1.match(diff_match_patch2.nonAlphaNumericRegex_);
      var nonAlphaNumeric2 = char2.match(diff_match_patch2.nonAlphaNumericRegex_);
      var whitespace1 = nonAlphaNumeric1 && char1.match(diff_match_patch2.whitespaceRegex_);
      var whitespace2 = nonAlphaNumeric2 && char2.match(diff_match_patch2.whitespaceRegex_);
      var lineBreak1 = whitespace1 && char1.match(diff_match_patch2.linebreakRegex_);
      var lineBreak2 = whitespace2 && char2.match(diff_match_patch2.linebreakRegex_);
      var blankLine1 = lineBreak1 && one.match(diff_match_patch2.blanklineEndRegex_);
      var blankLine2 = lineBreak2 && two.match(diff_match_patch2.blanklineStartRegex_);
      if (blankLine1 || blankLine2) {
        return 5;
      } else if (lineBreak1 || lineBreak2) {
        return 4;
      } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
        return 3;
      } else if (whitespace1 || whitespace2) {
        return 2;
      } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
        return 1;
      }
      return 0;
    }
    var pointer = 1;
    while (pointer < diffs.length - 1) {
      if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
        var equality1 = diffs[pointer - 1][1];
        var edit = diffs[pointer][1];
        var equality2 = diffs[pointer + 1][1];
        var commonOffset = this.diff_commonSuffix(equality1, edit);
        if (commonOffset) {
          var commonString = edit.substring(edit.length - commonOffset);
          equality1 = equality1.substring(0, equality1.length - commonOffset);
          edit = commonString + edit.substring(0, edit.length - commonOffset);
          equality2 = commonString + equality2;
        }
        var bestEquality1 = equality1;
        var bestEdit = edit;
        var bestEquality2 = equality2;
        var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
        while (edit.charAt(0) === equality2.charAt(0)) {
          equality1 += edit.charAt(0);
          edit = edit.substring(1) + equality2.charAt(0);
          equality2 = equality2.substring(1);
          var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
          if (score >= bestScore) {
            bestScore = score;
            bestEquality1 = equality1;
            bestEdit = edit;
            bestEquality2 = equality2;
          }
        }
        if (diffs[pointer - 1][1] != bestEquality1) {
          if (bestEquality1) {
            diffs[pointer - 1][1] = bestEquality1;
          } else {
            diffs.splice(pointer - 1, 1);
            pointer--;
          }
          diffs[pointer][1] = bestEdit;
          if (bestEquality2) {
            diffs[pointer + 1][1] = bestEquality2;
          } else {
            diffs.splice(pointer + 1, 1);
            pointer--;
          }
        }
      }
      pointer++;
    }
  };
  diff_match_patch2.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
  diff_match_patch2.whitespaceRegex_ = /\s/;
  diff_match_patch2.linebreakRegex_ = /[\r\n]/;
  diff_match_patch2.blanklineEndRegex_ = /\n\r?\n$/;
  diff_match_patch2.blanklineStartRegex_ = /^\r?\n\r?\n/;
  diff_match_patch2.prototype.diff_cleanupEfficiency = function(diffs) {
    var changes = false;
    var equalities = [];
    var equalitiesLength = 0;
    var lastEquality = null;
    var pointer = 0;
    var pre_ins = false;
    var pre_del = false;
    var post_ins = false;
    var post_del = false;
    while (pointer < diffs.length) {
      if (diffs[pointer][0] == DIFF_EQUAL) {
        if (diffs[pointer][1].length < this.Diff_EditCost && (post_ins || post_del)) {
          equalities[equalitiesLength++] = pointer;
          pre_ins = post_ins;
          pre_del = post_del;
          lastEquality = diffs[pointer][1];
        } else {
          equalitiesLength = 0;
          lastEquality = null;
        }
        post_ins = post_del = false;
      } else {
        if (diffs[pointer][0] == DIFF_DELETE) {
          post_del = true;
        } else {
          post_ins = true;
        }
        if (lastEquality && (pre_ins && pre_del && post_ins && post_del || lastEquality.length < this.Diff_EditCost / 2 && pre_ins + pre_del + post_ins + post_del == 3)) {
          diffs.splice(
            equalities[equalitiesLength - 1],
            0,
            new diff_match_patch2.Diff(DIFF_DELETE, lastEquality)
          );
          diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
          equalitiesLength--;
          lastEquality = null;
          if (pre_ins && pre_del) {
            post_ins = post_del = true;
            equalitiesLength = 0;
          } else {
            equalitiesLength--;
            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
            post_ins = post_del = false;
          }
          changes = true;
        }
      }
      pointer++;
    }
    if (changes) {
      this.diff_cleanupMerge(diffs);
    }
  };
  diff_match_patch2.prototype.diff_cleanupMerge = function(diffs) {
    diffs.push(new diff_match_patch2.Diff(DIFF_EQUAL, ""));
    var pointer = 0;
    var count_delete = 0;
    var count_insert = 0;
    var text_delete = "";
    var text_insert = "";
    var commonlength;
    while (pointer < diffs.length) {
      switch (diffs[pointer][0]) {
        case DIFF_INSERT:
          count_insert++;
          text_insert += diffs[pointer][1];
          pointer++;
          break;
        case DIFF_DELETE:
          count_delete++;
          text_delete += diffs[pointer][1];
          pointer++;
          break;
        case DIFF_EQUAL:
          if (count_delete + count_insert > 1) {
            if (count_delete !== 0 && count_insert !== 0) {
              commonlength = this.diff_commonPrefix(text_insert, text_delete);
              if (commonlength !== 0) {
                if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                  diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                } else {
                  diffs.splice(0, 0, new diff_match_patch2.Diff(
                    DIFF_EQUAL,
                    text_insert.substring(0, commonlength)
                  ));
                  pointer++;
                }
                text_insert = text_insert.substring(commonlength);
                text_delete = text_delete.substring(commonlength);
              }
              commonlength = this.diff_commonSuffix(text_insert, text_delete);
              if (commonlength !== 0) {
                diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                text_insert = text_insert.substring(0, text_insert.length - commonlength);
                text_delete = text_delete.substring(0, text_delete.length - commonlength);
              }
            }
            pointer -= count_delete + count_insert;
            diffs.splice(pointer, count_delete + count_insert);
            if (text_delete.length) {
              diffs.splice(
                pointer,
                0,
                new diff_match_patch2.Diff(DIFF_DELETE, text_delete)
              );
              pointer++;
            }
            if (text_insert.length) {
              diffs.splice(
                pointer,
                0,
                new diff_match_patch2.Diff(DIFF_INSERT, text_insert)
              );
              pointer++;
            }
            pointer++;
          } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
            diffs[pointer - 1][1] += diffs[pointer][1];
            diffs.splice(pointer, 1);
          } else {
            pointer++;
          }
          count_insert = 0;
          count_delete = 0;
          text_delete = "";
          text_insert = "";
          break;
      }
    }
    if (diffs[diffs.length - 1][1] === "") {
      diffs.pop();
    }
    var changes = false;
    pointer = 1;
    while (pointer < diffs.length - 1) {
      if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
        if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
          diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
          diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
          diffs.splice(pointer - 1, 1);
          changes = true;
        } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
          diffs[pointer - 1][1] += diffs[pointer + 1][1];
          diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
          diffs.splice(pointer + 1, 1);
          changes = true;
        }
      }
      pointer++;
    }
    if (changes) {
      this.diff_cleanupMerge(diffs);
    }
  };
  diff_match_patch2.prototype.diff_xIndex = function(diffs, loc2) {
    var chars1 = 0;
    var chars2 = 0;
    var last_chars1 = 0;
    var last_chars2 = 0;
    var x;
    for (x = 0; x < diffs.length; x++) {
      if (diffs[x][0] !== DIFF_INSERT) {
        chars1 += diffs[x][1].length;
      }
      if (diffs[x][0] !== DIFF_DELETE) {
        chars2 += diffs[x][1].length;
      }
      if (chars1 > loc2) {
        break;
      }
      last_chars1 = chars1;
      last_chars2 = chars2;
    }
    if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
      return last_chars2;
    }
    return last_chars2 + (loc2 - last_chars1);
  };
  diff_match_patch2.prototype.diff_prettyHtml = function(diffs) {
    var html = [];
    var pattern_amp = /&/g;
    var pattern_lt = /</g;
    var pattern_gt = />/g;
    var pattern_para = /\n/g;
    for (var x = 0; x < diffs.length; x++) {
      var op = diffs[x][0];
      var data = diffs[x][1];
      var text = data.replace(pattern_amp, "&amp;").replace(pattern_lt, "&lt;").replace(pattern_gt, "&gt;").replace(pattern_para, "&para;<br>");
      switch (op) {
        case DIFF_INSERT:
          html[x] = '<ins style="background:#e6ffe6;">' + text + "</ins>";
          break;
        case DIFF_DELETE:
          html[x] = '<del style="background:#ffe6e6;">' + text + "</del>";
          break;
        case DIFF_EQUAL:
          html[x] = "<span>" + text + "</span>";
          break;
      }
    }
    return html.join("");
  };
  diff_match_patch2.prototype.diff_text1 = function(diffs) {
    var text = [];
    for (var x = 0; x < diffs.length; x++) {
      if (diffs[x][0] !== DIFF_INSERT) {
        text[x] = diffs[x][1];
      }
    }
    return text.join("");
  };
  diff_match_patch2.prototype.diff_text2 = function(diffs) {
    var text = [];
    for (var x = 0; x < diffs.length; x++) {
      if (diffs[x][0] !== DIFF_DELETE) {
        text[x] = diffs[x][1];
      }
    }
    return text.join("");
  };
  diff_match_patch2.prototype.diff_levenshtein = function(diffs) {
    var levenshtein = 0;
    var insertions = 0;
    var deletions = 0;
    for (var x = 0; x < diffs.length; x++) {
      var op = diffs[x][0];
      var data = diffs[x][1];
      switch (op) {
        case DIFF_INSERT:
          insertions += data.length;
          break;
        case DIFF_DELETE:
          deletions += data.length;
          break;
        case DIFF_EQUAL:
          levenshtein += Math.max(insertions, deletions);
          insertions = 0;
          deletions = 0;
          break;
      }
    }
    levenshtein += Math.max(insertions, deletions);
    return levenshtein;
  };
  diff_match_patch2.prototype.diff_toDelta = function(diffs) {
    var text = [];
    for (var x = 0; x < diffs.length; x++) {
      switch (diffs[x][0]) {
        case DIFF_INSERT:
          text[x] = "+" + encodeURI(diffs[x][1]);
          break;
        case DIFF_DELETE:
          text[x] = "-" + diffs[x][1].length;
          break;
        case DIFF_EQUAL:
          text[x] = "=" + diffs[x][1].length;
          break;
      }
    }
    return text.join("	").replace(/%20/g, " ");
  };
  diff_match_patch2.prototype.diff_fromDelta = function(text1, delta) {
    var diffs = [];
    var diffsLength = 0;
    var pointer = 0;
    var tokens2 = delta.split(/\t/g);
    for (var x = 0; x < tokens2.length; x++) {
      var param = tokens2[x].substring(1);
      switch (tokens2[x].charAt(0)) {
        case "+":
          try {
            diffs[diffsLength++] = new diff_match_patch2.Diff(DIFF_INSERT, decodeURI(param));
          } catch (ex) {
            throw new Error("Illegal escape in diff_fromDelta: " + param);
          }
          break;
        case "-":
        case "=":
          var n = parseInt(param, 10);
          if (isNaN(n) || n < 0) {
            throw new Error("Invalid number in diff_fromDelta: " + param);
          }
          var text = text1.substring(pointer, pointer += n);
          if (tokens2[x].charAt(0) == "=") {
            diffs[diffsLength++] = new diff_match_patch2.Diff(DIFF_EQUAL, text);
          } else {
            diffs[diffsLength++] = new diff_match_patch2.Diff(DIFF_DELETE, text);
          }
          break;
        default:
          if (tokens2[x]) {
            throw new Error("Invalid diff operation in diff_fromDelta: " + tokens2[x]);
          }
      }
    }
    if (pointer != text1.length) {
      throw new Error("Delta length (" + pointer + ") does not equal source text length (" + text1.length + ").");
    }
    return diffs;
  };
  diff_match_patch2.prototype.match_main = function(text, pattern, loc2) {
    if (text == null || pattern == null || loc2 == null) {
      throw new Error("Null input. (match_main)");
    }
    loc2 = Math.max(0, Math.min(loc2, text.length));
    if (text == pattern) {
      return 0;
    } else if (!text.length) {
      return -1;
    } else if (text.substring(loc2, loc2 + pattern.length) == pattern) {
      return loc2;
    } else {
      return this.match_bitap_(text, pattern, loc2);
    }
  };
  diff_match_patch2.prototype.match_bitap_ = function(text, pattern, loc2) {
    if (pattern.length > this.Match_MaxBits) {
      throw new Error("Pattern too long for this browser.");
    }
    var s = this.match_alphabet_(pattern);
    var dmp2 = this;
    function match_bitapScore_(e2, x) {
      var accuracy = e2 / pattern.length;
      var proximity = Math.abs(loc2 - x);
      if (!dmp2.Match_Distance) {
        return proximity ? 1 : accuracy;
      }
      return accuracy + proximity / dmp2.Match_Distance;
    }
    var score_threshold = this.Match_Threshold;
    var best_loc = text.indexOf(pattern, loc2);
    if (best_loc != -1) {
      score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
      best_loc = text.lastIndexOf(pattern, loc2 + pattern.length);
      if (best_loc != -1) {
        score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
      }
    }
    var matchmask = 1 << pattern.length - 1;
    best_loc = -1;
    var bin_min, bin_mid;
    var bin_max = pattern.length + text.length;
    var last_rd;
    for (var d = 0; d < pattern.length; d++) {
      bin_min = 0;
      bin_mid = bin_max;
      while (bin_min < bin_mid) {
        if (match_bitapScore_(d, loc2 + bin_mid) <= score_threshold) {
          bin_min = bin_mid;
        } else {
          bin_max = bin_mid;
        }
        bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
      }
      bin_max = bin_mid;
      var start = Math.max(1, loc2 - bin_mid + 1);
      var finish = Math.min(loc2 + bin_mid, text.length) + pattern.length;
      var rd = Array(finish + 2);
      rd[finish + 1] = (1 << d) - 1;
      for (var j = finish; j >= start; j--) {
        var charMatch = s[text.charAt(j - 1)];
        if (d === 0) {
          rd[j] = (rd[j + 1] << 1 | 1) & charMatch;
        } else {
          rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((last_rd[j + 1] | last_rd[j]) << 1 | 1) | last_rd[j + 1];
        }
        if (rd[j] & matchmask) {
          var score = match_bitapScore_(d, j - 1);
          if (score <= score_threshold) {
            score_threshold = score;
            best_loc = j - 1;
            if (best_loc > loc2) {
              start = Math.max(1, 2 * loc2 - best_loc);
            } else {
              break;
            }
          }
        }
      }
      if (match_bitapScore_(d + 1, loc2) > score_threshold) {
        break;
      }
      last_rd = rd;
    }
    return best_loc;
  };
  diff_match_patch2.prototype.match_alphabet_ = function(pattern) {
    var s = {};
    for (var i = 0; i < pattern.length; i++) {
      s[pattern.charAt(i)] = 0;
    }
    for (var i = 0; i < pattern.length; i++) {
      s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;
    }
    return s;
  };
  diff_match_patch2.prototype.patch_addContext_ = function(patch, text) {
    if (text.length == 0) {
      return;
    }
    if (patch.start2 === null) {
      throw Error("patch not initialized");
    }
    var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
    var padding = 0;
    while (text.indexOf(pattern) != text.lastIndexOf(pattern) && pattern.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin) {
      padding += this.Patch_Margin;
      pattern = text.substring(
        patch.start2 - padding,
        patch.start2 + patch.length1 + padding
      );
    }
    padding += this.Patch_Margin;
    var prefix = text.substring(patch.start2 - padding, patch.start2);
    if (prefix) {
      patch.diffs.unshift(new diff_match_patch2.Diff(DIFF_EQUAL, prefix));
    }
    var suffix = text.substring(
      patch.start2 + patch.length1,
      patch.start2 + patch.length1 + padding
    );
    if (suffix) {
      patch.diffs.push(new diff_match_patch2.Diff(DIFF_EQUAL, suffix));
    }
    patch.start1 -= prefix.length;
    patch.start2 -= prefix.length;
    patch.length1 += prefix.length + suffix.length;
    patch.length2 += prefix.length + suffix.length;
  };
  diff_match_patch2.prototype.patch_make = function(a, opt_b, opt_c) {
    var text1, diffs;
    if (typeof a == "string" && typeof opt_b == "string" && typeof opt_c == "undefined") {
      text1 = /** @type {string} */
      a;
      diffs = this.diff_main(
        text1,
        /** @type {string} */
        opt_b,
        true
      );
      if (diffs.length > 2) {
        this.diff_cleanupSemantic(diffs);
        this.diff_cleanupEfficiency(diffs);
      }
    } else if (a && typeof a == "object" && typeof opt_b == "undefined" && typeof opt_c == "undefined") {
      diffs = /** @type {!Array.<!diff_match_patch.Diff>} */
      a;
      text1 = this.diff_text1(diffs);
    } else if (typeof a == "string" && opt_b && typeof opt_b == "object" && typeof opt_c == "undefined") {
      text1 = /** @type {string} */
      a;
      diffs = /** @type {!Array.<!diff_match_patch.Diff>} */
      opt_b;
    } else if (typeof a == "string" && typeof opt_b == "string" && opt_c && typeof opt_c == "object") {
      text1 = /** @type {string} */
      a;
      diffs = /** @type {!Array.<!diff_match_patch.Diff>} */
      opt_c;
    } else {
      throw new Error("Unknown call format to patch_make.");
    }
    if (diffs.length === 0) {
      return [];
    }
    var patches = [];
    var patch = new diff_match_patch2.patch_obj();
    var patchDiffLength = 0;
    var char_count1 = 0;
    var char_count2 = 0;
    var prepatch_text = text1;
    var postpatch_text = text1;
    for (var x = 0; x < diffs.length; x++) {
      var diff_type = diffs[x][0];
      var diff_text = diffs[x][1];
      if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
        patch.start1 = char_count1;
        patch.start2 = char_count2;
      }
      switch (diff_type) {
        case DIFF_INSERT:
          patch.diffs[patchDiffLength++] = diffs[x];
          patch.length2 += diff_text.length;
          postpatch_text = postpatch_text.substring(0, char_count2) + diff_text + postpatch_text.substring(char_count2);
          break;
        case DIFF_DELETE:
          patch.length1 += diff_text.length;
          patch.diffs[patchDiffLength++] = diffs[x];
          postpatch_text = postpatch_text.substring(0, char_count2) + postpatch_text.substring(char_count2 + diff_text.length);
          break;
        case DIFF_EQUAL:
          if (diff_text.length <= 2 * this.Patch_Margin && patchDiffLength && diffs.length != x + 1) {
            patch.diffs[patchDiffLength++] = diffs[x];
            patch.length1 += diff_text.length;
            patch.length2 += diff_text.length;
          } else if (diff_text.length >= 2 * this.Patch_Margin) {
            if (patchDiffLength) {
              this.patch_addContext_(patch, prepatch_text);
              patches.push(patch);
              patch = new diff_match_patch2.patch_obj();
              patchDiffLength = 0;
              prepatch_text = postpatch_text;
              char_count1 = char_count2;
            }
          }
          break;
      }
      if (diff_type !== DIFF_INSERT) {
        char_count1 += diff_text.length;
      }
      if (diff_type !== DIFF_DELETE) {
        char_count2 += diff_text.length;
      }
    }
    if (patchDiffLength) {
      this.patch_addContext_(patch, prepatch_text);
      patches.push(patch);
    }
    return patches;
  };
  diff_match_patch2.prototype.patch_deepCopy = function(patches) {
    var patchesCopy = [];
    for (var x = 0; x < patches.length; x++) {
      var patch = patches[x];
      var patchCopy = new diff_match_patch2.patch_obj();
      patchCopy.diffs = [];
      for (var y = 0; y < patch.diffs.length; y++) {
        patchCopy.diffs[y] = new diff_match_patch2.Diff(patch.diffs[y][0], patch.diffs[y][1]);
      }
      patchCopy.start1 = patch.start1;
      patchCopy.start2 = patch.start2;
      patchCopy.length1 = patch.length1;
      patchCopy.length2 = patch.length2;
      patchesCopy[x] = patchCopy;
    }
    return patchesCopy;
  };
  diff_match_patch2.prototype.patch_apply = function(patches, text) {
    if (patches.length == 0) {
      return [text, []];
    }
    patches = this.patch_deepCopy(patches);
    var nullPadding = this.patch_addPadding(patches);
    text = nullPadding + text + nullPadding;
    this.patch_splitMax(patches);
    var delta = 0;
    var results = [];
    for (var x = 0; x < patches.length; x++) {
      var expected_loc = patches[x].start2 + delta;
      var text1 = this.diff_text1(patches[x].diffs);
      var start_loc;
      var end_loc = -1;
      if (text1.length > this.Match_MaxBits) {
        start_loc = this.match_main(
          text,
          text1.substring(0, this.Match_MaxBits),
          expected_loc
        );
        if (start_loc != -1) {
          end_loc = this.match_main(
            text,
            text1.substring(text1.length - this.Match_MaxBits),
            expected_loc + text1.length - this.Match_MaxBits
          );
          if (end_loc == -1 || start_loc >= end_loc) {
            start_loc = -1;
          }
        }
      } else {
        start_loc = this.match_main(text, text1, expected_loc);
      }
      if (start_loc == -1) {
        results[x] = false;
        delta -= patches[x].length2 - patches[x].length1;
      } else {
        results[x] = true;
        delta = start_loc - expected_loc;
        var text2;
        if (end_loc == -1) {
          text2 = text.substring(start_loc, start_loc + text1.length);
        } else {
          text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
        }
        if (text1 == text2) {
          text = text.substring(0, start_loc) + this.diff_text2(patches[x].diffs) + text.substring(start_loc + text1.length);
        } else {
          var diffs = this.diff_main(text1, text2, false);
          if (text1.length > this.Match_MaxBits && this.diff_levenshtein(diffs) / text1.length > this.Patch_DeleteThreshold) {
            results[x] = false;
          } else {
            this.diff_cleanupSemanticLossless(diffs);
            var index1 = 0;
            var index2;
            for (var y = 0; y < patches[x].diffs.length; y++) {
              var mod2 = patches[x].diffs[y];
              if (mod2[0] !== DIFF_EQUAL) {
                index2 = this.diff_xIndex(diffs, index1);
              }
              if (mod2[0] === DIFF_INSERT) {
                text = text.substring(0, start_loc + index2) + mod2[1] + text.substring(start_loc + index2);
              } else if (mod2[0] === DIFF_DELETE) {
                text = text.substring(0, start_loc + index2) + text.substring(start_loc + this.diff_xIndex(
                  diffs,
                  index1 + mod2[1].length
                ));
              }
              if (mod2[0] !== DIFF_DELETE) {
                index1 += mod2[1].length;
              }
            }
          }
        }
      }
    }
    text = text.substring(nullPadding.length, text.length - nullPadding.length);
    return [text, results];
  };
  diff_match_patch2.prototype.patch_addPadding = function(patches) {
    var paddingLength = this.Patch_Margin;
    var nullPadding = "";
    for (var x = 1; x <= paddingLength; x++) {
      nullPadding += String.fromCharCode(x);
    }
    for (var x = 0; x < patches.length; x++) {
      patches[x].start1 += paddingLength;
      patches[x].start2 += paddingLength;
    }
    var patch = patches[0];
    var diffs = patch.diffs;
    if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
      diffs.unshift(new diff_match_patch2.Diff(DIFF_EQUAL, nullPadding));
      patch.start1 -= paddingLength;
      patch.start2 -= paddingLength;
      patch.length1 += paddingLength;
      patch.length2 += paddingLength;
    } else if (paddingLength > diffs[0][1].length) {
      var extraLength = paddingLength - diffs[0][1].length;
      diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
      patch.start1 -= extraLength;
      patch.start2 -= extraLength;
      patch.length1 += extraLength;
      patch.length2 += extraLength;
    }
    patch = patches[patches.length - 1];
    diffs = patch.diffs;
    if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
      diffs.push(new diff_match_patch2.Diff(DIFF_EQUAL, nullPadding));
      patch.length1 += paddingLength;
      patch.length2 += paddingLength;
    } else if (paddingLength > diffs[diffs.length - 1][1].length) {
      var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
      diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
      patch.length1 += extraLength;
      patch.length2 += extraLength;
    }
    return nullPadding;
  };
  diff_match_patch2.prototype.patch_splitMax = function(patches) {
    var patch_size = this.Match_MaxBits;
    for (var x = 0; x < patches.length; x++) {
      if (patches[x].length1 <= patch_size) {
        continue;
      }
      var bigpatch = patches[x];
      patches.splice(x--, 1);
      var start1 = bigpatch.start1;
      var start2 = bigpatch.start2;
      var precontext = "";
      while (bigpatch.diffs.length !== 0) {
        var patch = new diff_match_patch2.patch_obj();
        var empty = true;
        patch.start1 = start1 - precontext.length;
        patch.start2 = start2 - precontext.length;
        if (precontext !== "") {
          patch.length1 = patch.length2 = precontext.length;
          patch.diffs.push(new diff_match_patch2.Diff(DIFF_EQUAL, precontext));
        }
        while (bigpatch.diffs.length !== 0 && patch.length1 < patch_size - this.Patch_Margin) {
          var diff_type = bigpatch.diffs[0][0];
          var diff_text = bigpatch.diffs[0][1];
          if (diff_type === DIFF_INSERT) {
            patch.length2 += diff_text.length;
            start2 += diff_text.length;
            patch.diffs.push(bigpatch.diffs.shift());
            empty = false;
          } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 && patch.diffs[0][0] == DIFF_EQUAL && diff_text.length > 2 * patch_size) {
            patch.length1 += diff_text.length;
            start1 += diff_text.length;
            empty = false;
            patch.diffs.push(new diff_match_patch2.Diff(diff_type, diff_text));
            bigpatch.diffs.shift();
          } else {
            diff_text = diff_text.substring(
              0,
              patch_size - patch.length1 - this.Patch_Margin
            );
            patch.length1 += diff_text.length;
            start1 += diff_text.length;
            if (diff_type === DIFF_EQUAL) {
              patch.length2 += diff_text.length;
              start2 += diff_text.length;
            } else {
              empty = false;
            }
            patch.diffs.push(new diff_match_patch2.Diff(diff_type, diff_text));
            if (diff_text == bigpatch.diffs[0][1]) {
              bigpatch.diffs.shift();
            } else {
              bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diff_text.length);
            }
          }
        }
        precontext = this.diff_text2(patch.diffs);
        precontext = precontext.substring(precontext.length - this.Patch_Margin);
        var postcontext = this.diff_text1(bigpatch.diffs).substring(0, this.Patch_Margin);
        if (postcontext !== "") {
          patch.length1 += postcontext.length;
          patch.length2 += postcontext.length;
          if (patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
            patch.diffs[patch.diffs.length - 1][1] += postcontext;
          } else {
            patch.diffs.push(new diff_match_patch2.Diff(DIFF_EQUAL, postcontext));
          }
        }
        if (!empty) {
          patches.splice(++x, 0, patch);
        }
      }
    }
  };
  diff_match_patch2.prototype.patch_toText = function(patches) {
    var text = [];
    for (var x = 0; x < patches.length; x++) {
      text[x] = patches[x];
    }
    return text.join("");
  };
  diff_match_patch2.prototype.patch_fromText = function(textline) {
    var patches = [];
    if (!textline) {
      return patches;
    }
    var text = textline.split("\n");
    var textPointer = 0;
    var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
    while (textPointer < text.length) {
      var m = text[textPointer].match(patchHeader);
      if (!m) {
        throw new Error("Invalid patch string: " + text[textPointer]);
      }
      var patch = new diff_match_patch2.patch_obj();
      patches.push(patch);
      patch.start1 = parseInt(m[1], 10);
      if (m[2] === "") {
        patch.start1--;
        patch.length1 = 1;
      } else if (m[2] == "0") {
        patch.length1 = 0;
      } else {
        patch.start1--;
        patch.length1 = parseInt(m[2], 10);
      }
      patch.start2 = parseInt(m[3], 10);
      if (m[4] === "") {
        patch.start2--;
        patch.length2 = 1;
      } else if (m[4] == "0") {
        patch.length2 = 0;
      } else {
        patch.start2--;
        patch.length2 = parseInt(m[4], 10);
      }
      textPointer++;
      while (textPointer < text.length) {
        var sign2 = text[textPointer].charAt(0);
        try {
          var line = decodeURI(text[textPointer].substring(1));
        } catch (ex) {
          throw new Error("Illegal escape in patch_fromText: " + line);
        }
        if (sign2 == "-") {
          patch.diffs.push(new diff_match_patch2.Diff(DIFF_DELETE, line));
        } else if (sign2 == "+") {
          patch.diffs.push(new diff_match_patch2.Diff(DIFF_INSERT, line));
        } else if (sign2 == " ") {
          patch.diffs.push(new diff_match_patch2.Diff(DIFF_EQUAL, line));
        } else if (sign2 == "@") {
          break;
        } else if (sign2 === "")
          ;
        else {
          throw new Error('Invalid patch mode "' + sign2 + '" in: ' + line);
        }
        textPointer++;
      }
    }
    return patches;
  };
  diff_match_patch2.patch_obj = function() {
    this.diffs = [];
    this.start1 = null;
    this.start2 = null;
    this.length1 = 0;
    this.length2 = 0;
  };
  diff_match_patch2.patch_obj.prototype.toString = function() {
    var coords1, coords2;
    if (this.length1 === 0) {
      coords1 = this.start1 + ",0";
    } else if (this.length1 == 1) {
      coords1 = this.start1 + 1;
    } else {
      coords1 = this.start1 + 1 + "," + this.length1;
    }
    if (this.length2 === 0) {
      coords2 = this.start2 + ",0";
    } else if (this.length2 == 1) {
      coords2 = this.start2 + 1;
    } else {
      coords2 = this.start2 + 1 + "," + this.length2;
    }
    var text = ["@@ -" + coords1 + " +" + coords2 + " @@\n"];
    var op;
    for (var x = 0; x < this.diffs.length; x++) {
      switch (this.diffs[x][0]) {
        case DIFF_INSERT:
          op = "+";
          break;
        case DIFF_DELETE:
          op = "-";
          break;
        case DIFF_EQUAL:
          op = " ";
          break;
      }
      text[x + 1] = op + encodeURI(this.diffs[x][1]) + "\n";
    }
    return text.join("").replace(/%20/g, " ");
  };
  module.exports = diff_match_patch2;
  module.exports["diff_match_patch"] = diff_match_patch2;
  module.exports["DIFF_DELETE"] = DIFF_DELETE;
  module.exports["DIFF_INSERT"] = DIFF_INSERT;
  module.exports["DIFF_EQUAL"] = DIFF_EQUAL;
})(diffMatchPatch);
var diffMatchPatchExports = diffMatchPatch.exports;
const dmp = /* @__PURE__ */ getDefaultExportFromCjs(diffMatchPatchExports);
var chalk$1 = { exports: {} };
var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
var escapeStringRegexp = function(str) {
  if (typeof str !== "string") {
    throw new TypeError("Expected a string");
  }
  return str.replace(matchOperatorsRe, "\\$&");
};
var ansiStyles = { exports: {} };
var conversions$2 = { exports: {} };
var colorName = {
  "aliceblue": [240, 248, 255],
  "antiquewhite": [250, 235, 215],
  "aqua": [0, 255, 255],
  "aquamarine": [127, 255, 212],
  "azure": [240, 255, 255],
  "beige": [245, 245, 220],
  "bisque": [255, 228, 196],
  "black": [0, 0, 0],
  "blanchedalmond": [255, 235, 205],
  "blue": [0, 0, 255],
  "blueviolet": [138, 43, 226],
  "brown": [165, 42, 42],
  "burlywood": [222, 184, 135],
  "cadetblue": [95, 158, 160],
  "chartreuse": [127, 255, 0],
  "chocolate": [210, 105, 30],
  "coral": [255, 127, 80],
  "cornflowerblue": [100, 149, 237],
  "cornsilk": [255, 248, 220],
  "crimson": [220, 20, 60],
  "cyan": [0, 255, 255],
  "darkblue": [0, 0, 139],
  "darkcyan": [0, 139, 139],
  "darkgoldenrod": [184, 134, 11],
  "darkgray": [169, 169, 169],
  "darkgreen": [0, 100, 0],
  "darkgrey": [169, 169, 169],
  "darkkhaki": [189, 183, 107],
  "darkmagenta": [139, 0, 139],
  "darkolivegreen": [85, 107, 47],
  "darkorange": [255, 140, 0],
  "darkorchid": [153, 50, 204],
  "darkred": [139, 0, 0],
  "darksalmon": [233, 150, 122],
  "darkseagreen": [143, 188, 143],
  "darkslateblue": [72, 61, 139],
  "darkslategray": [47, 79, 79],
  "darkslategrey": [47, 79, 79],
  "darkturquoise": [0, 206, 209],
  "darkviolet": [148, 0, 211],
  "deeppink": [255, 20, 147],
  "deepskyblue": [0, 191, 255],
  "dimgray": [105, 105, 105],
  "dimgrey": [105, 105, 105],
  "dodgerblue": [30, 144, 255],
  "firebrick": [178, 34, 34],
  "floralwhite": [255, 250, 240],
  "forestgreen": [34, 139, 34],
  "fuchsia": [255, 0, 255],
  "gainsboro": [220, 220, 220],
  "ghostwhite": [248, 248, 255],
  "gold": [255, 215, 0],
  "goldenrod": [218, 165, 32],
  "gray": [128, 128, 128],
  "green": [0, 128, 0],
  "greenyellow": [173, 255, 47],
  "grey": [128, 128, 128],
  "honeydew": [240, 255, 240],
  "hotpink": [255, 105, 180],
  "indianred": [205, 92, 92],
  "indigo": [75, 0, 130],
  "ivory": [255, 255, 240],
  "khaki": [240, 230, 140],
  "lavender": [230, 230, 250],
  "lavenderblush": [255, 240, 245],
  "lawngreen": [124, 252, 0],
  "lemonchiffon": [255, 250, 205],
  "lightblue": [173, 216, 230],
  "lightcoral": [240, 128, 128],
  "lightcyan": [224, 255, 255],
  "lightgoldenrodyellow": [250, 250, 210],
  "lightgray": [211, 211, 211],
  "lightgreen": [144, 238, 144],
  "lightgrey": [211, 211, 211],
  "lightpink": [255, 182, 193],
  "lightsalmon": [255, 160, 122],
  "lightseagreen": [32, 178, 170],
  "lightskyblue": [135, 206, 250],
  "lightslategray": [119, 136, 153],
  "lightslategrey": [119, 136, 153],
  "lightsteelblue": [176, 196, 222],
  "lightyellow": [255, 255, 224],
  "lime": [0, 255, 0],
  "limegreen": [50, 205, 50],
  "linen": [250, 240, 230],
  "magenta": [255, 0, 255],
  "maroon": [128, 0, 0],
  "mediumaquamarine": [102, 205, 170],
  "mediumblue": [0, 0, 205],
  "mediumorchid": [186, 85, 211],
  "mediumpurple": [147, 112, 219],
  "mediumseagreen": [60, 179, 113],
  "mediumslateblue": [123, 104, 238],
  "mediumspringgreen": [0, 250, 154],
  "mediumturquoise": [72, 209, 204],
  "mediumvioletred": [199, 21, 133],
  "midnightblue": [25, 25, 112],
  "mintcream": [245, 255, 250],
  "mistyrose": [255, 228, 225],
  "moccasin": [255, 228, 181],
  "navajowhite": [255, 222, 173],
  "navy": [0, 0, 128],
  "oldlace": [253, 245, 230],
  "olive": [128, 128, 0],
  "olivedrab": [107, 142, 35],
  "orange": [255, 165, 0],
  "orangered": [255, 69, 0],
  "orchid": [218, 112, 214],
  "palegoldenrod": [238, 232, 170],
  "palegreen": [152, 251, 152],
  "paleturquoise": [175, 238, 238],
  "palevioletred": [219, 112, 147],
  "papayawhip": [255, 239, 213],
  "peachpuff": [255, 218, 185],
  "peru": [205, 133, 63],
  "pink": [255, 192, 203],
  "plum": [221, 160, 221],
  "powderblue": [176, 224, 230],
  "purple": [128, 0, 128],
  "rebeccapurple": [102, 51, 153],
  "red": [255, 0, 0],
  "rosybrown": [188, 143, 143],
  "royalblue": [65, 105, 225],
  "saddlebrown": [139, 69, 19],
  "salmon": [250, 128, 114],
  "sandybrown": [244, 164, 96],
  "seagreen": [46, 139, 87],
  "seashell": [255, 245, 238],
  "sienna": [160, 82, 45],
  "silver": [192, 192, 192],
  "skyblue": [135, 206, 235],
  "slateblue": [106, 90, 205],
  "slategray": [112, 128, 144],
  "slategrey": [112, 128, 144],
  "snow": [255, 250, 250],
  "springgreen": [0, 255, 127],
  "steelblue": [70, 130, 180],
  "tan": [210, 180, 140],
  "teal": [0, 128, 128],
  "thistle": [216, 191, 216],
  "tomato": [255, 99, 71],
  "turquoise": [64, 224, 208],
  "violet": [238, 130, 238],
  "wheat": [245, 222, 179],
  "white": [255, 255, 255],
  "whitesmoke": [245, 245, 245],
  "yellow": [255, 255, 0],
  "yellowgreen": [154, 205, 50]
};
var cssKeywords = colorName;
var reverseKeywords = {};
for (var key in cssKeywords) {
  if (cssKeywords.hasOwnProperty(key)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
}
var convert$1 = conversions$2.exports = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  lch: { channels: 3, labels: "lch" },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] }
};
for (var model in convert$1) {
  if (convert$1.hasOwnProperty(model)) {
    if (!("channels" in convert$1[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert$1[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert$1[model].labels.length !== convert$1[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    var channels = convert$1[model].channels;
    var labels = convert$1[model].labels;
    delete convert$1[model].channels;
    delete convert$1[model].labels;
    Object.defineProperty(convert$1[model], "channels", { value: channels });
    Object.defineProperty(convert$1[model], "labels", { value: labels });
  }
}
convert$1.rgb.hsl = function(rgb) {
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var min2 = Math.min(r, g, b);
  var max2 = Math.max(r, g, b);
  var delta = max2 - min2;
  var h2;
  var s;
  var l;
  if (max2 === min2) {
    h2 = 0;
  } else if (r === max2) {
    h2 = (g - b) / delta;
  } else if (g === max2) {
    h2 = 2 + (b - r) / delta;
  } else if (b === max2) {
    h2 = 4 + (r - g) / delta;
  }
  h2 = Math.min(h2 * 60, 360);
  if (h2 < 0) {
    h2 += 360;
  }
  l = (min2 + max2) / 2;
  if (max2 === min2) {
    s = 0;
  } else if (l <= 0.5) {
    s = delta / (max2 + min2);
  } else {
    s = delta / (2 - max2 - min2);
  }
  return [h2, s * 100, l * 100];
};
convert$1.rgb.hsv = function(rgb) {
  var rdif;
  var gdif;
  var bdif;
  var h2;
  var s;
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var v = Math.max(r, g, b);
  var diff2 = v - Math.min(r, g, b);
  var diffc = function(c) {
    return (v - c) / 6 / diff2 + 1 / 2;
  };
  if (diff2 === 0) {
    h2 = s = 0;
  } else {
    s = diff2 / v;
    rdif = diffc(r);
    gdif = diffc(g);
    bdif = diffc(b);
    if (r === v) {
      h2 = bdif - gdif;
    } else if (g === v) {
      h2 = 1 / 3 + rdif - bdif;
    } else if (b === v) {
      h2 = 2 / 3 + gdif - rdif;
    }
    if (h2 < 0) {
      h2 += 1;
    } else if (h2 > 1) {
      h2 -= 1;
    }
  }
  return [
    h2 * 360,
    s * 100,
    v * 100
  ];
};
convert$1.rgb.hwb = function(rgb) {
  var r = rgb[0];
  var g = rgb[1];
  var b = rgb[2];
  var h2 = convert$1.rgb.hsl(rgb)[0];
  var w = 1 / 255 * Math.min(r, Math.min(g, b));
  b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
  return [h2, w * 100, b * 100];
};
convert$1.rgb.cmyk = function(rgb) {
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var c;
  var m;
  var y;
  var k;
  k = Math.min(1 - r, 1 - g, 1 - b);
  c = (1 - r - k) / (1 - k) || 0;
  m = (1 - g - k) / (1 - k) || 0;
  y = (1 - b - k) / (1 - k) || 0;
  return [c * 100, m * 100, y * 100, k * 100];
};
function comparativeDistance(x, y) {
  return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
}
convert$1.rgb.keyword = function(rgb) {
  var reversed = reverseKeywords[rgb];
  if (reversed) {
    return reversed;
  }
  var currentClosestDistance = Infinity;
  var currentClosestKeyword;
  for (var keyword in cssKeywords) {
    if (cssKeywords.hasOwnProperty(keyword)) {
      var value = cssKeywords[keyword];
      var distance2 = comparativeDistance(rgb, value);
      if (distance2 < currentClosestDistance) {
        currentClosestDistance = distance2;
        currentClosestKeyword = keyword;
      }
    }
  }
  return currentClosestKeyword;
};
convert$1.keyword.rgb = function(keyword) {
  return cssKeywords[keyword];
};
convert$1.rgb.xyz = function(rgb) {
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
  g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
  b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
  var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
  var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
  var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
  return [x * 100, y * 100, z * 100];
};
convert$1.rgb.lab = function(rgb) {
  var xyz = convert$1.rgb.xyz(rgb);
  var x = xyz[0];
  var y = xyz[1];
  var z = xyz[2];
  var l;
  var a;
  var b;
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
  y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
  z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
  l = 116 * y - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);
  return [l, a, b];
};
convert$1.hsl.rgb = function(hsl) {
  var h2 = hsl[0] / 360;
  var s = hsl[1] / 100;
  var l = hsl[2] / 100;
  var t1;
  var t2;
  var t3;
  var rgb;
  var val;
  if (s === 0) {
    val = l * 255;
    return [val, val, val];
  }
  if (l < 0.5) {
    t2 = l * (1 + s);
  } else {
    t2 = l + s - l * s;
  }
  t1 = 2 * l - t2;
  rgb = [0, 0, 0];
  for (var i = 0; i < 3; i++) {
    t3 = h2 + 1 / 3 * -(i - 1);
    if (t3 < 0) {
      t3++;
    }
    if (t3 > 1) {
      t3--;
    }
    if (6 * t3 < 1) {
      val = t1 + (t2 - t1) * 6 * t3;
    } else if (2 * t3 < 1) {
      val = t2;
    } else if (3 * t3 < 2) {
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    } else {
      val = t1;
    }
    rgb[i] = val * 255;
  }
  return rgb;
};
convert$1.hsl.hsv = function(hsl) {
  var h2 = hsl[0];
  var s = hsl[1] / 100;
  var l = hsl[2] / 100;
  var smin = s;
  var lmin = Math.max(l, 0.01);
  var sv;
  var v;
  l *= 2;
  s *= l <= 1 ? l : 2 - l;
  smin *= lmin <= 1 ? lmin : 2 - lmin;
  v = (l + s) / 2;
  sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
  return [h2, sv * 100, v * 100];
};
convert$1.hsv.rgb = function(hsv) {
  var h2 = hsv[0] / 60;
  var s = hsv[1] / 100;
  var v = hsv[2] / 100;
  var hi = Math.floor(h2) % 6;
  var f = h2 - Math.floor(h2);
  var p2 = 255 * v * (1 - s);
  var q = 255 * v * (1 - s * f);
  var t = 255 * v * (1 - s * (1 - f));
  v *= 255;
  switch (hi) {
    case 0:
      return [v, t, p2];
    case 1:
      return [q, v, p2];
    case 2:
      return [p2, v, t];
    case 3:
      return [p2, q, v];
    case 4:
      return [t, p2, v];
    case 5:
      return [v, p2, q];
  }
};
convert$1.hsv.hsl = function(hsv) {
  var h2 = hsv[0];
  var s = hsv[1] / 100;
  var v = hsv[2] / 100;
  var vmin = Math.max(v, 0.01);
  var lmin;
  var sl;
  var l;
  l = (2 - s) * v;
  lmin = (2 - s) * vmin;
  sl = s * vmin;
  sl /= lmin <= 1 ? lmin : 2 - lmin;
  sl = sl || 0;
  l /= 2;
  return [h2, sl * 100, l * 100];
};
convert$1.hwb.rgb = function(hwb) {
  var h2 = hwb[0] / 360;
  var wh = hwb[1] / 100;
  var bl = hwb[2] / 100;
  var ratio = wh + bl;
  var i;
  var v;
  var f;
  var n;
  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }
  i = Math.floor(6 * h2);
  v = 1 - bl;
  f = 6 * h2 - i;
  if ((i & 1) !== 0) {
    f = 1 - f;
  }
  n = wh + f * (v - wh);
  var r;
  var g;
  var b;
  switch (i) {
    default:
    case 6:
    case 0:
      r = v;
      g = n;
      b = wh;
      break;
    case 1:
      r = n;
      g = v;
      b = wh;
      break;
    case 2:
      r = wh;
      g = v;
      b = n;
      break;
    case 3:
      r = wh;
      g = n;
      b = v;
      break;
    case 4:
      r = n;
      g = wh;
      b = v;
      break;
    case 5:
      r = v;
      g = wh;
      b = n;
      break;
  }
  return [r * 255, g * 255, b * 255];
};
convert$1.cmyk.rgb = function(cmyk) {
  var c = cmyk[0] / 100;
  var m = cmyk[1] / 100;
  var y = cmyk[2] / 100;
  var k = cmyk[3] / 100;
  var r;
  var g;
  var b;
  r = 1 - Math.min(1, c * (1 - k) + k);
  g = 1 - Math.min(1, m * (1 - k) + k);
  b = 1 - Math.min(1, y * (1 - k) + k);
  return [r * 255, g * 255, b * 255];
};
convert$1.xyz.rgb = function(xyz) {
  var x = xyz[0] / 100;
  var y = xyz[1] / 100;
  var z = xyz[2] / 100;
  var r;
  var g;
  var b;
  r = x * 3.2406 + y * -1.5372 + z * -0.4986;
  g = x * -0.9689 + y * 1.8758 + z * 0.0415;
  b = x * 0.0557 + y * -0.204 + z * 1.057;
  r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
  g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
  b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);
  return [r * 255, g * 255, b * 255];
};
convert$1.xyz.lab = function(xyz) {
  var x = xyz[0];
  var y = xyz[1];
  var z = xyz[2];
  var l;
  var a;
  var b;
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
  y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
  z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
  l = 116 * y - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);
  return [l, a, b];
};
convert$1.lab.xyz = function(lab) {
  var l = lab[0];
  var a = lab[1];
  var b = lab[2];
  var x;
  var y;
  var z;
  y = (l + 16) / 116;
  x = a / 500 + y;
  z = y - b / 200;
  var y2 = Math.pow(y, 3);
  var x2 = Math.pow(x, 3);
  var z2 = Math.pow(z, 3);
  y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
  x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
  z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
  x *= 95.047;
  y *= 100;
  z *= 108.883;
  return [x, y, z];
};
convert$1.lab.lch = function(lab) {
  var l = lab[0];
  var a = lab[1];
  var b = lab[2];
  var hr;
  var h2;
  var c;
  hr = Math.atan2(b, a);
  h2 = hr * 360 / 2 / Math.PI;
  if (h2 < 0) {
    h2 += 360;
  }
  c = Math.sqrt(a * a + b * b);
  return [l, c, h2];
};
convert$1.lch.lab = function(lch) {
  var l = lch[0];
  var c = lch[1];
  var h2 = lch[2];
  var a;
  var b;
  var hr;
  hr = h2 / 360 * 2 * Math.PI;
  a = c * Math.cos(hr);
  b = c * Math.sin(hr);
  return [l, a, b];
};
convert$1.rgb.ansi16 = function(args) {
  var r = args[0];
  var g = args[1];
  var b = args[2];
  var value = 1 in arguments ? arguments[1] : convert$1.rgb.hsv(args)[2];
  value = Math.round(value / 50);
  if (value === 0) {
    return 30;
  }
  var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
  if (value === 2) {
    ansi += 60;
  }
  return ansi;
};
convert$1.hsv.ansi16 = function(args) {
  return convert$1.rgb.ansi16(convert$1.hsv.rgb(args), args[2]);
};
convert$1.rgb.ansi256 = function(args) {
  var r = args[0];
  var g = args[1];
  var b = args[2];
  if (r === g && g === b) {
    if (r < 8) {
      return 16;
    }
    if (r > 248) {
      return 231;
    }
    return Math.round((r - 8) / 247 * 24) + 232;
  }
  var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
  return ansi;
};
convert$1.ansi16.rgb = function(args) {
  var color = args % 10;
  if (color === 0 || color === 7) {
    if (args > 50) {
      color += 3.5;
    }
    color = color / 10.5 * 255;
    return [color, color, color];
  }
  var mult = (~~(args > 50) + 1) * 0.5;
  var r = (color & 1) * mult * 255;
  var g = (color >> 1 & 1) * mult * 255;
  var b = (color >> 2 & 1) * mult * 255;
  return [r, g, b];
};
convert$1.ansi256.rgb = function(args) {
  if (args >= 232) {
    var c = (args - 232) * 10 + 8;
    return [c, c, c];
  }
  args -= 16;
  var rem;
  var r = Math.floor(args / 36) / 5 * 255;
  var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
  var b = rem % 6 / 5 * 255;
  return [r, g, b];
};
convert$1.rgb.hex = function(args) {
  var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
  var string = integer.toString(16).toUpperCase();
  return "000000".substring(string.length) + string;
};
convert$1.hex.rgb = function(args) {
  var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
  if (!match) {
    return [0, 0, 0];
  }
  var colorString = match[0];
  if (match[0].length === 3) {
    colorString = colorString.split("").map(function(char2) {
      return char2 + char2;
    }).join("");
  }
  var integer = parseInt(colorString, 16);
  var r = integer >> 16 & 255;
  var g = integer >> 8 & 255;
  var b = integer & 255;
  return [r, g, b];
};
convert$1.rgb.hcg = function(rgb) {
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var max2 = Math.max(Math.max(r, g), b);
  var min2 = Math.min(Math.min(r, g), b);
  var chroma = max2 - min2;
  var grayscale;
  var hue;
  if (chroma < 1) {
    grayscale = min2 / (1 - chroma);
  } else {
    grayscale = 0;
  }
  if (chroma <= 0) {
    hue = 0;
  } else if (max2 === r) {
    hue = (g - b) / chroma % 6;
  } else if (max2 === g) {
    hue = 2 + (b - r) / chroma;
  } else {
    hue = 4 + (r - g) / chroma + 4;
  }
  hue /= 6;
  hue %= 1;
  return [hue * 360, chroma * 100, grayscale * 100];
};
convert$1.hsl.hcg = function(hsl) {
  var s = hsl[1] / 100;
  var l = hsl[2] / 100;
  var c = 1;
  var f = 0;
  if (l < 0.5) {
    c = 2 * s * l;
  } else {
    c = 2 * s * (1 - l);
  }
  if (c < 1) {
    f = (l - 0.5 * c) / (1 - c);
  }
  return [hsl[0], c * 100, f * 100];
};
convert$1.hsv.hcg = function(hsv) {
  var s = hsv[1] / 100;
  var v = hsv[2] / 100;
  var c = s * v;
  var f = 0;
  if (c < 1) {
    f = (v - c) / (1 - c);
  }
  return [hsv[0], c * 100, f * 100];
};
convert$1.hcg.rgb = function(hcg) {
  var h2 = hcg[0] / 360;
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;
  if (c === 0) {
    return [g * 255, g * 255, g * 255];
  }
  var pure = [0, 0, 0];
  var hi = h2 % 1 * 6;
  var v = hi % 1;
  var w = 1 - v;
  var mg = 0;
  switch (Math.floor(hi)) {
    case 0:
      pure[0] = 1;
      pure[1] = v;
      pure[2] = 0;
      break;
    case 1:
      pure[0] = w;
      pure[1] = 1;
      pure[2] = 0;
      break;
    case 2:
      pure[0] = 0;
      pure[1] = 1;
      pure[2] = v;
      break;
    case 3:
      pure[0] = 0;
      pure[1] = w;
      pure[2] = 1;
      break;
    case 4:
      pure[0] = v;
      pure[1] = 0;
      pure[2] = 1;
      break;
    default:
      pure[0] = 1;
      pure[1] = 0;
      pure[2] = w;
  }
  mg = (1 - c) * g;
  return [
    (c * pure[0] + mg) * 255,
    (c * pure[1] + mg) * 255,
    (c * pure[2] + mg) * 255
  ];
};
convert$1.hcg.hsv = function(hcg) {
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;
  var v = c + g * (1 - c);
  var f = 0;
  if (v > 0) {
    f = c / v;
  }
  return [hcg[0], f * 100, v * 100];
};
convert$1.hcg.hsl = function(hcg) {
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;
  var l = g * (1 - c) + 0.5 * c;
  var s = 0;
  if (l > 0 && l < 0.5) {
    s = c / (2 * l);
  } else if (l >= 0.5 && l < 1) {
    s = c / (2 * (1 - l));
  }
  return [hcg[0], s * 100, l * 100];
};
convert$1.hcg.hwb = function(hcg) {
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;
  var v = c + g * (1 - c);
  return [hcg[0], (v - c) * 100, (1 - v) * 100];
};
convert$1.hwb.hcg = function(hwb) {
  var w = hwb[1] / 100;
  var b = hwb[2] / 100;
  var v = 1 - b;
  var c = v - w;
  var g = 0;
  if (c < 1) {
    g = (v - c) / (1 - c);
  }
  return [hwb[0], c * 100, g * 100];
};
convert$1.apple.rgb = function(apple) {
  return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
};
convert$1.rgb.apple = function(rgb) {
  return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
};
convert$1.gray.rgb = function(args) {
  return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};
convert$1.gray.hsl = convert$1.gray.hsv = function(args) {
  return [0, 0, args[0]];
};
convert$1.gray.hwb = function(gray) {
  return [0, 100, gray[0]];
};
convert$1.gray.cmyk = function(gray) {
  return [0, 0, 0, gray[0]];
};
convert$1.gray.lab = function(gray) {
  return [gray[0], 0, 0];
};
convert$1.gray.hex = function(gray) {
  var val = Math.round(gray[0] / 100 * 255) & 255;
  var integer = (val << 16) + (val << 8) + val;
  var string = integer.toString(16).toUpperCase();
  return "000000".substring(string.length) + string;
};
convert$1.rgb.gray = function(rgb) {
  var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
  return [val / 255 * 100];
};
var conversionsExports = conversions$2.exports;
var conversions$1 = conversionsExports;
function buildGraph() {
  var graph = {};
  var models2 = Object.keys(conversions$1);
  for (var len = models2.length, i = 0; i < len; i++) {
    graph[models2[i]] = {
      // http://jsperf.com/1-vs-infinity
      // micro-opt, but this is simple.
      distance: -1,
      parent: null
    };
  }
  return graph;
}
function deriveBFS(fromModel) {
  var graph = buildGraph();
  var queue2 = [fromModel];
  graph[fromModel].distance = 0;
  while (queue2.length) {
    var current = queue2.pop();
    var adjacents = Object.keys(conversions$1[current]);
    for (var len = adjacents.length, i = 0; i < len; i++) {
      var adjacent = adjacents[i];
      var node = graph[adjacent];
      if (node.distance === -1) {
        node.distance = graph[current].distance + 1;
        node.parent = current;
        queue2.unshift(adjacent);
      }
    }
  }
  return graph;
}
function link(from, to) {
  return function(args) {
    return to(from(args));
  };
}
function wrapConversion(toModel, graph) {
  var path = [graph[toModel].parent, toModel];
  var fn = conversions$1[graph[toModel].parent][toModel];
  var cur = graph[toModel].parent;
  while (graph[cur].parent) {
    path.unshift(graph[cur].parent);
    fn = link(conversions$1[graph[cur].parent][cur], fn);
    cur = graph[cur].parent;
  }
  fn.conversion = path;
  return fn;
}
var route$1 = function(fromModel) {
  var graph = deriveBFS(fromModel);
  var conversion = {};
  var models2 = Object.keys(graph);
  for (var len = models2.length, i = 0; i < len; i++) {
    var toModel = models2[i];
    var node = graph[toModel];
    if (node.parent === null) {
      continue;
    }
    conversion[toModel] = wrapConversion(toModel, graph);
  }
  return conversion;
};
var conversions = conversionsExports;
var route = route$1;
var convert = {};
var models = Object.keys(conversions);
function wrapRaw(fn) {
  var wrappedFn = function(args) {
    if (args === void 0 || args === null) {
      return args;
    }
    if (arguments.length > 1) {
      args = Array.prototype.slice.call(arguments);
    }
    return fn(args);
  };
  if ("conversion" in fn) {
    wrappedFn.conversion = fn.conversion;
  }
  return wrappedFn;
}
function wrapRounded(fn) {
  var wrappedFn = function(args) {
    if (args === void 0 || args === null) {
      return args;
    }
    if (arguments.length > 1) {
      args = Array.prototype.slice.call(arguments);
    }
    var result = fn(args);
    if (typeof result === "object") {
      for (var len = result.length, i = 0; i < len; i++) {
        result[i] = Math.round(result[i]);
      }
    }
    return result;
  };
  if ("conversion" in fn) {
    wrappedFn.conversion = fn.conversion;
  }
  return wrappedFn;
}
models.forEach(function(fromModel) {
  convert[fromModel] = {};
  Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
  Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
  var routes = route(fromModel);
  var routeModels = Object.keys(routes);
  routeModels.forEach(function(toModel) {
    var fn = routes[toModel];
    convert[fromModel][toModel] = wrapRounded(fn);
    convert[fromModel][toModel].raw = wrapRaw(fn);
  });
});
var colorConvert = convert;
ansiStyles.exports;
(function(module) {
  const colorConvert$1 = colorConvert;
  const wrapAnsi16 = (fn, offset2) => function() {
    const code2 = fn.apply(colorConvert$1, arguments);
    return `\x1B[${code2 + offset2}m`;
  };
  const wrapAnsi256 = (fn, offset2) => function() {
    const code2 = fn.apply(colorConvert$1, arguments);
    return `\x1B[${38 + offset2};5;${code2}m`;
  };
  const wrapAnsi16m = (fn, offset2) => function() {
    const rgb = fn.apply(colorConvert$1, arguments);
    return `\x1B[${38 + offset2};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };
  function assembleStyles() {
    const codes = /* @__PURE__ */ new Map();
    const styles = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        // Bright color
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles.color.grey = styles.color.gray;
    for (const groupName of Object.keys(styles)) {
      const group = styles[groupName];
      for (const styleName of Object.keys(group)) {
        const style = group[styleName];
        styles[styleName] = {
          open: `\x1B[${style[0]}m`,
          close: `\x1B[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
    }
    const ansi2ansi = (n) => n;
    const rgb2rgb = (r, g, b) => [r, g, b];
    styles.color.close = "\x1B[39m";
    styles.bgColor.close = "\x1B[49m";
    styles.color.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 0)
    };
    styles.color.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 0)
    };
    styles.color.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 0)
    };
    styles.bgColor.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 10)
    };
    styles.bgColor.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 10)
    };
    styles.bgColor.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 10)
    };
    for (let key of Object.keys(colorConvert$1)) {
      if (typeof colorConvert$1[key] !== "object") {
        continue;
      }
      const suite = colorConvert$1[key];
      if (key === "ansi16") {
        key = "ansi";
      }
      if ("ansi16" in suite) {
        styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
        styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
      }
      if ("ansi256" in suite) {
        styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
        styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
      }
      if ("rgb" in suite) {
        styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
        styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
      }
    }
    return styles;
  }
  Object.defineProperty(module, "exports", {
    enumerable: true,
    get: assembleStyles
  });
})(ansiStyles);
var ansiStylesExports = ansiStyles.exports;
var browser$2 = {
  stdout: false,
  stderr: false
};
const TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
const ESCAPES = /* @__PURE__ */ new Map([
  ["n", "\n"],
  ["r", "\r"],
  ["t", "	"],
  ["b", "\b"],
  ["f", "\f"],
  ["v", "\v"],
  ["0", "\0"],
  ["\\", "\\"],
  ["e", "\x1B"],
  ["a", "\x07"]
]);
function unescape(c) {
  if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
    return String.fromCharCode(parseInt(c.slice(1), 16));
  }
  return ESCAPES.get(c) || c;
}
function parseArguments(name, args) {
  const results = [];
  const chunks = args.trim().split(/\s*,\s*/g);
  let matches;
  for (const chunk of chunks) {
    if (!isNaN(chunk)) {
      results.push(Number(chunk));
    } else if (matches = chunk.match(STRING_REGEX)) {
      results.push(matches[2].replace(ESCAPE_REGEX, (m, escape2, chr) => escape2 ? unescape(escape2) : chr));
    } else {
      throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
    }
  }
  return results;
}
function parseStyle(style) {
  STYLE_REGEX.lastIndex = 0;
  const results = [];
  let matches;
  while ((matches = STYLE_REGEX.exec(style)) !== null) {
    const name = matches[1];
    if (matches[2]) {
      const args = parseArguments(name, matches[2]);
      results.push([name].concat(args));
    } else {
      results.push([name]);
    }
  }
  return results;
}
function buildStyle(chalk2, styles) {
  const enabled = {};
  for (const layer of styles) {
    for (const style of layer.styles) {
      enabled[style[0]] = layer.inverse ? null : style.slice(1);
    }
  }
  let current = chalk2;
  for (const styleName of Object.keys(enabled)) {
    if (Array.isArray(enabled[styleName])) {
      if (!(styleName in current)) {
        throw new Error(`Unknown Chalk style: ${styleName}`);
      }
      if (enabled[styleName].length > 0) {
        current = current[styleName].apply(current, enabled[styleName]);
      } else {
        current = current[styleName];
      }
    }
  }
  return current;
}
var templates = (chalk2, tmp) => {
  const styles = [];
  const chunks = [];
  let chunk = [];
  tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse2, style, close, chr) => {
    if (escapeChar) {
      chunk.push(unescape(escapeChar));
    } else if (style) {
      const str = chunk.join("");
      chunk = [];
      chunks.push(styles.length === 0 ? str : buildStyle(chalk2, styles)(str));
      styles.push({ inverse: inverse2, styles: parseStyle(style) });
    } else if (close) {
      if (styles.length === 0) {
        throw new Error("Found extraneous } in Chalk template literal");
      }
      chunks.push(buildStyle(chalk2, styles)(chunk.join("")));
      chunk = [];
      styles.pop();
    } else {
      chunk.push(chr);
    }
  });
  chunks.push(chunk.join(""));
  if (styles.length > 0) {
    const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
    throw new Error(errMsg);
  }
  return chunks.join("");
};
(function(module) {
  const escapeStringRegexp$1 = escapeStringRegexp;
  const ansiStyles2 = ansiStylesExports;
  const stdoutColor = browser$2.stdout;
  const template = templates;
  const levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
  const skipModels = /* @__PURE__ */ new Set(["gray"]);
  const styles = /* @__PURE__ */ Object.create(null);
  function applyOptions2(obj, options) {
    options = options || {};
    const scLevel = stdoutColor ? stdoutColor.level : 0;
    obj.level = options.level === void 0 ? scLevel : options.level;
    obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
  }
  function Chalk(options) {
    if (!this || !(this instanceof Chalk) || this.template) {
      const chalk2 = {};
      applyOptions2(chalk2, options);
      chalk2.template = function() {
        const args = [].slice.call(arguments);
        return chalkTag.apply(null, [chalk2.template].concat(args));
      };
      Object.setPrototypeOf(chalk2, Chalk.prototype);
      Object.setPrototypeOf(chalk2.template, chalk2);
      chalk2.template.constructor = Chalk;
      return chalk2.template;
    }
    applyOptions2(this, options);
  }
  for (const key of Object.keys(ansiStyles2)) {
    ansiStyles2[key].closeRe = new RegExp(escapeStringRegexp$1(ansiStyles2[key].close), "g");
    styles[key] = {
      get() {
        const codes = ansiStyles2[key];
        return build3.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
      }
    };
  }
  styles.visible = {
    get() {
      return build3.call(this, this._styles || [], true, "visible");
    }
  };
  ansiStyles2.color.closeRe = new RegExp(escapeStringRegexp$1(ansiStyles2.color.close), "g");
  for (const model of Object.keys(ansiStyles2.color.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }
    styles[model] = {
      get() {
        const level = this.level;
        return function() {
          const open = ansiStyles2.color[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open,
            close: ansiStyles2.color.close,
            closeRe: ansiStyles2.color.closeRe
          };
          return build3.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }
    };
  }
  ansiStyles2.bgColor.closeRe = new RegExp(escapeStringRegexp$1(ansiStyles2.bgColor.close), "g");
  for (const model of Object.keys(ansiStyles2.bgColor.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
      get() {
        const level = this.level;
        return function() {
          const open = ansiStyles2.bgColor[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open,
            close: ansiStyles2.bgColor.close,
            closeRe: ansiStyles2.bgColor.closeRe
          };
          return build3.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }
    };
  }
  const proto = Object.defineProperties(() => {
  }, styles);
  function build3(_styles, _empty, key) {
    const builder = function() {
      return applyStyle.apply(builder, arguments);
    };
    builder._styles = _styles;
    builder._empty = _empty;
    const self2 = this;
    Object.defineProperty(builder, "level", {
      enumerable: true,
      get() {
        return self2.level;
      },
      set(level) {
        self2.level = level;
      }
    });
    Object.defineProperty(builder, "enabled", {
      enumerable: true,
      get() {
        return self2.enabled;
      },
      set(enabled) {
        self2.enabled = enabled;
      }
    });
    builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
    builder.__proto__ = proto;
    return builder;
  }
  function applyStyle() {
    const args = arguments;
    const argsLen = args.length;
    let str = String(arguments[0]);
    if (argsLen === 0) {
      return "";
    }
    if (argsLen > 1) {
      for (let a = 1; a < argsLen; a++) {
        str += " " + args[a];
      }
    }
    if (!this.enabled || this.level <= 0 || !str) {
      return this._empty ? "" : str;
    }
    const originalDim = ansiStyles2.dim.open;
    for (const code2 of this._styles.slice().reverse()) {
      str = code2.open + str.replace(code2.closeRe, code2.open) + code2.close;
      str = str.replace(/\r?\n/g, `${code2.close}$&${code2.open}`);
    }
    ansiStyles2.dim.open = originalDim;
    return str;
  }
  function chalkTag(chalk2, strings) {
    if (!Array.isArray(strings)) {
      return [].slice.call(arguments, 1).join(" ");
    }
    const args = [].slice.call(arguments, 2);
    const parts = [strings.raw[0]];
    for (let i = 1; i < strings.length; i++) {
      parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
      parts.push(String(strings.raw[i]));
    }
    return template(chalk2, parts.join(""));
  }
  Object.defineProperties(Chalk.prototype, styles);
  module.exports = Chalk();
  module.exports.supportsColor = stdoutColor;
  module.exports.default = module.exports;
})(chalk$1);
var chalkExports = chalk$1.exports;
const chalk = /* @__PURE__ */ getDefaultExportFromCjs(chalkExports);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var classCallCheck = function(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
var createClass = /* @__PURE__ */ function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
var get$1 = function get(object, property, receiver) {
  if (object === null)
    object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);
  if (desc === void 0) {
    var parent = Object.getPrototypeOf(object);
    if (parent === null) {
      return void 0;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === void 0) {
      return void 0;
    }
    return getter.call(receiver);
  }
};
var inherits = function(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};
var possibleConstructorReturn = function(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
};
var Processor = function() {
  function Processor2(options) {
    classCallCheck(this, Processor2);
    this.selfOptions = options || {};
    this.pipes = {};
  }
  createClass(Processor2, [{
    key: "options",
    value: function options(_options) {
      if (_options) {
        this.selfOptions = _options;
      }
      return this.selfOptions;
    }
  }, {
    key: "pipe",
    value: function pipe(name, pipeArg) {
      var pipe2 = pipeArg;
      if (typeof name === "string") {
        if (typeof pipe2 === "undefined") {
          return this.pipes[name];
        } else {
          this.pipes[name] = pipe2;
        }
      }
      if (name && name.name) {
        pipe2 = name;
        if (pipe2.processor === this) {
          return pipe2;
        }
        this.pipes[pipe2.name] = pipe2;
      }
      pipe2.processor = this;
      return pipe2;
    }
  }, {
    key: "process",
    value: function process2(input, pipe) {
      var context = input;
      context.options = this.options();
      var nextPipe = pipe || input.pipe || "default";
      var lastPipe = void 0;
      var lastContext = void 0;
      while (nextPipe) {
        if (typeof context.nextAfterChildren !== "undefined") {
          context.next = context.nextAfterChildren;
          context.nextAfterChildren = null;
        }
        if (typeof nextPipe === "string") {
          nextPipe = this.pipe(nextPipe);
        }
        nextPipe.process(context);
        lastContext = context;
        lastPipe = nextPipe;
        nextPipe = null;
        if (context) {
          if (context.next) {
            context = context.next;
            nextPipe = lastContext.nextPipe || context.pipe || lastPipe;
          }
        }
      }
      return context.hasResult ? context.result : void 0;
    }
  }]);
  return Processor2;
}();
var Pipe = function() {
  function Pipe2(name) {
    classCallCheck(this, Pipe2);
    this.name = name;
    this.filters = [];
  }
  createClass(Pipe2, [{
    key: "process",
    value: function process2(input) {
      if (!this.processor) {
        throw new Error("add this pipe to a processor before using it");
      }
      var debug2 = this.debug;
      var length = this.filters.length;
      var context = input;
      for (var index2 = 0; index2 < length; index2++) {
        var filter = this.filters[index2];
        if (debug2) {
          this.log("filter: " + filter.filterName);
        }
        filter(context);
        if ((typeof context === "undefined" ? "undefined" : _typeof(context)) === "object" && context.exiting) {
          context.exiting = false;
          break;
        }
      }
      if (!context.next && this.resultCheck) {
        this.resultCheck(context);
      }
    }
  }, {
    key: "log",
    value: function log3(msg) {
      console.log("[jsondiffpatch] " + this.name + " pipe, " + msg);
    }
  }, {
    key: "append",
    value: function append() {
      var _filters;
      (_filters = this.filters).push.apply(_filters, arguments);
      return this;
    }
  }, {
    key: "prepend",
    value: function prepend() {
      var _filters2;
      (_filters2 = this.filters).unshift.apply(_filters2, arguments);
      return this;
    }
  }, {
    key: "indexOf",
    value: function indexOf(filterName) {
      if (!filterName) {
        throw new Error("a filter name is required");
      }
      for (var index2 = 0; index2 < this.filters.length; index2++) {
        var filter = this.filters[index2];
        if (filter.filterName === filterName) {
          return index2;
        }
      }
      throw new Error("filter not found: " + filterName);
    }
  }, {
    key: "list",
    value: function list() {
      return this.filters.map(function(f) {
        return f.filterName;
      });
    }
  }, {
    key: "after",
    value: function after(filterName) {
      var index2 = this.indexOf(filterName);
      var params = Array.prototype.slice.call(arguments, 1);
      if (!params.length) {
        throw new Error("a filter is required");
      }
      params.unshift(index2 + 1, 0);
      Array.prototype.splice.apply(this.filters, params);
      return this;
    }
  }, {
    key: "before",
    value: function before(filterName) {
      var index2 = this.indexOf(filterName);
      var params = Array.prototype.slice.call(arguments, 1);
      if (!params.length) {
        throw new Error("a filter is required");
      }
      params.unshift(index2, 0);
      Array.prototype.splice.apply(this.filters, params);
      return this;
    }
  }, {
    key: "replace",
    value: function replace(filterName) {
      var index2 = this.indexOf(filterName);
      var params = Array.prototype.slice.call(arguments, 1);
      if (!params.length) {
        throw new Error("a filter is required");
      }
      params.unshift(index2, 1);
      Array.prototype.splice.apply(this.filters, params);
      return this;
    }
  }, {
    key: "remove",
    value: function remove2(filterName) {
      var index2 = this.indexOf(filterName);
      this.filters.splice(index2, 1);
      return this;
    }
  }, {
    key: "clear",
    value: function clear2() {
      this.filters.length = 0;
      return this;
    }
  }, {
    key: "shouldHaveResult",
    value: function shouldHaveResult(should) {
      if (should === false) {
        this.resultCheck = null;
        return;
      }
      if (this.resultCheck) {
        return;
      }
      var pipe = this;
      this.resultCheck = function(context) {
        if (!context.hasResult) {
          console.log(context);
          var error = new Error(pipe.name + " failed");
          error.noResult = true;
          throw error;
        }
      };
      return this;
    }
  }]);
  return Pipe2;
}();
var Context = function() {
  function Context2() {
    classCallCheck(this, Context2);
  }
  createClass(Context2, [{
    key: "setResult",
    value: function setResult(result) {
      this.result = result;
      this.hasResult = true;
      return this;
    }
  }, {
    key: "exit",
    value: function exit() {
      this.exiting = true;
      return this;
    }
  }, {
    key: "switchTo",
    value: function switchTo(next, pipe) {
      if (typeof next === "string" || next instanceof Pipe) {
        this.nextPipe = next;
      } else {
        this.next = next;
        if (pipe) {
          this.nextPipe = pipe;
        }
      }
      return this;
    }
  }, {
    key: "push",
    value: function push(child, name) {
      child.parent = this;
      if (typeof name !== "undefined") {
        child.childName = name;
      }
      child.root = this.root || this;
      child.options = child.options || this.options;
      if (!this.children) {
        this.children = [child];
        this.nextAfterChildren = this.next || null;
        this.next = child;
      } else {
        this.children[this.children.length - 1].next = child;
        this.children.push(child);
      }
      child.next = this;
      return this;
    }
  }]);
  return Context2;
}();
var isArray$1 = typeof Array.isArray === "function" ? Array.isArray : function(a) {
  return a instanceof Array;
};
function cloneRegExp(re) {
  var regexMatch = /^\/(.*)\/([gimyu]*)$/.exec(re.toString());
  return new RegExp(regexMatch[1], regexMatch[2]);
}
function clone$2(arg) {
  if ((typeof arg === "undefined" ? "undefined" : _typeof(arg)) !== "object") {
    return arg;
  }
  if (arg === null) {
    return null;
  }
  if (isArray$1(arg)) {
    return arg.map(clone$2);
  }
  if (arg instanceof Date) {
    return new Date(arg.getTime());
  }
  if (arg instanceof RegExp) {
    return cloneRegExp(arg);
  }
  var cloned = {};
  for (var name in arg) {
    if (Object.prototype.hasOwnProperty.call(arg, name)) {
      cloned[name] = clone$2(arg[name]);
    }
  }
  return cloned;
}
var DiffContext = function(_Context) {
  inherits(DiffContext2, _Context);
  function DiffContext2(left, right) {
    classCallCheck(this, DiffContext2);
    var _this = possibleConstructorReturn(this, (DiffContext2.__proto__ || Object.getPrototypeOf(DiffContext2)).call(this));
    _this.left = left;
    _this.right = right;
    _this.pipe = "diff";
    return _this;
  }
  createClass(DiffContext2, [{
    key: "setResult",
    value: function setResult(result) {
      if (this.options.cloneDiffValues && (typeof result === "undefined" ? "undefined" : _typeof(result)) === "object") {
        var clone$$1 = typeof this.options.cloneDiffValues === "function" ? this.options.cloneDiffValues : clone$2;
        if (_typeof(result[0]) === "object") {
          result[0] = clone$$1(result[0]);
        }
        if (_typeof(result[1]) === "object") {
          result[1] = clone$$1(result[1]);
        }
      }
      return Context.prototype.setResult.apply(this, arguments);
    }
  }]);
  return DiffContext2;
}(Context);
var PatchContext = function(_Context) {
  inherits(PatchContext2, _Context);
  function PatchContext2(left, delta) {
    classCallCheck(this, PatchContext2);
    var _this = possibleConstructorReturn(this, (PatchContext2.__proto__ || Object.getPrototypeOf(PatchContext2)).call(this));
    _this.left = left;
    _this.delta = delta;
    _this.pipe = "patch";
    return _this;
  }
  return PatchContext2;
}(Context);
var ReverseContext = function(_Context) {
  inherits(ReverseContext2, _Context);
  function ReverseContext2(delta) {
    classCallCheck(this, ReverseContext2);
    var _this = possibleConstructorReturn(this, (ReverseContext2.__proto__ || Object.getPrototypeOf(ReverseContext2)).call(this));
    _this.delta = delta;
    _this.pipe = "reverse";
    return _this;
  }
  return ReverseContext2;
}(Context);
var isArray$1$1 = typeof Array.isArray === "function" ? Array.isArray : function(a) {
  return a instanceof Array;
};
var diffFilter = function trivialMatchesDiffFilter(context) {
  if (context.left === context.right) {
    context.setResult(void 0).exit();
    return;
  }
  if (typeof context.left === "undefined") {
    if (typeof context.right === "function") {
      throw new Error("functions are not supported");
    }
    context.setResult([context.right]).exit();
    return;
  }
  if (typeof context.right === "undefined") {
    context.setResult([context.left, 0, 0]).exit();
    return;
  }
  if (typeof context.left === "function" || typeof context.right === "function") {
    throw new Error("functions are not supported");
  }
  context.leftType = context.left === null ? "null" : _typeof(context.left);
  context.rightType = context.right === null ? "null" : _typeof(context.right);
  if (context.leftType !== context.rightType) {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  if (context.leftType === "boolean" || context.leftType === "number") {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  if (context.leftType === "object") {
    context.leftIsArray = isArray$1$1(context.left);
  }
  if (context.rightType === "object") {
    context.rightIsArray = isArray$1$1(context.right);
  }
  if (context.leftIsArray !== context.rightIsArray) {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  if (context.left instanceof RegExp) {
    if (context.right instanceof RegExp) {
      context.setResult([context.left.toString(), context.right.toString()]).exit();
    } else {
      context.setResult([context.left, context.right]).exit();
    }
  }
};
diffFilter.filterName = "trivial";
var patchFilter = function trivialMatchesPatchFilter(context) {
  if (typeof context.delta === "undefined") {
    context.setResult(context.left).exit();
    return;
  }
  context.nested = !isArray$1$1(context.delta);
  if (context.nested) {
    return;
  }
  if (context.delta.length === 1) {
    context.setResult(context.delta[0]).exit();
    return;
  }
  if (context.delta.length === 2) {
    if (context.left instanceof RegExp) {
      var regexArgs = /^\/(.*)\/([gimyu]+)$/.exec(context.delta[1]);
      if (regexArgs) {
        context.setResult(new RegExp(regexArgs[1], regexArgs[2])).exit();
        return;
      }
    }
    context.setResult(context.delta[1]).exit();
    return;
  }
  if (context.delta.length === 3 && context.delta[2] === 0) {
    context.setResult(void 0).exit();
  }
};
patchFilter.filterName = "trivial";
var reverseFilter = function trivialReferseFilter(context) {
  if (typeof context.delta === "undefined") {
    context.setResult(context.delta).exit();
    return;
  }
  context.nested = !isArray$1$1(context.delta);
  if (context.nested) {
    return;
  }
  if (context.delta.length === 1) {
    context.setResult([context.delta[0], 0, 0]).exit();
    return;
  }
  if (context.delta.length === 2) {
    context.setResult([context.delta[1], context.delta[0]]).exit();
    return;
  }
  if (context.delta.length === 3 && context.delta[2] === 0) {
    context.setResult([context.delta[0]]).exit();
  }
};
reverseFilter.filterName = "trivial";
function collectChildrenDiffFilter(context) {
  if (!context || !context.children) {
    return;
  }
  var length = context.children.length;
  var child = void 0;
  var result = context.result;
  for (var index2 = 0; index2 < length; index2++) {
    child = context.children[index2];
    if (typeof child.result === "undefined") {
      continue;
    }
    result = result || {};
    result[child.childName] = child.result;
  }
  if (result && context.leftIsArray) {
    result._t = "a";
  }
  context.setResult(result).exit();
}
collectChildrenDiffFilter.filterName = "collectChildren";
function objectsDiffFilter(context) {
  if (context.leftIsArray || context.leftType !== "object") {
    return;
  }
  var name = void 0;
  var child = void 0;
  var propertyFilter = context.options.propertyFilter;
  for (name in context.left) {
    if (!Object.prototype.hasOwnProperty.call(context.left, name)) {
      continue;
    }
    if (propertyFilter && !propertyFilter(name, context)) {
      continue;
    }
    child = new DiffContext(context.left[name], context.right[name]);
    context.push(child, name);
  }
  for (name in context.right) {
    if (!Object.prototype.hasOwnProperty.call(context.right, name)) {
      continue;
    }
    if (propertyFilter && !propertyFilter(name, context)) {
      continue;
    }
    if (typeof context.left[name] === "undefined") {
      child = new DiffContext(void 0, context.right[name]);
      context.push(child, name);
    }
  }
  if (!context.children || context.children.length === 0) {
    context.setResult(void 0).exit();
    return;
  }
  context.exit();
}
objectsDiffFilter.filterName = "objects";
var patchFilter$1 = function nestedPatchFilter(context) {
  if (!context.nested) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  var name = void 0;
  var child = void 0;
  for (name in context.delta) {
    child = new PatchContext(context.left[name], context.delta[name]);
    context.push(child, name);
  }
  context.exit();
};
patchFilter$1.filterName = "objects";
var collectChildrenPatchFilter = function collectChildrenPatchFilter2(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  var length = context.children.length;
  var child = void 0;
  for (var index2 = 0; index2 < length; index2++) {
    child = context.children[index2];
    if (Object.prototype.hasOwnProperty.call(context.left, child.childName) && child.result === void 0) {
      delete context.left[child.childName];
    } else if (context.left[child.childName] !== child.result) {
      context.left[child.childName] = child.result;
    }
  }
  context.setResult(context.left).exit();
};
collectChildrenPatchFilter.filterName = "collectChildren";
var reverseFilter$1 = function nestedReverseFilter(context) {
  if (!context.nested) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  var name = void 0;
  var child = void 0;
  for (name in context.delta) {
    child = new ReverseContext(context.delta[name]);
    context.push(child, name);
  }
  context.exit();
};
reverseFilter$1.filterName = "objects";
function collectChildrenReverseFilter(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  var length = context.children.length;
  var child = void 0;
  var delta = {};
  for (var index2 = 0; index2 < length; index2++) {
    child = context.children[index2];
    if (delta[child.childName] !== child.result) {
      delta[child.childName] = child.result;
    }
  }
  context.setResult(delta).exit();
}
collectChildrenReverseFilter.filterName = "collectChildren";
var defaultMatch = function defaultMatch2(array1, array2, index1, index2) {
  return array1[index1] === array2[index2];
};
var lengthMatrix = function lengthMatrix2(array1, array2, match, context) {
  var len1 = array1.length;
  var len2 = array2.length;
  var x = void 0, y = void 0;
  var matrix = [len1 + 1];
  for (x = 0; x < len1 + 1; x++) {
    matrix[x] = [len2 + 1];
    for (y = 0; y < len2 + 1; y++) {
      matrix[x][y] = 0;
    }
  }
  matrix.match = match;
  for (x = 1; x < len1 + 1; x++) {
    for (y = 1; y < len2 + 1; y++) {
      if (match(array1, array2, x - 1, y - 1, context)) {
        matrix[x][y] = matrix[x - 1][y - 1] + 1;
      } else {
        matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1]);
      }
    }
  }
  return matrix;
};
var backtrack = function backtrack2(matrix, array1, array2, context) {
  var index1 = array1.length;
  var index2 = array2.length;
  var subsequence = {
    sequence: [],
    indices1: [],
    indices2: []
  };
  while (index1 !== 0 && index2 !== 0) {
    var sameLetter = matrix.match(array1, array2, index1 - 1, index2 - 1, context);
    if (sameLetter) {
      subsequence.sequence.unshift(array1[index1 - 1]);
      subsequence.indices1.unshift(index1 - 1);
      subsequence.indices2.unshift(index2 - 1);
      --index1;
      --index2;
    } else {
      var valueAtMatrixAbove = matrix[index1][index2 - 1];
      var valueAtMatrixLeft = matrix[index1 - 1][index2];
      if (valueAtMatrixAbove > valueAtMatrixLeft) {
        --index2;
      } else {
        --index1;
      }
    }
  }
  return subsequence;
};
var get$1$1 = function get2(array1, array2, match, context) {
  var innerContext = context || {};
  var matrix = lengthMatrix(array1, array2, match || defaultMatch, innerContext);
  var result = backtrack(matrix, array1, array2, innerContext);
  if (typeof array1 === "string" && typeof array2 === "string") {
    result.sequence = result.sequence.join("");
  }
  return result;
};
var lcs = {
  get: get$1$1
};
var ARRAY_MOVE = 3;
var isArray$2 = typeof Array.isArray === "function" ? Array.isArray : function(a) {
  return a instanceof Array;
};
var arrayIndexOf = typeof Array.prototype.indexOf === "function" ? function(array, item) {
  return array.indexOf(item);
} : function(array, item) {
  var length = array.length;
  for (var i = 0; i < length; i++) {
    if (array[i] === item) {
      return i;
    }
  }
  return -1;
};
function arraysHaveMatchByRef(array1, array2, len1, len2) {
  for (var index1 = 0; index1 < len1; index1++) {
    var val1 = array1[index1];
    for (var index2 = 0; index2 < len2; index2++) {
      var val2 = array2[index2];
      if (index1 !== index2 && val1 === val2) {
        return true;
      }
    }
  }
}
function matchItems(array1, array2, index1, index2, context) {
  var value1 = array1[index1];
  var value2 = array2[index2];
  if (value1 === value2) {
    return true;
  }
  if ((typeof value1 === "undefined" ? "undefined" : _typeof(value1)) !== "object" || (typeof value2 === "undefined" ? "undefined" : _typeof(value2)) !== "object") {
    return false;
  }
  var objectHash = context.objectHash;
  if (!objectHash) {
    return context.matchByPosition && index1 === index2;
  }
  var hash1 = void 0;
  var hash2 = void 0;
  if (typeof index1 === "number") {
    context.hashCache1 = context.hashCache1 || [];
    hash1 = context.hashCache1[index1];
    if (typeof hash1 === "undefined") {
      context.hashCache1[index1] = hash1 = objectHash(value1, index1);
    }
  } else {
    hash1 = objectHash(value1);
  }
  if (typeof hash1 === "undefined") {
    return false;
  }
  if (typeof index2 === "number") {
    context.hashCache2 = context.hashCache2 || [];
    hash2 = context.hashCache2[index2];
    if (typeof hash2 === "undefined") {
      context.hashCache2[index2] = hash2 = objectHash(value2, index2);
    }
  } else {
    hash2 = objectHash(value2);
  }
  if (typeof hash2 === "undefined") {
    return false;
  }
  return hash1 === hash2;
}
var diffFilter$1 = function arraysDiffFilter(context) {
  if (!context.leftIsArray) {
    return;
  }
  var matchContext = {
    objectHash: context.options && context.options.objectHash,
    matchByPosition: context.options && context.options.matchByPosition
  };
  var commonHead = 0;
  var commonTail = 0;
  var index2 = void 0;
  var index1 = void 0;
  var index22 = void 0;
  var array1 = context.left;
  var array2 = context.right;
  var len1 = array1.length;
  var len2 = array2.length;
  var child = void 0;
  if (len1 > 0 && len2 > 0 && !matchContext.objectHash && typeof matchContext.matchByPosition !== "boolean") {
    matchContext.matchByPosition = !arraysHaveMatchByRef(array1, array2, len1, len2);
  }
  while (commonHead < len1 && commonHead < len2 && matchItems(array1, array2, commonHead, commonHead, matchContext)) {
    index2 = commonHead;
    child = new DiffContext(context.left[index2], context.right[index2]);
    context.push(child, index2);
    commonHead++;
  }
  while (commonTail + commonHead < len1 && commonTail + commonHead < len2 && matchItems(array1, array2, len1 - 1 - commonTail, len2 - 1 - commonTail, matchContext)) {
    index1 = len1 - 1 - commonTail;
    index22 = len2 - 1 - commonTail;
    child = new DiffContext(context.left[index1], context.right[index22]);
    context.push(child, index22);
    commonTail++;
  }
  var result = void 0;
  if (commonHead + commonTail === len1) {
    if (len1 === len2) {
      context.setResult(void 0).exit();
      return;
    }
    result = result || {
      _t: "a"
    };
    for (index2 = commonHead; index2 < len2 - commonTail; index2++) {
      result[index2] = [array2[index2]];
    }
    context.setResult(result).exit();
    return;
  }
  if (commonHead + commonTail === len2) {
    result = result || {
      _t: "a"
    };
    for (index2 = commonHead; index2 < len1 - commonTail; index2++) {
      result["_" + index2] = [array1[index2], 0, 0];
    }
    context.setResult(result).exit();
    return;
  }
  delete matchContext.hashCache1;
  delete matchContext.hashCache2;
  var trimmed1 = array1.slice(commonHead, len1 - commonTail);
  var trimmed2 = array2.slice(commonHead, len2 - commonTail);
  var seq = lcs.get(trimmed1, trimmed2, matchItems, matchContext);
  var removedItems = [];
  result = result || {
    _t: "a"
  };
  for (index2 = commonHead; index2 < len1 - commonTail; index2++) {
    if (arrayIndexOf(seq.indices1, index2 - commonHead) < 0) {
      result["_" + index2] = [array1[index2], 0, 0];
      removedItems.push(index2);
    }
  }
  var detectMove = true;
  if (context.options && context.options.arrays && context.options.arrays.detectMove === false) {
    detectMove = false;
  }
  var includeValueOnMove = false;
  if (context.options && context.options.arrays && context.options.arrays.includeValueOnMove) {
    includeValueOnMove = true;
  }
  var removedItemsLength = removedItems.length;
  for (index2 = commonHead; index2 < len2 - commonTail; index2++) {
    var indexOnArray2 = arrayIndexOf(seq.indices2, index2 - commonHead);
    if (indexOnArray2 < 0) {
      var isMove = false;
      if (detectMove && removedItemsLength > 0) {
        for (var removeItemIndex1 = 0; removeItemIndex1 < removedItemsLength; removeItemIndex1++) {
          index1 = removedItems[removeItemIndex1];
          if (matchItems(trimmed1, trimmed2, index1 - commonHead, index2 - commonHead, matchContext)) {
            result["_" + index1].splice(1, 2, index2, ARRAY_MOVE);
            if (!includeValueOnMove) {
              result["_" + index1][0] = "";
            }
            index22 = index2;
            child = new DiffContext(context.left[index1], context.right[index22]);
            context.push(child, index22);
            removedItems.splice(removeItemIndex1, 1);
            isMove = true;
            break;
          }
        }
      }
      if (!isMove) {
        result[index2] = [array2[index2]];
      }
    } else {
      index1 = seq.indices1[indexOnArray2] + commonHead;
      index22 = seq.indices2[indexOnArray2] + commonHead;
      child = new DiffContext(context.left[index1], context.right[index22]);
      context.push(child, index22);
    }
  }
  context.setResult(result).exit();
};
diffFilter$1.filterName = "arrays";
var compare = {
  numerically: function numerically(a, b) {
    return a - b;
  },
  numericallyBy: function numericallyBy(name) {
    return function(a, b) {
      return a[name] - b[name];
    };
  }
};
var patchFilter$2 = function nestedPatchFilter2(context) {
  if (!context.nested) {
    return;
  }
  if (context.delta._t !== "a") {
    return;
  }
  var index2 = void 0;
  var index1 = void 0;
  var delta = context.delta;
  var array = context.left;
  var toRemove = [];
  var toInsert = [];
  var toModify = [];
  for (index2 in delta) {
    if (index2 !== "_t") {
      if (index2[0] === "_") {
        if (delta[index2][2] === 0 || delta[index2][2] === ARRAY_MOVE) {
          toRemove.push(parseInt(index2.slice(1), 10));
        } else {
          throw new Error("only removal or move can be applied at original array indices," + (" invalid diff type: " + delta[index2][2]));
        }
      } else {
        if (delta[index2].length === 1) {
          toInsert.push({
            index: parseInt(index2, 10),
            value: delta[index2][0]
          });
        } else {
          toModify.push({
            index: parseInt(index2, 10),
            delta: delta[index2]
          });
        }
      }
    }
  }
  toRemove = toRemove.sort(compare.numerically);
  for (index2 = toRemove.length - 1; index2 >= 0; index2--) {
    index1 = toRemove[index2];
    var indexDiff = delta["_" + index1];
    var removedValue = array.splice(index1, 1)[0];
    if (indexDiff[2] === ARRAY_MOVE) {
      toInsert.push({
        index: indexDiff[1],
        value: removedValue
      });
    }
  }
  toInsert = toInsert.sort(compare.numericallyBy("index"));
  var toInsertLength = toInsert.length;
  for (index2 = 0; index2 < toInsertLength; index2++) {
    var insertion = toInsert[index2];
    array.splice(insertion.index, 0, insertion.value);
  }
  var toModifyLength = toModify.length;
  var child = void 0;
  if (toModifyLength > 0) {
    for (index2 = 0; index2 < toModifyLength; index2++) {
      var modification = toModify[index2];
      child = new PatchContext(context.left[modification.index], modification.delta);
      context.push(child, modification.index);
    }
  }
  if (!context.children) {
    context.setResult(context.left).exit();
    return;
  }
  context.exit();
};
patchFilter$2.filterName = "arrays";
var collectChildrenPatchFilter$1 = function collectChildrenPatchFilter3(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t !== "a") {
    return;
  }
  var length = context.children.length;
  var child = void 0;
  for (var index2 = 0; index2 < length; index2++) {
    child = context.children[index2];
    context.left[child.childName] = child.result;
  }
  context.setResult(context.left).exit();
};
collectChildrenPatchFilter$1.filterName = "arraysCollectChildren";
var reverseFilter$2 = function arraysReverseFilter(context) {
  if (!context.nested) {
    if (context.delta[2] === ARRAY_MOVE) {
      context.newName = "_" + context.delta[1];
      context.setResult([context.delta[0], parseInt(context.childName.substr(1), 10), ARRAY_MOVE]).exit();
    }
    return;
  }
  if (context.delta._t !== "a") {
    return;
  }
  var name = void 0;
  var child = void 0;
  for (name in context.delta) {
    if (name === "_t") {
      continue;
    }
    child = new ReverseContext(context.delta[name]);
    context.push(child, name);
  }
  context.exit();
};
reverseFilter$2.filterName = "arrays";
var reverseArrayDeltaIndex = function reverseArrayDeltaIndex2(delta, index2, itemDelta) {
  if (typeof index2 === "string" && index2[0] === "_") {
    return parseInt(index2.substr(1), 10);
  } else if (isArray$2(itemDelta) && itemDelta[2] === 0) {
    return "_" + index2;
  }
  var reverseIndex = +index2;
  for (var deltaIndex in delta) {
    var deltaItem = delta[deltaIndex];
    if (isArray$2(deltaItem)) {
      if (deltaItem[2] === ARRAY_MOVE) {
        var moveFromIndex = parseInt(deltaIndex.substr(1), 10);
        var moveToIndex = deltaItem[1];
        if (moveToIndex === +index2) {
          return moveFromIndex;
        }
        if (moveFromIndex <= reverseIndex && moveToIndex > reverseIndex) {
          reverseIndex++;
        } else if (moveFromIndex >= reverseIndex && moveToIndex < reverseIndex) {
          reverseIndex--;
        }
      } else if (deltaItem[2] === 0) {
        var deleteIndex = parseInt(deltaIndex.substr(1), 10);
        if (deleteIndex <= reverseIndex) {
          reverseIndex++;
        }
      } else if (deltaItem.length === 1 && deltaIndex <= reverseIndex) {
        reverseIndex--;
      }
    }
  }
  return reverseIndex;
};
function collectChildrenReverseFilter$1(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t !== "a") {
    return;
  }
  var length = context.children.length;
  var child = void 0;
  var delta = {
    _t: "a"
  };
  for (var index2 = 0; index2 < length; index2++) {
    child = context.children[index2];
    var name = child.newName;
    if (typeof name === "undefined") {
      name = reverseArrayDeltaIndex(context.delta, child.childName, child.result);
    }
    if (delta[name] !== child.result) {
      delta[name] = child.result;
    }
  }
  context.setResult(delta).exit();
}
collectChildrenReverseFilter$1.filterName = "arraysCollectChildren";
var diffFilter$2 = function datesDiffFilter(context) {
  if (context.left instanceof Date) {
    if (context.right instanceof Date) {
      if (context.left.getTime() !== context.right.getTime()) {
        context.setResult([context.left, context.right]);
      } else {
        context.setResult(void 0);
      }
    } else {
      context.setResult([context.left, context.right]);
    }
    context.exit();
  } else if (context.right instanceof Date) {
    context.setResult([context.left, context.right]).exit();
  }
};
diffFilter$2.filterName = "dates";
var TEXT_DIFF = 2;
var DEFAULT_MIN_LENGTH = 60;
var cachedDiffPatch = null;
var getDiffMatchPatch = function getDiffMatchPatch2(required) {
  if (!cachedDiffPatch) {
    var instance2 = void 0;
    if (typeof diff_match_patch !== "undefined") {
      instance2 = typeof diff_match_patch === "function" ? new diff_match_patch() : new diff_match_patch.diff_match_patch();
    } else if (dmp) {
      try {
        instance2 = dmp && new dmp();
      } catch (err) {
        instance2 = null;
      }
    }
    if (!instance2) {
      if (!required) {
        return null;
      }
      var error = new Error("text diff_match_patch library not found");
      error.diff_match_patch_not_found = true;
      throw error;
    }
    cachedDiffPatch = {
      diff: function diff2(txt1, txt2) {
        return instance2.patch_toText(instance2.patch_make(txt1, txt2));
      },
      patch: function patch(txt1, _patch) {
        var results = instance2.patch_apply(instance2.patch_fromText(_patch), txt1);
        for (var i = 0; i < results[1].length; i++) {
          if (!results[1][i]) {
            var _error = new Error("text patch failed");
            _error.textPatchFailed = true;
          }
        }
        return results[0];
      }
    };
  }
  return cachedDiffPatch;
};
var diffFilter$3 = function textsDiffFilter(context) {
  if (context.leftType !== "string") {
    return;
  }
  var minLength = context.options && context.options.textDiff && context.options.textDiff.minLength || DEFAULT_MIN_LENGTH;
  if (context.left.length < minLength || context.right.length < minLength) {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  var diffMatchPatch2 = getDiffMatchPatch();
  if (!diffMatchPatch2) {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  var diff2 = diffMatchPatch2.diff;
  context.setResult([diff2(context.left, context.right), 0, TEXT_DIFF]).exit();
};
diffFilter$3.filterName = "texts";
var patchFilter$3 = function textsPatchFilter(context) {
  if (context.nested) {
    return;
  }
  if (context.delta[2] !== TEXT_DIFF) {
    return;
  }
  var patch = getDiffMatchPatch(true).patch;
  context.setResult(patch(context.left, context.delta[0])).exit();
};
patchFilter$3.filterName = "texts";
var textDeltaReverse = function textDeltaReverse2(delta) {
  var i = void 0;
  var l = void 0;
  var lines = void 0;
  var line = void 0;
  var lineTmp = void 0;
  var header = null;
  var headerRegex = /^@@ +-(\d+),(\d+) +\+(\d+),(\d+) +@@$/;
  var lineHeader = void 0;
  lines = delta.split("\n");
  for (i = 0, l = lines.length; i < l; i++) {
    line = lines[i];
    var lineStart = line.slice(0, 1);
    if (lineStart === "@") {
      header = headerRegex.exec(line);
      lineHeader = i;
      lines[lineHeader] = "@@ -" + header[3] + "," + header[4] + " +" + header[1] + "," + header[2] + " @@";
    } else if (lineStart === "+") {
      lines[i] = "-" + lines[i].slice(1);
      if (lines[i - 1].slice(0, 1) === "+") {
        lineTmp = lines[i];
        lines[i] = lines[i - 1];
        lines[i - 1] = lineTmp;
      }
    } else if (lineStart === "-") {
      lines[i] = "+" + lines[i].slice(1);
    }
  }
  return lines.join("\n");
};
var reverseFilter$3 = function textsReverseFilter(context) {
  if (context.nested) {
    return;
  }
  if (context.delta[2] !== TEXT_DIFF) {
    return;
  }
  context.setResult([textDeltaReverse(context.delta[0]), 0, TEXT_DIFF]).exit();
};
reverseFilter$3.filterName = "texts";
var DiffPatcher = function() {
  function DiffPatcher2(options) {
    classCallCheck(this, DiffPatcher2);
    this.processor = new Processor(options);
    this.processor.pipe(new Pipe("diff").append(collectChildrenDiffFilter, diffFilter, diffFilter$2, diffFilter$3, objectsDiffFilter, diffFilter$1).shouldHaveResult());
    this.processor.pipe(new Pipe("patch").append(collectChildrenPatchFilter, collectChildrenPatchFilter$1, patchFilter, patchFilter$3, patchFilter$1, patchFilter$2).shouldHaveResult());
    this.processor.pipe(new Pipe("reverse").append(collectChildrenReverseFilter, collectChildrenReverseFilter$1, reverseFilter, reverseFilter$3, reverseFilter$1, reverseFilter$2).shouldHaveResult());
  }
  createClass(DiffPatcher2, [{
    key: "options",
    value: function options() {
      var _processor;
      return (_processor = this.processor).options.apply(_processor, arguments);
    }
  }, {
    key: "diff",
    value: function diff2(left, right) {
      return this.processor.process(new DiffContext(left, right));
    }
  }, {
    key: "patch",
    value: function patch(left, delta) {
      return this.processor.process(new PatchContext(left, delta));
    }
  }, {
    key: "reverse",
    value: function reverse(delta) {
      return this.processor.process(new ReverseContext(delta));
    }
  }, {
    key: "unpatch",
    value: function unpatch(right, delta) {
      return this.patch(right, this.reverse(delta));
    }
  }, {
    key: "clone",
    value: function clone$$1(value) {
      return clone$2(value);
    }
  }]);
  return DiffPatcher2;
}();
var isArray$3 = typeof Array.isArray === "function" ? Array.isArray : function(a) {
  return a instanceof Array;
};
var getObjectKeys = typeof Object.keys === "function" ? function(obj) {
  return Object.keys(obj);
} : function(obj) {
  var names2 = [];
  for (var property in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, property)) {
      names2.push(property);
    }
  }
  return names2;
};
var trimUnderscore = function trimUnderscore2(str) {
  if (str.substr(0, 1) === "_") {
    return str.slice(1);
  }
  return str;
};
var arrayKeyToSortNumber = function arrayKeyToSortNumber2(key) {
  if (key === "_t") {
    return -1;
  } else {
    if (key.substr(0, 1) === "_") {
      return parseInt(key.slice(1), 10);
    } else {
      return parseInt(key, 10) + 0.1;
    }
  }
};
var arrayKeyComparer = function arrayKeyComparer2(key1, key2) {
  return arrayKeyToSortNumber(key1) - arrayKeyToSortNumber(key2);
};
var BaseFormatter = function() {
  function BaseFormatter2() {
    classCallCheck(this, BaseFormatter2);
  }
  createClass(BaseFormatter2, [{
    key: "format",
    value: function format2(delta, left) {
      var context = {};
      this.prepareContext(context);
      this.recurse(context, delta, left);
      return this.finalize(context);
    }
  }, {
    key: "prepareContext",
    value: function prepareContext(context) {
      context.buffer = [];
      context.out = function() {
        var _buffer;
        (_buffer = this.buffer).push.apply(_buffer, arguments);
      };
    }
  }, {
    key: "typeFormattterNotFound",
    value: function typeFormattterNotFound(context, deltaType) {
      throw new Error("cannot format delta type: " + deltaType);
    }
  }, {
    key: "typeFormattterErrorFormatter",
    value: function typeFormattterErrorFormatter(context, err) {
      return err.toString();
    }
  }, {
    key: "finalize",
    value: function finalize(_ref) {
      var buffer = _ref.buffer;
      if (isArray$3(buffer)) {
        return buffer.join("");
      }
    }
  }, {
    key: "recurse",
    value: function recurse(context, delta, left, key, leftKey, movedFrom, isLast) {
      var useMoveOriginHere = delta && movedFrom;
      var leftValue = useMoveOriginHere ? movedFrom.value : left;
      if (typeof delta === "undefined" && typeof key === "undefined") {
        return void 0;
      }
      var type2 = this.getDeltaType(delta, movedFrom);
      var nodeType = type2 === "node" ? delta._t === "a" ? "array" : "object" : "";
      if (typeof key !== "undefined") {
        this.nodeBegin(context, key, leftKey, type2, nodeType, isLast);
      } else {
        this.rootBegin(context, type2, nodeType);
      }
      var typeFormattter = void 0;
      try {
        typeFormattter = this["format_" + type2] || this.typeFormattterNotFound(context, type2);
        typeFormattter.call(this, context, delta, leftValue, key, leftKey, movedFrom);
      } catch (err) {
        this.typeFormattterErrorFormatter(context, err, delta, leftValue, key, leftKey, movedFrom);
        if (typeof console !== "undefined" && console.error) {
          console.error(err.stack);
        }
      }
      if (typeof key !== "undefined") {
        this.nodeEnd(context, key, leftKey, type2, nodeType, isLast);
      } else {
        this.rootEnd(context, type2, nodeType);
      }
    }
  }, {
    key: "formatDeltaChildren",
    value: function formatDeltaChildren(context, delta, left) {
      var self2 = this;
      this.forEachDeltaKey(delta, left, function(key, leftKey, movedFrom, isLast) {
        self2.recurse(context, delta[key], left ? left[leftKey] : void 0, key, leftKey, movedFrom, isLast);
      });
    }
  }, {
    key: "forEachDeltaKey",
    value: function forEachDeltaKey(delta, left, fn) {
      var keys = getObjectKeys(delta);
      var arrayKeys = delta._t === "a";
      var moveDestinations = {};
      var name = void 0;
      if (typeof left !== "undefined") {
        for (name in left) {
          if (Object.prototype.hasOwnProperty.call(left, name)) {
            if (typeof delta[name] === "undefined" && (!arrayKeys || typeof delta["_" + name] === "undefined")) {
              keys.push(name);
            }
          }
        }
      }
      for (name in delta) {
        if (Object.prototype.hasOwnProperty.call(delta, name)) {
          var value = delta[name];
          if (isArray$3(value) && value[2] === 3) {
            moveDestinations[value[1].toString()] = {
              key: name,
              value: left && left[parseInt(name.substr(1))]
            };
            if (this.includeMoveDestinations !== false) {
              if (typeof left === "undefined" && typeof delta[value[1]] === "undefined") {
                keys.push(value[1].toString());
              }
            }
          }
        }
      }
      if (arrayKeys) {
        keys.sort(arrayKeyComparer);
      } else {
        keys.sort();
      }
      for (var index2 = 0, length = keys.length; index2 < length; index2++) {
        var key = keys[index2];
        if (arrayKeys && key === "_t") {
          continue;
        }
        var leftKey = arrayKeys ? typeof key === "number" ? key : parseInt(trimUnderscore(key), 10) : key;
        var isLast = index2 === length - 1;
        fn(key, leftKey, moveDestinations[leftKey], isLast);
      }
    }
  }, {
    key: "getDeltaType",
    value: function getDeltaType(delta, movedFrom) {
      if (typeof delta === "undefined") {
        if (typeof movedFrom !== "undefined") {
          return "movedestination";
        }
        return "unchanged";
      }
      if (isArray$3(delta)) {
        if (delta.length === 1) {
          return "added";
        }
        if (delta.length === 2) {
          return "modified";
        }
        if (delta.length === 3 && delta[2] === 0) {
          return "deleted";
        }
        if (delta.length === 3 && delta[2] === 2) {
          return "textdiff";
        }
        if (delta.length === 3 && delta[2] === 3) {
          return "moved";
        }
      } else if ((typeof delta === "undefined" ? "undefined" : _typeof(delta)) === "object") {
        return "node";
      }
      return "unknown";
    }
  }, {
    key: "parseTextDiff",
    value: function parseTextDiff(value) {
      var output = [];
      var lines = value.split("\n@@ ");
      for (var i = 0, l = lines.length; i < l; i++) {
        var line = lines[i];
        var lineOutput = {
          pieces: []
        };
        var location2 = /^(?:@@ )?[-+]?(\d+),(\d+)/.exec(line).slice(1);
        lineOutput.location = {
          line: location2[0],
          chr: location2[1]
        };
        var pieces = line.split("\n").slice(1);
        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
          var piece = pieces[pieceIndex];
          if (!piece.length) {
            continue;
          }
          var pieceOutput = {
            type: "context"
          };
          if (piece.substr(0, 1) === "+") {
            pieceOutput.type = "added";
          } else if (piece.substr(0, 1) === "-") {
            pieceOutput.type = "deleted";
          }
          pieceOutput.text = piece.slice(1);
          lineOutput.pieces.push(pieceOutput);
        }
        output.push(lineOutput);
      }
      return output;
    }
  }]);
  return BaseFormatter2;
}();
(function(_BaseFormatter) {
  inherits(HtmlFormatter, _BaseFormatter);
  function HtmlFormatter() {
    classCallCheck(this, HtmlFormatter);
    return possibleConstructorReturn(this, (HtmlFormatter.__proto__ || Object.getPrototypeOf(HtmlFormatter)).apply(this, arguments));
  }
  createClass(HtmlFormatter, [{
    key: "typeFormattterErrorFormatter",
    value: function typeFormattterErrorFormatter(context, err) {
      context.out('<pre class="jsondiffpatch-error">' + err + "</pre>");
    }
  }, {
    key: "formatValue",
    value: function formatValue(context, value) {
      context.out("<pre>" + htmlEscape(JSON.stringify(value, null, 2)) + "</pre>");
    }
  }, {
    key: "formatTextDiffString",
    value: function formatTextDiffString(context, value) {
      var lines = this.parseTextDiff(value);
      context.out('<ul class="jsondiffpatch-textdiff">');
      for (var i = 0, l = lines.length; i < l; i++) {
        var line = lines[i];
        context.out('<li><div class="jsondiffpatch-textdiff-location">' + ('<span class="jsondiffpatch-textdiff-line-number">' + line.location.line + '</span><span class="jsondiffpatch-textdiff-char">' + line.location.chr + '</span></div><div class="jsondiffpatch-textdiff-line">'));
        var pieces = line.pieces;
        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
          var piece = pieces[pieceIndex];
          context.out('<span class="jsondiffpatch-textdiff-' + piece.type + '">' + htmlEscape(decodeURI(piece.text)) + "</span>");
        }
        context.out("</div></li>");
      }
      context.out("</ul>");
    }
  }, {
    key: "rootBegin",
    value: function rootBegin(context, type2, nodeType) {
      var nodeClass = "jsondiffpatch-" + type2 + (nodeType ? " jsondiffpatch-child-node-type-" + nodeType : "");
      context.out('<div class="jsondiffpatch-delta ' + nodeClass + '">');
    }
  }, {
    key: "rootEnd",
    value: function rootEnd(context) {
      context.out("</div>" + (context.hasArrows ? '<script type="text/javascript">setTimeout(' + (adjustArrows.toString() + ",10);<\/script>") : ""));
    }
  }, {
    key: "nodeBegin",
    value: function nodeBegin(context, key, leftKey, type2, nodeType) {
      var nodeClass = "jsondiffpatch-" + type2 + (nodeType ? " jsondiffpatch-child-node-type-" + nodeType : "");
      context.out('<li class="' + nodeClass + '" data-key="' + leftKey + '">' + ('<div class="jsondiffpatch-property-name">' + leftKey + "</div>"));
    }
  }, {
    key: "nodeEnd",
    value: function nodeEnd(context) {
      context.out("</li>");
    }
    /* jshint camelcase: false */
    /* eslint-disable camelcase */
  }, {
    key: "format_unchanged",
    value: function format_unchanged(context, delta, left) {
      if (typeof left === "undefined") {
        return;
      }
      context.out('<div class="jsondiffpatch-value">');
      this.formatValue(context, left);
      context.out("</div>");
    }
  }, {
    key: "format_movedestination",
    value: function format_movedestination(context, delta, left) {
      if (typeof left === "undefined") {
        return;
      }
      context.out('<div class="jsondiffpatch-value">');
      this.formatValue(context, left);
      context.out("</div>");
    }
  }, {
    key: "format_node",
    value: function format_node(context, delta, left) {
      var nodeType = delta._t === "a" ? "array" : "object";
      context.out('<ul class="jsondiffpatch-node jsondiffpatch-node-type-' + nodeType + '">');
      this.formatDeltaChildren(context, delta, left);
      context.out("</ul>");
    }
  }, {
    key: "format_added",
    value: function format_added(context, delta) {
      context.out('<div class="jsondiffpatch-value">');
      this.formatValue(context, delta[0]);
      context.out("</div>");
    }
  }, {
    key: "format_modified",
    value: function format_modified(context, delta) {
      context.out('<div class="jsondiffpatch-value jsondiffpatch-left-value">');
      this.formatValue(context, delta[0]);
      context.out('</div><div class="jsondiffpatch-value jsondiffpatch-right-value">');
      this.formatValue(context, delta[1]);
      context.out("</div>");
    }
  }, {
    key: "format_deleted",
    value: function format_deleted(context, delta) {
      context.out('<div class="jsondiffpatch-value">');
      this.formatValue(context, delta[0]);
      context.out("</div>");
    }
  }, {
    key: "format_moved",
    value: function format_moved(context, delta) {
      context.out('<div class="jsondiffpatch-value">');
      this.formatValue(context, delta[0]);
      context.out('</div><div class="jsondiffpatch-moved-destination">' + delta[1] + "</div>");
      context.out(
        /* jshint multistr: true */
        '<div class="jsondiffpatch-arrow" style="position: relative; left: -34px;">\n          <svg width="30" height="60" style="position: absolute; display: none;">\n          <defs>\n              <marker id="markerArrow" markerWidth="8" markerHeight="8"\n                 refx="2" refy="4"\n                     orient="auto" markerUnits="userSpaceOnUse">\n                  <path d="M1,1 L1,7 L7,4 L1,1" style="fill: #339;" />\n              </marker>\n          </defs>\n          <path d="M30,0 Q-10,25 26,50"\n            style="stroke: #88f; stroke-width: 2px; fill: none; stroke-opacity: 0.5; marker-end: url(#markerArrow);"\n          ></path>\n          </svg>\n      </div>'
      );
      context.hasArrows = true;
    }
  }, {
    key: "format_textdiff",
    value: function format_textdiff(context, delta) {
      context.out('<div class="jsondiffpatch-value">');
      this.formatTextDiffString(context, delta[0]);
      context.out("</div>");
    }
  }]);
  return HtmlFormatter;
})(BaseFormatter);
function htmlEscape(text) {
  var html = text;
  var replacements = [[/&/g, "&amp;"], [/</g, "&lt;"], [/>/g, "&gt;"], [/'/g, "&apos;"], [/"/g, "&quot;"]];
  for (var i = 0; i < replacements.length; i++) {
    html = html.replace(replacements[i][0], replacements[i][1]);
  }
  return html;
}
var adjustArrows = function jsondiffpatchHtmlFormatterAdjustArrows(nodeArg) {
  var node = nodeArg || document;
  var getElementText = function getElementText2(_ref) {
    var textContent = _ref.textContent, innerText = _ref.innerText;
    return textContent || innerText;
  };
  var eachByQuery = function eachByQuery2(el, query, fn) {
    var elems = el.querySelectorAll(query);
    for (var i = 0, l = elems.length; i < l; i++) {
      fn(elems[i]);
    }
  };
  var eachChildren = function eachChildren2(_ref2, fn) {
    var children = _ref2.children;
    for (var i = 0, l = children.length; i < l; i++) {
      fn(children[i], i);
    }
  };
  eachByQuery(node, ".jsondiffpatch-arrow", function(_ref3) {
    var parentNode = _ref3.parentNode, children = _ref3.children, style = _ref3.style;
    var arrowParent = parentNode;
    var svg = children[0];
    var path = svg.children[1];
    svg.style.display = "none";
    var destination = getElementText(arrowParent.querySelector(".jsondiffpatch-moved-destination"));
    var container = arrowParent.parentNode;
    var destinationElem = void 0;
    eachChildren(container, function(child) {
      if (child.getAttribute("data-key") === destination) {
        destinationElem = child;
      }
    });
    if (!destinationElem) {
      return;
    }
    try {
      var distance2 = destinationElem.offsetTop - arrowParent.offsetTop;
      svg.setAttribute("height", Math.abs(distance2) + 6);
      style.top = -8 + (distance2 > 0 ? 0 : distance2) + "px";
      var curve = distance2 > 0 ? "M30,0 Q-10," + Math.round(distance2 / 2) + " 26," + (distance2 - 4) : "M30," + -distance2 + " Q-10," + Math.round(-distance2 / 2) + " 26,4";
      path.setAttribute("d", curve);
      svg.style.display = "";
    } catch (err) {
    }
  });
};
var AnnotatedFormatter = function(_BaseFormatter) {
  inherits(AnnotatedFormatter2, _BaseFormatter);
  function AnnotatedFormatter2() {
    classCallCheck(this, AnnotatedFormatter2);
    var _this = possibleConstructorReturn(this, (AnnotatedFormatter2.__proto__ || Object.getPrototypeOf(AnnotatedFormatter2)).call(this));
    _this.includeMoveDestinations = false;
    return _this;
  }
  createClass(AnnotatedFormatter2, [{
    key: "prepareContext",
    value: function prepareContext(context) {
      get$1(AnnotatedFormatter2.prototype.__proto__ || Object.getPrototypeOf(AnnotatedFormatter2.prototype), "prepareContext", this).call(this, context);
      context.indent = function(levels) {
        this.indentLevel = (this.indentLevel || 0) + (typeof levels === "undefined" ? 1 : levels);
        this.indentPad = new Array(this.indentLevel + 1).join("&nbsp;&nbsp;");
      };
      context.row = function(json, htmlNote) {
        context.out('<tr><td style="white-space: nowrap;"><pre class="jsondiffpatch-annotated-indent" style="display: inline-block">');
        context.out(context.indentPad);
        context.out('</pre><pre style="display: inline-block">');
        context.out(json);
        context.out('</pre></td><td class="jsondiffpatch-delta-note"><div>');
        context.out(htmlNote);
        context.out("</div></td></tr>");
      };
    }
  }, {
    key: "typeFormattterErrorFormatter",
    value: function typeFormattterErrorFormatter(context, err) {
      context.row("", '<pre class="jsondiffpatch-error">' + err + "</pre>");
    }
  }, {
    key: "formatTextDiffString",
    value: function formatTextDiffString(context, value) {
      var lines = this.parseTextDiff(value);
      context.out('<ul class="jsondiffpatch-textdiff">');
      for (var i = 0, l = lines.length; i < l; i++) {
        var line = lines[i];
        context.out('<li><div class="jsondiffpatch-textdiff-location">' + ('<span class="jsondiffpatch-textdiff-line-number">' + line.location.line + '</span><span class="jsondiffpatch-textdiff-char">' + line.location.chr + '</span></div><div class="jsondiffpatch-textdiff-line">'));
        var pieces = line.pieces;
        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
          var piece = pieces[pieceIndex];
          context.out('<span class="jsondiffpatch-textdiff-' + piece.type + '">' + piece.text + "</span>");
        }
        context.out("</div></li>");
      }
      context.out("</ul>");
    }
  }, {
    key: "rootBegin",
    value: function rootBegin(context, type2, nodeType) {
      context.out('<table class="jsondiffpatch-annotated-delta">');
      if (type2 === "node") {
        context.row("{");
        context.indent();
      }
      if (nodeType === "array") {
        context.row('"_t": "a",', "Array delta (member names indicate array indices)");
      }
    }
  }, {
    key: "rootEnd",
    value: function rootEnd(context, type2) {
      if (type2 === "node") {
        context.indent(-1);
        context.row("}");
      }
      context.out("</table>");
    }
  }, {
    key: "nodeBegin",
    value: function nodeBegin(context, key, leftKey, type2, nodeType) {
      context.row("&quot;" + key + "&quot;: {");
      if (type2 === "node") {
        context.indent();
      }
      if (nodeType === "array") {
        context.row('"_t": "a",', "Array delta (member names indicate array indices)");
      }
    }
  }, {
    key: "nodeEnd",
    value: function nodeEnd(context, key, leftKey, type2, nodeType, isLast) {
      if (type2 === "node") {
        context.indent(-1);
      }
      context.row("}" + (isLast ? "" : ","));
    }
    /* jshint camelcase: false */
    /* eslint-disable camelcase */
  }, {
    key: "format_unchanged",
    value: function format_unchanged() {
    }
  }, {
    key: "format_movedestination",
    value: function format_movedestination() {
    }
  }, {
    key: "format_node",
    value: function format_node(context, delta, left) {
      this.formatDeltaChildren(context, delta, left);
    }
  }]);
  return AnnotatedFormatter2;
}(BaseFormatter);
var wrapPropertyName = function wrapPropertyName2(name) {
  return '<pre style="display:inline-block">&quot;' + name + "&quot;</pre>";
};
var deltaAnnotations = {
  added: function added(delta, left, key, leftKey) {
    var formatLegend = " <pre>([newValue])</pre>";
    if (typeof leftKey === "undefined") {
      return "new value" + formatLegend;
    }
    if (typeof leftKey === "number") {
      return "insert at index " + leftKey + formatLegend;
    }
    return "add property " + wrapPropertyName(leftKey) + formatLegend;
  },
  modified: function modified(delta, left, key, leftKey) {
    var formatLegend = " <pre>([previousValue, newValue])</pre>";
    if (typeof leftKey === "undefined") {
      return "modify value" + formatLegend;
    }
    if (typeof leftKey === "number") {
      return "modify at index " + leftKey + formatLegend;
    }
    return "modify property " + wrapPropertyName(leftKey) + formatLegend;
  },
  deleted: function deleted(delta, left, key, leftKey) {
    var formatLegend = " <pre>([previousValue, 0, 0])</pre>";
    if (typeof leftKey === "undefined") {
      return "delete value" + formatLegend;
    }
    if (typeof leftKey === "number") {
      return "remove index " + leftKey + formatLegend;
    }
    return "delete property " + wrapPropertyName(leftKey) + formatLegend;
  },
  moved: function moved(delta, left, key, leftKey) {
    return 'move from <span title="(position to remove at original state)">' + ("index " + leftKey + '</span> to <span title="(position to insert at final') + (' state)">index ' + delta[1] + "</span>");
  },
  textdiff: function textdiff(delta, left, key, leftKey) {
    var location2 = typeof leftKey === "undefined" ? "" : typeof leftKey === "number" ? " at index " + leftKey : " at property " + wrapPropertyName(leftKey);
    return "text diff" + location2 + ', format is <a href="https://code.google.com/p/google-diff-match-patch/wiki/Unidiff">a variation of Unidiff</a>';
  }
};
var formatAnyChange = function formatAnyChange2(context, delta) {
  var deltaType = this.getDeltaType(delta);
  var annotator = deltaAnnotations[deltaType];
  var htmlNote = annotator && annotator.apply(annotator, Array.prototype.slice.call(arguments, 1));
  var json = JSON.stringify(delta, null, 2);
  if (deltaType === "textdiff") {
    json = json.split("\\n").join('\\n"+\n   "');
  }
  context.indent();
  context.row(json, htmlNote);
  context.indent(-1);
};
AnnotatedFormatter.prototype.format_added = formatAnyChange;
AnnotatedFormatter.prototype.format_modified = formatAnyChange;
AnnotatedFormatter.prototype.format_deleted = formatAnyChange;
AnnotatedFormatter.prototype.format_moved = formatAnyChange;
AnnotatedFormatter.prototype.format_textdiff = formatAnyChange;
var OPERATIONS = {
  add: "add",
  remove: "remove",
  replace: "replace",
  move: "move"
};
(function(_BaseFormatter) {
  inherits(JSONFormatter, _BaseFormatter);
  function JSONFormatter() {
    classCallCheck(this, JSONFormatter);
    var _this = possibleConstructorReturn(this, (JSONFormatter.__proto__ || Object.getPrototypeOf(JSONFormatter)).call(this));
    _this.includeMoveDestinations = true;
    return _this;
  }
  createClass(JSONFormatter, [{
    key: "prepareContext",
    value: function prepareContext(context) {
      get$1(JSONFormatter.prototype.__proto__ || Object.getPrototypeOf(JSONFormatter.prototype), "prepareContext", this).call(this, context);
      context.result = [];
      context.path = [];
      context.pushCurrentOp = function(obj) {
        var op = obj.op, value = obj.value;
        var val = {
          op,
          path: this.currentPath()
        };
        if (typeof value !== "undefined") {
          val.value = value;
        }
        this.result.push(val);
      };
      context.pushMoveOp = function(to) {
        var from = this.currentPath();
        this.result.push({
          op: OPERATIONS.move,
          from,
          path: this.toPath(to)
        });
      };
      context.currentPath = function() {
        return "/" + this.path.join("/");
      };
      context.toPath = function(toPath) {
        var to = this.path.slice();
        to[to.length - 1] = toPath;
        return "/" + to.join("/");
      };
    }
  }, {
    key: "typeFormattterErrorFormatter",
    value: function typeFormattterErrorFormatter(context, err) {
      context.out("[ERROR] " + err);
    }
  }, {
    key: "rootBegin",
    value: function rootBegin() {
    }
  }, {
    key: "rootEnd",
    value: function rootEnd() {
    }
  }, {
    key: "nodeBegin",
    value: function nodeBegin(_ref, key, leftKey) {
      var path = _ref.path;
      path.push(leftKey);
    }
  }, {
    key: "nodeEnd",
    value: function nodeEnd(_ref2) {
      var path = _ref2.path;
      path.pop();
    }
    /* jshint camelcase: false */
    /* eslint-disable camelcase */
  }, {
    key: "format_unchanged",
    value: function format_unchanged() {
    }
  }, {
    key: "format_movedestination",
    value: function format_movedestination() {
    }
  }, {
    key: "format_node",
    value: function format_node(context, delta, left) {
      this.formatDeltaChildren(context, delta, left);
    }
  }, {
    key: "format_added",
    value: function format_added(context, delta) {
      context.pushCurrentOp({ op: OPERATIONS.add, value: delta[0] });
    }
  }, {
    key: "format_modified",
    value: function format_modified(context, delta) {
      context.pushCurrentOp({ op: OPERATIONS.replace, value: delta[1] });
    }
  }, {
    key: "format_deleted",
    value: function format_deleted(context) {
      context.pushCurrentOp({ op: OPERATIONS.remove });
    }
  }, {
    key: "format_moved",
    value: function format_moved(context, delta) {
      var to = delta[1];
      context.pushMoveOp(to);
    }
  }, {
    key: "format_textdiff",
    value: function format_textdiff() {
      throw new Error("Not implemented");
    }
  }, {
    key: "format",
    value: function format2(delta, left) {
      var context = {};
      this.prepareContext(context);
      this.recurse(context, delta, left);
      return context.result;
    }
  }]);
  return JSONFormatter;
})(BaseFormatter);
function chalkColor(name) {
  return chalk && chalk[name] || function() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return args;
  };
}
var colors = {
  added: chalkColor("green"),
  deleted: chalkColor("red"),
  movedestination: chalkColor("gray"),
  moved: chalkColor("yellow"),
  unchanged: chalkColor("gray"),
  error: chalkColor("white.bgRed"),
  textDiffLine: chalkColor("gray")
};
(function(_BaseFormatter) {
  inherits(ConsoleFormatter, _BaseFormatter);
  function ConsoleFormatter() {
    classCallCheck(this, ConsoleFormatter);
    var _this = possibleConstructorReturn(this, (ConsoleFormatter.__proto__ || Object.getPrototypeOf(ConsoleFormatter)).call(this));
    _this.includeMoveDestinations = false;
    return _this;
  }
  createClass(ConsoleFormatter, [{
    key: "prepareContext",
    value: function prepareContext(context) {
      get$1(ConsoleFormatter.prototype.__proto__ || Object.getPrototypeOf(ConsoleFormatter.prototype), "prepareContext", this).call(this, context);
      context.indent = function(levels) {
        this.indentLevel = (this.indentLevel || 0) + (typeof levels === "undefined" ? 1 : levels);
        this.indentPad = new Array(this.indentLevel + 1).join("  ");
        this.outLine();
      };
      context.outLine = function() {
        this.buffer.push("\n" + (this.indentPad || ""));
      };
      context.out = function() {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        for (var i = 0, l = args.length; i < l; i++) {
          var lines = args[i].split("\n");
          var text = lines.join("\n" + (this.indentPad || ""));
          if (this.color && this.color[0]) {
            text = this.color[0](text);
          }
          this.buffer.push(text);
        }
      };
      context.pushColor = function(color) {
        this.color = this.color || [];
        this.color.unshift(color);
      };
      context.popColor = function() {
        this.color = this.color || [];
        this.color.shift();
      };
    }
  }, {
    key: "typeFormattterErrorFormatter",
    value: function typeFormattterErrorFormatter(context, err) {
      context.pushColor(colors.error);
      context.out("[ERROR]" + err);
      context.popColor();
    }
  }, {
    key: "formatValue",
    value: function formatValue(context, value) {
      context.out(JSON.stringify(value, null, 2));
    }
  }, {
    key: "formatTextDiffString",
    value: function formatTextDiffString(context, value) {
      var lines = this.parseTextDiff(value);
      context.indent();
      for (var i = 0, l = lines.length; i < l; i++) {
        var line = lines[i];
        context.pushColor(colors.textDiffLine);
        context.out(line.location.line + "," + line.location.chr + " ");
        context.popColor();
        var pieces = line.pieces;
        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
          var piece = pieces[pieceIndex];
          context.pushColor(colors[piece.type]);
          context.out(piece.text);
          context.popColor();
        }
        if (i < l - 1) {
          context.outLine();
        }
      }
      context.indent(-1);
    }
  }, {
    key: "rootBegin",
    value: function rootBegin(context, type2, nodeType) {
      context.pushColor(colors[type2]);
      if (type2 === "node") {
        context.out(nodeType === "array" ? "[" : "{");
        context.indent();
      }
    }
  }, {
    key: "rootEnd",
    value: function rootEnd(context, type2, nodeType) {
      if (type2 === "node") {
        context.indent(-1);
        context.out(nodeType === "array" ? "]" : "}");
      }
      context.popColor();
    }
  }, {
    key: "nodeBegin",
    value: function nodeBegin(context, key, leftKey, type2, nodeType) {
      context.pushColor(colors[type2]);
      context.out(leftKey + ": ");
      if (type2 === "node") {
        context.out(nodeType === "array" ? "[" : "{");
        context.indent();
      }
    }
  }, {
    key: "nodeEnd",
    value: function nodeEnd(context, key, leftKey, type2, nodeType, isLast) {
      if (type2 === "node") {
        context.indent(-1);
        context.out(nodeType === "array" ? "]" : "}" + (isLast ? "" : ","));
      }
      if (!isLast) {
        context.outLine();
      }
      context.popColor();
    }
    /* jshint camelcase: false */
    /* eslint-disable camelcase */
  }, {
    key: "format_unchanged",
    value: function format_unchanged(context, delta, left) {
      if (typeof left === "undefined") {
        return;
      }
      this.formatValue(context, left);
    }
  }, {
    key: "format_movedestination",
    value: function format_movedestination(context, delta, left) {
      if (typeof left === "undefined") {
        return;
      }
      this.formatValue(context, left);
    }
  }, {
    key: "format_node",
    value: function format_node(context, delta, left) {
      this.formatDeltaChildren(context, delta, left);
    }
  }, {
    key: "format_added",
    value: function format_added(context, delta) {
      this.formatValue(context, delta[0]);
    }
  }, {
    key: "format_modified",
    value: function format_modified(context, delta) {
      context.pushColor(colors.deleted);
      this.formatValue(context, delta[0]);
      context.popColor();
      context.out(" => ");
      context.pushColor(colors.added);
      this.formatValue(context, delta[1]);
      context.popColor();
    }
  }, {
    key: "format_deleted",
    value: function format_deleted(context, delta) {
      this.formatValue(context, delta[0]);
    }
  }, {
    key: "format_moved",
    value: function format_moved(context, delta) {
      context.out("==> " + delta[1]);
    }
  }, {
    key: "format_textdiff",
    value: function format_textdiff(context, delta) {
      this.formatTextDiffString(context, delta[0]);
    }
  }]);
  return ConsoleFormatter;
})(BaseFormatter);
function create$3(options) {
  return new DiffPatcher(options);
}
var defaultInstance$4 = void 0;
function diff() {
  if (!defaultInstance$4) {
    defaultInstance$4 = new DiffPatcher();
  }
  return defaultInstance$4.diff.apply(defaultInstance$4, arguments);
}
var localforage$1 = { exports: {} };
/*!
    localForage -- Offline Storage, Improved
    Version 1.10.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
(function(module, exports) {
  (function(f) {
    {
      module.exports = f();
    }
  })(function() {
    return function e2(t, n, r) {
      function s(o2, u) {
        if (!n[o2]) {
          if (!t[o2]) {
            var a = typeof commonjsRequire == "function" && commonjsRequire;
            if (!u && a)
              return a(o2, true);
            if (i)
              return i(o2, true);
            var f = new Error("Cannot find module '" + o2 + "'");
            throw f.code = "MODULE_NOT_FOUND", f;
          }
          var l = n[o2] = { exports: {} };
          t[o2][0].call(l.exports, function(e3) {
            var n2 = t[o2][1][e3];
            return s(n2 ? n2 : e3);
          }, l, l.exports, e2, t, n, r);
        }
        return n[o2].exports;
      }
      var i = typeof commonjsRequire == "function" && commonjsRequire;
      for (var o = 0; o < r.length; o++)
        s(r[o]);
      return s;
    }({ 1: [function(_dereq_, module2, exports2) {
      (function(global2) {
        var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
        var scheduleDrain;
        {
          if (Mutation) {
            var called = 0;
            var observer = new Mutation(nextTick2);
            var element = global2.document.createTextNode("");
            observer.observe(element, {
              characterData: true
            });
            scheduleDrain = function() {
              element.data = called = ++called % 2;
            };
          } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
            var channel = new global2.MessageChannel();
            channel.port1.onmessage = nextTick2;
            scheduleDrain = function() {
              channel.port2.postMessage(0);
            };
          } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
            scheduleDrain = function() {
              var scriptEl = global2.document.createElement("script");
              scriptEl.onreadystatechange = function() {
                nextTick2();
                scriptEl.onreadystatechange = null;
                scriptEl.parentNode.removeChild(scriptEl);
                scriptEl = null;
              };
              global2.document.documentElement.appendChild(scriptEl);
            };
          } else {
            scheduleDrain = function() {
              setTimeout(nextTick2, 0);
            };
          }
        }
        var draining;
        var queue2 = [];
        function nextTick2() {
          draining = true;
          var i, oldQueue;
          var len = queue2.length;
          while (len) {
            oldQueue = queue2;
            queue2 = [];
            i = -1;
            while (++i < len) {
              oldQueue[i]();
            }
            len = queue2.length;
          }
          draining = false;
        }
        module2.exports = immediate;
        function immediate(task) {
          if (queue2.push(task) === 1 && !draining) {
            scheduleDrain();
          }
        }
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 2: [function(_dereq_, module2, exports2) {
      var immediate = _dereq_(1);
      function INTERNAL() {
      }
      var handlers2 = {};
      var REJECTED = ["REJECTED"];
      var FULFILLED = ["FULFILLED"];
      var PENDING = ["PENDING"];
      module2.exports = Promise2;
      function Promise2(resolver) {
        if (typeof resolver !== "function") {
          throw new TypeError("resolver must be a function");
        }
        this.state = PENDING;
        this.queue = [];
        this.outcome = void 0;
        if (resolver !== INTERNAL) {
          safelyResolveThenable(this, resolver);
        }
      }
      Promise2.prototype["catch"] = function(onRejected) {
        return this.then(null, onRejected);
      };
      Promise2.prototype.then = function(onFulfilled, onRejected) {
        if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
          return this;
        }
        var promise = new this.constructor(INTERNAL);
        if (this.state !== PENDING) {
          var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
          unwrap(promise, resolver, this.outcome);
        } else {
          this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
        }
        return promise;
      };
      function QueueItem(promise, onFulfilled, onRejected) {
        this.promise = promise;
        if (typeof onFulfilled === "function") {
          this.onFulfilled = onFulfilled;
          this.callFulfilled = this.otherCallFulfilled;
        }
        if (typeof onRejected === "function") {
          this.onRejected = onRejected;
          this.callRejected = this.otherCallRejected;
        }
      }
      QueueItem.prototype.callFulfilled = function(value) {
        handlers2.resolve(this.promise, value);
      };
      QueueItem.prototype.otherCallFulfilled = function(value) {
        unwrap(this.promise, this.onFulfilled, value);
      };
      QueueItem.prototype.callRejected = function(value) {
        handlers2.reject(this.promise, value);
      };
      QueueItem.prototype.otherCallRejected = function(value) {
        unwrap(this.promise, this.onRejected, value);
      };
      function unwrap(promise, func, value) {
        immediate(function() {
          var returnValue;
          try {
            returnValue = func(value);
          } catch (e2) {
            return handlers2.reject(promise, e2);
          }
          if (returnValue === promise) {
            handlers2.reject(promise, new TypeError("Cannot resolve promise with itself"));
          } else {
            handlers2.resolve(promise, returnValue);
          }
        });
      }
      handlers2.resolve = function(self2, value) {
        var result = tryCatch(getThen, value);
        if (result.status === "error") {
          return handlers2.reject(self2, result.value);
        }
        var thenable = result.value;
        if (thenable) {
          safelyResolveThenable(self2, thenable);
        } else {
          self2.state = FULFILLED;
          self2.outcome = value;
          var i = -1;
          var len = self2.queue.length;
          while (++i < len) {
            self2.queue[i].callFulfilled(value);
          }
        }
        return self2;
      };
      handlers2.reject = function(self2, error) {
        self2.state = REJECTED;
        self2.outcome = error;
        var i = -1;
        var len = self2.queue.length;
        while (++i < len) {
          self2.queue[i].callRejected(error);
        }
        return self2;
      };
      function getThen(obj) {
        var then = obj && obj.then;
        if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
          return function appyThen() {
            then.apply(obj, arguments);
          };
        }
      }
      function safelyResolveThenable(self2, thenable) {
        var called = false;
        function onError(value) {
          if (called) {
            return;
          }
          called = true;
          handlers2.reject(self2, value);
        }
        function onSuccess(value) {
          if (called) {
            return;
          }
          called = true;
          handlers2.resolve(self2, value);
        }
        function tryToUnwrap() {
          thenable(onSuccess, onError);
        }
        var result = tryCatch(tryToUnwrap);
        if (result.status === "error") {
          onError(result.value);
        }
      }
      function tryCatch(func, value) {
        var out = {};
        try {
          out.value = func(value);
          out.status = "success";
        } catch (e2) {
          out.status = "error";
          out.value = e2;
        }
        return out;
      }
      Promise2.resolve = resolve2;
      function resolve2(value) {
        if (value instanceof this) {
          return value;
        }
        return handlers2.resolve(new this(INTERNAL), value);
      }
      Promise2.reject = reject;
      function reject(reason) {
        var promise = new this(INTERNAL);
        return handlers2.reject(promise, reason);
      }
      Promise2.all = all;
      function all(iterable) {
        var self2 = this;
        if (Object.prototype.toString.call(iterable) !== "[object Array]") {
          return this.reject(new TypeError("must be an array"));
        }
        var len = iterable.length;
        var called = false;
        if (!len) {
          return this.resolve([]);
        }
        var values = new Array(len);
        var resolved = 0;
        var i = -1;
        var promise = new this(INTERNAL);
        while (++i < len) {
          allResolver(iterable[i], i);
        }
        return promise;
        function allResolver(value, i2) {
          self2.resolve(value).then(resolveFromAll, function(error) {
            if (!called) {
              called = true;
              handlers2.reject(promise, error);
            }
          });
          function resolveFromAll(outValue) {
            values[i2] = outValue;
            if (++resolved === len && !called) {
              called = true;
              handlers2.resolve(promise, values);
            }
          }
        }
      }
      Promise2.race = race;
      function race(iterable) {
        var self2 = this;
        if (Object.prototype.toString.call(iterable) !== "[object Array]") {
          return this.reject(new TypeError("must be an array"));
        }
        var len = iterable.length;
        var called = false;
        if (!len) {
          return this.resolve([]);
        }
        var i = -1;
        var promise = new this(INTERNAL);
        while (++i < len) {
          resolver(iterable[i]);
        }
        return promise;
        function resolver(value) {
          self2.resolve(value).then(function(response) {
            if (!called) {
              called = true;
              handlers2.resolve(promise, response);
            }
          }, function(error) {
            if (!called) {
              called = true;
              handlers2.reject(promise, error);
            }
          });
        }
      }
    }, { "1": 1 }], 3: [function(_dereq_, module2, exports2) {
      (function(global2) {
        if (typeof global2.Promise !== "function") {
          global2.Promise = _dereq_(2);
        }
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "2": 2 }], 4: [function(_dereq_, module2, exports2) {
      var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      function _classCallCheck2(instance2, Constructor) {
        if (!(instance2 instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function getIDB() {
        try {
          if (typeof indexedDB !== "undefined") {
            return indexedDB;
          }
          if (typeof webkitIndexedDB !== "undefined") {
            return webkitIndexedDB;
          }
          if (typeof mozIndexedDB !== "undefined") {
            return mozIndexedDB;
          }
          if (typeof OIndexedDB !== "undefined") {
            return OIndexedDB;
          }
          if (typeof msIndexedDB !== "undefined") {
            return msIndexedDB;
          }
        } catch (e2) {
          return;
        }
      }
      var idb = getIDB();
      function isIndexedDBValid() {
        try {
          if (!idb || !idb.open) {
            return false;
          }
          var isSafari = typeof openDatabase !== "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
          var hasFetch = typeof fetch === "function" && fetch.toString().indexOf("[native code") !== -1;
          return (!isSafari || hasFetch) && typeof indexedDB !== "undefined" && // some outdated implementations of IDB that appear on Samsung
          // and HTC Android devices <4.4 are missing IDBKeyRange
          // See: https://github.com/mozilla/localForage/issues/128
          // See: https://github.com/mozilla/localForage/issues/272
          typeof IDBKeyRange !== "undefined";
        } catch (e2) {
          return false;
        }
      }
      function createBlob(parts, properties) {
        parts = parts || [];
        properties = properties || {};
        try {
          return new Blob(parts, properties);
        } catch (e2) {
          if (e2.name !== "TypeError") {
            throw e2;
          }
          var Builder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : WebKitBlobBuilder;
          var builder = new Builder();
          for (var i = 0; i < parts.length; i += 1) {
            builder.append(parts[i]);
          }
          return builder.getBlob(properties.type);
        }
      }
      if (typeof Promise === "undefined") {
        _dereq_(3);
      }
      var Promise$1 = Promise;
      function executeCallback(promise, callback) {
        if (callback) {
          promise.then(function(result) {
            callback(null, result);
          }, function(error) {
            callback(error);
          });
        }
      }
      function executeTwoCallbacks(promise, callback, errorCallback) {
        if (typeof callback === "function") {
          promise.then(callback);
        }
        if (typeof errorCallback === "function") {
          promise["catch"](errorCallback);
        }
      }
      function normalizeKey2(key2) {
        if (typeof key2 !== "string") {
          console.warn(key2 + " used as a key, but it is not a string.");
          key2 = String(key2);
        }
        return key2;
      }
      function getCallback() {
        if (arguments.length && typeof arguments[arguments.length - 1] === "function") {
          return arguments[arguments.length - 1];
        }
      }
      var DETECT_BLOB_SUPPORT_STORE = "local-forage-detect-blob-support";
      var supportsBlobs = void 0;
      var dbContexts = {};
      var toString2 = Object.prototype.toString;
      var READ_ONLY = "readonly";
      var READ_WRITE = "readwrite";
      function _binStringToArrayBuffer(bin) {
        var length2 = bin.length;
        var buf = new ArrayBuffer(length2);
        var arr = new Uint8Array(buf);
        for (var i = 0; i < length2; i++) {
          arr[i] = bin.charCodeAt(i);
        }
        return buf;
      }
      function _checkBlobSupportWithoutCaching(idb2) {
        return new Promise$1(function(resolve2) {
          var txn = idb2.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
          var blob = createBlob([""]);
          txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, "key");
          txn.onabort = function(e2) {
            e2.preventDefault();
            e2.stopPropagation();
            resolve2(false);
          };
          txn.oncomplete = function() {
            var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
            var matchedEdge = navigator.userAgent.match(/Edge\//);
            resolve2(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
          };
        })["catch"](function() {
          return false;
        });
      }
      function _checkBlobSupport(idb2) {
        if (typeof supportsBlobs === "boolean") {
          return Promise$1.resolve(supportsBlobs);
        }
        return _checkBlobSupportWithoutCaching(idb2).then(function(value) {
          supportsBlobs = value;
          return supportsBlobs;
        });
      }
      function _deferReadiness(dbInfo) {
        var dbContext = dbContexts[dbInfo.name];
        var deferredOperation = {};
        deferredOperation.promise = new Promise$1(function(resolve2, reject) {
          deferredOperation.resolve = resolve2;
          deferredOperation.reject = reject;
        });
        dbContext.deferredOperations.push(deferredOperation);
        if (!dbContext.dbReady) {
          dbContext.dbReady = deferredOperation.promise;
        } else {
          dbContext.dbReady = dbContext.dbReady.then(function() {
            return deferredOperation.promise;
          });
        }
      }
      function _advanceReadiness(dbInfo) {
        var dbContext = dbContexts[dbInfo.name];
        var deferredOperation = dbContext.deferredOperations.pop();
        if (deferredOperation) {
          deferredOperation.resolve();
          return deferredOperation.promise;
        }
      }
      function _rejectReadiness(dbInfo, err) {
        var dbContext = dbContexts[dbInfo.name];
        var deferredOperation = dbContext.deferredOperations.pop();
        if (deferredOperation) {
          deferredOperation.reject(err);
          return deferredOperation.promise;
        }
      }
      function _getConnection(dbInfo, upgradeNeeded) {
        return new Promise$1(function(resolve2, reject) {
          dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
          if (dbInfo.db) {
            if (upgradeNeeded) {
              _deferReadiness(dbInfo);
              dbInfo.db.close();
            } else {
              return resolve2(dbInfo.db);
            }
          }
          var dbArgs = [dbInfo.name];
          if (upgradeNeeded) {
            dbArgs.push(dbInfo.version);
          }
          var openreq = idb.open.apply(idb, dbArgs);
          if (upgradeNeeded) {
            openreq.onupgradeneeded = function(e2) {
              var db = openreq.result;
              try {
                db.createObjectStore(dbInfo.storeName);
                if (e2.oldVersion <= 1) {
                  db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                }
              } catch (ex) {
                if (ex.name === "ConstraintError") {
                  console.warn('The database "' + dbInfo.name + '" has been upgraded from version ' + e2.oldVersion + " to version " + e2.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                } else {
                  throw ex;
                }
              }
            };
          }
          openreq.onerror = function(e2) {
            e2.preventDefault();
            reject(openreq.error);
          };
          openreq.onsuccess = function() {
            var db = openreq.result;
            db.onversionchange = function(e2) {
              e2.target.close();
            };
            resolve2(db);
            _advanceReadiness(dbInfo);
          };
        });
      }
      function _getOriginalConnection(dbInfo) {
        return _getConnection(dbInfo, false);
      }
      function _getUpgradedConnection(dbInfo) {
        return _getConnection(dbInfo, true);
      }
      function _isUpgradeNeeded(dbInfo, defaultVersion) {
        if (!dbInfo.db) {
          return true;
        }
        var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
        var isDowngrade = dbInfo.version < dbInfo.db.version;
        var isUpgrade = dbInfo.version > dbInfo.db.version;
        if (isDowngrade) {
          if (dbInfo.version !== defaultVersion) {
            console.warn('The database "' + dbInfo.name + `" can't be downgraded from version ` + dbInfo.db.version + " to version " + dbInfo.version + ".");
          }
          dbInfo.version = dbInfo.db.version;
        }
        if (isUpgrade || isNewStore) {
          if (isNewStore) {
            var incVersion = dbInfo.db.version + 1;
            if (incVersion > dbInfo.version) {
              dbInfo.version = incVersion;
            }
          }
          return true;
        }
        return false;
      }
      function _encodeBlob(blob) {
        return new Promise$1(function(resolve2, reject) {
          var reader = new FileReader();
          reader.onerror = reject;
          reader.onloadend = function(e2) {
            var base64 = btoa(e2.target.result || "");
            resolve2({
              __local_forage_encoded_blob: true,
              data: base64,
              type: blob.type
            });
          };
          reader.readAsBinaryString(blob);
        });
      }
      function _decodeBlob(encodedBlob) {
        var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
        return createBlob([arrayBuff], { type: encodedBlob.type });
      }
      function _isEncodedBlob(value) {
        return value && value.__local_forage_encoded_blob;
      }
      function _fullyReady(callback) {
        var self2 = this;
        var promise = self2._initReady().then(function() {
          var dbContext = dbContexts[self2._dbInfo.name];
          if (dbContext && dbContext.dbReady) {
            return dbContext.dbReady;
          }
        });
        executeTwoCallbacks(promise, callback, callback);
        return promise;
      }
      function _tryReconnect(dbInfo) {
        _deferReadiness(dbInfo);
        var dbContext = dbContexts[dbInfo.name];
        var forages = dbContext.forages;
        for (var i = 0; i < forages.length; i++) {
          var forage = forages[i];
          if (forage._dbInfo.db) {
            forage._dbInfo.db.close();
            forage._dbInfo.db = null;
          }
        }
        dbInfo.db = null;
        return _getOriginalConnection(dbInfo).then(function(db) {
          dbInfo.db = db;
          if (_isUpgradeNeeded(dbInfo)) {
            return _getUpgradedConnection(dbInfo);
          }
          return db;
        }).then(function(db) {
          dbInfo.db = dbContext.db = db;
          for (var i2 = 0; i2 < forages.length; i2++) {
            forages[i2]._dbInfo.db = db;
          }
        })["catch"](function(err) {
          _rejectReadiness(dbInfo, err);
          throw err;
        });
      }
      function createTransaction(dbInfo, mode, callback, retries) {
        if (retries === void 0) {
          retries = 1;
        }
        try {
          var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
          callback(null, tx);
        } catch (err) {
          if (retries > 0 && (!dbInfo.db || err.name === "InvalidStateError" || err.name === "NotFoundError")) {
            return Promise$1.resolve().then(function() {
              if (!dbInfo.db || err.name === "NotFoundError" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                if (dbInfo.db) {
                  dbInfo.version = dbInfo.db.version + 1;
                }
                return _getUpgradedConnection(dbInfo);
              }
            }).then(function() {
              return _tryReconnect(dbInfo).then(function() {
                createTransaction(dbInfo, mode, callback, retries - 1);
              });
            })["catch"](callback);
          }
          callback(err);
        }
      }
      function createDbContext() {
        return {
          // Running localForages sharing a database.
          forages: [],
          // Shared database.
          db: null,
          // Database readiness (promise).
          dbReady: null,
          // Deferred operations on the database.
          deferredOperations: []
        };
      }
      function _initStorage(options) {
        var self2 = this;
        var dbInfo = {
          db: null
        };
        if (options) {
          for (var i in options) {
            dbInfo[i] = options[i];
          }
        }
        var dbContext = dbContexts[dbInfo.name];
        if (!dbContext) {
          dbContext = createDbContext();
          dbContexts[dbInfo.name] = dbContext;
        }
        dbContext.forages.push(self2);
        if (!self2._initReady) {
          self2._initReady = self2.ready;
          self2.ready = _fullyReady;
        }
        var initPromises = [];
        function ignoreErrors() {
          return Promise$1.resolve();
        }
        for (var j = 0; j < dbContext.forages.length; j++) {
          var forage = dbContext.forages[j];
          if (forage !== self2) {
            initPromises.push(forage._initReady()["catch"](ignoreErrors));
          }
        }
        var forages = dbContext.forages.slice(0);
        return Promise$1.all(initPromises).then(function() {
          dbInfo.db = dbContext.db;
          return _getOriginalConnection(dbInfo);
        }).then(function(db) {
          dbInfo.db = db;
          if (_isUpgradeNeeded(dbInfo, self2._defaultConfig.version)) {
            return _getUpgradedConnection(dbInfo);
          }
          return db;
        }).then(function(db) {
          dbInfo.db = dbContext.db = db;
          self2._dbInfo = dbInfo;
          for (var k = 0; k < forages.length; k++) {
            var forage2 = forages[k];
            if (forage2 !== self2) {
              forage2._dbInfo.db = dbInfo.db;
              forage2._dbInfo.version = dbInfo.version;
            }
          }
        });
      }
      function getItem(key2, callback) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store.get(key2);
                req.onsuccess = function() {
                  var value = req.result;
                  if (value === void 0) {
                    value = null;
                  }
                  if (_isEncodedBlob(value)) {
                    value = _decodeBlob(value);
                  }
                  resolve2(value);
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function iterate(iterator2, callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store.openCursor();
                var iterationNumber = 1;
                req.onsuccess = function() {
                  var cursor = req.result;
                  if (cursor) {
                    var value = cursor.value;
                    if (_isEncodedBlob(value)) {
                      value = _decodeBlob(value);
                    }
                    var result = iterator2(value, cursor.key, iterationNumber++);
                    if (result !== void 0) {
                      resolve2(result);
                    } else {
                      cursor["continue"]();
                    }
                  } else {
                    resolve2();
                  }
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function setItem(key2, value, callback) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          var dbInfo;
          self2.ready().then(function() {
            dbInfo = self2._dbInfo;
            if (toString2.call(value) === "[object Blob]") {
              return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {
                if (blobSupport) {
                  return value;
                }
                return _encodeBlob(value);
              });
            }
            return value;
          }).then(function(value2) {
            createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                if (value2 === null) {
                  value2 = void 0;
                }
                var req = store.put(value2, key2);
                transaction.oncomplete = function() {
                  if (value2 === void 0) {
                    value2 = null;
                  }
                  resolve2(value2);
                };
                transaction.onabort = transaction.onerror = function() {
                  var err2 = req.error ? req.error : req.transaction.error;
                  reject(err2);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function removeItem(key2, callback) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store["delete"](key2);
                transaction.oncomplete = function() {
                  resolve2();
                };
                transaction.onerror = function() {
                  reject(req.error);
                };
                transaction.onabort = function() {
                  var err2 = req.error ? req.error : req.transaction.error;
                  reject(err2);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function clear2(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store.clear();
                transaction.oncomplete = function() {
                  resolve2();
                };
                transaction.onabort = transaction.onerror = function() {
                  var err2 = req.error ? req.error : req.transaction.error;
                  reject(err2);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function length(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store.count();
                req.onsuccess = function() {
                  resolve2(req.result);
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function key(n, callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          if (n < 0) {
            resolve2(null);
            return;
          }
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var advanced = false;
                var req = store.openKeyCursor();
                req.onsuccess = function() {
                  var cursor = req.result;
                  if (!cursor) {
                    resolve2(null);
                    return;
                  }
                  if (n === 0) {
                    resolve2(cursor.key);
                  } else {
                    if (!advanced) {
                      advanced = true;
                      cursor.advance(n);
                    } else {
                      resolve2(cursor.key);
                    }
                  }
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function keys(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store.openKeyCursor();
                var keys2 = [];
                req.onsuccess = function() {
                  var cursor = req.result;
                  if (!cursor) {
                    resolve2(keys2);
                    return;
                  }
                  keys2.push(cursor.key);
                  cursor["continue"]();
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function dropInstance(options, callback) {
        callback = getCallback.apply(this, arguments);
        var currentConfig = this.config();
        options = typeof options !== "function" && options || {};
        if (!options.name) {
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
        }
        var self2 = this;
        var promise;
        if (!options.name) {
          promise = Promise$1.reject("Invalid arguments");
        } else {
          var isCurrentDb = options.name === currentConfig.name && self2._dbInfo.db;
          var dbPromise = isCurrentDb ? Promise$1.resolve(self2._dbInfo.db) : _getOriginalConnection(options).then(function(db) {
            var dbContext = dbContexts[options.name];
            var forages = dbContext.forages;
            dbContext.db = db;
            for (var i = 0; i < forages.length; i++) {
              forages[i]._dbInfo.db = db;
            }
            return db;
          });
          if (!options.storeName) {
            promise = dbPromise.then(function(db) {
              _deferReadiness(options);
              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              db.close();
              for (var i = 0; i < forages.length; i++) {
                var forage = forages[i];
                forage._dbInfo.db = null;
              }
              var dropDBPromise = new Promise$1(function(resolve2, reject) {
                var req = idb.deleteDatabase(options.name);
                req.onerror = function() {
                  var db2 = req.result;
                  if (db2) {
                    db2.close();
                  }
                  reject(req.error);
                };
                req.onblocked = function() {
                  console.warn('dropInstance blocked for database "' + options.name + '" until all open connections are closed');
                };
                req.onsuccess = function() {
                  var db2 = req.result;
                  if (db2) {
                    db2.close();
                  }
                  resolve2(db2);
                };
              });
              return dropDBPromise.then(function(db2) {
                dbContext.db = db2;
                for (var i2 = 0; i2 < forages.length; i2++) {
                  var _forage = forages[i2];
                  _advanceReadiness(_forage._dbInfo);
                }
              })["catch"](function(err) {
                (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                });
                throw err;
              });
            });
          } else {
            promise = dbPromise.then(function(db) {
              if (!db.objectStoreNames.contains(options.storeName)) {
                return;
              }
              var newVersion = db.version + 1;
              _deferReadiness(options);
              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              db.close();
              for (var i = 0; i < forages.length; i++) {
                var forage = forages[i];
                forage._dbInfo.db = null;
                forage._dbInfo.version = newVersion;
              }
              var dropObjectPromise = new Promise$1(function(resolve2, reject) {
                var req = idb.open(options.name, newVersion);
                req.onerror = function(err) {
                  var db2 = req.result;
                  db2.close();
                  reject(err);
                };
                req.onupgradeneeded = function() {
                  var db2 = req.result;
                  db2.deleteObjectStore(options.storeName);
                };
                req.onsuccess = function() {
                  var db2 = req.result;
                  db2.close();
                  resolve2(db2);
                };
              });
              return dropObjectPromise.then(function(db2) {
                dbContext.db = db2;
                for (var j = 0; j < forages.length; j++) {
                  var _forage2 = forages[j];
                  _forage2._dbInfo.db = db2;
                  _advanceReadiness(_forage2._dbInfo);
                }
              })["catch"](function(err) {
                (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                });
                throw err;
              });
            });
          }
        }
        executeCallback(promise, callback);
        return promise;
      }
      var asyncStorage = {
        _driver: "asyncStorage",
        _initStorage,
        _support: isIndexedDBValid(),
        iterate,
        getItem,
        setItem,
        removeItem,
        clear: clear2,
        length,
        key,
        keys,
        dropInstance
      };
      function isWebSQLValid() {
        return typeof openDatabase === "function";
      }
      var BASE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var BLOB_TYPE_PREFIX = "~~local_forage_type~";
      var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
      var SERIALIZED_MARKER = "__lfsc__:";
      var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
      var TYPE_ARRAYBUFFER = "arbf";
      var TYPE_BLOB = "blob";
      var TYPE_INT8ARRAY = "si08";
      var TYPE_UINT8ARRAY = "ui08";
      var TYPE_UINT8CLAMPEDARRAY = "uic8";
      var TYPE_INT16ARRAY = "si16";
      var TYPE_INT32ARRAY = "si32";
      var TYPE_UINT16ARRAY = "ur16";
      var TYPE_UINT32ARRAY = "ui32";
      var TYPE_FLOAT32ARRAY = "fl32";
      var TYPE_FLOAT64ARRAY = "fl64";
      var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
      var toString$1 = Object.prototype.toString;
      function stringToBuffer(serializedString) {
        var bufferLength = serializedString.length * 0.75;
        var len = serializedString.length;
        var i;
        var p2 = 0;
        var encoded1, encoded2, encoded3, encoded4;
        if (serializedString[serializedString.length - 1] === "=") {
          bufferLength--;
          if (serializedString[serializedString.length - 2] === "=") {
            bufferLength--;
          }
        }
        var buffer = new ArrayBuffer(bufferLength);
        var bytes = new Uint8Array(buffer);
        for (i = 0; i < len; i += 4) {
          encoded1 = BASE_CHARS.indexOf(serializedString[i]);
          encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
          encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
          encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);
          bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
          bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
          bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
        }
        return buffer;
      }
      function bufferToString(buffer) {
        var bytes = new Uint8Array(buffer);
        var base64String = "";
        var i;
        for (i = 0; i < bytes.length; i += 3) {
          base64String += BASE_CHARS[bytes[i] >> 2];
          base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
          base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
          base64String += BASE_CHARS[bytes[i + 2] & 63];
        }
        if (bytes.length % 3 === 2) {
          base64String = base64String.substring(0, base64String.length - 1) + "=";
        } else if (bytes.length % 3 === 1) {
          base64String = base64String.substring(0, base64String.length - 2) + "==";
        }
        return base64String;
      }
      function serialize(value, callback) {
        var valueType = "";
        if (value) {
          valueType = toString$1.call(value);
        }
        if (value && (valueType === "[object ArrayBuffer]" || value.buffer && toString$1.call(value.buffer) === "[object ArrayBuffer]")) {
          var buffer;
          var marker = SERIALIZED_MARKER;
          if (value instanceof ArrayBuffer) {
            buffer = value;
            marker += TYPE_ARRAYBUFFER;
          } else {
            buffer = value.buffer;
            if (valueType === "[object Int8Array]") {
              marker += TYPE_INT8ARRAY;
            } else if (valueType === "[object Uint8Array]") {
              marker += TYPE_UINT8ARRAY;
            } else if (valueType === "[object Uint8ClampedArray]") {
              marker += TYPE_UINT8CLAMPEDARRAY;
            } else if (valueType === "[object Int16Array]") {
              marker += TYPE_INT16ARRAY;
            } else if (valueType === "[object Uint16Array]") {
              marker += TYPE_UINT16ARRAY;
            } else if (valueType === "[object Int32Array]") {
              marker += TYPE_INT32ARRAY;
            } else if (valueType === "[object Uint32Array]") {
              marker += TYPE_UINT32ARRAY;
            } else if (valueType === "[object Float32Array]") {
              marker += TYPE_FLOAT32ARRAY;
            } else if (valueType === "[object Float64Array]") {
              marker += TYPE_FLOAT64ARRAY;
            } else {
              callback(new Error("Failed to get type for BinaryArray"));
            }
          }
          callback(marker + bufferToString(buffer));
        } else if (valueType === "[object Blob]") {
          var fileReader = new FileReader();
          fileReader.onload = function() {
            var str = BLOB_TYPE_PREFIX + value.type + "~" + bufferToString(this.result);
            callback(SERIALIZED_MARKER + TYPE_BLOB + str);
          };
          fileReader.readAsArrayBuffer(value);
        } else {
          try {
            callback(JSON.stringify(value));
          } catch (e2) {
            console.error("Couldn't convert value into a JSON string: ", value);
            callback(null, e2);
          }
        }
      }
      function deserialize(value) {
        if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
          return JSON.parse(value);
        }
        var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
        var type2 = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
        var blobType;
        if (type2 === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
          var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
          blobType = matcher[1];
          serializedString = serializedString.substring(matcher[0].length);
        }
        var buffer = stringToBuffer(serializedString);
        switch (type2) {
          case TYPE_ARRAYBUFFER:
            return buffer;
          case TYPE_BLOB:
            return createBlob([buffer], { type: blobType });
          case TYPE_INT8ARRAY:
            return new Int8Array(buffer);
          case TYPE_UINT8ARRAY:
            return new Uint8Array(buffer);
          case TYPE_UINT8CLAMPEDARRAY:
            return new Uint8ClampedArray(buffer);
          case TYPE_INT16ARRAY:
            return new Int16Array(buffer);
          case TYPE_UINT16ARRAY:
            return new Uint16Array(buffer);
          case TYPE_INT32ARRAY:
            return new Int32Array(buffer);
          case TYPE_UINT32ARRAY:
            return new Uint32Array(buffer);
          case TYPE_FLOAT32ARRAY:
            return new Float32Array(buffer);
          case TYPE_FLOAT64ARRAY:
            return new Float64Array(buffer);
          default:
            throw new Error("Unkown type: " + type2);
        }
      }
      var localforageSerializer = {
        serialize,
        deserialize,
        stringToBuffer,
        bufferToString
      };
      function createDbTable(t, dbInfo, callback, errorCallback) {
        t.executeSql("CREATE TABLE IF NOT EXISTS " + dbInfo.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], callback, errorCallback);
      }
      function _initStorage$1(options) {
        var self2 = this;
        var dbInfo = {
          db: null
        };
        if (options) {
          for (var i in options) {
            dbInfo[i] = typeof options[i] !== "string" ? options[i].toString() : options[i];
          }
        }
        var dbInfoPromise = new Promise$1(function(resolve2, reject) {
          try {
            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
          } catch (e2) {
            return reject(e2);
          }
          dbInfo.db.transaction(function(t) {
            createDbTable(t, dbInfo, function() {
              self2._dbInfo = dbInfo;
              resolve2();
            }, function(t2, error) {
              reject(error);
            });
          }, reject);
        });
        dbInfo.serializer = localforageSerializer;
        return dbInfoPromise;
      }
      function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
        t.executeSql(sqlStatement, args, callback, function(t2, error) {
          if (error.code === error.SYNTAX_ERR) {
            t2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [dbInfo.storeName], function(t3, results) {
              if (!results.rows.length) {
                createDbTable(t3, dbInfo, function() {
                  t3.executeSql(sqlStatement, args, callback, errorCallback);
                }, errorCallback);
              } else {
                errorCallback(t3, error);
              }
            }, errorCallback);
          } else {
            errorCallback(t2, error);
          }
        }, errorCallback);
      }
      function getItem$1(key2, callback) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t) {
              tryExecuteSql(t, dbInfo, "SELECT * FROM " + dbInfo.storeName + " WHERE key = ? LIMIT 1", [key2], function(t2, results) {
                var result = results.rows.length ? results.rows.item(0).value : null;
                if (result) {
                  result = dbInfo.serializer.deserialize(result);
                }
                resolve2(result);
              }, function(t2, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function iterate$1(iterator2, callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t) {
              tryExecuteSql(t, dbInfo, "SELECT * FROM " + dbInfo.storeName, [], function(t2, results) {
                var rows = results.rows;
                var length2 = rows.length;
                for (var i = 0; i < length2; i++) {
                  var item = rows.item(i);
                  var result = item.value;
                  if (result) {
                    result = dbInfo.serializer.deserialize(result);
                  }
                  result = iterator2(result, item.key, i + 1);
                  if (result !== void 0) {
                    resolve2(result);
                    return;
                  }
                }
                resolve2();
              }, function(t2, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function _setItem(key2, value, callback, retriesLeft) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            if (value === void 0) {
              value = null;
            }
            var originalValue = value;
            var dbInfo = self2._dbInfo;
            dbInfo.serializer.serialize(value, function(value2, error) {
              if (error) {
                reject(error);
              } else {
                dbInfo.db.transaction(function(t) {
                  tryExecuteSql(t, dbInfo, "INSERT OR REPLACE INTO " + dbInfo.storeName + " (key, value) VALUES (?, ?)", [key2, value2], function() {
                    resolve2(originalValue);
                  }, function(t2, error2) {
                    reject(error2);
                  });
                }, function(sqlError) {
                  if (sqlError.code === sqlError.QUOTA_ERR) {
                    if (retriesLeft > 0) {
                      resolve2(_setItem.apply(self2, [key2, originalValue, callback, retriesLeft - 1]));
                      return;
                    }
                    reject(sqlError);
                  }
                });
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function setItem$1(key2, value, callback) {
        return _setItem.apply(this, [key2, value, callback, 1]);
      }
      function removeItem$1(key2, callback) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t) {
              tryExecuteSql(t, dbInfo, "DELETE FROM " + dbInfo.storeName + " WHERE key = ?", [key2], function() {
                resolve2();
              }, function(t2, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function clear$1(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t) {
              tryExecuteSql(t, dbInfo, "DELETE FROM " + dbInfo.storeName, [], function() {
                resolve2();
              }, function(t2, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function length$1(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t) {
              tryExecuteSql(t, dbInfo, "SELECT COUNT(key) as c FROM " + dbInfo.storeName, [], function(t2, results) {
                var result = results.rows.item(0).c;
                resolve2(result);
              }, function(t2, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function key$1(n, callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t) {
              tryExecuteSql(t, dbInfo, "SELECT key FROM " + dbInfo.storeName + " WHERE id = ? LIMIT 1", [n + 1], function(t2, results) {
                var result = results.rows.length ? results.rows.item(0).key : null;
                resolve2(result);
              }, function(t2, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function keys$1(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t) {
              tryExecuteSql(t, dbInfo, "SELECT key FROM " + dbInfo.storeName, [], function(t2, results) {
                var keys2 = [];
                for (var i = 0; i < results.rows.length; i++) {
                  keys2.push(results.rows.item(i).key);
                }
                resolve2(keys2);
              }, function(t2, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function getAllStoreNames(db) {
        return new Promise$1(function(resolve2, reject) {
          db.transaction(function(t) {
            t.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(t2, results) {
              var storeNames = [];
              for (var i = 0; i < results.rows.length; i++) {
                storeNames.push(results.rows.item(i).name);
              }
              resolve2({
                db,
                storeNames
              });
            }, function(t2, error) {
              reject(error);
            });
          }, function(sqlError) {
            reject(sqlError);
          });
        });
      }
      function dropInstance$1(options, callback) {
        callback = getCallback.apply(this, arguments);
        var currentConfig = this.config();
        options = typeof options !== "function" && options || {};
        if (!options.name) {
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
        }
        var self2 = this;
        var promise;
        if (!options.name) {
          promise = Promise$1.reject("Invalid arguments");
        } else {
          promise = new Promise$1(function(resolve2) {
            var db;
            if (options.name === currentConfig.name) {
              db = self2._dbInfo.db;
            } else {
              db = openDatabase(options.name, "", "", 0);
            }
            if (!options.storeName) {
              resolve2(getAllStoreNames(db));
            } else {
              resolve2({
                db,
                storeNames: [options.storeName]
              });
            }
          }).then(function(operationInfo) {
            return new Promise$1(function(resolve2, reject) {
              operationInfo.db.transaction(function(t) {
                function dropTable(storeName) {
                  return new Promise$1(function(resolve3, reject2) {
                    t.executeSql("DROP TABLE IF EXISTS " + storeName, [], function() {
                      resolve3();
                    }, function(t2, error) {
                      reject2(error);
                    });
                  });
                }
                var operations = [];
                for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
                  operations.push(dropTable(operationInfo.storeNames[i]));
                }
                Promise$1.all(operations).then(function() {
                  resolve2();
                })["catch"](function(e2) {
                  reject(e2);
                });
              }, function(sqlError) {
                reject(sqlError);
              });
            });
          });
        }
        executeCallback(promise, callback);
        return promise;
      }
      var webSQLStorage = {
        _driver: "webSQLStorage",
        _initStorage: _initStorage$1,
        _support: isWebSQLValid(),
        iterate: iterate$1,
        getItem: getItem$1,
        setItem: setItem$1,
        removeItem: removeItem$1,
        clear: clear$1,
        length: length$1,
        key: key$1,
        keys: keys$1,
        dropInstance: dropInstance$1
      };
      function isLocalStorageValid() {
        try {
          return typeof localStorage !== "undefined" && "setItem" in localStorage && // in IE8 typeof localStorage.setItem === 'object'
          !!localStorage.setItem;
        } catch (e2) {
          return false;
        }
      }
      function _getKeyPrefix(options, defaultConfig) {
        var keyPrefix = options.name + "/";
        if (options.storeName !== defaultConfig.storeName) {
          keyPrefix += options.storeName + "/";
        }
        return keyPrefix;
      }
      function checkIfLocalStorageThrows() {
        var localStorageTestKey = "_localforage_support_test";
        try {
          localStorage.setItem(localStorageTestKey, true);
          localStorage.removeItem(localStorageTestKey);
          return false;
        } catch (e2) {
          return true;
        }
      }
      function _isLocalStorageUsable() {
        return !checkIfLocalStorageThrows() || localStorage.length > 0;
      }
      function _initStorage$2(options) {
        var self2 = this;
        var dbInfo = {};
        if (options) {
          for (var i in options) {
            dbInfo[i] = options[i];
          }
        }
        dbInfo.keyPrefix = _getKeyPrefix(options, self2._defaultConfig);
        if (!_isLocalStorageUsable()) {
          return Promise$1.reject();
        }
        self2._dbInfo = dbInfo;
        dbInfo.serializer = localforageSerializer;
        return Promise$1.resolve();
      }
      function clear$2(callback) {
        var self2 = this;
        var promise = self2.ready().then(function() {
          var keyPrefix = self2._dbInfo.keyPrefix;
          for (var i = localStorage.length - 1; i >= 0; i--) {
            var key2 = localStorage.key(i);
            if (key2.indexOf(keyPrefix) === 0) {
              localStorage.removeItem(key2);
            }
          }
        });
        executeCallback(promise, callback);
        return promise;
      }
      function getItem$2(key2, callback) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var result = localStorage.getItem(dbInfo.keyPrefix + key2);
          if (result) {
            result = dbInfo.serializer.deserialize(result);
          }
          return result;
        });
        executeCallback(promise, callback);
        return promise;
      }
      function iterate$2(iterator2, callback) {
        var self2 = this;
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var keyPrefix = dbInfo.keyPrefix;
          var keyPrefixLength = keyPrefix.length;
          var length2 = localStorage.length;
          var iterationNumber = 1;
          for (var i = 0; i < length2; i++) {
            var key2 = localStorage.key(i);
            if (key2.indexOf(keyPrefix) !== 0) {
              continue;
            }
            var value = localStorage.getItem(key2);
            if (value) {
              value = dbInfo.serializer.deserialize(value);
            }
            value = iterator2(value, key2.substring(keyPrefixLength), iterationNumber++);
            if (value !== void 0) {
              return value;
            }
          }
        });
        executeCallback(promise, callback);
        return promise;
      }
      function key$2(n, callback) {
        var self2 = this;
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var result;
          try {
            result = localStorage.key(n);
          } catch (error) {
            result = null;
          }
          if (result) {
            result = result.substring(dbInfo.keyPrefix.length);
          }
          return result;
        });
        executeCallback(promise, callback);
        return promise;
      }
      function keys$2(callback) {
        var self2 = this;
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var length2 = localStorage.length;
          var keys2 = [];
          for (var i = 0; i < length2; i++) {
            var itemKey = localStorage.key(i);
            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
              keys2.push(itemKey.substring(dbInfo.keyPrefix.length));
            }
          }
          return keys2;
        });
        executeCallback(promise, callback);
        return promise;
      }
      function length$2(callback) {
        var self2 = this;
        var promise = self2.keys().then(function(keys2) {
          return keys2.length;
        });
        executeCallback(promise, callback);
        return promise;
      }
      function removeItem$2(key2, callback) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          localStorage.removeItem(dbInfo.keyPrefix + key2);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function setItem$2(key2, value, callback) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = self2.ready().then(function() {
          if (value === void 0) {
            value = null;
          }
          var originalValue = value;
          return new Promise$1(function(resolve2, reject) {
            var dbInfo = self2._dbInfo;
            dbInfo.serializer.serialize(value, function(value2, error) {
              if (error) {
                reject(error);
              } else {
                try {
                  localStorage.setItem(dbInfo.keyPrefix + key2, value2);
                  resolve2(originalValue);
                } catch (e2) {
                  if (e2.name === "QuotaExceededError" || e2.name === "NS_ERROR_DOM_QUOTA_REACHED") {
                    reject(e2);
                  }
                  reject(e2);
                }
              }
            });
          });
        });
        executeCallback(promise, callback);
        return promise;
      }
      function dropInstance$2(options, callback) {
        callback = getCallback.apply(this, arguments);
        options = typeof options !== "function" && options || {};
        if (!options.name) {
          var currentConfig = this.config();
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
        }
        var self2 = this;
        var promise;
        if (!options.name) {
          promise = Promise$1.reject("Invalid arguments");
        } else {
          promise = new Promise$1(function(resolve2) {
            if (!options.storeName) {
              resolve2(options.name + "/");
            } else {
              resolve2(_getKeyPrefix(options, self2._defaultConfig));
            }
          }).then(function(keyPrefix) {
            for (var i = localStorage.length - 1; i >= 0; i--) {
              var key2 = localStorage.key(i);
              if (key2.indexOf(keyPrefix) === 0) {
                localStorage.removeItem(key2);
              }
            }
          });
        }
        executeCallback(promise, callback);
        return promise;
      }
      var localStorageWrapper = {
        _driver: "localStorageWrapper",
        _initStorage: _initStorage$2,
        _support: isLocalStorageValid(),
        iterate: iterate$2,
        getItem: getItem$2,
        setItem: setItem$2,
        removeItem: removeItem$2,
        clear: clear$2,
        length: length$2,
        key: key$2,
        keys: keys$2,
        dropInstance: dropInstance$2
      };
      var sameValue = function sameValue2(x, y) {
        return x === y || typeof x === "number" && typeof y === "number" && isNaN(x) && isNaN(y);
      };
      var includes = function includes2(array, searchElement) {
        var len = array.length;
        var i = 0;
        while (i < len) {
          if (sameValue(array[i], searchElement)) {
            return true;
          }
          i++;
        }
        return false;
      };
      var isArray2 = Array.isArray || function(arg) {
        return Object.prototype.toString.call(arg) === "[object Array]";
      };
      var DefinedDrivers = {};
      var DriverSupport = {};
      var DefaultDrivers = {
        INDEXEDDB: asyncStorage,
        WEBSQL: webSQLStorage,
        LOCALSTORAGE: localStorageWrapper
      };
      var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];
      var OptionalDriverMethods = ["dropInstance"];
      var LibraryMethods = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(OptionalDriverMethods);
      var DefaultConfig = {
        description: "",
        driver: DefaultDriverOrder.slice(),
        name: "localforage",
        // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
        // we can use without a prompt.
        size: 4980736,
        storeName: "keyvaluepairs",
        version: 1
      };
      function callWhenReady(localForageInstance, libraryMethod) {
        localForageInstance[libraryMethod] = function() {
          var _args = arguments;
          return localForageInstance.ready().then(function() {
            return localForageInstance[libraryMethod].apply(localForageInstance, _args);
          });
        };
      }
      function extend2() {
        for (var i = 1; i < arguments.length; i++) {
          var arg = arguments[i];
          if (arg) {
            for (var _key in arg) {
              if (arg.hasOwnProperty(_key)) {
                if (isArray2(arg[_key])) {
                  arguments[0][_key] = arg[_key].slice();
                } else {
                  arguments[0][_key] = arg[_key];
                }
              }
            }
          }
        }
        return arguments[0];
      }
      var LocalForage = function() {
        function LocalForage2(options) {
          _classCallCheck2(this, LocalForage2);
          for (var driverTypeKey in DefaultDrivers) {
            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
              var driver = DefaultDrivers[driverTypeKey];
              var driverName = driver._driver;
              this[driverTypeKey] = driverName;
              if (!DefinedDrivers[driverName]) {
                this.defineDriver(driver);
              }
            }
          }
          this._defaultConfig = extend2({}, DefaultConfig);
          this._config = extend2({}, this._defaultConfig, options);
          this._driverSet = null;
          this._initDriver = null;
          this._ready = false;
          this._dbInfo = null;
          this._wrapLibraryMethodsWithReady();
          this.setDriver(this._config.driver)["catch"](function() {
          });
        }
        LocalForage2.prototype.config = function config(options) {
          if ((typeof options === "undefined" ? "undefined" : _typeof2(options)) === "object") {
            if (this._ready) {
              return new Error("Can't call config() after localforage has been used.");
            }
            for (var i in options) {
              if (i === "storeName") {
                options[i] = options[i].replace(/\W/g, "_");
              }
              if (i === "version" && typeof options[i] !== "number") {
                return new Error("Database version must be a number.");
              }
              this._config[i] = options[i];
            }
            if ("driver" in options && options.driver) {
              return this.setDriver(this._config.driver);
            }
            return true;
          } else if (typeof options === "string") {
            return this._config[options];
          } else {
            return this._config;
          }
        };
        LocalForage2.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
          var promise = new Promise$1(function(resolve2, reject) {
            try {
              var driverName = driverObject._driver;
              var complianceError = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
              if (!driverObject._driver) {
                reject(complianceError);
                return;
              }
              var driverMethods = LibraryMethods.concat("_initStorage");
              for (var i = 0, len = driverMethods.length; i < len; i++) {
                var driverMethodName = driverMethods[i];
                var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== "function") {
                  reject(complianceError);
                  return;
                }
              }
              var configureMissingMethods = function configureMissingMethods2() {
                var methodNotImplementedFactory = function methodNotImplementedFactory2(methodName) {
                  return function() {
                    var error = new Error("Method " + methodName + " is not implemented by the current driver");
                    var promise2 = Promise$1.reject(error);
                    executeCallback(promise2, arguments[arguments.length - 1]);
                    return promise2;
                  };
                };
                for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                  var optionalDriverMethod = OptionalDriverMethods[_i];
                  if (!driverObject[optionalDriverMethod]) {
                    driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                  }
                }
              };
              configureMissingMethods();
              var setDriverSupport = function setDriverSupport2(support) {
                if (DefinedDrivers[driverName]) {
                  console.info("Redefining LocalForage driver: " + driverName);
                }
                DefinedDrivers[driverName] = driverObject;
                DriverSupport[driverName] = support;
                resolve2();
              };
              if ("_support" in driverObject) {
                if (driverObject._support && typeof driverObject._support === "function") {
                  driverObject._support().then(setDriverSupport, reject);
                } else {
                  setDriverSupport(!!driverObject._support);
                }
              } else {
                setDriverSupport(true);
              }
            } catch (e2) {
              reject(e2);
            }
          });
          executeTwoCallbacks(promise, callback, errorCallback);
          return promise;
        };
        LocalForage2.prototype.driver = function driver() {
          return this._driver || null;
        };
        LocalForage2.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
          var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error("Driver not found."));
          executeTwoCallbacks(getDriverPromise, callback, errorCallback);
          return getDriverPromise;
        };
        LocalForage2.prototype.getSerializer = function getSerializer(callback) {
          var serializerPromise = Promise$1.resolve(localforageSerializer);
          executeTwoCallbacks(serializerPromise, callback);
          return serializerPromise;
        };
        LocalForage2.prototype.ready = function ready(callback) {
          var self2 = this;
          var promise = self2._driverSet.then(function() {
            if (self2._ready === null) {
              self2._ready = self2._initDriver();
            }
            return self2._ready;
          });
          executeTwoCallbacks(promise, callback, callback);
          return promise;
        };
        LocalForage2.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
          var self2 = this;
          if (!isArray2(drivers)) {
            drivers = [drivers];
          }
          var supportedDrivers = this._getSupportedDrivers(drivers);
          function setDriverToConfig() {
            self2._config.driver = self2.driver();
          }
          function extendSelfWithDriver(driver) {
            self2._extend(driver);
            setDriverToConfig();
            self2._ready = self2._initStorage(self2._config);
            return self2._ready;
          }
          function initDriver(supportedDrivers2) {
            return function() {
              var currentDriverIndex = 0;
              function driverPromiseLoop() {
                while (currentDriverIndex < supportedDrivers2.length) {
                  var driverName = supportedDrivers2[currentDriverIndex];
                  currentDriverIndex++;
                  self2._dbInfo = null;
                  self2._ready = null;
                  return self2.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                }
                setDriverToConfig();
                var error = new Error("No available storage method found.");
                self2._driverSet = Promise$1.reject(error);
                return self2._driverSet;
              }
              return driverPromiseLoop();
            };
          }
          var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function() {
            return Promise$1.resolve();
          }) : Promise$1.resolve();
          this._driverSet = oldDriverSetDone.then(function() {
            var driverName = supportedDrivers[0];
            self2._dbInfo = null;
            self2._ready = null;
            return self2.getDriver(driverName).then(function(driver) {
              self2._driver = driver._driver;
              setDriverToConfig();
              self2._wrapLibraryMethodsWithReady();
              self2._initDriver = initDriver(supportedDrivers);
            });
          })["catch"](function() {
            setDriverToConfig();
            var error = new Error("No available storage method found.");
            self2._driverSet = Promise$1.reject(error);
            return self2._driverSet;
          });
          executeTwoCallbacks(this._driverSet, callback, errorCallback);
          return this._driverSet;
        };
        LocalForage2.prototype.supports = function supports(driverName) {
          return !!DriverSupport[driverName];
        };
        LocalForage2.prototype._extend = function _extend(libraryMethodsAndProperties) {
          extend2(this, libraryMethodsAndProperties);
        };
        LocalForage2.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
          var supportedDrivers = [];
          for (var i = 0, len = drivers.length; i < len; i++) {
            var driverName = drivers[i];
            if (this.supports(driverName)) {
              supportedDrivers.push(driverName);
            }
          }
          return supportedDrivers;
        };
        LocalForage2.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
          for (var i = 0, len = LibraryMethods.length; i < len; i++) {
            callWhenReady(this, LibraryMethods[i]);
          }
        };
        LocalForage2.prototype.createInstance = function createInstance(options) {
          return new LocalForage2(options);
        };
        return LocalForage2;
      }();
      var localforage_js = new LocalForage();
      module2.exports = localforage_js;
    }, { "3": 3 }] }, {}, [4])(4);
  });
})(localforage$1);
var localforageExports$1 = localforage$1.exports;
const localForage$1 = /* @__PURE__ */ getDefaultExportFromCjs(localforageExports$1);
let nanoid$1 = (size2 = 21) => crypto.getRandomValues(new Uint8Array(size2)).reduce((id, byte2) => {
  byte2 &= 63;
  if (byte2 < 36) {
    id += byte2.toString(36);
  } else if (byte2 < 62) {
    id += (byte2 - 26).toString(36).toUpperCase();
  } else if (byte2 > 62) {
    id += "-";
  } else {
    id += "_";
  }
  return id;
}, "");
function copy$1(a) {
  return JSON.parse(JSON.stringify(a));
}
class Bouncer {
  constructor(timeout = 1e3) {
    __publicField(this, "resolve");
    __publicField(this, "timeout");
    __publicField(this, "promise");
    __publicField(this, "_timeout", -1);
    this.resolve = null;
    this.timeout = timeout;
    this.promise = null;
  }
  async debounce() {
    this.cancel();
    this.promise = new Promise((resolve2, reject) => {
      this.resolve = resolve2;
      clearTimeout(this._timeout);
      this._timeout = window.setTimeout(() => {
        resolve2(true);
      }, this.timeout);
    });
    return this.promise;
  }
  cancel() {
    if (this.resolve) {
      clearTimeout(this._timeout);
      this.resolve(false);
      this.promise = null;
    }
  }
}
const bouncers = {};
function debounce(name, timeout = 1e3) {
  if (!bouncers[name]) {
    bouncers[name] = new Bouncer(timeout);
  }
  return bouncers[name].debounce();
}
class Deferred {
  constructor() {
    __publicField(this, "resetCount", -1);
    __publicField(this, "resolved", false);
    __publicField(this, "promise");
    __publicField(this, "resolve");
    __publicField(this, "reject");
    this.reset();
  }
  reset() {
    this.resetCount += 1;
    this.resolved = false;
    this.promise = new Promise((resolve2, reject) => {
      this.resolve = (a) => {
        this.resolved = true;
        resolve2(a);
      };
      this.reject = (a) => {
        this.resolved = true;
        reject(a);
      };
    });
  }
}
var define_import_meta_env_default$2 = { BASE_URL: "./", MODE: "production", DEV: false, PROD: true, SSR: false };
const statusTexts = {
  413: "Your upload is too large and the server rejected it"
};
async function jsonapi(opts) {
  var _a;
  let url = `${define_import_meta_env_default$2.VITE_APP_TSUNAMI_SERVER}${opts.event}/`;
  let fetchopts = {
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json",
      ...opts.headers || {}
    },
    method: opts.method || "POST",
    body: void 0
  };
  let data = {};
  if (opts.data) {
    data = { ...opts.data };
  }
  if ((_a = opts.user) == null ? void 0 : _a.token) {
    data.token = opts.user.token;
    data.token_user = opts.user.id;
  }
  if (fetchopts.method.toUpperCase() === "GET") {
    const params = [];
    for (let key in data) {
      params.push(`${key}=${data[key]}`);
    }
    if (params.length > 0) {
      url += `?${params.join("&")}`;
    }
  } else if (data) {
    fetchopts.body = JSON.stringify(data);
  }
  let response = await fetch(url, fetchopts);
  if (response.headers.get("Content-Type") === "application/json") {
    return response.json();
  } else if (response.status === 204) {
    return { ok: true, message: "no content" };
  } else if (response.status > 200) {
    let error = response.statusText || statusTexts[response.status];
    return { error: `${error} [${response.status}]` };
  } else {
    return { error: await response.text() };
  }
}
/*! Capacitor: https://capacitorjs.com/ - MIT License */
const createCapacitorPlatforms$1 = (win) => {
  const defaultPlatformMap = /* @__PURE__ */ new Map();
  defaultPlatformMap.set("web", { name: "web" });
  const capPlatforms = win.CapacitorPlatforms || {
    currentPlatform: { name: "web" },
    platforms: defaultPlatformMap
  };
  const addPlatform = (name, platform) => {
    capPlatforms.platforms.set(name, platform);
  };
  const setPlatform = (name) => {
    if (capPlatforms.platforms.has(name)) {
      capPlatforms.currentPlatform = capPlatforms.platforms.get(name);
    }
  };
  capPlatforms.addPlatform = addPlatform;
  capPlatforms.setPlatform = setPlatform;
  return capPlatforms;
};
const initPlatforms$1 = (win) => win.CapacitorPlatforms = createCapacitorPlatforms$1(win);
const CapacitorPlatforms$1 = /* @__PURE__ */ initPlatforms$1(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
CapacitorPlatforms$1.addPlatform;
CapacitorPlatforms$1.setPlatform;
var ExceptionCode$1;
(function(ExceptionCode2) {
  ExceptionCode2["Unimplemented"] = "UNIMPLEMENTED";
  ExceptionCode2["Unavailable"] = "UNAVAILABLE";
})(ExceptionCode$1 || (ExceptionCode$1 = {}));
let CapacitorException$1 = class CapacitorException extends Error {
  constructor(message, code2, data) {
    super(message);
    this.message = message;
    this.code = code2;
    this.data = data;
  }
};
const getPlatformId$1 = (win) => {
  var _a, _b;
  if (win === null || win === void 0 ? void 0 : win.androidBridge) {
    return "android";
  } else if ((_b = (_a = win === null || win === void 0 ? void 0 : win.webkit) === null || _a === void 0 ? void 0 : _a.messageHandlers) === null || _b === void 0 ? void 0 : _b.bridge) {
    return "ios";
  } else {
    return "web";
  }
};
const createCapacitor$1 = (win) => {
  var _a, _b, _c, _d, _e;
  const capCustomPlatform = win.CapacitorCustomPlatform || null;
  const cap = win.Capacitor || {};
  const Plugins = cap.Plugins = cap.Plugins || {};
  const capPlatforms = win.CapacitorPlatforms;
  const defaultGetPlatform = () => {
    return capCustomPlatform !== null ? capCustomPlatform.name : getPlatformId$1(win);
  };
  const getPlatform = ((_a = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _a === void 0 ? void 0 : _a.getPlatform) || defaultGetPlatform;
  const defaultIsNativePlatform = () => getPlatform() !== "web";
  const isNativePlatform = ((_b = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _b === void 0 ? void 0 : _b.isNativePlatform) || defaultIsNativePlatform;
  const defaultIsPluginAvailable = (pluginName) => {
    const plugin = registeredPlugins.get(pluginName);
    if (plugin === null || plugin === void 0 ? void 0 : plugin.platforms.has(getPlatform())) {
      return true;
    }
    if (getPluginHeader(pluginName)) {
      return true;
    }
    return false;
  };
  const isPluginAvailable = ((_c = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _c === void 0 ? void 0 : _c.isPluginAvailable) || defaultIsPluginAvailable;
  const defaultGetPluginHeader = (pluginName) => {
    var _a2;
    return (_a2 = cap.PluginHeaders) === null || _a2 === void 0 ? void 0 : _a2.find((h2) => h2.name === pluginName);
  };
  const getPluginHeader = ((_d = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _d === void 0 ? void 0 : _d.getPluginHeader) || defaultGetPluginHeader;
  const handleError2 = (err) => win.console.error(err);
  const pluginMethodNoop = (_target2, prop, pluginName) => {
    return Promise.reject(`${pluginName} does not have an implementation of "${prop}".`);
  };
  const registeredPlugins = /* @__PURE__ */ new Map();
  const defaultRegisterPlugin = (pluginName, jsImplementations = {}) => {
    const registeredPlugin = registeredPlugins.get(pluginName);
    if (registeredPlugin) {
      console.warn(`Capacitor plugin "${pluginName}" already registered. Cannot register plugins twice.`);
      return registeredPlugin.proxy;
    }
    const platform = getPlatform();
    const pluginHeader = getPluginHeader(pluginName);
    let jsImplementation;
    const loadPluginImplementation = async () => {
      if (!jsImplementation && platform in jsImplementations) {
        jsImplementation = typeof jsImplementations[platform] === "function" ? jsImplementation = await jsImplementations[platform]() : jsImplementation = jsImplementations[platform];
      } else if (capCustomPlatform !== null && !jsImplementation && "web" in jsImplementations) {
        jsImplementation = typeof jsImplementations["web"] === "function" ? jsImplementation = await jsImplementations["web"]() : jsImplementation = jsImplementations["web"];
      }
      return jsImplementation;
    };
    const createPluginMethod = (impl, prop) => {
      var _a2, _b2;
      if (pluginHeader) {
        const methodHeader = pluginHeader === null || pluginHeader === void 0 ? void 0 : pluginHeader.methods.find((m) => prop === m.name);
        if (methodHeader) {
          if (methodHeader.rtype === "promise") {
            return (options) => cap.nativePromise(pluginName, prop.toString(), options);
          } else {
            return (options, callback) => cap.nativeCallback(pluginName, prop.toString(), options, callback);
          }
        } else if (impl) {
          return (_a2 = impl[prop]) === null || _a2 === void 0 ? void 0 : _a2.bind(impl);
        }
      } else if (impl) {
        return (_b2 = impl[prop]) === null || _b2 === void 0 ? void 0 : _b2.bind(impl);
      } else {
        throw new CapacitorException$1(`"${pluginName}" plugin is not implemented on ${platform}`, ExceptionCode$1.Unimplemented);
      }
    };
    const createPluginMethodWrapper = (prop) => {
      let remove2;
      const wrapper = (...args) => {
        const p2 = loadPluginImplementation().then((impl) => {
          const fn = createPluginMethod(impl, prop);
          if (fn) {
            const p3 = fn(...args);
            remove2 = p3 === null || p3 === void 0 ? void 0 : p3.remove;
            return p3;
          } else {
            throw new CapacitorException$1(`"${pluginName}.${prop}()" is not implemented on ${platform}`, ExceptionCode$1.Unimplemented);
          }
        });
        if (prop === "addListener") {
          p2.remove = async () => remove2();
        }
        return p2;
      };
      wrapper.toString = () => `${prop.toString()}() { [capacitor code] }`;
      Object.defineProperty(wrapper, "name", {
        value: prop,
        writable: false,
        configurable: false
      });
      return wrapper;
    };
    const addListener = createPluginMethodWrapper("addListener");
    const removeListener = createPluginMethodWrapper("removeListener");
    const addListenerNative = (eventName, callback) => {
      const call = addListener({ eventName }, callback);
      const remove2 = async () => {
        const callbackId = await call;
        removeListener({
          eventName,
          callbackId
        }, callback);
      };
      const p2 = new Promise((resolve2) => call.then(() => resolve2({ remove: remove2 })));
      p2.remove = async () => {
        console.warn(`Using addListener() without 'await' is deprecated.`);
        await remove2();
      };
      return p2;
    };
    const proxy = new Proxy({}, {
      get(_, prop) {
        switch (prop) {
          case "$$typeof":
            return void 0;
          case "toJSON":
            return () => ({});
          case "addListener":
            return pluginHeader ? addListenerNative : addListener;
          case "removeListener":
            return removeListener;
          default:
            return createPluginMethodWrapper(prop);
        }
      }
    });
    Plugins[pluginName] = proxy;
    registeredPlugins.set(pluginName, {
      name: pluginName,
      proxy,
      platforms: /* @__PURE__ */ new Set([
        ...Object.keys(jsImplementations),
        ...pluginHeader ? [platform] : []
      ])
    });
    return proxy;
  };
  const registerPlugin2 = ((_e = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _e === void 0 ? void 0 : _e.registerPlugin) || defaultRegisterPlugin;
  if (!cap.convertFileSrc) {
    cap.convertFileSrc = (filePath) => filePath;
  }
  cap.getPlatform = getPlatform;
  cap.handleError = handleError2;
  cap.isNativePlatform = isNativePlatform;
  cap.isPluginAvailable = isPluginAvailable;
  cap.pluginMethodNoop = pluginMethodNoop;
  cap.registerPlugin = registerPlugin2;
  cap.Exception = CapacitorException$1;
  cap.DEBUG = !!cap.DEBUG;
  cap.isLoggingEnabled = !!cap.isLoggingEnabled;
  cap.platform = cap.getPlatform();
  cap.isNative = cap.isNativePlatform();
  return cap;
};
const initCapacitorGlobal$1 = (win) => win.Capacitor = createCapacitor$1(win);
const Capacitor$1 = /* @__PURE__ */ initCapacitorGlobal$1(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
const registerPlugin$1 = Capacitor$1.registerPlugin;
Capacitor$1.Plugins;
let WebPlugin$1 = class WebPlugin {
  constructor(config) {
    this.listeners = {};
    this.retainedEventArguments = {};
    this.windowListeners = {};
    if (config) {
      console.warn(`Capacitor WebPlugin "${config.name}" config object was deprecated in v3 and will be removed in v4.`);
      this.config = config;
    }
  }
  addListener(eventName, listenerFunc) {
    let firstListener = false;
    const listeners = this.listeners[eventName];
    if (!listeners) {
      this.listeners[eventName] = [];
      firstListener = true;
    }
    this.listeners[eventName].push(listenerFunc);
    const windowListener = this.windowListeners[eventName];
    if (windowListener && !windowListener.registered) {
      this.addWindowListener(windowListener);
    }
    if (firstListener) {
      this.sendRetainedArgumentsForEvent(eventName);
    }
    const remove2 = async () => this.removeListener(eventName, listenerFunc);
    const p2 = Promise.resolve({ remove: remove2 });
    return p2;
  }
  async removeAllListeners() {
    this.listeners = {};
    for (const listener in this.windowListeners) {
      this.removeWindowListener(this.windowListeners[listener]);
    }
    this.windowListeners = {};
  }
  notifyListeners(eventName, data, retainUntilConsumed) {
    const listeners = this.listeners[eventName];
    if (!listeners) {
      if (retainUntilConsumed) {
        let args = this.retainedEventArguments[eventName];
        if (!args) {
          args = [];
        }
        args.push(data);
        this.retainedEventArguments[eventName] = args;
      }
      return;
    }
    listeners.forEach((listener) => listener(data));
  }
  hasListeners(eventName) {
    return !!this.listeners[eventName].length;
  }
  registerWindowListener(windowEventName, pluginEventName) {
    this.windowListeners[pluginEventName] = {
      registered: false,
      windowEventName,
      pluginEventName,
      handler: (event) => {
        this.notifyListeners(pluginEventName, event);
      }
    };
  }
  unimplemented(msg = "not implemented") {
    return new Capacitor$1.Exception(msg, ExceptionCode$1.Unimplemented);
  }
  unavailable(msg = "not available") {
    return new Capacitor$1.Exception(msg, ExceptionCode$1.Unavailable);
  }
  async removeListener(eventName, listenerFunc) {
    const listeners = this.listeners[eventName];
    if (!listeners) {
      return;
    }
    const index2 = listeners.indexOf(listenerFunc);
    this.listeners[eventName].splice(index2, 1);
    if (!this.listeners[eventName].length) {
      this.removeWindowListener(this.windowListeners[eventName]);
    }
  }
  addWindowListener(handle) {
    window.addEventListener(handle.windowEventName, handle.handler);
    handle.registered = true;
  }
  removeWindowListener(handle) {
    if (!handle) {
      return;
    }
    window.removeEventListener(handle.windowEventName, handle.handler);
    handle.registered = false;
  }
  sendRetainedArgumentsForEvent(eventName) {
    const args = this.retainedEventArguments[eventName];
    if (!args) {
      return;
    }
    delete this.retainedEventArguments[eventName];
    args.forEach((arg) => {
      this.notifyListeners(eventName, arg);
    });
  }
};
const encode$1 = (str) => encodeURIComponent(str).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
const decode$1 = (str) => str.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
let CapacitorCookiesPluginWeb$1 = class CapacitorCookiesPluginWeb extends WebPlugin$1 {
  async getCookies() {
    const cookies = document.cookie;
    const cookieMap = {};
    cookies.split(";").forEach((cookie) => {
      if (cookie.length <= 0)
        return;
      let [key, value] = cookie.replace(/=/, "CAP_COOKIE").split("CAP_COOKIE");
      key = decode$1(key).trim();
      value = decode$1(value).trim();
      cookieMap[key] = value;
    });
    return cookieMap;
  }
  async setCookie(options) {
    try {
      const encodedKey = encode$1(options.key);
      const encodedValue = encode$1(options.value);
      const expires = `; expires=${(options.expires || "").replace("expires=", "")}`;
      const path = (options.path || "/").replace("path=", "");
      const domain = options.url != null && options.url.length > 0 ? `domain=${options.url}` : "";
      document.cookie = `${encodedKey}=${encodedValue || ""}${expires}; path=${path}; ${domain};`;
    } catch (error) {
      return Promise.reject(error);
    }
  }
  async deleteCookie(options) {
    try {
      document.cookie = `${options.key}=; Max-Age=0`;
    } catch (error) {
      return Promise.reject(error);
    }
  }
  async clearCookies() {
    try {
      const cookies = document.cookie.split(";") || [];
      for (const cookie of cookies) {
        document.cookie = cookie.replace(/^ +/, "").replace(/=.*/, `=;expires=${(/* @__PURE__ */ new Date()).toUTCString()};path=/`);
      }
    } catch (error) {
      return Promise.reject(error);
    }
  }
  async clearAllCookies() {
    try {
      await this.clearCookies();
    } catch (error) {
      return Promise.reject(error);
    }
  }
};
registerPlugin$1("CapacitorCookies", {
  web: () => new CapacitorCookiesPluginWeb$1()
});
const readBlobAsBase64$1 = async (blob) => new Promise((resolve2, reject) => {
  const reader = new FileReader();
  reader.onload = () => {
    const base64String = reader.result;
    resolve2(base64String.indexOf(",") >= 0 ? base64String.split(",")[1] : base64String);
  };
  reader.onerror = (error) => reject(error);
  reader.readAsDataURL(blob);
});
const normalizeHttpHeaders$1 = (headers = {}) => {
  const originalKeys = Object.keys(headers);
  const loweredKeys = Object.keys(headers).map((k) => k.toLocaleLowerCase());
  const normalized = loweredKeys.reduce((acc, key, index2) => {
    acc[key] = headers[originalKeys[index2]];
    return acc;
  }, {});
  return normalized;
};
const buildUrlParams$1 = (params, shouldEncode = true) => {
  if (!params)
    return null;
  const output = Object.entries(params).reduce((accumulator, entry) => {
    const [key, value] = entry;
    let encodedValue;
    let item;
    if (Array.isArray(value)) {
      item = "";
      value.forEach((str) => {
        encodedValue = shouldEncode ? encodeURIComponent(str) : str;
        item += `${key}=${encodedValue}&`;
      });
      item.slice(0, -1);
    } else {
      encodedValue = shouldEncode ? encodeURIComponent(value) : value;
      item = `${key}=${encodedValue}`;
    }
    return `${accumulator}&${item}`;
  }, "");
  return output.substr(1);
};
const buildRequestInit$1 = (options, extra = {}) => {
  const output = Object.assign({ method: options.method || "GET", headers: options.headers }, extra);
  const headers = normalizeHttpHeaders$1(options.headers);
  const type2 = headers["content-type"] || "";
  if (typeof options.data === "string") {
    output.body = options.data;
  } else if (type2.includes("application/x-www-form-urlencoded")) {
    const params = new URLSearchParams();
    for (const [key, value] of Object.entries(options.data || {})) {
      params.set(key, value);
    }
    output.body = params.toString();
  } else if (type2.includes("multipart/form-data") || options.data instanceof FormData) {
    const form = new FormData();
    if (options.data instanceof FormData) {
      options.data.forEach((value, key) => {
        form.append(key, value);
      });
    } else {
      for (const key of Object.keys(options.data)) {
        form.append(key, options.data[key]);
      }
    }
    output.body = form;
    const headers2 = new Headers(output.headers);
    headers2.delete("content-type");
    output.headers = headers2;
  } else if (type2.includes("application/json") || typeof options.data === "object") {
    output.body = JSON.stringify(options.data);
  }
  return output;
};
let CapacitorHttpPluginWeb$1 = class CapacitorHttpPluginWeb extends WebPlugin$1 {
  /**
   * Perform an Http request given a set of options
   * @param options Options to build the HTTP request
   */
  async request(options) {
    const requestInit = buildRequestInit$1(options, options.webFetchExtra);
    const urlParams = buildUrlParams$1(options.params, options.shouldEncodeUrlParams);
    const url = urlParams ? `${options.url}?${urlParams}` : options.url;
    const response = await fetch(url, requestInit);
    const contentType = response.headers.get("content-type") || "";
    let { responseType = "text" } = response.ok ? options : {};
    if (contentType.includes("application/json")) {
      responseType = "json";
    }
    let data;
    let blob;
    switch (responseType) {
      case "arraybuffer":
      case "blob":
        blob = await response.blob();
        data = await readBlobAsBase64$1(blob);
        break;
      case "json":
        data = await response.json();
        break;
      case "document":
      case "text":
      default:
        data = await response.text();
    }
    const headers = {};
    response.headers.forEach((value, key) => {
      headers[key] = value;
    });
    return {
      data,
      headers,
      status: response.status,
      url: response.url
    };
  }
  /**
   * Perform an Http GET request given a set of options
   * @param options Options to build the HTTP request
   */
  async get(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "GET" }));
  }
  /**
   * Perform an Http POST request given a set of options
   * @param options Options to build the HTTP request
   */
  async post(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "POST" }));
  }
  /**
   * Perform an Http PUT request given a set of options
   * @param options Options to build the HTTP request
   */
  async put(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "PUT" }));
  }
  /**
   * Perform an Http PATCH request given a set of options
   * @param options Options to build the HTTP request
   */
  async patch(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "PATCH" }));
  }
  /**
   * Perform an Http DELETE request given a set of options
   * @param options Options to build the HTTP request
   */
  async delete(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "DELETE" }));
  }
};
registerPlugin$1("CapacitorHttp", {
  web: () => new CapacitorHttpPluginWeb$1()
});
const scriptRel = "modulepreload";
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    const links = document.getElementsByTagName("link");
    promise = Promise.all(deps.map((dep) => {
      dep = assetsURL(dep, importerUrl);
      if (dep in seen)
        return;
      seen[dep] = true;
      const isCss = dep.endsWith(".css");
      const cssSelector = isCss ? '[rel="stylesheet"]' : "";
      const isBaseRelative = !!importerUrl;
      if (isBaseRelative) {
        for (let i = links.length - 1; i >= 0; i--) {
          const link3 = links[i];
          if (link3.href === dep && (!isCss || link3.rel === "stylesheet")) {
            return;
          }
        }
      } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
        return;
      }
      const link2 = document.createElement("link");
      link2.rel = isCss ? "stylesheet" : scriptRel;
      if (!isCss) {
        link2.as = "script";
        link2.crossOrigin = "";
      }
      link2.href = dep;
      document.head.appendChild(link2);
      if (isCss) {
        return new Promise((res, rej) => {
          link2.addEventListener("load", res);
          link2.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
        });
      }
    }));
  }
  return promise.then(() => baseModule()).catch((err) => {
    const e2 = new Event("vite:preloadError", { cancelable: true });
    e2.payload = err;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err;
    }
  });
};
var Directory;
(function(Directory2) {
  Directory2["Documents"] = "DOCUMENTS";
  Directory2["Data"] = "DATA";
  Directory2["Library"] = "LIBRARY";
  Directory2["Cache"] = "CACHE";
  Directory2["External"] = "EXTERNAL";
  Directory2["ExternalStorage"] = "EXTERNAL_STORAGE";
})(Directory || (Directory = {}));
var Encoding;
(function(Encoding2) {
  Encoding2["UTF8"] = "utf8";
  Encoding2["ASCII"] = "ascii";
  Encoding2["UTF16"] = "utf16";
})(Encoding || (Encoding = {}));
const Filesystem = registerPlugin$1("Filesystem", {
  web: () => __vitePreload(() => import("./web-U2qG6t9K.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url).then((m) => new m.FilesystemWeb())
});
var define_import_meta_env_default$1 = { BASE_URL: "./", MODE: "production", DEV: false, PROD: true, SSR: false };
const PREFIX = define_import_meta_env_default$1.VITE_APP_STORAGE_PREFIX || "app";
class FileStorage {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "isReady");
    this.opts = opts;
    if (!this.opts.ext) {
      this.opts.ext = ".json";
    }
    if (this.opts.encoding === void 0) {
      this.opts.encoding = Encoding.UTF8;
    }
    if (!this.opts.directory) {
      this.opts.directory = Directory.Documents;
    }
    this.isReady = (async () => {
      const path = `${this.opts.name}`;
      try {
        await Filesystem.mkdir({
          path,
          directory: this.opts.directory,
          recursive: true
        });
      } catch (err) {
      }
    })();
  }
  getFilePath(name) {
    return `${this.opts.name}/${name}${this.opts.ext}`;
  }
  async getItem(name, useAsDefault) {
    await this.isReady;
    const path = this.getFilePath(name);
    console.warn("file storage: get file", path);
    let entry = void 0;
    try {
      entry = await Filesystem.readFile({
        path,
        directory: this.opts.directory,
        encoding: this.opts.encoding
      });
    } catch (ex) {
    }
    if (entry) {
      if (typeof entry.data === "string") {
        return JSON.parse(entry.data);
      } else {
        return entry.data;
      }
    }
    return useAsDefault;
  }
  async setItem(name, value) {
    await this.isReady;
    console.log("setItem", this.opts.directory);
    await nextTick();
    await Filesystem.writeFile({
      path: this.getFilePath(name),
      directory: this.opts.directory,
      encoding: this.opts.encoding,
      data: JSON.stringify(value)
    });
  }
  async removeItem(name) {
    await this.isReady;
    console.log("removeItem", this.opts.directory);
    await Filesystem.deleteFile({
      path: this.getFilePath(name),
      directory: this.opts.directory
    });
  }
  async clear() {
    await this.isReady;
    console.log("clear", this.opts.directory);
    await Filesystem.deleteFile({
      path: this.opts.name,
      directory: this.opts.directory
    });
  }
  async iterate(callback) {
    await this.isReady;
    const read = await Filesystem.readdir({
      path: this.opts.name,
      directory: this.opts.directory
    });
    for (const file of read.files) {
      if (file.type === "file") {
        console.log("iterate", this.opts.directory, file);
        const data = await Filesystem.readFile({
          path: file.uri,
          // directory: this.opts.directory,
          encoding: this.opts.encoding
        });
        let contents = void 0;
        if (typeof data.data === "string") {
          contents = JSON.parse(data.data);
        } else {
          contents = data.data;
        }
        if (await callback(contents)) {
          return;
        }
      }
    }
  }
}
function pickStorage(name, ext, binary = false) {
  if (Capacitor$1.isNativePlatform()) {
    return new FileStorage({ name, encoding: binary ? null : Encoding.UTF8, ext });
  }
  const engine = new LocalForageProxy(name);
  engine.migrate();
  return engine;
}
class LocalForageProxy {
  constructor(name) {
    __publicField(this, "name");
    __publicField(this, "store");
    this.name = name;
    this.store = localForage$1.createInstance({ name: PREFIX, storeName: name });
  }
  async getItem(key, useAsDefault) {
    return await this.store.getItem(key) || useAsDefault;
  }
  async setItem(key, value) {
    await this.store.setItem(key, value);
  }
  async removeItem(key) {
    await this.store.removeItem(key);
  }
  async clear() {
    await this.store.clear();
  }
  async iterate(callback) {
    await this.store.iterate(callback);
  }
  async migrate() {
  }
}
const descriptions = [
  "amazing",
  "bright",
  "calculating",
  "delicious",
  "demure",
  "distracted",
  "dominating",
  "epic",
  "experimental",
  "flirty",
  "glorious",
  "handsome",
  "happy",
  "hinting",
  "interjecting",
  "junior",
  "knowledgable",
  "laughing",
  "magnificent",
  "nervous",
  "oppurtunistic",
  "popular",
  "quiet",
  "righteous",
  "shy",
  "tempestuous",
  "ultimate",
  "vivacious",
  "wandering",
  "xyloid",
  "yappy",
  "zen"
];
const names = [
  "admiral",
  "buddy",
  "cat",
  "chameleon",
  "chocolate",
  "crocodile",
  "denizen",
  "earthling",
  "framer",
  "geode",
  "hero",
  "host",
  "informant",
  "joker",
  "kraken",
  "lama",
  "lampshade",
  "moon",
  "nightmare",
  "opinion",
  "plot",
  "quasar",
  "raven",
  "servant",
  "star",
  "sun",
  "technician",
  "ultimatum",
  "victorian",
  "warrior",
  "writer",
  "xenops",
  "youngling"
];
const sample_data = {
  names,
  descriptions
};
function choice(array) {
  const idx = Math.floor(Math.random() * array.length);
  return array[idx];
}
const useUserStore = /* @__PURE__ */ defineStore$1("users", () => {
  const current = ref(newUser());
  const list = ref([]);
  const store = pickStorage("user");
  const userId = ref("");
  let loggingIn = null;
  const ready = new Deferred();
  watch(
    () => {
      var _a;
      return (_a = current.value) == null ? void 0 : _a.id;
    },
    () => localStorage.user = current.value.id
  );
  watch(
    () => {
      var _a;
      return (_a = current.value) == null ? void 0 : _a.updated;
    },
    (o, n) => {
      var _a;
      if ((_a = current.value) == null ? void 0 : _a.id) {
        const record = JSON.parse(JSON.stringify(current.value));
        record.updated = (/* @__PURE__ */ new Date()).toISOString();
        store.setItem(current.value.id, record);
        if (userId.value === current.value.id) {
          console.warn("saving user", o, n);
        } else {
          console.log("user switched");
        }
        userId.value = current.value.id;
      }
    },
    { deep: true }
  );
  async function initialize(force = false) {
    var _a, _b;
    if (force || !ready.resolved) {
      const userId2 = sessionStorage.user ?? localStorage.user;
      if (userId2) {
        const user = await store.getItem(userId2, void 0);
        if (user) {
          current.value = user;
        }
      }
      for (const key of ["cyoa:user"]) {
        const localUserSource = localStorage.getItem(key);
        if (localUserSource) {
          try {
            console.log("- user from single localstorage", key, localUserSource);
            const localUser = JSON.parse(localUserSource);
            localUser.dbSource = `localStorage.${key}`;
            if ((localUser == null ? void 0 : localUser.id) && !((_a = current.value) == null ? void 0 : _a.id)) {
              current.value = localUser;
            }
          } catch (err) {
          }
        }
      }
      for (const key of ["_users"]) {
        const localUsersSource = localStorage.getItem(key);
        if (localUsersSource) {
          try {
            console.log("- user from multi localstorage", key, localUsersSource);
            const localUsers = JSON.parse(localUsersSource);
            if ((localUsers == null ? void 0 : localUsers.length) > 0) {
              for (const row of localUsers) {
                row.dbSource = `localStorage.${key}`;
                list.value.push(row);
                if (row.id && !((_b = current.value) == null ? void 0 : _b.id)) {
                  current.value = row;
                }
              }
            }
          } catch (ex) {
          }
        }
      }
      const stores = {
        primary: store
      };
      for (const key in stores) {
        const db = stores[key];
        await db.iterate((row) => {
          var _a2;
          if (row) {
            console.log("- user from localforage", key, row);
            row.dbSource = key;
            list.value.push(row);
            if (!((_a2 = current.value) == null ? void 0 : _a2.id)) {
              current.value = row;
            }
          }
        });
      }
      if (!current.value.username) {
        current.value.username = generateUsername();
        current.value.updated = (/* @__PURE__ */ new Date()).toISOString();
      }
      if (ready.resolve) {
        ready.resolve(true);
      }
      renewLogin();
    }
  }
  function newUser() {
    return {
      id: void 0,
      username: generateUsername()
    };
  }
  function generateUsername() {
    return `${choice(sample_data.descriptions)}-${choice(sample_data.names)}`;
  }
  async function login() {
    await ready.promise;
    if (!current.value.token) {
      if (!loggingIn) {
        if (await debounce("user-login", 10)) {
          loggingIn = new Deferred();
          try {
            await Promise.race([
              httpLogin(),
              new Promise((r, err) => setTimeout(() => err(new Error("login timeout")), 15e3))
            ]);
          } finally {
            if (loggingIn.resolve) {
              loggingIn.resolve();
              loggingIn = null;
            }
          }
        }
      } else {
        await loggingIn.promise;
      }
    } else {
      await renewLogin();
    }
  }
  async function renewLogin(force = false) {
    if (current.value.id && current.value.token && (force || await debounce("renewLogin"))) {
      let shouldRenew = force;
      if (!shouldRenew && current.value.tokenCreated) {
        const cutoff = new Date(Date.now() - 1e3 * 60 * 60 * 24 * 14);
        shouldRenew = new Date(current.value.tokenCreated) < cutoff;
      }
      if (!shouldRenew && current.value.tokenExpires) {
        const cutoff = new Date(Date.now() + 1e3 * 60 * 60 * 24 * 30);
        shouldRenew = new Date(current.value.tokenExpires) < cutoff;
      }
      if (shouldRenew) {
        console.log("refreshing token...");
        const tokenRefresh = await jsonapi({
          event: "rest/tokens/refresh",
          headers: { "X-UID": current.value.id, AUTHORIZATION: `Token ${current.value.token}` },
          method: "POST"
        });
        console.log("token refresh", current.value.id, tokenRefresh);
        if (!tokenRefresh.error && !tokenRefresh.detail) {
          const prevToken = current.value.token;
          const echoTest = await jsonapi({
            event: "rest/users",
            headers: { "X-UID": current.value.id, AUTHORIZATION: `Token ${tokenRefresh.token}` },
            method: "get"
          });
          if (echoTest.uid === current.value.id) {
            current.value.token = tokenRefresh.token;
            current.value.tokenExpires = tokenRefresh.expires;
            current.value.tokenCreated = tokenRefresh.created;
            current.value.updated = (/* @__PURE__ */ new Date()).toISOString();
            const id = prevToken.split(":")[0];
            await jsonapi({
              event: `rest/tokens/${id}`,
              headers: {
                "X-UID": current.value.id,
                AUTHORIZATION: `Token ${current.value.token}`
              },
              method: "DELETE"
            });
          } else {
            console.error("refresh echo test failed", echoTest);
          }
        } else {
          console.error("refresh failed", tokenRefresh);
        }
      }
      if (!current.value.token) {
        await resetLogin();
        await httpLogin();
      }
    }
  }
  async function httpLogin() {
    if (current.value.tokenExpires) {
      if (new Date(current.value.tokenExpires) < /* @__PURE__ */ new Date()) {
        console.error(
          "token expired, doing last ditch effort for token:",
          current.value.token,
          "expiring:",
          current.value.tokenExpires
        );
        await renewLogin();
      }
    }
    if (!current.value.token && current.value.id && current.value.pub) {
      const response = await jsonapi({
        event: "rest/users/login",
        data: { uid: current.value.id, key: current.value.pub },
        method: "POST"
      });
      if (!response.error) {
        current.value.token = response.token;
        current.value.tokenExpires = response.expires;
        current.value.updated = (/* @__PURE__ */ new Date()).toISOString();
      } else {
        resetLogin();
      }
    }
    if (!current.value.token && !current.value.id) {
      const response = await jsonapi({
        event: "rest/users/register",
        data: { username: current.value.username },
        method: "POST"
      });
      current.value.id = response.user.uid;
      current.value.created = response.user.created;
      current.value.updated = response.user.updated;
      current.value.token = response.token.token;
      current.value.tokenExpires = response.token.expires;
      current.value.tokenCreated = response.token.created;
      current.value.pub = void 0;
      current.value.updated = (/* @__PURE__ */ new Date()).toISOString();
    }
  }
  function resetLogin() {
    current.value.id = void 0;
    current.value.token = void 0;
    current.value.tokenCreated = void 0;
    current.value.tokenExpires = void 0;
    current.value.updated = (/* @__PURE__ */ new Date()).toISOString();
  }
  async function remove2(user) {
    if (user.id) {
      await store.removeItem(user.id);
    }
    const index2 = list.value.indexOf(user);
    list.value.splice(index2, 1);
  }
  initialize();
  return {
    current,
    list,
    ready: ready.promise,
    readyDeferred: ready,
    store,
    initialize,
    login,
    renewLogin,
    resetLogin,
    remove: remove2,
    generateUsername
  };
});
var browser$1 = { exports: {} };
var ms$1;
var hasRequiredMs$1;
function requireMs$1() {
  if (hasRequiredMs$1)
    return ms$1;
  hasRequiredMs$1 = 1;
  var s = 1e3;
  var m = s * 60;
  var h2 = m * 60;
  var d = h2 * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms$1 = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse4(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse4(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h2) {
      return plural(ms2, msAbs, h2, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms$1;
}
function setup$1(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = requireMs$1();
  createDebug.destroy = destroy;
  Object.keys(env).forEach((key) => {
    createDebug[key] = env[key];
  });
  createDebug.names = [];
  createDebug.skips = [];
  createDebug.formatters = {};
  function selectColor(namespace) {
    let hash = 0;
    for (let i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0;
    }
    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;
  function createDebug(namespace) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug2(...args) {
      if (!debug2.enabled) {
        return;
      }
      const self2 = debug2;
      const curr = Number(/* @__PURE__ */ new Date());
      const ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      let index2 = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
        if (match === "%%") {
          return "%";
        }
        index2++;
        const formatter = createDebug.formatters[format2];
        if (typeof formatter === "function") {
          const val = args[index2];
          match = formatter.call(self2, val);
          args.splice(index2, 1);
          index2--;
        }
        return match;
      });
      createDebug.formatArgs.call(self2, args);
      const logFn = self2.log || createDebug.log;
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace;
    debug2.useColors = createDebug.useColors();
    debug2.color = createDebug.selectColor(namespace);
    debug2.extend = extend2;
    debug2.destroy = createDebug.destroy;
    Object.defineProperty(debug2, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: (v) => {
        enableOverride = v;
      }
    });
    if (typeof createDebug.init === "function") {
      createDebug.init(debug2);
    }
    return debug2;
  }
  function extend2(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    let i;
    const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    const len = split.length;
    for (i = 0; i < len; i++) {
      if (!split[i]) {
        continue;
      }
      namespaces = split[i].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
      } else {
        createDebug.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    const namespaces = [
      ...createDebug.names.map(toNamespace),
      ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
    ].join(",");
    createDebug.enable("");
    return namespaces;
  }
  function enabled(name) {
    if (name[name.length - 1] === "*") {
      return true;
    }
    let i;
    let len;
    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }
  function destroy() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  createDebug.enable(createDebug.load());
  return createDebug;
}
var common$n = setup$1;
(function(module, exports) {
  var define_process_env_default = { PRODUCTION: "production", cyoa: true };
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = /* @__PURE__ */ (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index2 = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index2++;
      if (match === "%c") {
        lastC = index2;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = define_process_env_default.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module.exports = common$n(exports);
  const { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
})(browser$1, browser$1.exports);
var browserExports$1 = browser$1.exports;
const debug$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports$1);
const log$6 = debug$1("websocket");
class Socket {
  constructor(endpoint, opts = {}) {
    if (!endpoint) {
      endpoint = location.host;
      let proto = /https/i.test(location.protocol) ? "wss" : "ws";
      endpoint = `${proto}://${endpoint}/ws/`;
    }
    endpoint = endpoint.replace("https:", "wss:");
    endpoint = endpoint.replace("http:", "ws:");
    this.endpoint = endpoint;
    this.pending = [];
    this.counts = {};
    this.events = {};
    this.makePromise();
    this.ready = new Promise((r) => {
      this._ready = r;
    });
    this.connecting = false;
    this.connected = false;
    if (opts.connect === void 0 ? true : opts.connect) {
      this.connect();
    }
    this.connectedTime = null;
    this.connectedDuration = null;
    this.consecutiveDisconnects = 0;
    this.baseTimeout = 1e3;
    this.heartbeatTimeout = opts.heartbeatTimeout === void 0 ? 60 * 1e3 : opts.heartbeatTimeout;
    this.timeout = this.baseTimeout;
    this.closed = false;
    this.autoreconnect = opts.autoreconnect === void 0 ? true : opts.autoreconnect;
    window.wsevents = this.events;
  }
  addEventListener(event, func) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(func);
  }
  removeEventListener(event, func) {
    if (this.events[event]) {
      let idx = this.events[event].indexOf(func);
      if (idx > -1) {
        this.events[event].splice(idx, 1);
      }
    }
  }
  callEventListeners(event, data) {
    if (this.events[event]) {
      for (let func of this.events[event]) {
        func(data);
      }
    }
  }
  count(event) {
    this.counts[event] = (this.counts[event] || 0) + 1;
  }
  makePromise() {
    this.promise = new Promise((resolve2) => {
      this._resolve = () => {
        resolve2();
      };
    });
  }
  async ensureConnected() {
    await new Promise((r) => setTimeout(r, 1));
    if (this.connecting) {
      await this.promise;
    } else if (!this.connected) {
      await this.connect();
    }
  }
  async connect() {
    if (!this.connecting) {
      this.connecting = true;
      if (!this.worker) {
        let WebsocketWorker = (await __vitePreload(() => import("./websocket_worker-H-k5b-ia.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url)).default;
        this.worker = new WebsocketWorker();
        this.worker.onmessage = (e2) => {
          let type2 = e2.data.type;
          let data = e2.data.data;
          log$6("message", e2, type2, data);
          if (type2 == "connect") {
            this.onConnect(data);
          } else if (type2 == "disconnect") {
            this.onDisconnect(data);
          } else if (type2 == "ready") {
            this._ready();
          } else if (data) {
            this.onMessage(data);
          }
        };
        this.worker.onerror = (e2) => {
          console.error(e2);
        };
        setTimeout(() => this.worker.sendMessage({ type: "ready" }), 10);
      }
      log$6("waiting for worker", this.events.connect);
      await this.ready;
      this.closed = false;
      log$6(`connecting to ${this.endpoint}`);
      this.worker.postMessage({ action: "connect", endpoint: this.endpoint });
    }
  }
  onConnect(e2) {
    log$6("*** connected! ***");
    this.connected = true;
    this.callEventListeners("connect", null);
    for (let msg of this.pending) {
      log$6(`resending pending message ${msg[0]}`);
      this.emit(msg[0], msg[1]);
    }
    this.pending = [];
    this.count("connect");
    this.connectedTime = Date.now();
    this._resolve(true);
  }
  onMessage(packet) {
    this.timeout = this.baseTimeout;
    this.heartbeat();
    let data = JSON.parse(packet);
    this.callEventListeners("_message_", data);
    this.callEventListeners(data[0], data[1]);
    this.count(data[0]);
    this.count("_message");
  }
  getDisconnectReason(code2) {
    return {
      "1000": "Normal Closure",
      "1001": "Going Away",
      "1002": "Protocol error",
      "1003": "Unsupported Data",
      "1004": "Reserved",
      "1005": "No Status Rcvd",
      "1006": "Abnormal Closure",
      "1007": "Invalid frame payload data",
      "1008": "Policy Violation",
      "1009": "Message Too Big",
      "1010": "Mandatory Ext",
      "1011": "Internal Server Error",
      "1015": "TLS handshake"
    }[code2];
  }
  async onDisconnect(e2) {
    let reason = this.getDisconnectReason(e2.code);
    if (e2.reason) {
      log$6(`disconnected (${reason} - ${e2.reason})`);
    } else {
      log$6(`disconnected (${reason} : ${e2.code})`);
    }
    this.connectedDuration = Date.now() - this.connectedTime;
    if (this.connectedDuration < 1e4) {
      this.consecutiveDisconnects += 1;
      await new Promise((r) => setTimeout(r, 1e3));
    } else {
      this.consecutiveDisconnects = 0;
      log$6(`disconnected (${reason})`);
    }
    if (e2.code != 1e3 && (e2.code != 1006 || !this.counts._message)) {
      (async () => {
        ({
          code: e2.code,
          reason: e2.reason,
          rfc: this.getDisconnectReason(e2.code),
          counts: this.counts,
          online: navigator.onLine,
          started: this._started,
          ended: Date.now(),
          waited: Date.now() - this._started
        });
        let connection = navigator.connection;
        if (connection) {
          connection.type;
          connection.effectiveType;
          connection.rtt;
          connection.downlink;
        }
      })();
    }
    this.connected = false;
    this.connecting = false;
    this._resolve(false);
    if (this._resolve_close) {
      this._resolve_close();
    }
    this.callEventListeners("disconnect", null);
    clearTimeout(this.__heartbeat);
    clearTimeout(this.__reconnect);
    if (this.consecutiveDisconnects > 3) {
      console.warn("server is not connecting, quiting for a while");
      this.__reconnect = setTimeout(() => this.ensureConnected(), this.timeout * 100);
    } else if (!this.closed && this.autoreconnect) {
      this.makePromise();
      this.__reconnect = setTimeout(() => this.ensureConnected(), this.timeout);
      log$6(`Will attempt to reconnect in ${this.timeout}ms`);
      this.timeout += Math.floor(Math.random() * 5e3) + this.timeout;
      this.timeout = Math.min(60 * 1e3, this.timeout);
    }
    this.count("disconnect");
  }
  on(event, callback) {
    if (event === "connect" && this.connected) {
      callback();
    }
    this.addEventListener(event, callback);
  }
  once(event, callback) {
    let listener = (data) => {
      this.removeEventListener(event, listener);
      callback(data);
    };
    this.addEventListener(event, listener);
  }
  async waitFor(event, timeout = 1e4) {
    return Promise.race([
      new Promise((r) => this.once(event, () => r)),
      new Promise((r) => setTimeout(r, timeout))
    ]);
  }
  off(event) {
    if (this.events[event]) {
      delete this.events[event];
    }
  }
  emit(event, data = {}, retry = true) {
    if (this.connected) {
      this.worker.postMessage({ action: "emit", event, data });
      this.heartbeat();
      this.count("_emit");
    } else if (retry) {
      log$6(`Queuing message to send later: ${event}`);
      this.pending.push([event, data]);
      this.pending = this.pending.slice(0, 3);
    }
  }
  heartbeat() {
    if (this.heartbeatTimeout > 0) {
      clearTimeout(this.__heartbeat);
      this.__heartbeat = setTimeout(() => {
        log$6("");
        this.worker.postMessage({ action: "heartbeat" });
        this.count("_heartbeat");
      }, this.heartbeatTimeout);
    }
  }
  close() {
    this.closed = true;
    return new Promise((resolve2) => {
      this.worker.postMessage({ action: "close" });
      this._resolve_close = resolve2;
    });
  }
}
const log$5 = debug$1("api");
var socket = null;
function timer$3(value, timeout, raise = false) {
  return new Promise(
    (resolve2, reject) => setTimeout(
      () => (raise ? reject : resolve2)(value),
      timeout
    )
  );
}
function create$2(host, opts = {}) {
  socket = new Socket(host, opts);
  return socket;
}
async function sendwait(event, data, timeout = 1e4) {
  if (socket.connected) {
    await Promise.race([
      socket.promise,
      timer$3(null, timeout, true)
    ]);
  }
  socket.emit(event, data);
  return Promise.race([
    new Promise((resolve2) => {
      socket.once(event, (data2) => {
        log$5(`<= ${event}:${JSON.stringify(data2).slice(0, 100)}`);
        resolve2(data2);
      });
    }),
    timer$3(null, timeout)
  ]);
}
var define_import_meta_env_default = { BASE_URL: "./", MODE: "production", DEV: false, PROD: true, SSR: false };
const useWebsocketStore = /* @__PURE__ */ defineStore$1("websocket", () => {
  const users = useUserStore();
  const loggedIn = new Deferred();
  const isLoggedIn = ref(false);
  let socket2 = shallowRef();
  async function send(opts) {
    if (!socket2.value.connected) {
      console.error("websocket not connected");
      return;
    }
    await isLoggedIn;
    return sendwait(opts.event, opts.data);
  }
  function setup2() {
    socket2.value = create$2(define_import_meta_env_default.VITE_APP_TSUNAMI_SERVER.replace("/api/", "/ws/"));
    socket2.value.on("connect", () => {
      login();
    });
    socket2.value.on("disconnect", () => {
      loggedIn.reset();
      isLoggedIn.value = false;
    });
  }
  async function login(attempt = 0) {
    if (!isLoggedIn.value && socket2.value.connected) {
      const user = users.current;
      if (attempt > 0 || !(user == null ? void 0 : user.token)) {
        await users.login();
      }
      const response = await sendwait("login", {
        id: user.id,
        username: user.username,
        token: user.token
      });
      if (response.error) {
        console.error("bad token", user.token);
        if (attempt > 1) {
          throw new Error("Login attempt failed");
        } else {
          console.error("Login attempt failed", response.error);
        }
      } else {
        isLoggedIn.value = true;
        loggedIn.resolve(true);
      }
    }
  }
  return {
    setup: setup2,
    login,
    send,
    socket: socket2,
    isLoggedIn,
    loggedIn: loggedIn.promise
  };
});
async function http(opts) {
  const user = useUserStore();
  await user.login();
  const data = opts.data || {};
  if (opts.user && opts.user.token) {
    data.token = opts.user.token;
  }
  if (opts.user) {
    data.token_user = opts.user.id;
  }
  let retval = await jsonapi({ user: user.current, ...opts });
  if (retval.error && (retval.code === "login" || retval.token == "fail" || retval.code == "token-invalid")) {
    console.log("refreshing login", user.current.token);
    await user.renewLogin(true);
    console.log("refreshed login", user.current.token);
    data.token = user.current.token;
    retval = await jsonapi({ user: user.current, ...opts });
  }
  return retval;
}
function createStorageAdapter(name, options = {}) {
  const prefix = options.prefix ? options.prefix + ":" : "";
  const lsUpdatedKey = `${prefix}${name}:lastUpdate`;
  const store = localForage$1.createInstance({ name: `${prefix}${name}` });
  const list = ref([]);
  const list2 = ref([]);
  const updated = ref(new Date(localStorage[lsUpdatedKey] || 0));
  const migrate = options.migrate || ((a) => a);
  const patching = ref(false);
  const missed = ref(0);
  watch(updated, () => {
    localStorage[lsUpdatedKey] = updated.value.toISOString();
  });
  watch(
    list,
    async () => {
      if (!patching.value) {
        if (await patch()) {
          updated.value = /* @__PURE__ */ new Date();
        }
      } else {
        missed.value += 1;
      }
    },
    { deep: true }
  );
  async function patch() {
    patching.value = true;
    let listChanged = false;
    while (true) {
      for (let object of list.value) {
        if (!object) {
          console.log("list.value has bad value", list.value);
        }
        if (!object.id) {
          object.id = nanoid$1();
          object = migrate(object);
        }
        const index2 = list2.value.findIndex((i) => i.id === object.id);
        let changed = false;
        if (index2 > -1) {
          const patch2 = diff(object, list2.value[index2]);
          changed = !!patch2;
        } else {
          changed = true;
        }
        if (changed) {
          listChanged = true;
          await store.setItem(object.id, copy$1(object));
        }
      }
      for (const object of list2.value) {
        const index2 = list.value.findIndex((i) => i.id === object.id);
        if (index2 === -1) {
          await store.removeItem(object.id);
          listChanged = true;
        }
      }
      list2.value = copy$1(list.value);
      if (missed.value) {
        missed.value = 0;
      } else {
        break;
      }
    }
    patching.value = false;
    return listChanged;
  }
  async function copyFromStorage() {
    patching.value = true;
    await store.iterate((row) => {
      const match = list.value.find((o) => o.id === row.id);
      if (match) {
        if (match.updated < row.updated) {
          for (const key in row) {
            match[key] = row[key];
          }
        }
      } else {
        list.value.push(migrate(row));
      }
    });
    list2.value = copy$1(list.value);
    patching.value = false;
  }
  async function setup2() {
    window.addEventListener("storage", async (e2) => {
      console.log("storage event", name, e2);
      if (e2.key === lsUpdatedKey) {
        const current = new Date(localStorage[lsUpdatedKey]);
        if (current > updated.value) {
          await copyFromStorage();
          updated.value = current;
        }
      }
    });
    await copyFromStorage();
  }
  const isSetupPromise = setup2();
  async function ready() {
    await isSetupPromise;
    await nextTick();
  }
  return { store, list, updated, ready };
}
const useToasterStore = /* @__PURE__ */ defineStore$1("toaster", () => {
  const data = reactive({
    alerts: [],
    maxAlerts: 25,
    counts: {},
    suppress: {}
  });
  function add2(msg) {
    const suppressAs = msg.suppressor || msg.message;
    if (!data.counts[suppressAs]) {
      data.counts[suppressAs] = 0;
    }
    data.counts[suppressAs] += 1;
    if (msg.ex) {
      console.error("alert", msg.ex);
    }
    if (!data.suppress[suppressAs]) {
      let alert = null;
      if (msg.channel) {
        alert = data.alerts.find((a) => a.channel === msg.channel);
      }
      if (alert) {
        alert.message = msg.message;
        alert.title = msg.title;
        alert.link = msg.link;
        alert.timeout = msg.timeout || 1e4;
        alert.timeoutMax = msg.timeout || 1e4;
        alert.count = data.counts[msg.message];
      } else {
        data.alerts.unshift({
          id: nanoid$1(),
          message: msg.message,
          title: msg.title,
          className: msg.className,
          channel: msg.channel,
          level: msg.level || "warn",
          link: msg.link,
          timeout: msg.timeout || 1e4,
          timeoutMax: msg.timeout || 1e4,
          count: data.counts[msg.message]
        });
      }
      if (data.alerts.length > data.maxAlerts) {
        data.alerts.pop();
      }
    }
  }
  function changeSuppression(message, value) {
    data.suppress[message] = value;
  }
  return {
    alerts: data.alerts,
    add: add2,
    changeSuppression
  };
});
function createStore(name, options = {}) {
  const prefix = options.prefix ? options.prefix + ":" : "";
  return /* @__PURE__ */ defineStore$1(prefix + name, () => {
    const toast = useToasterStore();
    const mirror = localForage$1.createInstance({ name: prefix + name + ":server" });
    const { store, list, updated, ready } = createStorageAdapter(name, {
      prefix: options.prefix,
      migrate: options.migrate
    });
    const migrate = options.migrate || ((a) => a);
    const endpoint = options.endpoint ?? name;
    const differ2 = create$3({
      objectHash(obj) {
        return obj.id;
      },
      arrays: {
        detectMove: true,
        includeValueOnMove: true
      }
    });
    async function getIds() {
      const ids = {};
      await list.value.forEach((item2) => ids[item2.id] = item2);
      return ids;
    }
    async function getServerIds() {
      const ids = {};
      await mirror.iterate((item2) => {
        ids[item2.key] = item2;
      });
      return ids;
    }
    async function pushAll() {
      return Promise.all(list.value.map((item2) => push(item2)));
    }
    async function push(object) {
      if (!object.id) {
        object.id = nanoid$1();
      }
      const server = await mirror.getItem(object.id);
      if ((server == null ? void 0 : server.level) === "viewer") {
        console.warn("you cannot push as a viewer");
      }
      try {
        const response = await http({
          event: "db_push",
          data: {
            id: object.id,
            model: endpoint,
            updated: object.updated,
            client: localStorage.clientid,
            content: JSON.stringify(object)
          }
        });
        if (response.error) {
          console.error("server error", object, response);
          if (response.code === "nsfw") {
            toast.add({
              title: "Server save failed moderation",
              message: response.error,
              level: "error"
            });
          } else {
            toast.add({
              title: "Server save failed",
              message: response.error,
              level: "error"
            });
          }
        }
        const record = {
          key: object.id,
          updated: object.updated || "",
          object: copy$1(object)
        };
        await mirror.setItem(object.id, record);
        return response;
      } catch (ex) {
        console.error("Failed to push", ex);
      }
      toast.add({
        title: "Sync problem",
        message: `Failed to push to server (${endpoint}:${object.id})`,
        level: "error"
      });
      throw new Error("failed to push");
    }
    async function pullHeader(id) {
      try {
        const response = await http({
          event: "db_pull",
          data: {
            id,
            model: endpoint
          }
        });
        if (response.ok) {
          const record = response.record;
          record.object = JSON.parse(record.content);
          return record;
        } else {
          throw new Error(response.error);
        }
      } catch (ex) {
        console.error("Failed to push", ex);
      }
      toast.add({
        title: "Pull failed",
        message: `Failed to pull data form server`,
        level: "error"
      });
      throw new Error("failed to pull");
    }
    async function pull(id) {
      const record = await pullHeader(id);
      const match = list.value.find((item2) => item2.id === record.key);
      if (match) {
        for (const key in record.object) {
          match[key] = record.object[key];
        }
      } else {
        list.value.push(record.object);
      }
      await mirror.setItem(record.key, record);
      return record;
    }
    async function destroy(id) {
      try {
        const response = await http({
          event: "db_destroy",
          data: {
            id,
            model: endpoint
          }
        });
        await mirror.removeItem(id);
        return response.ok;
      } catch (ex) {
        console.log("error", ex);
        console.error("Failed to push", ex);
      }
      console.log("failed to destroy");
      toast.add({
        title: "Destroy failed",
        message: `Failed to destroy data from server`,
        level: "error"
      });
      throw new Error("failed to destroy");
    }
    async function pullAllHeaders() {
      try {
        const response = await http({
          event: "db_list",
          data: {
            model: endpoint
          }
        });
        return response.records;
      } catch (ex) {
        console.error("Failed to push", ex);
      }
      toast.add({
        title: "Pull failed",
        message: `Failed to pull data form server`,
        level: "error"
      });
      throw new Error("failed to pull");
    }
    async function sync() {
      const ids = await getIds();
      const serverIds = await getServerIds();
      await Promise.all(
        Object.keys(serverIds).filter((id) => !ids[id]).map(async (id) => {
          console.log(" x> ", id, ids[id]);
          delete serverIds[id];
          await mirror.removeItem(id);
          return destroy(id);
        })
      );
      const clouds = await pullAllHeaders();
      await Promise.all(
        clouds.map(async (cloud) => {
          let instance2 = ids[cloud.key];
          if (instance2) {
            const saved = await syncObject(instance2, cloud, true);
            if (saved) {
              const index2 = list.value.findIndex((item2) => item2.id === cloud.key);
              list.value[index2] = saved;
            }
            delete ids[cloud.key];
          } else {
            console.log(" <= ", cloud.key);
            const server = await pull(cloud.key);
            instance2 = server.object;
          }
          if (serverIds[cloud.key]) {
            delete serverIds[cloud.key];
          }
          return instance2;
        })
      );
      await Promise.all(
        Object.keys(ids).filter((id) => !serverIds[id]).map(async (id) => {
          console.log(" => ", id);
          await push(ids[id]);
          delete ids[id];
        })
      );
      await Promise.all(
        Object.keys(ids).map((key) => {
          const index2 = list.value.findIndex((item2) => item2.id === key);
          if (index2 > -1) {
            list.value.splice(index2, 1);
          }
        })
      );
      await Promise.all(
        Object.keys(serverIds).map((key) => {
          return mirror.removeItem(key);
        })
      );
    }
    async function syncObject(object, serverObject, lazyPull = false) {
      let output = copy$1(object);
      let server = serverObject;
      const original = await mirror.getItem(object.id);
      const originalDate = new Date((original == null ? void 0 : original.updated) || 1);
      const serverDate = new Date(server.updated || 1);
      const objectDate = new Date(object.updated || 1);
      const objectUpdated = objectDate > originalDate;
      const serverUpdated = serverDate > originalDate;
      if (serverUpdated && objectUpdated && original) {
        if (!serverObject.object && lazyPull) {
          server = await pullHeader(object.id);
        }
        const latestDate = new Date(
          Math.max(
            ...[output.updated, server.updated, original.updated].filter((a) => a).map((a) => new Date(a).getTime())
          ) || 0
        ).toISOString();
        const diff1 = differ2.diff(original.object, output);
        const diff2 = differ2.diff(original.object, server.object);
        let diff3;
        if (serverDate > objectDate) {
          diff3 = await mergeDiffs(diff2, diff1);
        } else {
          diff3 = await mergeDiffs(diff1, diff2);
        }
        let output2 = output;
        try {
          output2 = differ2.patch(original.object, diff3);
        } catch (e2) {
          output2 = serverDate > objectDate ? server.object : object;
          console.error(e2);
        }
        output = output2;
        output.updated = latestDate;
        await push(output);
      } else if (serverUpdated) {
        if (serverObject && lazyPull) {
          server = await pull(object.id);
        }
        for (const prop in server.object) {
          output[prop] = server.object[prop];
        }
      } else if (objectUpdated) {
        await push(output);
      }
      return output;
    }
    async function mergeDiffs(a, b, key) {
      let retval = {};
      if (a === void 0) {
        retval = b;
      } else if (b === void 0) {
        retval = a;
      } else if (a instanceof Array) {
        retval = a;
        if (a.length === 1) {
          retval = [await mergeKey(key, null, a[0], b[0])];
        } else if (a.length === 2) {
          retval = [a[0], await mergeKey(key, a[0], a[1], b[1])];
        }
      } else {
        const keys = new Set(Object.keys(a).concat(Object.keys(b)));
        if (keys.has("_t")) {
          keys.delete("_t");
          retval._t = "a";
        }
        for (const sub2 of keys) {
          if (a[sub2] && b[sub2]) {
            retval[sub2] = await mergeDiffs(a[sub2], b[sub2], `${key || "$root"}.${sub2}`);
          } else if (a[sub2]) {
            retval[sub2] = a[sub2];
          } else if (b[sub2]) {
            retval[sub2] = b[sub2];
          }
        }
      }
      return retval;
    }
    function mergeKey(key, orig, a, b) {
      const type2 = typeof (orig || a);
      if (type2 === "string") {
        if (!a && !b || a && !b) {
          return a;
        }
        if (b && !a) {
          return b;
        }
        return a.length >= b.length ? a : b;
      }
      return a;
    }
    async function serverList() {
      const retval = [];
      await mirror.iterate((item2) => {
        retval.push(item2);
      });
      return retval;
    }
    function item(idSource) {
      const value = ref();
      watchEffect(() => {
        const id = typeof idSource === "function" ? idSource() : idSource.value;
        value.value = list.value.find((i) => i.id === id);
      });
      return value;
    }
    function get4(id) {
      return {
        get: () => list.value.find((i) => i.id === id) || initialize({}),
        set: (v) => {
          const index2 = list.value.findIndex((i) => i.id === id);
          if (index2 !== -1) {
            list.value[index2] = v;
          }
        }
      };
    }
    function initialize(a) {
      if (!a.id) {
        a.id = nanoid$1();
      }
      if (!a.updated) {
        a.updated = (/* @__PURE__ */ new Date()).toISOString();
      }
      a = migrate(a);
      return a;
    }
    async function create2(a = {}, temp = false) {
      const b = await initialize(a);
      if (!temp) {
        list.value.push(b);
      }
      return b;
    }
    async function remove2(a) {
      const index2 = list.value.findIndex((i) => i.id === a.id);
      if (index2 !== -1) {
        list.value.splice(index2, 1);
        return true;
      }
      return false;
    }
    return {
      prefix,
      updated,
      store,
      list,
      ready,
      get: get4,
      item,
      create: create2,
      initialize,
      remove: remove2,
      push,
      pushAll,
      pull,
      destroy,
      sync,
      serverList
    };
  });
}
function inpx(x) {
  let retval = `${x}`;
  if (!/px$/.test(retval)) {
    retval = `${retval}px`;
  }
  return retval;
}
function updateColors(theme) {
  const color1 = new Color$1(theme.accent);
  const color2 = color1.clone();
  const color3 = color1.clone();
  const dark = "black";
  const light = "white";
  const text = new Color$1(theme.dark ? light : dark);
  let bg = new Color$1(!theme.dark ? light : dark);
  const spark = new Color$1(theme.spark);
  color1.lerp(bg, 0.6);
  color2.lerp(bg, 0.4);
  bg = bg.lerp(color3, 0.25);
  text.lerp(color3, 0.25);
  const rootVars = {};
  rootVars["--bg"] = `#${bg.getHexString()}`;
  rootVars["--padding"] = inpx(theme.padding);
  rootVars["--spacing"] = inpx(theme.spacing);
  rootVars["--softness"] = inpx(theme.softness);
  updatePreset(MorphosisPreset, {
    primitive: {
      borderRadius: {
        none: "0",
        xs: `${theme.softness * 0.3}px`,
        sm: `${theme.softness * 0.6}px`,
        md: `${theme.softness}px`,
        lg: `${theme.softness * 1.5}px`,
        xl: `${theme.softness * 2}px`
      }
    },
    semantic: {
      surface: palette_default(`#${color1.getHexString()}`),
      primary: palette_default(`#${spark.getHexString()}`),
      colorScheme: {
        light: {
          surface: palette_default(`#${color1.getHexString()}`),
          primary: {
            color: "{primary.500}",
            contrastColor: "#ffffff",
            hoverColor: "{primary.600}",
            activeColor: "{primary.700}"
          }
        },
        dark: {
          surface: palette_default(`#${color1.getHexString()}`),
          primary: {
            color: "{primary.500}",
            contrastColor: "#ffffff",
            hoverColor: "{primary.600}",
            activeColor: "{primary.700}"
          }
        }
      }
    }
  });
  return {
    ...rootVars,
    ...lerpColors("color1", color1),
    ...lerpColors("color2", color2),
    ...lerpColors("color3", color3),
    ...lerpColors("accent", color1),
    ...lerpColors("spark", spark)
  };
}
const useThemesStore = createStore("themes", { endpoint: "theme" });
const useThemeStore = /* @__PURE__ */ defineStore$1("theme", () => {
  const themes = useThemesStore();
  const socket2 = useWebsocketStore();
  const defaultTheme = {
    id: "app",
    darkColor: "black",
    lightColor: "white",
    accent: "#6d07cc",
    spark: "#1e71cf",
    dark: true,
    padding: 5,
    spacing: 5,
    softness: 5,
    updated: (/* @__PURE__ */ new Date()).toISOString()
  };
  const vars = ref({});
  const saved = computed(themes.get("app"));
  const current = ref(copy$2(themes.list.find((t) => t.id === "app") || defaultTheme));
  const offline = ref(true);
  watch(
    () => current.value.updated,
    async () => {
      saved.value = current.value;
      vars.value = updateColors(current.value);
    }
  );
  watch(vars, () => {
    updateStyle();
  });
  async function setup2() {
    offline.value = false;
    await themes.ready();
    const temp = themes.list.find((t) => t.id === "app");
    if (temp) {
      current.value = unref(temp);
    } else if (themes.list.length === 0) {
      await themes.create(defaultTheme);
    }
    vars.value = updateColors(current.value);
    await themes.sync();
    if (!socket2.socket) {
      console.warn(
        "socket is not initialized! Rewrite to ensure socket is ready before using themes"
      );
    } else {
      await socket2.socket.ready;
      await socket2.socket.addEventListener("db_update", (packet) => {
        if (packet.model === "theme") {
          const content = JSON.parse(packet.content);
          current.value = content;
        }
      });
      await socket2.send({ event: "db_listen", data: { model: "theme" } });
    }
  }
  async function reset2() {
    current.value = {
      id: "app",
      ...defaultTheme,
      updated: (/* @__PURE__ */ new Date()).toISOString()
    };
    vars.value = updateColors(current.value);
  }
  function updateStyle() {
    let styleTag = document.querySelector("#root-vars");
    if (!styleTag) {
      styleTag = document.createElement("style");
      document.head.appendChild(styleTag);
      styleTag.id = "root-vars";
    }
    let sheet = "#app {";
    for (const key in vars.value) {
      const value = vars.value[key];
      sheet += `  ${key}: ${value};`;
    }
    sheet += "}";
    styleTag.innerHTML = sheet;
  }
  function update() {
    vars.value = updateColors(current.value);
  }
  function push() {
    current.value.updated = (/* @__PURE__ */ new Date()).toISOString();
    themes.push(current.value);
  }
  return { offline, current, vars, reset: reset2, setup: setup2, update, updateStyle, push };
});
/*!
 * pinia v2.2.0
 * (c) 2024 Eduardo San Martin Morote
 * @license MIT
 */
let activePinia;
const setActivePinia = (pinia) => activePinia = pinia;
const piniaSymbol$1 = (
  /* istanbul ignore next */
  Symbol()
);
function isPlainObject$1(o) {
  return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
}
var MutationType$1;
(function(MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType$1 || (MutationType$1 = {}));
const noop = () => {
};
function addSubscription(subscriptions, callback, detached, onCleanup = noop) {
  subscriptions.push(callback);
  const removeSubscription = () => {
    const idx = subscriptions.indexOf(callback);
    if (idx > -1) {
      subscriptions.splice(idx, 1);
      onCleanup();
    }
  };
  if (!detached && getCurrentScope()) {
    onScopeDispose(removeSubscription);
  }
  return removeSubscription;
}
function triggerSubscriptions(subscriptions, ...args) {
  subscriptions.slice().forEach((callback) => {
    callback(...args);
  });
}
const fallbackRunWithContext = (fn) => fn();
const ACTION_MARKER = Symbol();
const ACTION_NAME = Symbol();
function mergeReactiveObjects(target, patchToApply) {
  if (target instanceof Map && patchToApply instanceof Map) {
    patchToApply.forEach((value, key) => target.set(key, value));
  } else if (target instanceof Set && patchToApply instanceof Set) {
    patchToApply.forEach(target.add, target);
  }
  for (const key in patchToApply) {
    if (!patchToApply.hasOwnProperty(key))
      continue;
    const subPatch = patchToApply[key];
    const targetValue = target[key];
    if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
      target[key] = mergeReactiveObjects(targetValue, subPatch);
    } else {
      target[key] = subPatch;
    }
  }
  return target;
}
const skipHydrateSymbol = (
  /* istanbul ignore next */
  Symbol()
);
function shouldHydrate(obj) {
  return !isPlainObject$1(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
}
const { assign: assign$2 } = Object;
function isComputed(o) {
  return !!(isRef(o) && o.effect);
}
function createOptionsStore(id, options, pinia, hot) {
  const { state: state2, actions, getters } = options;
  const initialState = pinia.state.value[id];
  let store;
  function setup2() {
    if (!initialState && true) {
      {
        pinia.state.value[id] = state2 ? state2() : {};
      }
    }
    const localState = toRefs(pinia.state.value[id]);
    return assign$2(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
      computedGetters[name] = markRaw(computed(() => {
        setActivePinia(pinia);
        const store2 = pinia._s.get(id);
        return getters[name].call(store2, store2);
      }));
      return computedGetters;
    }, {}));
  }
  store = createSetupStore(id, setup2, options, pinia, hot, true);
  return store;
}
function createSetupStore($id, setup2, options = {}, pinia, hot, isOptionsStore) {
  let scope;
  const optionsForPlugin = assign$2({ actions: {} }, options);
  const $subscribeOptions = { deep: true };
  let isListening;
  let isSyncListening;
  let subscriptions = [];
  let actionSubscriptions = [];
  let debuggerEvents;
  const initialState = pinia.state.value[$id];
  if (!isOptionsStore && !initialState && true) {
    {
      pinia.state.value[$id] = {};
    }
  }
  ref({});
  let activeListener;
  function $patch(partialStateOrMutator) {
    let subscriptionMutation;
    isListening = isSyncListening = false;
    if (typeof partialStateOrMutator === "function") {
      partialStateOrMutator(pinia.state.value[$id]);
      subscriptionMutation = {
        type: MutationType$1.patchFunction,
        storeId: $id,
        events: debuggerEvents
      };
    } else {
      mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
      subscriptionMutation = {
        type: MutationType$1.patchObject,
        payload: partialStateOrMutator,
        storeId: $id,
        events: debuggerEvents
      };
    }
    const myListenerId = activeListener = Symbol();
    nextTick().then(() => {
      if (activeListener === myListenerId) {
        isListening = true;
      }
    });
    isSyncListening = true;
    triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
  }
  const $reset = isOptionsStore ? function $reset2() {
    const { state: state2 } = options;
    const newState = state2 ? state2() : {};
    this.$patch(($state) => {
      assign$2($state, newState);
    });
  } : (
    /* istanbul ignore next */
    noop
  );
  function $dispose() {
    scope.stop();
    subscriptions = [];
    actionSubscriptions = [];
    pinia._s.delete($id);
  }
  const action = (fn, name = "") => {
    if (ACTION_MARKER in fn) {
      fn[ACTION_NAME] = name;
      return fn;
    }
    const wrappedAction = function() {
      setActivePinia(pinia);
      const args = Array.from(arguments);
      const afterCallbackList = [];
      const onErrorCallbackList = [];
      function after(callback) {
        afterCallbackList.push(callback);
      }
      function onError(callback) {
        onErrorCallbackList.push(callback);
      }
      triggerSubscriptions(actionSubscriptions, {
        args,
        name: wrappedAction[ACTION_NAME],
        store,
        after,
        onError
      });
      let ret;
      try {
        ret = fn.apply(this && this.$id === $id ? this : store, args);
      } catch (error) {
        triggerSubscriptions(onErrorCallbackList, error);
        throw error;
      }
      if (ret instanceof Promise) {
        return ret.then((value) => {
          triggerSubscriptions(afterCallbackList, value);
          return value;
        }).catch((error) => {
          triggerSubscriptions(onErrorCallbackList, error);
          return Promise.reject(error);
        });
      }
      triggerSubscriptions(afterCallbackList, ret);
      return ret;
    };
    wrappedAction[ACTION_MARKER] = true;
    wrappedAction[ACTION_NAME] = name;
    return wrappedAction;
  };
  const partialStore = {
    _p: pinia,
    // _s: scope,
    $id,
    $onAction: addSubscription.bind(null, actionSubscriptions),
    $patch,
    $reset,
    $subscribe(callback, options2 = {}) {
      const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
      const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state2) => {
        if (options2.flush === "sync" ? isSyncListening : isListening) {
          callback({
            storeId: $id,
            type: MutationType$1.direct,
            events: debuggerEvents
          }, state2);
        }
      }, assign$2({}, $subscribeOptions, options2)));
      return removeSubscription;
    },
    $dispose
  };
  const store = reactive(partialStore);
  pinia._s.set($id, store);
  const runWithContext = pinia._a && pinia._a.runWithContext || fallbackRunWithContext;
  const setupStore = runWithContext(() => pinia._e.run(() => (scope = effectScope()).run(() => setup2({ action }))));
  for (const key in setupStore) {
    const prop = setupStore[key];
    if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
      if (!isOptionsStore) {
        if (initialState && shouldHydrate(prop)) {
          if (isRef(prop)) {
            prop.value = initialState[key];
          } else {
            mergeReactiveObjects(prop, initialState[key]);
          }
        }
        {
          pinia.state.value[$id][key] = prop;
        }
      }
    } else if (typeof prop === "function") {
      const actionValue = action(prop, key);
      {
        setupStore[key] = actionValue;
      }
      optionsForPlugin.actions[key] = prop;
    } else
      ;
  }
  {
    assign$2(store, setupStore);
    assign$2(toRaw(store), setupStore);
  }
  Object.defineProperty(store, "$state", {
    get: () => pinia.state.value[$id],
    set: (state2) => {
      $patch(($state) => {
        assign$2($state, state2);
      });
    }
  });
  pinia._p.forEach((extender) => {
    {
      assign$2(store, scope.run(() => extender({
        store,
        app: pinia._a,
        pinia,
        options: optionsForPlugin
      })));
    }
  });
  if (initialState && isOptionsStore && options.hydrate) {
    options.hydrate(store.$state, initialState);
  }
  isListening = true;
  isSyncListening = true;
  return store;
}
function defineStore(idOrOptions, setup2, setupOptions) {
  let id;
  let options;
  const isSetupStore = typeof setup2 === "function";
  if (typeof idOrOptions === "string") {
    id = idOrOptions;
    options = isSetupStore ? setupOptions : setup2;
  } else {
    options = idOrOptions;
    id = idOrOptions.id;
  }
  function useStore(pinia, hot) {
    const hasContext = hasInjectionContext();
    pinia = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    pinia || (hasContext ? inject(piniaSymbol$1, null) : null);
    if (pinia)
      setActivePinia(pinia);
    pinia = activePinia;
    if (!pinia._s.has(id)) {
      if (isSetupStore) {
        createSetupStore(id, setup2, options, pinia);
      } else {
        createOptionsStore(id, options, pinia);
      }
    }
    const store = pinia._s.get(id);
    return store;
  }
  useStore.$id = id;
  return useStore;
}
let mapStoreSuffix = "Store";
function mapStores(...stores) {
  return stores.reduce((reduced, useStore) => {
    reduced[useStore.$id + mapStoreSuffix] = function() {
      return useStore(this.$pinia);
    };
    return reduced;
  }, {});
}
const useImageStore = defineStore("images", () => {
  const thumbnails = ref({});
  const images = ref({});
  const queue2 = ref({});
  function loadImage(blobId, thumbnail = true) {
    const key = `${blobId}-${thumbnail}`;
    if (!queue2.value[key]) {
      queue2.value[key] = processQueue(blobId, thumbnail);
    }
    return queue2.value[key];
  }
  async function processQueue(blobId, thumbnail = true) {
    let image = null;
    if (thumbnail) {
      image = thumbnails.value[blobId];
    } else {
      image = images.value[blobId];
    }
    if (!image) {
      if (blobId) {
        const instance2 = await Media.load(blobId);
        if (instance2) {
          if (thumbnail) {
            image = await instance2.getThumbnail();
            thumbnails.value[blobId] = image;
          } else {
            image = await instance2.getUrl();
            images.value[blobId] = image;
          }
        }
      } else {
        image = null;
      }
      if (image) {
        const img = new Image();
        await new Promise((resolve2, reject) => {
          img.onload = resolve2;
          img.onerror = reject;
          img.src = image;
        });
      }
    }
    queue2.value[`${blobId}-${thumbnail}`] = null;
    return image;
  }
  function clearOne(blobId, thumbnail = true) {
    queue2.value[`${blobId}-${thumbnail}`] = void 0;
    images.value[blobId] = void 0;
    thumbnails.value[blobId] = void 0;
  }
  function clear2() {
    thumbnails.value = {};
    images.value = {};
  }
  return { thumbnails, images, loadImage, clear: clear2, clearOne };
});
class BaseDriver {
  constructor(name, ext) {
    __publicField(this, "name");
    __publicField(this, "ext");
    this.name = name;
    this.ext = ext;
  }
  async ready() {
    return true;
  }
  async length() {
    throw new Error("Not implemented");
  }
  async iterate(predicate) {
    throw new Error("Not implemented");
  }
  async setItem(name, data) {
    throw new Error("Not implemented");
  }
  async getItem(name, def2) {
    throw new Error("Not implemented");
  }
  async removeItem(name) {
    throw new Error("Not implemented");
  }
}
class PlatformDriver extends BaseDriver {
  constructor(name, ext) {
    super();
    this.name = name;
    this.ext = ext;
    this.proxy = null;
  }
  get isMergable() {
    return this.proxy.isMergable;
  }
  get type() {
    return this.proxy.type;
  }
  async ready() {
    if (!this.proxy) {
      let Driver = null;
      if (window.electron) {
        Driver = (await __vitePreload(() => import("./JetpackDriver-r8WMRBaO.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url)).default;
      } else {
        Driver = (await __vitePreload(() => import("./LocalForageDriver-95XTc84k.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url)).default;
      }
      this.proxy = new Driver(this.name, this.ext);
    }
    return this.proxy.ready();
  }
  async length() {
    return this.proxy.length();
  }
  async iterate(predicate) {
    return this.proxy.iterate(predicate);
  }
  async setItem(name, data) {
    await this.ready();
    return this.proxy.setItem(name, data);
  }
  async getItem(name, def2) {
    return this.proxy.getItem(name, def2);
  }
  async removeItem(name) {
    return this.proxy.removeItem(name);
  }
}
let canvas = document.createElement("canvas");
async function compress(image, opts) {
  let reader = new FileReader();
  let src = await new Promise((resolve2, reject) => {
    reader.onload = function() {
      resolve2(reader.result);
    };
    reader.onerror = reject;
    reader.readAsDataURL(image);
  });
  let img = new Image();
  await new Promise((resolve2, reject) => {
    img.onload = resolve2;
    img.onerror = reject;
    img.src = src;
  });
  let w = null;
  w = img.width;
  let h2 = img.height;
  if (w > opts.maxWidthOrHeight) {
    let ratio = h2 / w;
    w = opts.maxWidthOrHeight;
    h2 = w * ratio;
  } else if (h2 > opts.maxWidthOrHeight) {
    let ratio = w / h2;
    h2 = opts.maxWidthOrHeight;
    w = h2 * ratio;
  }
  if (w > 500 && ["image/svg", "image/svg+xml", "image/gif"].indexOf(image.type) > -1) {
    return src;
  } else {
    canvas.width = w;
    canvas.height = h2;
    let ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, w, h2);
    let result = canvas.toDataURL("image/webp");
    return result;
  }
}
compress.getDataUrlFromFile = function(canvas2) {
  return canvas2;
};
class BaseField {
  createProperty(object, key, fieldname = null) {
    this.initialize(object, key);
    const field = fieldname || key;
    Object.defineProperty(object, field, {
      get: () => this.getValue(object, key),
      set: (v) => {
        this.setValue(object, key, v);
      }
    });
  }
  initialize(object, key) {
    this.object = object;
    this.key = key;
  }
  getValue(object, key) {
    return this.object.data[key];
  }
  setValue(object, key, v) {
    this.object.data[key] = v;
  }
  async serialize() {
    return this.object.data[this.key];
  }
  async dispose() {
  }
}
class ImageField extends BaseField {
  initialize(object, key) {
    super.initialize(object, key);
    const url = object.data[key];
    object.data[key] = null;
    if (url) {
      this.ready = this.cachedUrl(url);
    } else {
      this.ready = true;
    }
  }
  getValue() {
    return this.url;
  }
  setValue(v) {
    this.cachedUrl(v);
  }
  getCacheKey() {
    return `${this.object.constructor.name}-${this.object.data.id}-${this.key}`;
  }
  async getBlobURL(url) {
    if (this.url) {
      URL.revokeObjectURL(this.url);
      console.log("revoked blob url", this.url);
    }
    this.url = URL.createObjectURL(await (await fetch(url)).blob());
    console.log("got blob url", this.url);
    return this.url;
  }
  async cachedUrl(url = null) {
    const cacheKey = this.getCacheKey();
    if (url) {
      ImageField._imageCache[cacheKey] = await this.getBlobURL(url);
    }
    return ImageField._imageCache[cacheKey];
  }
  async serialize() {
    return this.fetch();
  }
  async dispose() {
    URL.revokeObjectURL(this.url);
    console.log("revoked blob url2", this.url);
  }
}
ImageField._imageCache = {};
class Manager {
  constructor(name) {
    this.name = name;
    if (!localStorage.clientid) {
      localStorage.clientid = nanoid$1();
    }
  }
  async list(ref2) {
    throw new Error("not implemented");
  }
  async load(id) {
    throw new Error("not implemented");
  }
  async save(object) {
    throw new Error("not implemented");
  }
  async delete(id) {
    return new Error("not implemented");
  }
  async push(object, opts = {}) {
    if (!window.app.disconnected) {
      if (!object.id) {
        object.id = nanoid$1();
      }
      if (object._server) {
        if (object._server.level === "viewer") {
          console.warn("you cannot push as a viewer");
        }
        delete object._server;
      }
      object.updated = (/* @__PURE__ */ new Date()).toISOString();
      try {
        const response = await window.app.http("db_push", {
          id: object.id,
          model: this.name,
          updated: object.updated,
          client: localStorage.clientid,
          content: opts.content || await this.pushContent(object),
          ...opts
        });
        if (response.error && window.app && window.app.addAlert) {
          console.error("server error", object, response);
          if (response.code === "nsfw") {
            window.app.addAlert({
              title: "Server save failed",
              message: response.error,
              level: "error"
            });
          } else {
            window.app.addAlert({
              title: "Server save failed",
              message: response.error,
              level: "error"
            });
          }
        }
        if (object._server) {
          delete object._server;
        }
        object._server = copy$1(object);
        return response;
      } catch (ex) {
        console.error("Failed to push", ex);
      }
      if (window.app && window.app.addAlert) {
        window.app.addAlert({
          title: "Sync problem",
          message: `Failed to push to server (${this.name}:${object.id})`,
          level: "error"
        });
      }
      return { error: "failed to push" };
    }
    console.log("offline, not pushing");
    return { error: "offline" };
  }
  async pull(id, object = {}) {
    const response = await window.app.http("db_pull", { id, model: this.name });
    if (response.ok) {
      if (response.record.public) {
        object.content = response.record.content;
        object.updated = response.record.updated;
      } else {
        try {
          const value = JSON.parse(response.record.content);
          for (const prop in value) {
            object[prop] = value[prop];
          }
          if (value._server) {
            delete value._server;
          }
          object._server = value;
        } catch (ex) {
          console.log("trying to update from record", response);
          console.error(ex);
        }
      }
    }
    return object;
  }
  async pullList() {
    const retval = [];
    const response = await window.app.http("db_list", { model: this.name });
    if (response.ok) {
      for (const row of response.records) {
        row.id = row.key;
        delete row.key;
        retval.push(row);
      }
    }
    return retval;
  }
  async pushDelete(id) {
    return window.app.http("db_destroy", {
      id,
      model: this.name
    });
  }
}
const STORES = {};
class LocalForageManager extends Manager {
  static get prefix() {
    return this.appPrefix || "";
  }
  static set prefix(v) {
    this.appPrefix = v;
  }
  get store() {
    const label = `${this.constructor.prefix}:${this.name}`;
    if (!STORES[label]) {
      STORES[label] = localForage$1.createInstance({ name: label });
    }
    return STORES[label];
  }
  async list(ref2) {
    const retval = ref2 || [];
    await this.store.iterate((object) => {
      retval.push(object);
    });
    return retval;
  }
  async count() {
    let count = 0;
    await this.store.iterate(() => {
      count += 1;
    });
    return count;
  }
  async load(id) {
    return this.store.getItem(`${id}`);
  }
  async save(object) {
    let data = object;
    if (!object.id) {
      data = copy$1(object);
      data.id = nanoid$1();
    }
    try {
      await this.store.setItem(data.id, data);
    } catch (ex) {
      window.app.addAlert({
        title: "Failed to write to with mgLocalStorage driver",
        message: `${ex.message}`,
        ex
      });
    }
    return data.id;
  }
  delete(id) {
    return this.store.removeItem(`${id}`);
  }
}
const differ = create$3({
  objectHash(obj) {
    return obj._id || obj.id;
  },
  arrays: {
    detectMove: true,
    includeValueOnMove: true
  }
});
class TsunamiManager extends LocalForageManager {
  get storageName() {
    if (this.namespace) {
      return `${this.namespace}_${this.name}`;
    }
    return this.name;
  }
  async pushContent(object) {
    const retval = copy$1(object);
    if (retval._server) {
      delete retval._server;
    }
    if (retval._meta) {
      delete retval._meta;
    }
    return JSON.stringify(retval);
  }
  async syncAll(Model2, callback = null) {
    const clouds = await this.pullList();
    return Promise.all(clouds.map(async (cloud) => {
      let instance2 = await Model2.load(cloud.id);
      if (!instance2) {
        instance2 = new Model2({ id: cloud.id });
      }
      const saved = await this.sync(instance2, cloud, true);
      if (saved) {
        instance2.update(saved);
        await instance2.save();
        if (callback) {
          callback(instance2, cloud);
        }
      }
      return instance2;
    }));
  }
  async sync(object, serverObject = null, lazyPull = false) {
    let output = copy$1(object);
    let server = serverObject || await this.pull(object.id);
    delete server._server;
    if (serverObject) {
      output._meta = serverObject;
    }
    const originalDate = new Date((object._server || {}).updated || 1);
    const serverDate = new Date(server.updated || 1);
    const objectDate = new Date(object.updated || 1);
    const objectUpdated = objectDate > originalDate;
    const serverUpdated = serverDate > originalDate;
    if (serverUpdated && objectUpdated && object._server) {
      if (serverObject && lazyPull) {
        server = await this.pull(object.id);
      }
      const original = object._server;
      delete output.updated;
      delete server.updated;
      delete original.updated;
      const diff1 = differ.diff(original, output);
      const diff2 = differ.diff(original, server);
      const args = serverDate > objectDate ? [diff2, diff1] : [diff1, diff2];
      const diff3 = await this.mergeDiffs(...args);
      let output2 = null;
      try {
        output2 = differ.patch(original, diff3);
      } catch (e2) {
        output2 = serverDate > objectDate ? server : object;
        console.error(e2);
      }
      output = output2;
      output.updated = (/* @__PURE__ */ new Date()).toISOString();
      await this.push(output);
    } else if (serverUpdated) {
      if (serverObject && lazyPull) {
        server = await this.pull(object.id);
      }
      for (const prop in server) {
        output[prop] = server[prop];
      }
      server.updated = serverDate.toISOString();
      if (server._server) {
        delete server._server;
      }
      output._server = server;
    } else if (objectUpdated) {
      await this.push(output);
    }
    return output;
  }
  async mergeDiffs(a, b, key = null) {
    console.log("diff", key, "=>", a, "|", b);
    let retval = {};
    if (a === void 0) {
      retval = b;
    } else if (b === void 0) {
      retval = a;
    } else if (a instanceof Array) {
      retval = a;
      if (a.length === 1) {
        retval = [await this.mergeKey(key, null, a[0], b[0])];
      } else if (a.length === 2) {
        retval = [a[0], await this.mergeKey(key, a[0], a[1], b[1])];
      }
    } else {
      const keys = new Set(Object.keys(a).concat(Object.keys(b)));
      if (keys.has("_t")) {
        keys.delete("_t");
        retval._t = "a";
      }
      for (const sub2 of keys) {
        if (a[sub2] && b[sub2]) {
          retval[sub2] = await this.mergeDiffs(
            a[sub2],
            b[sub2],
            `${key || "$root"}.${sub2}`
          );
        } else if (a[sub2]) {
          retval[sub2] = a[sub2];
        } else if (b[sub2]) {
          retval[sub2] = b[sub2];
        }
      }
    }
    return retval;
  }
  async mergeKey(key, orig, a, b) {
    const type2 = typeof (orig || a);
    if (type2 === "string") {
      if (!a && !b || a && !b) {
        return a;
      }
      if (b && !a) {
        return b;
      }
      return a.length >= b.length ? a : b;
    }
    return a;
  }
  async listEditors(object) {
    return window.app.http("db_editor", {
      doc: object.id.toString(),
      model: this.storageName,
      action: "list"
    });
  }
  async addEditor(object, { user, level }) {
    return window.app.http("db_editor", {
      doc: object.id,
      model: this.storageName,
      user,
      level,
      action: "add"
    });
  }
  async changeEditor(object, { member, user, level }) {
    return window.app.http("db_editor", {
      doc: object.id,
      model: this.storageName,
      id: member,
      user,
      level,
      action: "change"
    });
  }
  async removeEditor(object, { member, user }) {
    return window.app.http("db_editor", {
      doc: object.id,
      model: this.storageName,
      id: member,
      user,
      action: "delete"
    });
  }
}
class OneRelation extends BaseField {
  constructor(model) {
    super();
    this.model = model;
  }
  getValue(object, key) {
    return this;
  }
  setValue(object, key, v) {
    console.log("setting foreign key", v);
    if (typeof v === "object") {
      this.object.data[key] = v.id;
    } else {
      this.object.data[key] = v;
    }
  }
  get value() {
    return this.object.data[this.key];
  }
  async object() {
    if (this.value && !this._object) {
      this._object = await this.model.load(this.value);
    }
    return this._object || null;
  }
  async dispose() {
    if (this._object) {
      await this._object.dispose();
    }
    this._object = null;
  }
}
class Relation extends BaseField {
  constructor(model, fieldname = null) {
    super();
    this.model = model;
    this.fieldname = fieldname;
    this._cache = null;
  }
  get length() {
    return this.object.data[this.field].length;
  }
  get field() {
    return this.fieldname || this.key;
  }
  getValue() {
    return this;
  }
  clearCache() {
    this._cache = null;
  }
  async addToCache(object) {
    if (!this._cache) {
      await this.list();
    }
    if (!this._cache.find((o) => o.id === object.id)) {
      this._cache.push(object);
    }
  }
  async list() {
    if (!this._cache) {
      const ids = this.object.data[this.field];
      this._cache = await Promise.all(ids.map((s) => this.model.load(s)));
      this._cache = this._cache.filter((a) => a);
      if (ids.length !== this._cache.length) {
        const remove2 = new Set(ids);
        this._cache.map((c) => c.id).forEach((c) => remove2.delete(c));
        console.warn("missing objects", remove2);
      }
    }
    return this._cache;
  }
  async add(object) {
    if (this.object.data[this.field].indexOf(object.id) === -1) {
      this.object.data[this.field].push(object.id);
      await this.object.save();
      this.addToCache(object);
      return true;
    }
    return false;
  }
  async create(props) {
    const sub2 = new this.model(props);
    await sub2.save();
    this.object.data[this.field].push(sub2.id);
    await this.object.save();
    if (this._cache) {
      this._cache.push(sub2);
    }
    return sub2;
  }
  async delete(instance2) {
    if (this._cache) {
      const index3 = this._cache.findIndex((c) => c.id === instance2.id);
      if (index3 > -1) {
        this._cache.splice(index3, 1);
      }
    }
    const index2 = this.object.data[this.field].findIndex((c) => c === instance2.id);
    if (index2 > -1) {
      this.object.data[this.field].splice(index2, 1);
      await this.object.save();
    }
    console.log("delete", instance2.id, this.object.data[this.field]);
    return instance2.delete();
  }
}
const _Model = class _Model {
  constructor(data) {
    __publicField(this, "data");
    if (!data) {
      this.data = {};
    } else {
      this.data = copy$1(data);
    }
    this.beforeDefaultProperties();
    const defaultObject = this.constructor.defaultObject;
    this.fields = this.constructor.fields;
    for (const key in this.fields) {
      this.fields[key].createProperty(this, key);
    }
    for (const key in defaultObject) {
      if (this.data[key] === void 0) {
        this.data[key] = defaultObject[key];
      }
      if (!this[key] && !this.fields[key]) {
        Object.defineProperty(this, key, {
          get: () => this.data[key],
          set: (v) => {
            this.data[key] = v;
          }
        });
      }
    }
    this.afterDefaultProperties();
  }
  static get objectName() {
    return this.name || "document";
  }
  static get defaultObject() {
    return {};
  }
  static get fields() {
    return {};
  }
  static get ManagerClass() {
    return this._ManagerClass || _Model.DefaultManagerClass;
  }
  static set ManagerClass(v) {
    this._ManagerClass = v;
    this.manager = null;
  }
  static get objects() {
    if (!this.manager) {
      this.manager = new this.ManagerClass(this.objectName);
    }
    return this.manager;
  }
  static async list() {
    const retval = await this.objects.list();
    const objects = retval.map((d) => new this(d));
    await Promise.all(
      objects.map(async (o) => {
        if (await this.shouldMigrate(o)) {
          await this.migrate(o);
        }
      })
    );
    return objects;
  }
  static async count() {
    return this.objects.count();
  }
  static async load(id) {
    const data = await this.objects.load(id);
    if (data && data.id) {
      const object = new this(data);
      if (await this.shouldMigrate(object)) {
        await this.migrate(object);
      }
      return object;
    }
    return null;
  }
  static async shouldMigrate(object) {
    return this.VERSION && (!object._version || object._version < this.VERSION);
  }
  static async migrate(object) {
    return null;
  }
  get objects() {
    return this.constructor.objects;
  }
  get id() {
    return this.data.id;
  }
  get _version() {
    return this.data._version;
  }
  get editable() {
    return !this._server || this._server.level !== "viewer";
  }
  dispose() {
    const fields = this.constructor.fields;
    for (const key in fields) {
      fields[key].dispose();
    }
  }
  beforeDefaultProperties() {
  }
  afterDefaultProperties() {
  }
  // defineRelation(name, model, fieldname) {
  //   const field = fieldname || name;
  //   this.relations[field] = new Relation(this, name, model);
  //   Object.defineProperty(this, field, {
  //     get: () => this.relations[field],
  //     set: (v) => { throw new Error('cannot set relation'); },
  //   });
  // }
  // async filter(ref, filters) {
  //   const retval = ref || [];
  //   for (const object of await this.constructor.objects.list()) {
  //     let ok = true;
  //     if (filters) {
  //       for (const name in filters) {
  //         if (object[name] !== filters[name]) {
  //           ok = false;
  //           break;
  //         }
  //       }
  //     }
  //     if (ok) {
  //       retval.push(object);
  //     }
  //   }
  //   return retval;
  // }
  update(data) {
    for (const key in data) {
      this.data[key] = data[key];
    }
  }
  updateMissingDefaults() {
    const defaultObject = this.constructor.defaultObject;
    for (const key in defaultObject) {
      if (this.data[key] === void 0) {
        this.data[key] = defaultObject[key];
        console.log("missing2", key, this.data[key]);
      }
    }
  }
  updateProperties() {
  }
  async load(id) {
    const data = await this.objects.load(id, this.data);
    if (data) {
      this.data = data;
    }
    if (await this.constructor.shouldMigrate(this)) {
      await this.constructor.migrate(this);
    }
  }
  async unload() {
    return this.objects.unload(this.id);
  }
  async save() {
    const object = copy$1(this.data);
    this.data.id = await this.objects.save(object);
    return this.data.id;
  }
  async saveAndPush() {
    await this.save();
    await this.push();
    return this.data.id;
  }
  async delete() {
    return this.objects.delete(this.id);
  }
  static async syncAll(callback = null) {
    return this.objects.syncAll(this, callback);
  }
  async sync(server, lazyPull = false) {
    const updated = this.data.updated;
    const serverUpdated = (this.data._server || {}).updated || 1;
    const bytes = this.data.byte_size;
    this.data = await this.objects.sync(this.data, server, lazyPull);
    if (this.data.updated !== updated || this.data._server.updated !== serverUpdated || this.data.byte_size !== bytes) {
      console.log(" -> synced", this.constructor.name, this.id);
      await this.save();
      return true;
    }
    return false;
  }
  async push(opts = {}) {
    console.warn(" <- pushed", this.constructor.name, this.id);
    return this.objects.push(this.data, opts);
  }
  async pushDelete() {
    return this.objects.pushDelete(this.id);
  }
  async syncGroupAsEditors(group, level = null) {
    const response = await this.listEditors();
    console.log(this.id, "response", response);
    const editors = response.members;
    console.log(this.id, "existing editors3", editors, group);
    const adds = group.members.filter(
      (m) => m && m.user_id && m.joined && !editors.find((e2) => e2.user_id === m.user_id)
    );
    const updates = group.members.map((m) => editors.find((e2) => e2.user_id === m.user_id)).filter((a) => a && a.user_id);
    const deletes = editors.filter((e2) => !group.members.find((m) => m.user_id === e2.user_id));
    console.log(
      this.id,
      "add/update/delete",
      level,
      adds.map((a) => a.user_id),
      updates.map((a) => a.user_id),
      deletes.map((a) => a.user_id)
    );
    await Promise.all([
      ...adds.map(async (m) => {
        await this.addEditor({
          doc: this.id,
          user: m.user_id,
          level: level || "viewer"
        });
      }),
      ...updates.map(async (m) => {
        await this.changeEditor({
          doc: this.id,
          user: m.user_id,
          level: level || "viewer"
        });
      }),
      ...deletes.map(async (m) => {
        await this.deleteEditor({
          doc: this.id,
          user: m.user_id
        });
      })
    ]);
  }
  async listEditors() {
    return this.objects.listEditors(this.data);
  }
  async addEditor(opts) {
    return this.objects.addEditor(this.data, opts);
  }
  async changeEditor(opts) {
    return this.objects.changeEditor(this.data, opts);
  }
  async removeEditor(opts) {
    return this.objects.removeEditor(this.data, opts);
  }
  static get fieldtypes() {
    return {
      BaseField,
      ImageField,
      Relation,
      OneRelation
    };
  }
};
__publicField(_Model, "VERSION", 0);
let Model = _Model;
Model.DefaultManagerClass = TsunamiManager;
class BaseModel extends Model {
  static get defaultObject() {
    return {
      id: null,
      updated: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
  static get ManagerClass() {
    return TsunamiManager;
  }
  static get allowSyncing() {
    var _a;
    return !!((_a = window.app.user) == null ? void 0 : _a.email) && window.app.$root.allowSyncing;
  }
  async sync(cloud, lazyPull = false) {
    if (this.constructor.allowSyncing) {
      return super.sync(cloud, lazyPull);
    }
    return null;
  }
  async push(opts = {}) {
    if (this.constructor.allowSyncing) {
      return super.push(opts);
    }
    return null;
  }
  async pushDelete() {
    if (this.constructor.allowSyncing) {
      return super.pushDelete();
    }
    return null;
  }
  /** returns a list of reasons why maybe you don't want to delete this */
  deleteCheck() {
    return [];
  }
}
class FilesystemManager extends Manager {
  static get prefix() {
    return this.appPrefix || "";
  }
  static set prefix(v) {
    this.appPrefix = v;
  }
  async getStore() {
    const label = `${this.constructor.prefix}:${this.name}`;
    if (!window.app) {
      console.error("this model requires an `app`");
      throw new Error("missing app");
    } else if (!window.app.getFilesystem) {
      console.error("this model requires an app with filesystem_mixin", window.app);
      throw new Error("missing app with filesystem_mixin");
    } else {
      return window.app.getFilesystem(label);
    }
  }
  async list(ref2) {
    const store = await this.getStore();
    const retval = ref2 || [];
    await store.iterate((object) => {
      retval.push(object);
    });
    return retval;
  }
  async count() {
    const store = await this.getStore();
    return store.length();
  }
  async load(id) {
    const store = await this.getStore();
    return store.getItem(`${id}`);
  }
  async save(object) {
    const store = await this.getStore();
    let data = object;
    if (!object.id) {
      data = copy$1(object);
      data.id = nanoid$1();
    }
    try {
      await store.setItem(data.id, data);
    } catch (ex) {
      window.app.addAlert({
        title: "Failed to write to with mgLocalStorage driver",
        message: `${ex.message}`,
        ex
      });
    }
    return data.id;
  }
  async delete(id) {
    const store = await this.getStore();
    return store.removeItem(`${id}`);
  }
}
class FilesystemModel extends BaseModel {
  static get ManagerClass() {
    return FilesystemManager;
  }
}
function cacheBusted(originalUrl) {
  let url = originalUrl;
  if (!/^data:/.test(url)) {
    if (/\?/.test(url)) {
      url += "&";
    } else {
      url += "?";
    }
    url += `dt=${Date.now()}`;
  }
  return url;
}
class Media extends FilesystemModel {
  static get objectName() {
    return "media";
  }
  static get defaultObject() {
    return {
      id: null,
      name: "",
      type: "image/png",
      permalink: null,
      cloud: false,
      cloudSafe: false,
      width: null,
      height: null,
      updated: (/* @__PURE__ */ new Date()).toISOString(),
      isPrivate: null,
      size: null,
      // @deprecated
      thumb: null
    };
  }
  static get blobs() {
    if (!Media._blobs) {
      Media._blobs = new PlatformDriver("mediablobs");
    }
    return Media._blobs;
  }
  static get thumbnails() {
    if (!Media._thumbnails) {
      Media._thumbnails = new PlatformDriver("mediathumbnails");
    }
    return Media._thumbnails;
  }
  static get canvases() {
    if (!Media._canvases) {
      Media._canvases = new PlatformDriver("mediacanvases");
    }
    return Media._canvases;
  }
  static async importBlob(blob, id = null, isPrivate = false) {
    const blob_id = id || blob.blob_id;
    if (typeof blob === "string") {
      blob = await (await fetch(cacheBusted(blob))).blob();
    }
    let media = null;
    if (blob_id) {
      media = await Media.load(blob_id);
    }
    if (!media) {
      const ext = blob.type ? blob.type.split("/")[1] : "";
      media = new Media({
        id: blob_id,
        name: blob_id + ext
      });
      if (!media.id) {
        await media.save();
      }
    }
    return media.importBlob(blob, isPrivate);
  }
  static async clearCachedUrls() {
    console.error(" --> clearCachedUrls");
    for (const key in Media.cachedUrls) {
      URL.revokeObjectURL(Media.cachedUrls[key]);
      delete Media.cachedUrls[key];
    }
    const store = useImageStore();
    await store.clear();
  }
  static async ready() {
    await Promise.all([Media.canvases.ready(), Media.blobs.ready(), Media.thumbnails.ready()]);
  }
  get canvas() {
    return Media.canvases.getItem(this.id);
  }
  set canvas(value) {
    this.setCanvas(value);
  }
  async setCanvas(value) {
    this.updated = (/* @__PURE__ */ new Date()).toISOString();
    return Media.canvases.setItem(this.id, value);
  }
  get isImage() {
    return /^image/.test(this.type);
  }
  get isAudio() {
    return /^audio/.test(this.type);
  }
  toString() {
    return this.name;
  }
  async thumbnailImage(blob = null, isPrivate = false) {
    const tkey = `t.${this.id}`;
    if (Media.cachedUrls[tkey]) {
      await URL.revokeObjectURL(Media.cachedUrls[tkey]);
      delete Media.cachedUrls[tkey];
    }
    if (blob) {
      let url = null;
      if (typeof blob === "string") {
        blob = await (await fetch(cacheBusted(blob))).blob();
      }
      if (blob.size === 0) {
        throw new Error("blob is empty");
      }
      try {
        url = await compress(blob, {
          maxWidthOrHeight: 200,
          useWebWorker: app.platform !== "ios"
        });
      } catch (e2) {
        throw e2;
      }
      const tblob = await (await fetch(url)).blob();
      if (!isPrivate) {
        await Media.thumbnails.setItem(this.id, tblob);
      }
      return tblob;
    } else if (this.id) {
      this.thumb = null;
      await Media.thumbnails.removeItem(this.id);
      return null;
    }
  }
  async getBlob() {
    if (this.id) {
      let blob = await Media.blobs.getItem(this.id);
      return blob;
    }
  }
  async getUrl(existing = null) {
    if (this.id && !Media.cachedUrls[this.id]) {
      let blob = existing || await this.getBlob();
      if (blob) {
        if (typeof blob === "string") {
          blob = await (await fetch(cacheBusted(blob))).blob();
          console.log("blob is a string, fixing", this.id, blob);
        }
        Media.blobs.setItem(this.id, blob);
        Media.cachedUrls[this.id] = URL.createObjectURL(blob);
      }
    }
    return Media.cachedUrls[this.id];
  }
  async getDataUrl() {
    const blob = await this.getBlob();
    if (blob) {
      const url = new Promise((resolve2, reject) => {
        var a = new FileReader();
        a.onload = (e2) => resolve2(e2.target.result);
        a.onerror = reject;
        a.readAsDataURL(blob);
      });
      return url;
    }
    return "";
  }
  async getThumbnail(blob = null) {
    const tkey = `t.${this.id}`;
    if (!blob && this.thumb) {
      blob = await (await fetch(this.thumb)).blob();
    }
    if (this.thumb) {
      this.thumb = null;
      await this.save();
    }
    if (blob) {
      if (Media.cachedUrls[tkey]) {
        await URL.revokeObjectURL(Media.cachedUrls[tkey]);
        delete Media.cachedUrls[tkey];
      }
    }
    if (blob || !Media.cachedUrls[tkey]) {
      if (!blob && this.isImage) {
        blob = await this.getBlob();
      }
      if (blob) {
        blob = await this.thumbnailImage(blob);
      }
      if (blob) {
        Media.cachedUrls[tkey] = URL.createObjectURL(blob);
      }
    }
    return Media.cachedUrls[tkey];
  }
  async cleanImage(file) {
    if (["image/svg", "image/svg+xml", "image/gif"].includes(file.type)) {
      return { result: file, error: null };
    }
    try {
      file = await compress(file, {
        // maxWidthOrHeight: 2048,
        maxWidthOrHeight: 3840,
        useWebWorker: app.platform !== "ios"
      });
      const str = await compress.getDataUrlFromFile(file);
      return { result: str, error: null };
    } catch (ex) {
      return { result: null, error: ex };
    }
  }
  async importBlob(blob, isPrivate = false) {
    if (typeof blob === "string") {
      blob = await (await fetch(cacheBusted(blob))).blob();
    }
    if (!this.id) {
      await this.save();
    }
    if (!isPrivate) {
      await Media.blobs.setItem(this.id, blob);
    }
    if (Media.cachedUrls[this.id]) {
      URL.revokeObjectURL(Media.cachedUrls[this.id]);
      delete Media.cachedUrls[this.id];
      Media.cachedUrls[this.id] = null;
    }
    const url = await this.getUrl(blob);
    let image = null;
    try {
      image = await new Promise((resolve2, reject) => {
        const image2 = new Image();
        image2.onload = () => resolve2(image2);
        image2.onerror = () => reject(new Error("Invalid image"));
        image2.src = url;
      });
    } catch (err) {
    }
    if (blob.name) {
      this.name = blob.name;
    }
    if (blob.type && blob.type !== "application/octet-stream") {
      this.type = blob.type;
    }
    if (image) {
      this.width = image.width;
      this.height = image.height;
      await this.thumbnailImage(blob, isPrivate);
    } else {
      await this.thumbnailImage(null, isPrivate);
    }
    this.size = blob.size;
    this.isPrivate = isPrivate;
    this.updated = (/* @__PURE__ */ new Date()).toISOString();
    await this.save();
    return this;
  }
  async save() {
    if (this.data.content) {
      console.log(" --> save", this.id);
      const content = this.data.content;
      this.data.content = null;
      await this.importBlob(content);
    }
    if (this.id && !this.size) {
      this.size = (await this.getBlob()).size;
    }
    if (this.id && this.data.canvas) {
      await this.setCanvas(this.data.canvas);
      delete this.data.canvas;
    }
    return super.save();
  }
  async push() {
    console.warn("pushing");
    const content = await this.getDataUrl();
    if (content) {
      console.log("push", this.name, this.type);
      const response = await Media.objects.push(
        {
          id: this.id,
          client: localStorage.clientid
        },
        {
          content,
          model: "media",
          public: true,
          updated: this.updated,
          name: this.name,
          content_type: this.type
        }
      );
      let shouldSave = false;
      if (response.error && (/moderation/gi.test(response.error) || response.code === "nsfw")) {
        this.permalink = "";
        this.cloud = false;
        this.cloudSafe = false;
        shouldSave = true;
      } else if (response.url && this.permalink !== response.url) {
        this.permalink = response.url;
        shouldSave = true;
      }
      if (shouldSave) {
        await this.save();
      }
      return response;
    }
  }
  async pushDelete() {
    return Media.objects.pushDelete(this.id);
  }
  async pull() {
    console.warn("pulling");
    const response = await window.app.http("db_pull", {
      id: this.id,
      model: this.constructor.objectName
    });
    console.log("pull response", response);
    if (response.ok) {
      const record = response.record;
      const permalink = response.record.permalink || response.record.url;
      if (record.name) {
        this.name = record.name;
      }
      if (record.content_type) {
        this.type = record.content_type;
      }
      if (permalink) {
        this.permalink = permalink;
        this.cloud = true;
        await this.importBlob(permalink);
        this.updated = response.record.updated;
      }
      this.save();
    } else {
      await this.push();
    }
    return null;
  }
  async sync(server, lazyPull = false) {
    const serverDate = new Date(server.updated || 1);
    const objectDate = new Date(this.updated || 1);
    if (serverDate.getTime() > objectDate.getTime()) {
      console.log("media sync pull", this.id, serverDate);
      const url = server.permalink || server.content;
      if (url) {
        console.log("server in pull", server);
        if (server.name) {
          this.name = server.name;
        }
        if (server.type) {
          this.type = server.type;
        }
        this.permalink = url;
        this.cloud = true;
        await this.importBlob(url);
        this.updated = server.updated;
        await this.save();
      } else {
        await this.pull();
      }
      return true;
    } else if (serverDate.getTime() < objectDate.getTime()) {
      console.warn(
        "media sync push",
        this.id,
        this.cloud,
        serverDate.toISOString(),
        objectDate.toISOString()
      );
      await this.push();
    }
    return false;
  }
  async dispose() {
    console.log("--> disposed", this.id);
    if (Media.cachedUrls[this.id]) {
      URL.revokeObjectURL(Media.cachedUrls[this.id]);
      delete Media.cachedUrls[this.id];
    }
    const tkey = `t.${this.id}`;
    if (Media.cachedUrls[tkey]) {
      URL.revokeObjectURL(Media.cachedUrls[tkey]);
      delete Media.cachedUrls[tkey];
    }
  }
  async delete() {
    await Media.blobs.removeItem(this.id);
    try {
      await Media.canvases.removeItem(this.id);
    } catch (ex) {
    }
    try {
      await Media.thumbnails.removeItem(this.id);
    } catch (ex) {
    }
    console.log("--> deleted");
    return super.delete();
  }
}
Media.cachedUrls = {};
function sceneGetText(scene, width = 50) {
  const d = scene.directions.find((d2) => d2.type === "text");
  return ((d ? d.content : null) || `(Scene ${scene.id})`).slice(0, width).replace("\n", " ").trim();
}
function put(name, data) {
  try {
    localStorage[name] = JSON.stringify(data);
  } catch (ex) {
    this.$root.addAlert({
      title: "Failed to save data",
      message: `${ex.message}`,
      ex
    });
  }
}
function fetch$1(name, def2) {
  try {
    const result = JSON.parse(localStorage[name]);
    if (result === void 0) {
      return def2;
    }
    return result;
  } catch (ex) {
    return def2;
  }
}
var INUMBER = "INUMBER";
var IOP1 = "IOP1";
var IOP2 = "IOP2";
var IOP3 = "IOP3";
var IVAR = "IVAR";
var IVARNAME = "IVARNAME";
var IFUNCALL = "IFUNCALL";
var IFUNDEF = "IFUNDEF";
var IEXPR = "IEXPR";
var IEXPREVAL = "IEXPREVAL";
var IMEMBER = "IMEMBER";
var IENDSTATEMENT = "IENDSTATEMENT";
var IARRAY = "IARRAY";
function Instruction(type2, value) {
  this.type = type2;
  this.value = value !== void 0 && value !== null ? value : 0;
}
Instruction.prototype.toString = function() {
  switch (this.type) {
    case INUMBER:
    case IOP1:
    case IOP2:
    case IOP3:
    case IVAR:
    case IVARNAME:
    case IENDSTATEMENT:
      return this.value;
    case IFUNCALL:
      return "CALL " + this.value;
    case IFUNDEF:
      return "DEF " + this.value;
    case IARRAY:
      return "ARRAY " + this.value;
    case IMEMBER:
      return "." + this.value;
    default:
      return "Invalid Instruction";
  }
};
function unaryInstruction(value) {
  return new Instruction(IOP1, value);
}
function binaryInstruction(value) {
  return new Instruction(IOP2, value);
}
function ternaryInstruction(value) {
  return new Instruction(IOP3, value);
}
function simplify(tokens2, unaryOps, binaryOps, ternaryOps, values) {
  var nstack = [];
  var newexpression = [];
  var n1, n2, n3;
  var f;
  for (var i = 0; i < tokens2.length; i++) {
    var item = tokens2[i];
    var type2 = item.type;
    if (type2 === INUMBER || type2 === IVARNAME) {
      if (Array.isArray(item.value)) {
        nstack.push.apply(nstack, simplify(item.value.map(function(x) {
          return new Instruction(INUMBER, x);
        }).concat(new Instruction(IARRAY, item.value.length)), unaryOps, binaryOps, ternaryOps, values));
      } else {
        nstack.push(item);
      }
    } else if (type2 === IVAR && values.hasOwnProperty(item.value)) {
      item = new Instruction(INUMBER, values[item.value]);
      nstack.push(item);
    } else if (type2 === IOP2 && nstack.length > 1) {
      n2 = nstack.pop();
      n1 = nstack.pop();
      f = binaryOps[item.value];
      item = new Instruction(INUMBER, f(n1.value, n2.value));
      nstack.push(item);
    } else if (type2 === IOP3 && nstack.length > 2) {
      n3 = nstack.pop();
      n2 = nstack.pop();
      n1 = nstack.pop();
      if (item.value === "?") {
        nstack.push(n1.value ? n2.value : n3.value);
      } else {
        f = ternaryOps[item.value];
        item = new Instruction(INUMBER, f(n1.value, n2.value, n3.value));
        nstack.push(item);
      }
    } else if (type2 === IOP1 && nstack.length > 0) {
      n1 = nstack.pop();
      f = unaryOps[item.value];
      item = new Instruction(INUMBER, f(n1.value));
      nstack.push(item);
    } else if (type2 === IEXPR) {
      while (nstack.length > 0) {
        newexpression.push(nstack.shift());
      }
      newexpression.push(new Instruction(IEXPR, simplify(item.value, unaryOps, binaryOps, ternaryOps, values)));
    } else if (type2 === IMEMBER && nstack.length > 0) {
      n1 = nstack.pop();
      nstack.push(new Instruction(INUMBER, n1.value[item.value]));
    } else {
      while (nstack.length > 0) {
        newexpression.push(nstack.shift());
      }
      newexpression.push(item);
    }
  }
  while (nstack.length > 0) {
    newexpression.push(nstack.shift());
  }
  return newexpression;
}
function substitute(tokens2, variable, expr) {
  var newexpression = [];
  for (var i = 0; i < tokens2.length; i++) {
    var item = tokens2[i];
    var type2 = item.type;
    if (type2 === IVAR && item.value === variable) {
      for (var j = 0; j < expr.tokens.length; j++) {
        var expritem = expr.tokens[j];
        var replitem;
        if (expritem.type === IOP1) {
          replitem = unaryInstruction(expritem.value);
        } else if (expritem.type === IOP2) {
          replitem = binaryInstruction(expritem.value);
        } else if (expritem.type === IOP3) {
          replitem = ternaryInstruction(expritem.value);
        } else {
          replitem = new Instruction(expritem.type, expritem.value);
        }
        newexpression.push(replitem);
      }
    } else if (type2 === IEXPR) {
      newexpression.push(new Instruction(IEXPR, substitute(item.value, variable, expr)));
    } else {
      newexpression.push(item);
    }
  }
  return newexpression;
}
function evaluate(tokens2, expr, values) {
  var nstack = [];
  var n1, n2, n3;
  var f, args, argCount;
  if (isExpressionEvaluator(tokens2)) {
    return resolveExpression(tokens2, values);
  }
  var numTokens = tokens2.length;
  for (var i = 0; i < numTokens; i++) {
    var item = tokens2[i];
    var type2 = item.type;
    if (type2 === INUMBER || type2 === IVARNAME) {
      nstack.push(item.value);
    } else if (type2 === IOP2) {
      n2 = nstack.pop();
      n1 = nstack.pop();
      if (item.value === "and") {
        nstack.push(n1 ? !!evaluate(n2, expr, values) : false);
      } else if (item.value === "or") {
        nstack.push(n1 ? true : !!evaluate(n2, expr, values));
      } else if (item.value === "=") {
        f = expr.binaryOps[item.value];
        nstack.push(f(n1, evaluate(n2, expr, values), values));
      } else {
        f = expr.binaryOps[item.value];
        nstack.push(f(resolveExpression(n1, values), resolveExpression(n2, values)));
      }
    } else if (type2 === IOP3) {
      n3 = nstack.pop();
      n2 = nstack.pop();
      n1 = nstack.pop();
      if (item.value === "?") {
        nstack.push(evaluate(n1 ? n2 : n3, expr, values));
      } else {
        f = expr.ternaryOps[item.value];
        nstack.push(f(resolveExpression(n1, values), resolveExpression(n2, values), resolveExpression(n3, values)));
      }
    } else if (type2 === IVAR) {
      if (item.value in expr.functions) {
        nstack.push(expr.functions[item.value]);
      } else if (item.value in expr.unaryOps && expr.parser.isOperatorEnabled(item.value)) {
        nstack.push(expr.unaryOps[item.value]);
      } else {
        var v = values[item.value];
        if (v !== void 0) {
          nstack.push(v);
        } else {
          throw new Error("undefined variable: " + item.value);
        }
      }
    } else if (type2 === IOP1) {
      n1 = nstack.pop();
      f = expr.unaryOps[item.value];
      nstack.push(f(resolveExpression(n1, values)));
    } else if (type2 === IFUNCALL) {
      argCount = item.value;
      args = [];
      while (argCount-- > 0) {
        args.unshift(resolveExpression(nstack.pop(), values));
      }
      f = nstack.pop();
      if (f.apply && f.call) {
        nstack.push(f.apply(void 0, args));
      } else {
        throw new Error(f + " is not a function");
      }
    } else if (type2 === IFUNDEF) {
      nstack.push(function() {
        var n22 = nstack.pop();
        var args2 = [];
        var argCount2 = item.value;
        while (argCount2-- > 0) {
          args2.unshift(nstack.pop());
        }
        var n12 = nstack.pop();
        var f2 = function() {
          var scope = Object.assign({}, values);
          for (var i2 = 0, len = args2.length; i2 < len; i2++) {
            scope[args2[i2]] = arguments[i2];
          }
          return evaluate(n22, expr, scope);
        };
        Object.defineProperty(f2, "name", {
          value: n12,
          writable: false
        });
        values[n12] = f2;
        return f2;
      }());
    } else if (type2 === IEXPR) {
      nstack.push(createExpressionEvaluator(item, expr));
    } else if (type2 === IEXPREVAL) {
      nstack.push(item);
    } else if (type2 === IMEMBER) {
      n1 = nstack.pop();
      nstack.push(n1[item.value]);
    } else if (type2 === IENDSTATEMENT) {
      nstack.pop();
    } else if (type2 === IARRAY) {
      argCount = item.value;
      args = [];
      while (argCount-- > 0) {
        args.unshift(nstack.pop());
      }
      nstack.push(args);
    } else {
      throw new Error("invalid Expression");
    }
  }
  if (nstack.length > 1) {
    throw new Error("invalid Expression (parity)");
  }
  return nstack[0] === 0 ? 0 : resolveExpression(nstack[0], values);
}
function createExpressionEvaluator(token, expr, values) {
  if (isExpressionEvaluator(token))
    return token;
  return {
    type: IEXPREVAL,
    value: function(scope) {
      return evaluate(token.value, expr, scope);
    }
  };
}
function isExpressionEvaluator(n) {
  return n && n.type === IEXPREVAL;
}
function resolveExpression(n, values) {
  return isExpressionEvaluator(n) ? n.value(values) : n;
}
function expressionToString(tokens2, toJS) {
  var nstack = [];
  var n1, n2, n3;
  var f, args, argCount;
  for (var i = 0; i < tokens2.length; i++) {
    var item = tokens2[i];
    var type2 = item.type;
    if (type2 === INUMBER) {
      if (typeof item.value === "number" && item.value < 0) {
        nstack.push("(" + item.value + ")");
      } else if (Array.isArray(item.value)) {
        nstack.push("[" + item.value.map(escapeValue).join(", ") + "]");
      } else {
        nstack.push(escapeValue(item.value));
      }
    } else if (type2 === IOP2) {
      n2 = nstack.pop();
      n1 = nstack.pop();
      f = item.value;
      if (toJS) {
        if (f === "^") {
          nstack.push("Math.pow(" + n1 + ", " + n2 + ")");
        } else if (f === "and") {
          nstack.push("(!!" + n1 + " && !!" + n2 + ")");
        } else if (f === "or") {
          nstack.push("(!!" + n1 + " || !!" + n2 + ")");
        } else if (f === "||") {
          nstack.push("(function(a,b){ return Array.isArray(a) && Array.isArray(b) ? a.concat(b) : String(a) + String(b); }((" + n1 + "),(" + n2 + ")))");
        } else if (f === "==") {
          nstack.push("(" + n1 + " === " + n2 + ")");
        } else if (f === "!=") {
          nstack.push("(" + n1 + " !== " + n2 + ")");
        } else if (f === "[") {
          nstack.push(n1 + "[(" + n2 + ") | 0]");
        } else {
          nstack.push("(" + n1 + " " + f + " " + n2 + ")");
        }
      } else {
        if (f === "[") {
          nstack.push(n1 + "[" + n2 + "]");
        } else {
          nstack.push("(" + n1 + " " + f + " " + n2 + ")");
        }
      }
    } else if (type2 === IOP3) {
      n3 = nstack.pop();
      n2 = nstack.pop();
      n1 = nstack.pop();
      f = item.value;
      if (f === "?") {
        nstack.push("(" + n1 + " ? " + n2 + " : " + n3 + ")");
      } else {
        throw new Error("invalid Expression");
      }
    } else if (type2 === IVAR || type2 === IVARNAME) {
      nstack.push(item.value);
    } else if (type2 === IOP1) {
      n1 = nstack.pop();
      f = item.value;
      if (f === "-" || f === "+") {
        nstack.push("(" + f + n1 + ")");
      } else if (toJS) {
        if (f === "not") {
          nstack.push("(!" + n1 + ")");
        } else if (f === "!") {
          nstack.push("fac(" + n1 + ")");
        } else {
          nstack.push(f + "(" + n1 + ")");
        }
      } else if (f === "!") {
        nstack.push("(" + n1 + "!)");
      } else {
        nstack.push("(" + f + " " + n1 + ")");
      }
    } else if (type2 === IFUNCALL) {
      argCount = item.value;
      args = [];
      while (argCount-- > 0) {
        args.unshift(nstack.pop());
      }
      f = nstack.pop();
      nstack.push(f + "(" + args.join(", ") + ")");
    } else if (type2 === IFUNDEF) {
      n2 = nstack.pop();
      argCount = item.value;
      args = [];
      while (argCount-- > 0) {
        args.unshift(nstack.pop());
      }
      n1 = nstack.pop();
      if (toJS) {
        nstack.push("(" + n1 + " = function(" + args.join(", ") + ") { return " + n2 + " })");
      } else {
        nstack.push("(" + n1 + "(" + args.join(", ") + ") = " + n2 + ")");
      }
    } else if (type2 === IMEMBER) {
      n1 = nstack.pop();
      nstack.push(n1 + "." + item.value);
    } else if (type2 === IARRAY) {
      argCount = item.value;
      args = [];
      while (argCount-- > 0) {
        args.unshift(nstack.pop());
      }
      nstack.push("[" + args.join(", ") + "]");
    } else if (type2 === IEXPR) {
      nstack.push("(" + expressionToString(item.value, toJS) + ")");
    } else if (type2 === IENDSTATEMENT)
      ;
    else {
      throw new Error("invalid Expression");
    }
  }
  if (nstack.length > 1) {
    if (toJS) {
      nstack = [nstack.join(",")];
    } else {
      nstack = [nstack.join(";")];
    }
  }
  return String(nstack[0]);
}
function escapeValue(v) {
  if (typeof v === "string") {
    return JSON.stringify(v).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  return v;
}
function contains(array, obj) {
  for (var i = 0; i < array.length; i++) {
    if (array[i] === obj) {
      return true;
    }
  }
  return false;
}
function getSymbols(tokens2, symbols, options) {
  options = options || {};
  var withMembers = !!options.withMembers;
  var prevVar = null;
  for (var i = 0; i < tokens2.length; i++) {
    var item = tokens2[i];
    if (item.type === IVAR || item.type === IVARNAME) {
      if (!withMembers && !contains(symbols, item.value)) {
        symbols.push(item.value);
      } else if (prevVar !== null) {
        if (!contains(symbols, prevVar)) {
          symbols.push(prevVar);
        }
        prevVar = item.value;
      } else {
        prevVar = item.value;
      }
    } else if (item.type === IMEMBER && withMembers && prevVar !== null) {
      prevVar += "." + item.value;
    } else if (item.type === IEXPR) {
      getSymbols(item.value, symbols, options);
    } else if (prevVar !== null) {
      if (!contains(symbols, prevVar)) {
        symbols.push(prevVar);
      }
      prevVar = null;
    }
  }
  if (prevVar !== null && !contains(symbols, prevVar)) {
    symbols.push(prevVar);
  }
}
function Expression(tokens2, parser2) {
  this.tokens = tokens2;
  this.parser = parser2;
  this.unaryOps = parser2.unaryOps;
  this.binaryOps = parser2.binaryOps;
  this.ternaryOps = parser2.ternaryOps;
  this.functions = parser2.functions;
}
Expression.prototype.simplify = function(values) {
  values = values || {};
  return new Expression(simplify(this.tokens, this.unaryOps, this.binaryOps, this.ternaryOps, values), this.parser);
};
Expression.prototype.substitute = function(variable, expr) {
  if (!(expr instanceof Expression)) {
    expr = this.parser.parse(String(expr));
  }
  return new Expression(substitute(this.tokens, variable, expr), this.parser);
};
Expression.prototype.evaluate = function(values) {
  values = values || {};
  return evaluate(this.tokens, this, values);
};
Expression.prototype.toString = function() {
  return expressionToString(this.tokens, false);
};
Expression.prototype.symbols = function(options) {
  options = options || {};
  var vars = [];
  getSymbols(this.tokens, vars, options);
  return vars;
};
Expression.prototype.variables = function(options) {
  options = options || {};
  var vars = [];
  getSymbols(this.tokens, vars, options);
  var functions = this.functions;
  return vars.filter(function(name) {
    return !(name in functions);
  });
};
Expression.prototype.toJSFunction = function(param, variables) {
  var expr = this;
  var f = new Function(param, "with(this.functions) with (this.ternaryOps) with (this.binaryOps) with (this.unaryOps) { return " + expressionToString(this.simplify(variables).tokens, true) + "; }");
  return function() {
    return f.apply(expr, arguments);
  };
};
var TEOF = "TEOF";
var TOP = "TOP";
var TNUMBER = "TNUMBER";
var TSTRING = "TSTRING";
var TPAREN = "TPAREN";
var TBRACKET = "TBRACKET";
var TCOMMA = "TCOMMA";
var TNAME = "TNAME";
var TSEMICOLON = "TSEMICOLON";
function Token(type2, value, index2) {
  this.type = type2;
  this.value = value;
  this.index = index2;
}
Token.prototype.toString = function() {
  return this.type + ": " + this.value;
};
function TokenStream(parser2, expression) {
  this.pos = 0;
  this.current = null;
  this.unaryOps = parser2.unaryOps;
  this.binaryOps = parser2.binaryOps;
  this.ternaryOps = parser2.ternaryOps;
  this.consts = parser2.consts;
  this.expression = expression;
  this.savedPosition = 0;
  this.savedCurrent = null;
  this.options = parser2.options;
  this.parser = parser2;
}
TokenStream.prototype.newToken = function(type2, value, pos) {
  return new Token(type2, value, pos != null ? pos : this.pos);
};
TokenStream.prototype.save = function() {
  this.savedPosition = this.pos;
  this.savedCurrent = this.current;
};
TokenStream.prototype.restore = function() {
  this.pos = this.savedPosition;
  this.current = this.savedCurrent;
};
TokenStream.prototype.next = function() {
  if (this.pos >= this.expression.length) {
    return this.newToken(TEOF, "EOF");
  }
  if (this.isWhitespace() || this.isComment()) {
    return this.next();
  } else if (this.isRadixInteger() || this.isNumber() || this.isOperator() || this.isString() || this.isParen() || this.isBracket() || this.isComma() || this.isSemicolon() || this.isNamedOp() || this.isConst() || this.isName()) {
    return this.current;
  } else {
    this.parseError('Unknown character "' + this.expression.charAt(this.pos) + '"');
  }
};
TokenStream.prototype.isString = function() {
  var r = false;
  var startPos = this.pos;
  var quote = this.expression.charAt(startPos);
  if (quote === "'" || quote === '"') {
    var index2 = this.expression.indexOf(quote, startPos + 1);
    while (index2 >= 0 && this.pos < this.expression.length) {
      this.pos = index2 + 1;
      if (this.expression.charAt(index2 - 1) !== "\\") {
        var rawString = this.expression.substring(startPos + 1, index2);
        this.current = this.newToken(TSTRING, this.unescape(rawString), startPos);
        r = true;
        break;
      }
      index2 = this.expression.indexOf(quote, index2 + 1);
    }
  }
  return r;
};
TokenStream.prototype.isParen = function() {
  var c = this.expression.charAt(this.pos);
  if (c === "(" || c === ")") {
    this.current = this.newToken(TPAREN, c);
    this.pos++;
    return true;
  }
  return false;
};
TokenStream.prototype.isBracket = function() {
  var c = this.expression.charAt(this.pos);
  if ((c === "[" || c === "]") && this.isOperatorEnabled("[")) {
    this.current = this.newToken(TBRACKET, c);
    this.pos++;
    return true;
  }
  return false;
};
TokenStream.prototype.isComma = function() {
  var c = this.expression.charAt(this.pos);
  if (c === ",") {
    this.current = this.newToken(TCOMMA, ",");
    this.pos++;
    return true;
  }
  return false;
};
TokenStream.prototype.isSemicolon = function() {
  var c = this.expression.charAt(this.pos);
  if (c === ";") {
    this.current = this.newToken(TSEMICOLON, ";");
    this.pos++;
    return true;
  }
  return false;
};
TokenStream.prototype.isConst = function() {
  var startPos = this.pos;
  var i = startPos;
  for (; i < this.expression.length; i++) {
    var c = this.expression.charAt(i);
    if (c.toUpperCase() === c.toLowerCase()) {
      if (i === this.pos || c !== "_" && c !== "." && (c < "0" || c > "9")) {
        break;
      }
    }
  }
  if (i > startPos) {
    var str = this.expression.substring(startPos, i);
    if (str in this.consts) {
      this.current = this.newToken(TNUMBER, this.consts[str]);
      this.pos += str.length;
      return true;
    }
  }
  return false;
};
TokenStream.prototype.isNamedOp = function() {
  var startPos = this.pos;
  var i = startPos;
  for (; i < this.expression.length; i++) {
    var c = this.expression.charAt(i);
    if (c.toUpperCase() === c.toLowerCase()) {
      if (i === this.pos || c !== "_" && (c < "0" || c > "9")) {
        break;
      }
    }
  }
  if (i > startPos) {
    var str = this.expression.substring(startPos, i);
    if (this.isOperatorEnabled(str) && (str in this.binaryOps || str in this.unaryOps || str in this.ternaryOps)) {
      this.current = this.newToken(TOP, str);
      this.pos += str.length;
      return true;
    }
  }
  return false;
};
TokenStream.prototype.isName = function() {
  var startPos = this.pos;
  var i = startPos;
  var hasLetter = false;
  for (; i < this.expression.length; i++) {
    var c = this.expression.charAt(i);
    if (c.toUpperCase() === c.toLowerCase()) {
      if (i === this.pos && (c === "$" || c === "_")) {
        if (c === "_") {
          hasLetter = true;
        }
        continue;
      } else if (i === this.pos || !hasLetter || c !== "_" && (c < "0" || c > "9")) {
        break;
      }
    } else {
      hasLetter = true;
    }
  }
  if (hasLetter) {
    var str = this.expression.substring(startPos, i);
    this.current = this.newToken(TNAME, str);
    this.pos += str.length;
    return true;
  }
  return false;
};
TokenStream.prototype.isWhitespace = function() {
  var r = false;
  var c = this.expression.charAt(this.pos);
  while (c === " " || c === "	" || c === "\n" || c === "\r") {
    r = true;
    this.pos++;
    if (this.pos >= this.expression.length) {
      break;
    }
    c = this.expression.charAt(this.pos);
  }
  return r;
};
var codePointPattern = /^[0-9a-f]{4}$/i;
TokenStream.prototype.unescape = function(v) {
  var index2 = v.indexOf("\\");
  if (index2 < 0) {
    return v;
  }
  var buffer = v.substring(0, index2);
  while (index2 >= 0) {
    var c = v.charAt(++index2);
    switch (c) {
      case "'":
        buffer += "'";
        break;
      case '"':
        buffer += '"';
        break;
      case "\\":
        buffer += "\\";
        break;
      case "/":
        buffer += "/";
        break;
      case "b":
        buffer += "\b";
        break;
      case "f":
        buffer += "\f";
        break;
      case "n":
        buffer += "\n";
        break;
      case "r":
        buffer += "\r";
        break;
      case "t":
        buffer += "	";
        break;
      case "u":
        var codePoint = v.substring(index2 + 1, index2 + 5);
        if (!codePointPattern.test(codePoint)) {
          this.parseError("Illegal escape sequence: \\u" + codePoint);
        }
        buffer += String.fromCharCode(parseInt(codePoint, 16));
        index2 += 4;
        break;
      default:
        throw this.parseError('Illegal escape sequence: "\\' + c + '"');
    }
    ++index2;
    var backslash = v.indexOf("\\", index2);
    buffer += v.substring(index2, backslash < 0 ? v.length : backslash);
    index2 = backslash;
  }
  return buffer;
};
TokenStream.prototype.isComment = function() {
  var c = this.expression.charAt(this.pos);
  if (c === "/" && this.expression.charAt(this.pos + 1) === "*") {
    this.pos = this.expression.indexOf("*/", this.pos) + 2;
    if (this.pos === 1) {
      this.pos = this.expression.length;
    }
    return true;
  }
  return false;
};
TokenStream.prototype.isRadixInteger = function() {
  var pos = this.pos;
  if (pos >= this.expression.length - 2 || this.expression.charAt(pos) !== "0") {
    return false;
  }
  ++pos;
  var radix;
  var validDigit;
  if (this.expression.charAt(pos) === "x") {
    radix = 16;
    validDigit = /^[0-9a-f]$/i;
    ++pos;
  } else if (this.expression.charAt(pos) === "b") {
    radix = 2;
    validDigit = /^[01]$/i;
    ++pos;
  } else {
    return false;
  }
  var valid = false;
  var startPos = pos;
  while (pos < this.expression.length) {
    var c = this.expression.charAt(pos);
    if (validDigit.test(c)) {
      pos++;
      valid = true;
    } else {
      break;
    }
  }
  if (valid) {
    this.current = this.newToken(TNUMBER, parseInt(this.expression.substring(startPos, pos), radix));
    this.pos = pos;
  }
  return valid;
};
TokenStream.prototype.isNumber = function() {
  var valid = false;
  var pos = this.pos;
  var startPos = pos;
  var resetPos = pos;
  var foundDot = false;
  var foundDigits = false;
  var c;
  while (pos < this.expression.length) {
    c = this.expression.charAt(pos);
    if (c >= "0" && c <= "9" || !foundDot && c === ".") {
      if (c === ".") {
        foundDot = true;
      } else {
        foundDigits = true;
      }
      pos++;
      valid = foundDigits;
    } else {
      break;
    }
  }
  if (valid) {
    resetPos = pos;
  }
  if (c === "e" || c === "E") {
    pos++;
    var acceptSign = true;
    var validExponent = false;
    while (pos < this.expression.length) {
      c = this.expression.charAt(pos);
      if (acceptSign && (c === "+" || c === "-")) {
        acceptSign = false;
      } else if (c >= "0" && c <= "9") {
        validExponent = true;
        acceptSign = false;
      } else {
        break;
      }
      pos++;
    }
    if (!validExponent) {
      pos = resetPos;
    }
  }
  if (valid) {
    this.current = this.newToken(TNUMBER, parseFloat(this.expression.substring(startPos, pos)));
    this.pos = pos;
  } else {
    this.pos = resetPos;
  }
  return valid;
};
TokenStream.prototype.isOperator = function() {
  var startPos = this.pos;
  var c = this.expression.charAt(this.pos);
  if (c === "+" || c === "-" || c === "*" || c === "/" || c === "%" || c === "^" || c === "?" || c === ":" || c === ".") {
    this.current = this.newToken(TOP, c);
  } else if (c === "" || c === "") {
    this.current = this.newToken(TOP, "*");
  } else if (c === ">") {
    if (this.expression.charAt(this.pos + 1) === "=") {
      this.current = this.newToken(TOP, ">=");
      this.pos++;
    } else {
      this.current = this.newToken(TOP, ">");
    }
  } else if (c === "<") {
    if (this.expression.charAt(this.pos + 1) === "=") {
      this.current = this.newToken(TOP, "<=");
      this.pos++;
    } else {
      this.current = this.newToken(TOP, "<");
    }
  } else if (c === "|") {
    if (this.expression.charAt(this.pos + 1) === "|") {
      this.current = this.newToken(TOP, "||");
      this.pos++;
    } else {
      return false;
    }
  } else if (c === "=") {
    if (this.expression.charAt(this.pos + 1) === "=") {
      this.current = this.newToken(TOP, "==");
      this.pos++;
    } else {
      this.current = this.newToken(TOP, c);
    }
  } else if (c === "!") {
    if (this.expression.charAt(this.pos + 1) === "=") {
      this.current = this.newToken(TOP, "!=");
      this.pos++;
    } else {
      this.current = this.newToken(TOP, c);
    }
  } else {
    return false;
  }
  this.pos++;
  if (this.isOperatorEnabled(this.current.value)) {
    return true;
  } else {
    this.pos = startPos;
    return false;
  }
};
TokenStream.prototype.isOperatorEnabled = function(op) {
  return this.parser.isOperatorEnabled(op);
};
TokenStream.prototype.getCoordinates = function() {
  var line = 0;
  var column;
  var newline = -1;
  do {
    line++;
    column = this.pos - newline;
    newline = this.expression.indexOf("\n", newline + 1);
  } while (newline >= 0 && newline < this.pos);
  return {
    line,
    column
  };
};
TokenStream.prototype.parseError = function(msg) {
  var coords = this.getCoordinates();
  throw new Error("parse error [" + coords.line + ":" + coords.column + "]: " + msg);
};
function ParserState(parser2, tokenStream, options) {
  this.parser = parser2;
  this.tokens = tokenStream;
  this.current = null;
  this.nextToken = null;
  this.next();
  this.savedCurrent = null;
  this.savedNextToken = null;
  this.allowMemberAccess = options.allowMemberAccess !== false;
}
ParserState.prototype.next = function() {
  this.current = this.nextToken;
  return this.nextToken = this.tokens.next();
};
ParserState.prototype.tokenMatches = function(token, value) {
  if (typeof value === "undefined") {
    return true;
  } else if (Array.isArray(value)) {
    return contains(value, token.value);
  } else if (typeof value === "function") {
    return value(token);
  } else {
    return token.value === value;
  }
};
ParserState.prototype.save = function() {
  this.savedCurrent = this.current;
  this.savedNextToken = this.nextToken;
  this.tokens.save();
};
ParserState.prototype.restore = function() {
  this.tokens.restore();
  this.current = this.savedCurrent;
  this.nextToken = this.savedNextToken;
};
ParserState.prototype.accept = function(type2, value) {
  if (this.nextToken.type === type2 && this.tokenMatches(this.nextToken, value)) {
    this.next();
    return true;
  }
  return false;
};
ParserState.prototype.expect = function(type2, value) {
  if (!this.accept(type2, value)) {
    var coords = this.tokens.getCoordinates();
    throw new Error("parse error [" + coords.line + ":" + coords.column + "]: Expected " + (value || type2));
  }
};
ParserState.prototype.parseAtom = function(instr) {
  var unaryOps = this.tokens.unaryOps;
  function isPrefixOperator(token) {
    return token.value in unaryOps;
  }
  if (this.accept(TNAME) || this.accept(TOP, isPrefixOperator)) {
    instr.push(new Instruction(IVAR, this.current.value));
  } else if (this.accept(TNUMBER)) {
    instr.push(new Instruction(INUMBER, this.current.value));
  } else if (this.accept(TSTRING)) {
    instr.push(new Instruction(INUMBER, this.current.value));
  } else if (this.accept(TPAREN, "(")) {
    this.parseExpression(instr);
    this.expect(TPAREN, ")");
  } else if (this.accept(TBRACKET, "[")) {
    if (this.accept(TBRACKET, "]")) {
      instr.push(new Instruction(IARRAY, 0));
    } else {
      var argCount = this.parseArrayList(instr);
      instr.push(new Instruction(IARRAY, argCount));
    }
  } else {
    throw new Error("unexpected " + this.nextToken);
  }
};
ParserState.prototype.parseExpression = function(instr) {
  var exprInstr = [];
  if (this.parseUntilEndStatement(instr, exprInstr)) {
    return;
  }
  this.parseVariableAssignmentExpression(exprInstr);
  if (this.parseUntilEndStatement(instr, exprInstr)) {
    return;
  }
  this.pushExpression(instr, exprInstr);
};
ParserState.prototype.pushExpression = function(instr, exprInstr) {
  for (var i = 0, len = exprInstr.length; i < len; i++) {
    instr.push(exprInstr[i]);
  }
};
ParserState.prototype.parseUntilEndStatement = function(instr, exprInstr) {
  if (!this.accept(TSEMICOLON))
    return false;
  if (this.nextToken && this.nextToken.type !== TEOF && !(this.nextToken.type === TPAREN && this.nextToken.value === ")")) {
    exprInstr.push(new Instruction(IENDSTATEMENT));
  }
  if (this.nextToken.type !== TEOF) {
    this.parseExpression(exprInstr);
  }
  instr.push(new Instruction(IEXPR, exprInstr));
  return true;
};
ParserState.prototype.parseArrayList = function(instr) {
  var argCount = 0;
  while (!this.accept(TBRACKET, "]")) {
    this.parseExpression(instr);
    ++argCount;
    while (this.accept(TCOMMA)) {
      this.parseExpression(instr);
      ++argCount;
    }
  }
  return argCount;
};
ParserState.prototype.parseVariableAssignmentExpression = function(instr) {
  this.parseConditionalExpression(instr);
  while (this.accept(TOP, "=")) {
    var varName = instr.pop();
    var varValue = [];
    var lastInstrIndex = instr.length - 1;
    if (varName.type === IFUNCALL) {
      if (!this.tokens.isOperatorEnabled("()=")) {
        throw new Error("function definition is not permitted");
      }
      for (var i = 0, len = varName.value + 1; i < len; i++) {
        var index2 = lastInstrIndex - i;
        if (instr[index2].type === IVAR) {
          instr[index2] = new Instruction(IVARNAME, instr[index2].value);
        }
      }
      this.parseVariableAssignmentExpression(varValue);
      instr.push(new Instruction(IEXPR, varValue));
      instr.push(new Instruction(IFUNDEF, varName.value));
      continue;
    }
    if (varName.type !== IVAR && varName.type !== IMEMBER) {
      throw new Error("expected variable for assignment");
    }
    this.parseVariableAssignmentExpression(varValue);
    instr.push(new Instruction(IVARNAME, varName.value));
    instr.push(new Instruction(IEXPR, varValue));
    instr.push(binaryInstruction("="));
  }
};
ParserState.prototype.parseConditionalExpression = function(instr) {
  this.parseOrExpression(instr);
  while (this.accept(TOP, "?")) {
    var trueBranch = [];
    var falseBranch = [];
    this.parseConditionalExpression(trueBranch);
    this.expect(TOP, ":");
    this.parseConditionalExpression(falseBranch);
    instr.push(new Instruction(IEXPR, trueBranch));
    instr.push(new Instruction(IEXPR, falseBranch));
    instr.push(ternaryInstruction("?"));
  }
};
ParserState.prototype.parseOrExpression = function(instr) {
  this.parseAndExpression(instr);
  while (this.accept(TOP, "or")) {
    var falseBranch = [];
    this.parseAndExpression(falseBranch);
    instr.push(new Instruction(IEXPR, falseBranch));
    instr.push(binaryInstruction("or"));
  }
};
ParserState.prototype.parseAndExpression = function(instr) {
  this.parseComparison(instr);
  while (this.accept(TOP, "and")) {
    var trueBranch = [];
    this.parseComparison(trueBranch);
    instr.push(new Instruction(IEXPR, trueBranch));
    instr.push(binaryInstruction("and"));
  }
};
var COMPARISON_OPERATORS = ["==", "!=", "<", "<=", ">=", ">", "in"];
ParserState.prototype.parseComparison = function(instr) {
  this.parseAddSub(instr);
  while (this.accept(TOP, COMPARISON_OPERATORS)) {
    var op = this.current;
    this.parseAddSub(instr);
    instr.push(binaryInstruction(op.value));
  }
};
var ADD_SUB_OPERATORS = ["+", "-", "||"];
ParserState.prototype.parseAddSub = function(instr) {
  this.parseTerm(instr);
  while (this.accept(TOP, ADD_SUB_OPERATORS)) {
    var op = this.current;
    this.parseTerm(instr);
    instr.push(binaryInstruction(op.value));
  }
};
var TERM_OPERATORS = ["*", "/", "%"];
ParserState.prototype.parseTerm = function(instr) {
  this.parseFactor(instr);
  while (this.accept(TOP, TERM_OPERATORS)) {
    var op = this.current;
    this.parseFactor(instr);
    instr.push(binaryInstruction(op.value));
  }
};
ParserState.prototype.parseFactor = function(instr) {
  var unaryOps = this.tokens.unaryOps;
  function isPrefixOperator(token) {
    return token.value in unaryOps;
  }
  this.save();
  if (this.accept(TOP, isPrefixOperator)) {
    if (this.current.value !== "-" && this.current.value !== "+") {
      if (this.nextToken.type === TPAREN && this.nextToken.value === "(") {
        this.restore();
        this.parseExponential(instr);
        return;
      } else if (this.nextToken.type === TSEMICOLON || this.nextToken.type === TCOMMA || this.nextToken.type === TEOF || this.nextToken.type === TPAREN && this.nextToken.value === ")") {
        this.restore();
        this.parseAtom(instr);
        return;
      }
    }
    var op = this.current;
    this.parseFactor(instr);
    instr.push(unaryInstruction(op.value));
  } else {
    this.parseExponential(instr);
  }
};
ParserState.prototype.parseExponential = function(instr) {
  this.parsePostfixExpression(instr);
  while (this.accept(TOP, "^")) {
    this.parseFactor(instr);
    instr.push(binaryInstruction("^"));
  }
};
ParserState.prototype.parsePostfixExpression = function(instr) {
  this.parseFunctionCall(instr);
  while (this.accept(TOP, "!")) {
    instr.push(unaryInstruction("!"));
  }
};
ParserState.prototype.parseFunctionCall = function(instr) {
  var unaryOps = this.tokens.unaryOps;
  function isPrefixOperator(token) {
    return token.value in unaryOps;
  }
  if (this.accept(TOP, isPrefixOperator)) {
    var op = this.current;
    this.parseAtom(instr);
    instr.push(unaryInstruction(op.value));
  } else {
    this.parseMemberExpression(instr);
    while (this.accept(TPAREN, "(")) {
      if (this.accept(TPAREN, ")")) {
        instr.push(new Instruction(IFUNCALL, 0));
      } else {
        var argCount = this.parseArgumentList(instr);
        instr.push(new Instruction(IFUNCALL, argCount));
      }
    }
  }
};
ParserState.prototype.parseArgumentList = function(instr) {
  var argCount = 0;
  while (!this.accept(TPAREN, ")")) {
    this.parseExpression(instr);
    ++argCount;
    while (this.accept(TCOMMA)) {
      this.parseExpression(instr);
      ++argCount;
    }
  }
  return argCount;
};
ParserState.prototype.parseMemberExpression = function(instr) {
  this.parseAtom(instr);
  while (this.accept(TOP, ".") || this.accept(TBRACKET, "[")) {
    var op = this.current;
    if (op.value === ".") {
      if (!this.allowMemberAccess) {
        throw new Error('unexpected ".", member access is not permitted');
      }
      this.expect(TNAME);
      instr.push(new Instruction(IMEMBER, this.current.value));
    } else if (op.value === "[") {
      if (!this.tokens.isOperatorEnabled("[")) {
        throw new Error('unexpected "[]", arrays are disabled');
      }
      this.parseExpression(instr);
      this.expect(TBRACKET, "]");
      instr.push(binaryInstruction("["));
    } else {
      throw new Error("unexpected symbol: " + op.value);
    }
  }
};
function add(a, b) {
  return Number(a) + Number(b);
}
function sub(a, b) {
  return a - b;
}
function mul(a, b) {
  return a * b;
}
function div(a, b) {
  return a / b;
}
function mod(a, b) {
  return a % b;
}
function concat(a, b) {
  if (Array.isArray(a) && Array.isArray(b)) {
    return a.concat(b);
  }
  return "" + a + b;
}
function equal$2(a, b) {
  return a === b;
}
function notEqual(a, b) {
  return a !== b;
}
function greaterThan(a, b) {
  return a > b;
}
function lessThan(a, b) {
  return a < b;
}
function greaterThanEqual(a, b) {
  return a >= b;
}
function lessThanEqual(a, b) {
  return a <= b;
}
function andOperator(a, b) {
  return Boolean(a && b);
}
function orOperator(a, b) {
  return Boolean(a || b);
}
function inOperator(a, b) {
  return contains(b, a);
}
function sinh(a) {
  return (Math.exp(a) - Math.exp(-a)) / 2;
}
function cosh(a) {
  return (Math.exp(a) + Math.exp(-a)) / 2;
}
function tanh(a) {
  if (a === Infinity)
    return 1;
  if (a === -Infinity)
    return -1;
  return (Math.exp(a) - Math.exp(-a)) / (Math.exp(a) + Math.exp(-a));
}
function asinh(a) {
  if (a === -Infinity)
    return a;
  return Math.log(a + Math.sqrt(a * a + 1));
}
function acosh(a) {
  return Math.log(a + Math.sqrt(a * a - 1));
}
function atanh(a) {
  return Math.log((1 + a) / (1 - a)) / 2;
}
function log10(a) {
  return Math.log(a) * Math.LOG10E;
}
function neg(a) {
  return -a;
}
function not(a) {
  return !a;
}
function trunc(a) {
  return a < 0 ? Math.ceil(a) : Math.floor(a);
}
function random$1(a) {
  return Math.random() * (a || 1);
}
function factorial(a) {
  return gamma(a + 1);
}
function isInteger(value) {
  return isFinite(value) && value === Math.round(value);
}
var GAMMA_G = 4.7421875;
var GAMMA_P = [
  0.9999999999999971,
  57.15623566586292,
  -59.59796035547549,
  14.136097974741746,
  -0.4919138160976202,
  3399464998481189e-20,
  4652362892704858e-20,
  -9837447530487956e-20,
  1580887032249125e-19,
  -21026444172410488e-20,
  21743961811521265e-20,
  -1643181065367639e-19,
  8441822398385275e-20,
  -26190838401581408e-21,
  36899182659531625e-22
];
function gamma(n) {
  var t, x;
  if (isInteger(n)) {
    if (n <= 0) {
      return isFinite(n) ? Infinity : NaN;
    }
    if (n > 171) {
      return Infinity;
    }
    var value = n - 2;
    var res = n - 1;
    while (value > 1) {
      res *= value;
      value--;
    }
    if (res === 0) {
      res = 1;
    }
    return res;
  }
  if (n < 0.5) {
    return Math.PI / (Math.sin(Math.PI * n) * gamma(1 - n));
  }
  if (n >= 171.35) {
    return Infinity;
  }
  if (n > 85) {
    var twoN = n * n;
    var threeN = twoN * n;
    var fourN = threeN * n;
    var fiveN = fourN * n;
    return Math.sqrt(2 * Math.PI / n) * Math.pow(n / Math.E, n) * (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) - 571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) + 5246819 / (75246796800 * fiveN * n));
  }
  --n;
  x = GAMMA_P[0];
  for (var i = 1; i < GAMMA_P.length; ++i) {
    x += GAMMA_P[i] / (n + i);
  }
  t = n + GAMMA_G + 0.5;
  return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
}
function stringOrArrayLength(s) {
  if (Array.isArray(s)) {
    return s.length;
  }
  return String(s).length;
}
function hypot() {
  var sum = 0;
  var larg = 0;
  for (var i = 0; i < arguments.length; i++) {
    var arg = Math.abs(arguments[i]);
    var div2;
    if (larg < arg) {
      div2 = larg / arg;
      sum = sum * div2 * div2 + 1;
      larg = arg;
    } else if (arg > 0) {
      div2 = arg / larg;
      sum += div2 * div2;
    } else {
      sum += arg;
    }
  }
  return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
}
function condition(cond, yep, nope) {
  return cond ? yep : nope;
}
function roundTo(value, exp) {
  if (typeof exp === "undefined" || +exp === 0) {
    return Math.round(value);
  }
  value = +value;
  exp = -+exp;
  if (isNaN(value) || !(typeof exp === "number" && exp % 1 === 0)) {
    return NaN;
  }
  value = value.toString().split("e");
  value = Math.round(+(value[0] + "e" + (value[1] ? +value[1] - exp : -exp)));
  value = value.toString().split("e");
  return +(value[0] + "e" + (value[1] ? +value[1] + exp : exp));
}
function setVar(name, value, variables) {
  if (variables)
    variables[name] = value;
  return value;
}
function arrayIndex(array, index2) {
  return array[index2 | 0];
}
function max$1(array) {
  if (arguments.length === 1 && Array.isArray(array)) {
    return Math.max.apply(Math, array);
  } else {
    return Math.max.apply(Math, arguments);
  }
}
function min$1(array) {
  if (arguments.length === 1 && Array.isArray(array)) {
    return Math.min.apply(Math, array);
  } else {
    return Math.min.apply(Math, arguments);
  }
}
function arrayMap(f, a) {
  if (typeof f !== "function") {
    throw new Error("First argument to map is not a function");
  }
  if (!Array.isArray(a)) {
    throw new Error("Second argument to map is not an array");
  }
  return a.map(function(x, i) {
    return f(x, i);
  });
}
function arrayFold(f, init6, a) {
  if (typeof f !== "function") {
    throw new Error("First argument to fold is not a function");
  }
  if (!Array.isArray(a)) {
    throw new Error("Second argument to fold is not an array");
  }
  return a.reduce(function(acc, x, i) {
    return f(acc, x, i);
  }, init6);
}
function arrayFilter(f, a) {
  if (typeof f !== "function") {
    throw new Error("First argument to filter is not a function");
  }
  if (!Array.isArray(a)) {
    throw new Error("Second argument to filter is not an array");
  }
  return a.filter(function(x, i) {
    return f(x, i);
  });
}
function stringOrArrayIndexOf(target, s) {
  if (!(Array.isArray(s) || typeof s === "string")) {
    throw new Error("Second argument to indexOf is not a string or array");
  }
  return s.indexOf(target);
}
function arrayJoin(sep, a) {
  if (!Array.isArray(a)) {
    throw new Error("Second argument to join is not an array");
  }
  return a.join(sep);
}
function sign(x) {
  return (x > 0) - (x < 0) || +x;
}
var ONE_THIRD = 1 / 3;
function cbrt(x) {
  return x < 0 ? -Math.pow(-x, ONE_THIRD) : Math.pow(x, ONE_THIRD);
}
function expm1(x) {
  return Math.exp(x) - 1;
}
function log1p(x) {
  return Math.log(1 + x);
}
function log2(x) {
  return Math.log(x) / Math.LN2;
}
function Parser(options) {
  this.options = options || {};
  this.unaryOps = {
    sin: Math.sin,
    cos: Math.cos,
    tan: Math.tan,
    asin: Math.asin,
    acos: Math.acos,
    atan: Math.atan,
    sinh: Math.sinh || sinh,
    cosh: Math.cosh || cosh,
    tanh: Math.tanh || tanh,
    asinh: Math.asinh || asinh,
    acosh: Math.acosh || acosh,
    atanh: Math.atanh || atanh,
    sqrt: Math.sqrt,
    cbrt: Math.cbrt || cbrt,
    log: Math.log,
    log2: Math.log2 || log2,
    ln: Math.log,
    lg: Math.log10 || log10,
    log10: Math.log10 || log10,
    expm1: Math.expm1 || expm1,
    log1p: Math.log1p || log1p,
    abs: Math.abs,
    ceil: Math.ceil,
    floor: Math.floor,
    round: Math.round,
    trunc: Math.trunc || trunc,
    "-": neg,
    "+": Number,
    exp: Math.exp,
    not,
    length: stringOrArrayLength,
    "!": factorial,
    sign: Math.sign || sign
  };
  this.binaryOps = {
    "+": add,
    "-": sub,
    "*": mul,
    "/": div,
    "%": mod,
    "^": Math.pow,
    "||": concat,
    "==": equal$2,
    "!=": notEqual,
    ">": greaterThan,
    "<": lessThan,
    ">=": greaterThanEqual,
    "<=": lessThanEqual,
    and: andOperator,
    or: orOperator,
    "in": inOperator,
    "=": setVar,
    "[": arrayIndex
  };
  this.ternaryOps = {
    "?": condition
  };
  this.functions = {
    random: random$1,
    fac: factorial,
    min: min$1,
    max: max$1,
    hypot: Math.hypot || hypot,
    pyt: Math.hypot || hypot,
    // backward compat
    pow: Math.pow,
    atan2: Math.atan2,
    "if": condition,
    gamma,
    roundTo,
    map: arrayMap,
    fold: arrayFold,
    filter: arrayFilter,
    indexOf: stringOrArrayIndexOf,
    join: arrayJoin
  };
  this.consts = {
    E: Math.E,
    PI: Math.PI,
    "true": true,
    "false": false
  };
}
Parser.prototype.parse = function(expr) {
  var instr = [];
  var parserState = new ParserState(
    this,
    new TokenStream(this, expr),
    { allowMemberAccess: this.options.allowMemberAccess }
  );
  parserState.parseExpression(instr);
  parserState.expect(TEOF, "EOF");
  return new Expression(instr, this);
};
Parser.prototype.evaluate = function(expr, variables) {
  return this.parse(expr).evaluate(variables);
};
var sharedParser = new Parser();
Parser.parse = function(expr) {
  return sharedParser.parse(expr);
};
Parser.evaluate = function(expr, variables) {
  return sharedParser.parse(expr).evaluate(variables);
};
var optionNameMap = {
  "+": "add",
  "-": "subtract",
  "*": "multiply",
  "/": "divide",
  "%": "remainder",
  "^": "power",
  "!": "factorial",
  "<": "comparison",
  ">": "comparison",
  "<=": "comparison",
  ">=": "comparison",
  "==": "comparison",
  "!=": "comparison",
  "||": "concatenate",
  "and": "logical",
  "or": "logical",
  "not": "logical",
  "?": "conditional",
  ":": "conditional",
  "=": "assignment",
  "[": "array",
  "()=": "fndef"
};
function getOptionName(op) {
  return optionNameMap.hasOwnProperty(op) ? optionNameMap[op] : op;
}
Parser.prototype.isOperatorEnabled = function(op) {
  var optionName = getOptionName(op);
  var operators = this.options.operators || {};
  return !(optionName in operators) || !!operators[optionName];
};
/*!
 Based on ndef.parser, by Raphael Graf(r@undefined.ch)
 http://www.undefined.ch/mparser/index.html

 Ported to JavaScript and modified by Matthew Crumley (email@matthewcrumley.com, http://silentmatt.com/)

 You are free to use and modify this code in anyway you find useful. Please leave this comment in the code
 to acknowledge its original source. If you feel like it, I enjoy hearing about projects that use my code,
 but don't feel like you have to let me know or ask permission.
*/
var index = {
  Parser,
  Expression
};
class AnalyzerOptions {
  constructor(heuristic_replimit) {
    this.heuristic_replimit = heuristic_replimit;
  }
}
class Analyzer {
  constructor(analyzerOptions) {
    this.options = analyzerOptions;
  }
  // Subclasser must implement
  // Return boolean
  isVulnerable(regExp) {
    return false;
  }
  // Subclass must implement
  // Returns an AttackString or null
  genAttackString(regExp) {
    return null;
  }
}
var analyzer$2 = function(re, replimit) {
  let myRegExp = null;
  let ast = null;
  try {
    if (re instanceof RegExp) {
      myRegExp = re;
    } else if (typeof re === "string") {
      myRegExp = new RegExp(re);
    } else {
      myRegExp = new RegExp(String(re));
    }
    ast = regexpTree.parse(myRegExp);
  } catch (err) {
    return false;
  }
  let currentStarHeight = 0;
  let maxObservedStarHeight = 0;
  let repetitionCount = 0;
  regexpTree.traverse(ast, {
    Repetition: {
      pre({ node }) {
        repetitionCount++;
        currentStarHeight++;
        if (maxObservedStarHeight < currentStarHeight) {
          maxObservedStarHeight = currentStarHeight;
        }
      },
      post({ node }) {
        currentStarHeight--;
      }
    }
  });
  return maxObservedStarHeight <= 1 && repetitionCount <= replimit;
};
analyzer$2 = {
  "AnalyzerOptions": AnalyzerOptions,
  "Analyzer": Analyzer
};
var compatDotallSTransform = {
  // Whether `u` flag present. In which case we transform to
  // \u{10FFFF} instead of \uFFFF.
  _hasUFlag: false,
  // Only run this plugin if we have `s` flag.
  shouldRun: function shouldRun(ast) {
    var shouldRun4 = ast.flags.includes("s");
    if (!shouldRun4) {
      return false;
    }
    ast.flags = ast.flags.replace("s", "");
    this._hasUFlag = ast.flags.includes("u");
    return true;
  },
  Char: function Char(path) {
    var node = path.node;
    if (node.kind !== "meta" || node.value !== ".") {
      return;
    }
    var toValue2 = "\\uFFFF";
    var toSymbol = "";
    if (this._hasUFlag) {
      toValue2 = "\\u{10FFFF}";
      toSymbol = "";
    }
    path.replace({
      type: "CharacterClass",
      expressions: [{
        type: "ClassRange",
        from: {
          type: "Char",
          value: "\\0",
          kind: "decimal",
          symbol: "\0"
        },
        to: {
          type: "Char",
          value: toValue2,
          kind: "unicode",
          symbol: toSymbol
        }
      }]
    });
  }
};
var compatNamedCapturingGroupsTransform = {
  // To track the names of the groups, and return them
  // in the transform result state.
  //
  // A map from name to number: {foo: 2, bar: 4}
  _groupNames: {},
  /**
   * Initialises the trasnform.
   */
  init: function init() {
    this._groupNames = {};
  },
  /**
   * Returns extra state, which eventually is returned to
   */
  getExtra: function getExtra() {
    return this._groupNames;
  },
  Group: function Group(path) {
    var node = path.node;
    if (!node.name) {
      return;
    }
    this._groupNames[node.name] = node.number;
    delete node.name;
    delete node.nameRaw;
  },
  Backreference: function Backreference(path) {
    var node = path.node;
    if (node.kind !== "name") {
      return;
    }
    node.kind = "number";
    node.reference = node.number;
    delete node.referenceRaw;
  }
};
var compatXFlagTransform = {
  RegExp: function RegExp2(_ref) {
    var node = _ref.node;
    if (node.flags.includes("x")) {
      node.flags = node.flags.replace("x", "");
    }
  }
};
var transforms$1 = {
  // "dotAll" `s` flag
  dotAll: compatDotallSTransform,
  // Named capturing groups.
  namedCapturingGroups: compatNamedCapturingGroupsTransform,
  // `x` flag
  xFlag: compatXFlagTransform
};
function gen$1(node) {
  return node ? generator$3[node.type](node) : "";
}
var generator$3 = {
  RegExp: function RegExp3(node) {
    return "/" + gen$1(node.body) + "/" + node.flags;
  },
  Alternative: function Alternative(node) {
    return (node.expressions || []).map(gen$1).join("");
  },
  Disjunction: function Disjunction(node) {
    return gen$1(node.left) + "|" + gen$1(node.right);
  },
  Group: function Group2(node) {
    var expression = gen$1(node.expression);
    if (node.capturing) {
      if (node.name) {
        return "(?<" + (node.nameRaw || node.name) + ">" + expression + ")";
      }
      return "(" + expression + ")";
    }
    return "(?:" + expression + ")";
  },
  Backreference: function Backreference2(node) {
    switch (node.kind) {
      case "number":
        return "\\" + node.reference;
      case "name":
        return "\\k<" + (node.referenceRaw || node.reference) + ">";
      default:
        throw new TypeError("Unknown Backreference kind: " + node.kind);
    }
  },
  Assertion: function Assertion(node) {
    switch (node.kind) {
      case "^":
      case "$":
      case "\\b":
      case "\\B":
        return node.kind;
      case "Lookahead": {
        var assertion = gen$1(node.assertion);
        if (node.negative) {
          return "(?!" + assertion + ")";
        }
        return "(?=" + assertion + ")";
      }
      case "Lookbehind": {
        var _assertion = gen$1(node.assertion);
        if (node.negative) {
          return "(?<!" + _assertion + ")";
        }
        return "(?<=" + _assertion + ")";
      }
      default:
        throw new TypeError("Unknown Assertion kind: " + node.kind);
    }
  },
  CharacterClass: function CharacterClass(node) {
    var expressions = node.expressions.map(gen$1).join("");
    if (node.negative) {
      return "[^" + expressions + "]";
    }
    return "[" + expressions + "]";
  },
  ClassRange: function ClassRange(node) {
    return gen$1(node.from) + "-" + gen$1(node.to);
  },
  Repetition: function Repetition(node) {
    return "" + gen$1(node.expression) + gen$1(node.quantifier);
  },
  Quantifier: function Quantifier(node) {
    var quantifier = void 0;
    var greedy = node.greedy ? "" : "?";
    switch (node.kind) {
      case "+":
      case "?":
      case "*":
        quantifier = node.kind;
        break;
      case "Range":
        if (node.from === node.to) {
          quantifier = "{" + node.from + "}";
        } else if (!node.to) {
          quantifier = "{" + node.from + ",}";
        } else {
          quantifier = "{" + node.from + "," + node.to + "}";
        }
        break;
      default:
        throw new TypeError("Unknown Quantifier kind: " + node.kind);
    }
    return "" + quantifier + greedy;
  },
  Char: function Char2(node) {
    var value = node.value;
    switch (node.kind) {
      case "simple": {
        if (node.escaped) {
          return "\\" + value;
        }
        return value;
      }
      case "hex":
      case "unicode":
      case "oct":
      case "decimal":
      case "control":
      case "meta":
        return value;
      default:
        throw new TypeError("Unknown Char kind: " + node.kind);
    }
  },
  UnicodeProperty: function UnicodeProperty(node) {
    var escapeChar = node.negative ? "P" : "p";
    var namePart = void 0;
    if (!node.shorthand && !node.binary) {
      namePart = node.name + "=";
    } else {
      namePart = "";
    }
    return "\\" + escapeChar + "{" + namePart + node.value + "}";
  }
};
var generator_1 = {
  /**
   * Generates a regexp string from an AST.
   *
   * @param Object ast - an AST node
   */
  generate: gen$1
};
var NON_BINARY_PROP_NAMES_TO_ALIASES = {
  General_Category: "gc",
  Script: "sc",
  Script_Extensions: "scx"
};
var NON_BINARY_ALIASES_TO_PROP_NAMES = inverseMap(NON_BINARY_PROP_NAMES_TO_ALIASES);
var BINARY_PROP_NAMES_TO_ALIASES = {
  ASCII: "ASCII",
  ASCII_Hex_Digit: "AHex",
  Alphabetic: "Alpha",
  Any: "Any",
  Assigned: "Assigned",
  Bidi_Control: "Bidi_C",
  Bidi_Mirrored: "Bidi_M",
  Case_Ignorable: "CI",
  Cased: "Cased",
  Changes_When_Casefolded: "CWCF",
  Changes_When_Casemapped: "CWCM",
  Changes_When_Lowercased: "CWL",
  Changes_When_NFKC_Casefolded: "CWKCF",
  Changes_When_Titlecased: "CWT",
  Changes_When_Uppercased: "CWU",
  Dash: "Dash",
  Default_Ignorable_Code_Point: "DI",
  Deprecated: "Dep",
  Diacritic: "Dia",
  Emoji: "Emoji",
  Emoji_Component: "Emoji_Component",
  Emoji_Modifier: "Emoji_Modifier",
  Emoji_Modifier_Base: "Emoji_Modifier_Base",
  Emoji_Presentation: "Emoji_Presentation",
  Extended_Pictographic: "Extended_Pictographic",
  Extender: "Ext",
  Grapheme_Base: "Gr_Base",
  Grapheme_Extend: "Gr_Ext",
  Hex_Digit: "Hex",
  IDS_Binary_Operator: "IDSB",
  IDS_Trinary_Operator: "IDST",
  ID_Continue: "IDC",
  ID_Start: "IDS",
  Ideographic: "Ideo",
  Join_Control: "Join_C",
  Logical_Order_Exception: "LOE",
  Lowercase: "Lower",
  Math: "Math",
  Noncharacter_Code_Point: "NChar",
  Pattern_Syntax: "Pat_Syn",
  Pattern_White_Space: "Pat_WS",
  Quotation_Mark: "QMark",
  Radical: "Radical",
  Regional_Indicator: "RI",
  Sentence_Terminal: "STerm",
  Soft_Dotted: "SD",
  Terminal_Punctuation: "Term",
  Unified_Ideograph: "UIdeo",
  Uppercase: "Upper",
  Variation_Selector: "VS",
  White_Space: "space",
  XID_Continue: "XIDC",
  XID_Start: "XIDS"
};
var BINARY_ALIASES_TO_PROP_NAMES = inverseMap(BINARY_PROP_NAMES_TO_ALIASES);
var GENERAL_CATEGORY_VALUE_TO_ALIASES = {
  Cased_Letter: "LC",
  Close_Punctuation: "Pe",
  Connector_Punctuation: "Pc",
  Control: ["Cc", "cntrl"],
  Currency_Symbol: "Sc",
  Dash_Punctuation: "Pd",
  Decimal_Number: ["Nd", "digit"],
  Enclosing_Mark: "Me",
  Final_Punctuation: "Pf",
  Format: "Cf",
  Initial_Punctuation: "Pi",
  Letter: "L",
  Letter_Number: "Nl",
  Line_Separator: "Zl",
  Lowercase_Letter: "Ll",
  Mark: ["M", "Combining_Mark"],
  Math_Symbol: "Sm",
  Modifier_Letter: "Lm",
  Modifier_Symbol: "Sk",
  Nonspacing_Mark: "Mn",
  Number: "N",
  Open_Punctuation: "Ps",
  Other: "C",
  Other_Letter: "Lo",
  Other_Number: "No",
  Other_Punctuation: "Po",
  Other_Symbol: "So",
  Paragraph_Separator: "Zp",
  Private_Use: "Co",
  Punctuation: ["P", "punct"],
  Separator: "Z",
  Space_Separator: "Zs",
  Spacing_Mark: "Mc",
  Surrogate: "Cs",
  Symbol: "S",
  Titlecase_Letter: "Lt",
  Unassigned: "Cn",
  Uppercase_Letter: "Lu"
};
var GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES = inverseMap(GENERAL_CATEGORY_VALUE_TO_ALIASES);
var SCRIPT_VALUE_TO_ALIASES = {
  Adlam: "Adlm",
  Ahom: "Ahom",
  Anatolian_Hieroglyphs: "Hluw",
  Arabic: "Arab",
  Armenian: "Armn",
  Avestan: "Avst",
  Balinese: "Bali",
  Bamum: "Bamu",
  Bassa_Vah: "Bass",
  Batak: "Batk",
  Bengali: "Beng",
  Bhaiksuki: "Bhks",
  Bopomofo: "Bopo",
  Brahmi: "Brah",
  Braille: "Brai",
  Buginese: "Bugi",
  Buhid: "Buhd",
  Canadian_Aboriginal: "Cans",
  Carian: "Cari",
  Caucasian_Albanian: "Aghb",
  Chakma: "Cakm",
  Cham: "Cham",
  Cherokee: "Cher",
  Common: "Zyyy",
  Coptic: ["Copt", "Qaac"],
  Cuneiform: "Xsux",
  Cypriot: "Cprt",
  Cyrillic: "Cyrl",
  Deseret: "Dsrt",
  Devanagari: "Deva",
  Dogra: "Dogr",
  Duployan: "Dupl",
  Egyptian_Hieroglyphs: "Egyp",
  Elbasan: "Elba",
  Ethiopic: "Ethi",
  Georgian: "Geor",
  Glagolitic: "Glag",
  Gothic: "Goth",
  Grantha: "Gran",
  Greek: "Grek",
  Gujarati: "Gujr",
  Gunjala_Gondi: "Gong",
  Gurmukhi: "Guru",
  Han: "Hani",
  Hangul: "Hang",
  Hanifi_Rohingya: "Rohg",
  Hanunoo: "Hano",
  Hatran: "Hatr",
  Hebrew: "Hebr",
  Hiragana: "Hira",
  Imperial_Aramaic: "Armi",
  Inherited: ["Zinh", "Qaai"],
  Inscriptional_Pahlavi: "Phli",
  Inscriptional_Parthian: "Prti",
  Javanese: "Java",
  Kaithi: "Kthi",
  Kannada: "Knda",
  Katakana: "Kana",
  Kayah_Li: "Kali",
  Kharoshthi: "Khar",
  Khmer: "Khmr",
  Khojki: "Khoj",
  Khudawadi: "Sind",
  Lao: "Laoo",
  Latin: "Latn",
  Lepcha: "Lepc",
  Limbu: "Limb",
  Linear_A: "Lina",
  Linear_B: "Linb",
  Lisu: "Lisu",
  Lycian: "Lyci",
  Lydian: "Lydi",
  Mahajani: "Mahj",
  Makasar: "Maka",
  Malayalam: "Mlym",
  Mandaic: "Mand",
  Manichaean: "Mani",
  Marchen: "Marc",
  Medefaidrin: "Medf",
  Masaram_Gondi: "Gonm",
  Meetei_Mayek: "Mtei",
  Mende_Kikakui: "Mend",
  Meroitic_Cursive: "Merc",
  Meroitic_Hieroglyphs: "Mero",
  Miao: "Plrd",
  Modi: "Modi",
  Mongolian: "Mong",
  Mro: "Mroo",
  Multani: "Mult",
  Myanmar: "Mymr",
  Nabataean: "Nbat",
  New_Tai_Lue: "Talu",
  Newa: "Newa",
  Nko: "Nkoo",
  Nushu: "Nshu",
  Ogham: "Ogam",
  Ol_Chiki: "Olck",
  Old_Hungarian: "Hung",
  Old_Italic: "Ital",
  Old_North_Arabian: "Narb",
  Old_Permic: "Perm",
  Old_Persian: "Xpeo",
  Old_Sogdian: "Sogo",
  Old_South_Arabian: "Sarb",
  Old_Turkic: "Orkh",
  Oriya: "Orya",
  Osage: "Osge",
  Osmanya: "Osma",
  Pahawh_Hmong: "Hmng",
  Palmyrene: "Palm",
  Pau_Cin_Hau: "Pauc",
  Phags_Pa: "Phag",
  Phoenician: "Phnx",
  Psalter_Pahlavi: "Phlp",
  Rejang: "Rjng",
  Runic: "Runr",
  Samaritan: "Samr",
  Saurashtra: "Saur",
  Sharada: "Shrd",
  Shavian: "Shaw",
  Siddham: "Sidd",
  SignWriting: "Sgnw",
  Sinhala: "Sinh",
  Sogdian: "Sogd",
  Sora_Sompeng: "Sora",
  Soyombo: "Soyo",
  Sundanese: "Sund",
  Syloti_Nagri: "Sylo",
  Syriac: "Syrc",
  Tagalog: "Tglg",
  Tagbanwa: "Tagb",
  Tai_Le: "Tale",
  Tai_Tham: "Lana",
  Tai_Viet: "Tavt",
  Takri: "Takr",
  Tamil: "Taml",
  Tangut: "Tang",
  Telugu: "Telu",
  Thaana: "Thaa",
  Thai: "Thai",
  Tibetan: "Tibt",
  Tifinagh: "Tfng",
  Tirhuta: "Tirh",
  Ugaritic: "Ugar",
  Vai: "Vaii",
  Warang_Citi: "Wara",
  Yi: "Yiii",
  Zanabazar_Square: "Zanb"
};
var SCRIPT_VALUE_ALIASES_TO_VALUE = inverseMap(SCRIPT_VALUE_TO_ALIASES);
function inverseMap(data) {
  var inverse2 = {};
  for (var name in data) {
    if (!data.hasOwnProperty(name)) {
      continue;
    }
    var value = data[name];
    if (Array.isArray(value)) {
      for (var i = 0; i < value.length; i++) {
        inverse2[value[i]] = name;
      }
    } else {
      inverse2[value] = name;
    }
  }
  return inverse2;
}
function isValidName(name) {
  return NON_BINARY_PROP_NAMES_TO_ALIASES.hasOwnProperty(name) || NON_BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name) || BINARY_PROP_NAMES_TO_ALIASES.hasOwnProperty(name) || BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name);
}
function isValidValue(name, value) {
  if (isGeneralCategoryName(name)) {
    return isGeneralCategoryValue(value);
  }
  if (isScriptCategoryName(name)) {
    return isScriptCategoryValue(value);
  }
  return false;
}
function isAlias(name) {
  return NON_BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name) || BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name);
}
function isGeneralCategoryName(name) {
  return name === "General_Category" || name == "gc";
}
function isScriptCategoryName(name) {
  return name === "Script" || name === "Script_Extensions" || name === "sc" || name === "scx";
}
function isGeneralCategoryValue(value) {
  return GENERAL_CATEGORY_VALUE_TO_ALIASES.hasOwnProperty(value) || GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES.hasOwnProperty(value);
}
function isScriptCategoryValue(value) {
  return SCRIPT_VALUE_TO_ALIASES.hasOwnProperty(value) || SCRIPT_VALUE_ALIASES_TO_VALUE.hasOwnProperty(value);
}
function isBinaryPropertyName(name) {
  return BINARY_PROP_NAMES_TO_ALIASES.hasOwnProperty(name) || BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name);
}
function getCanonicalName(name) {
  if (NON_BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name)) {
    return NON_BINARY_ALIASES_TO_PROP_NAMES[name];
  }
  if (BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name)) {
    return BINARY_ALIASES_TO_PROP_NAMES[name];
  }
  return null;
}
function getCanonicalValue(value) {
  if (GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES.hasOwnProperty(value)) {
    return GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES[value];
  }
  if (SCRIPT_VALUE_ALIASES_TO_VALUE.hasOwnProperty(value)) {
    return SCRIPT_VALUE_ALIASES_TO_VALUE[value];
  }
  if (BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(value)) {
    return BINARY_ALIASES_TO_PROP_NAMES[value];
  }
  return null;
}
var parserUnicodeProperties = {
  isAlias,
  isValidName,
  isValidValue,
  isGeneralCategoryValue,
  isScriptCategoryValue,
  isBinaryPropertyName,
  getCanonicalName,
  getCanonicalValue,
  NON_BINARY_PROP_NAMES_TO_ALIASES,
  NON_BINARY_ALIASES_TO_PROP_NAMES,
  BINARY_PROP_NAMES_TO_ALIASES,
  BINARY_ALIASES_TO_PROP_NAMES,
  GENERAL_CATEGORY_VALUE_TO_ALIASES,
  GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES,
  SCRIPT_VALUE_TO_ALIASES,
  SCRIPT_VALUE_ALIASES_TO_VALUE
};
var _slicedToArray$2 = /* @__PURE__ */ function() {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"])
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  return function(arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
function _toConsumableArray$8(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
var yytext = void 0;
var yy = {};
var __ = void 0;
var __loc = void 0;
function yyloc(start, end) {
  if (!yy.options.captureLocations) {
    return null;
  }
  if (!start || !end) {
    return start || end;
  }
  return {
    startOffset: start.startOffset,
    endOffset: end.endOffset,
    startLine: start.startLine,
    endLine: end.endLine,
    startColumn: start.startColumn,
    endColumn: end.endColumn
  };
}
var EOF$1 = "$";
var productions = [[-1, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = _1;
}], [0, 4, function(_1, _2, _3, _4, _1loc, _2loc, _3loc, _4loc) {
  __loc = yyloc(_1loc, _4loc);
  __ = Node({
    type: "RegExp",
    body: _2,
    flags: checkFlags(_4)
  }, loc(_1loc, _4loc || _3loc));
}], [1, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = _1;
}], [1, 0, function() {
  __loc = null;
  __ = "";
}], [2, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = _1;
}], [2, 2, function(_1, _2, _1loc, _2loc) {
  __loc = yyloc(_1loc, _2loc);
  __ = _1 + _2;
}], [3, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = _1;
}], [4, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = _1;
}], [4, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  var _loc = null;
  if (_2loc) {
    _loc = loc(_1loc || _2loc, _3loc || _2loc);
  }
  __ = Node({
    type: "Disjunction",
    left: _1,
    right: _3
  }, _loc);
}], [5, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  if (_1.length === 0) {
    __ = null;
    return;
  }
  if (_1.length === 1) {
    __ = Node(_1[0], __loc);
  } else {
    __ = Node({
      type: "Alternative",
      expressions: _1
    }, __loc);
  }
}], [6, 0, function() {
  __loc = null;
  __ = [];
}], [6, 2, function(_1, _2, _1loc, _2loc) {
  __loc = yyloc(_1loc, _2loc);
  __ = _1.concat(_2);
}], [7, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = Node(Object.assign({ type: "Assertion" }, _1), __loc);
}], [7, 2, function(_1, _2, _1loc, _2loc) {
  __loc = yyloc(_1loc, _2loc);
  __ = _1;
  if (_2) {
    __ = Node({
      type: "Repetition",
      expression: _1,
      quantifier: _2
    }, __loc);
  }
}], [8, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = { kind: "^" };
}], [8, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = { kind: "$" };
}], [8, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = { kind: "\\b" };
}], [8, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = { kind: "\\B" };
}], [8, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  __ = {
    kind: "Lookahead",
    assertion: _2
  };
}], [8, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  __ = {
    kind: "Lookahead",
    negative: true,
    assertion: _2
  };
}], [8, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  __ = {
    kind: "Lookbehind",
    assertion: _2
  };
}], [8, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  __ = {
    kind: "Lookbehind",
    negative: true,
    assertion: _2
  };
}], [9, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = _1;
}], [9, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = _1;
}], [9, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = _1;
}], [10, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = Char3(_1, "simple", __loc);
}], [10, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = Char3(_1.slice(1), "simple", __loc);
  __.escaped = true;
}], [10, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = Char3(_1, "unicode", __loc);
  __.isSurrogatePair = true;
}], [10, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = Char3(_1, "unicode", __loc);
}], [10, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = UnicodeProperty2(_1, __loc);
}], [10, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = Char3(_1, "control", __loc);
}], [10, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = Char3(_1, "hex", __loc);
}], [10, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = Char3(_1, "oct", __loc);
}], [10, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = GroupRefOrDecChar(_1, __loc);
}], [10, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = Char3(_1, "meta", __loc);
}], [10, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = Char3(_1, "meta", __loc);
}], [10, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = NamedGroupRefOrChars(_1, _1loc);
}], [11, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = _1;
}], [11, 0], [12, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = _1;
}], [12, 2, function(_1, _2, _1loc, _2loc) {
  __loc = yyloc(_1loc, _2loc);
  _1.greedy = false;
  __ = _1;
}], [13, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = Node({
    type: "Quantifier",
    kind: _1,
    greedy: true
  }, __loc);
}], [13, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = Node({
    type: "Quantifier",
    kind: _1,
    greedy: true
  }, __loc);
}], [13, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = Node({
    type: "Quantifier",
    kind: _1,
    greedy: true
  }, __loc);
}], [13, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  var range = getRange(_1);
  __ = Node({
    type: "Quantifier",
    kind: "Range",
    from: range[0],
    to: range[0],
    greedy: true
  }, __loc);
}], [13, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = Node({
    type: "Quantifier",
    kind: "Range",
    from: getRange(_1)[0],
    greedy: true
  }, __loc);
}], [13, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  var range = getRange(_1);
  __ = Node({
    type: "Quantifier",
    kind: "Range",
    from: range[0],
    to: range[1],
    greedy: true
  }, __loc);
}], [14, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = _1;
}], [14, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = _1;
}], [15, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  var nameRaw = String(_1);
  var name = decodeUnicodeGroupName(nameRaw);
  if (!yy.options.allowGroupNameDuplicates && namedGroups.hasOwnProperty(name)) {
    throw new SyntaxError('Duplicate of the named group "' + name + '".');
  }
  namedGroups[name] = _1.groupNumber;
  __ = Node({
    type: "Group",
    capturing: true,
    name,
    nameRaw,
    number: _1.groupNumber,
    expression: _2
  }, __loc);
}], [15, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  __ = Node({
    type: "Group",
    capturing: true,
    number: _1.groupNumber,
    expression: _2
  }, __loc);
}], [16, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  __ = Node({
    type: "Group",
    capturing: false,
    expression: _2
  }, __loc);
}], [17, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  __ = Node({
    type: "CharacterClass",
    negative: true,
    expressions: _2
  }, __loc);
}], [17, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
  __loc = yyloc(_1loc, _3loc);
  __ = Node({
    type: "CharacterClass",
    expressions: _2
  }, __loc);
}], [18, 0, function() {
  __loc = null;
  __ = [];
}], [18, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = _1;
}], [19, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = [_1];
}], [19, 2, function(_1, _2, _1loc, _2loc) {
  __loc = yyloc(_1loc, _2loc);
  __ = [_1].concat(_2);
}], [19, 4, function(_1, _2, _3, _4, _1loc, _2loc, _3loc, _4loc) {
  __loc = yyloc(_1loc, _4loc);
  checkClassRange(_1, _3);
  __ = [Node({
    type: "ClassRange",
    from: _1,
    to: _3
  }, loc(_1loc, _3loc))];
  if (_4) {
    __ = __.concat(_4);
  }
}], [20, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = _1;
}], [20, 2, function(_1, _2, _1loc, _2loc) {
  __loc = yyloc(_1loc, _2loc);
  __ = [_1].concat(_2);
}], [20, 4, function(_1, _2, _3, _4, _1loc, _2loc, _3loc, _4loc) {
  __loc = yyloc(_1loc, _4loc);
  checkClassRange(_1, _3);
  __ = [Node({
    type: "ClassRange",
    from: _1,
    to: _3
  }, loc(_1loc, _3loc))];
  if (_4) {
    __ = __.concat(_4);
  }
}], [21, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = Char3(_1, "simple", __loc);
}], [21, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = _1;
}], [22, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = _1;
}], [22, 1, function(_1, _1loc) {
  __loc = yyloc(_1loc, _1loc);
  __ = Char3(_1, "meta", __loc);
}]];
var tokens = { "SLASH": "23", "CHAR": "24", "BAR": "25", "BOS": "26", "EOS": "27", "ESC_b": "28", "ESC_B": "29", "POS_LA_ASSERT": "30", "R_PAREN": "31", "NEG_LA_ASSERT": "32", "POS_LB_ASSERT": "33", "NEG_LB_ASSERT": "34", "ESC_CHAR": "35", "U_CODE_SURROGATE": "36", "U_CODE": "37", "U_PROP_VALUE_EXP": "38", "CTRL_CH": "39", "HEX_CODE": "40", "OCT_CODE": "41", "DEC_CODE": "42", "META_CHAR": "43", "ANY": "44", "NAMED_GROUP_REF": "45", "Q_MARK": "46", "STAR": "47", "PLUS": "48", "RANGE_EXACT": "49", "RANGE_OPEN": "50", "RANGE_CLOSED": "51", "NAMED_CAPTURE_GROUP": "52", "L_PAREN": "53", "NON_CAPTURE_GROUP": "54", "NEG_CLASS": "55", "R_BRACKET": "56", "L_BRACKET": "57", "DASH": "58", "$": "59" };
var table = [{ "0": 1, "23": "s2" }, { "59": "acc" }, { "3": 3, "4": 4, "5": 5, "6": 6, "23": "r10", "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "23": "s7" }, { "23": "r6", "25": "s12" }, { "23": "r7", "25": "r7", "31": "r7" }, { "7": 14, "8": 15, "9": 16, "10": 25, "14": 27, "15": 42, "16": 43, "17": 26, "23": "r9", "24": "s28", "25": "r9", "26": "s17", "27": "s18", "28": "s19", "29": "s20", "30": "s21", "31": "r9", "32": "s22", "33": "s23", "34": "s24", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "52": "s44", "53": "s45", "54": "s46", "55": "s40", "57": "s41" }, { "1": 8, "2": 9, "24": "s10", "59": "r3" }, { "59": "r1" }, { "24": "s11", "59": "r2" }, { "24": "r4", "59": "r4" }, { "24": "r5", "59": "r5" }, { "5": 13, "6": 6, "23": "r10", "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "23": "r8", "25": "r8", "31": "r8" }, { "23": "r11", "24": "r11", "25": "r11", "26": "r11", "27": "r11", "28": "r11", "29": "r11", "30": "r11", "31": "r11", "32": "r11", "33": "r11", "34": "r11", "35": "r11", "36": "r11", "37": "r11", "38": "r11", "39": "r11", "40": "r11", "41": "r11", "42": "r11", "43": "r11", "44": "r11", "45": "r11", "52": "r11", "53": "r11", "54": "r11", "55": "r11", "57": "r11" }, { "23": "r12", "24": "r12", "25": "r12", "26": "r12", "27": "r12", "28": "r12", "29": "r12", "30": "r12", "31": "r12", "32": "r12", "33": "r12", "34": "r12", "35": "r12", "36": "r12", "37": "r12", "38": "r12", "39": "r12", "40": "r12", "41": "r12", "42": "r12", "43": "r12", "44": "r12", "45": "r12", "52": "r12", "53": "r12", "54": "r12", "55": "r12", "57": "r12" }, { "11": 47, "12": 48, "13": 49, "23": "r38", "24": "r38", "25": "r38", "26": "r38", "27": "r38", "28": "r38", "29": "r38", "30": "r38", "31": "r38", "32": "r38", "33": "r38", "34": "r38", "35": "r38", "36": "r38", "37": "r38", "38": "r38", "39": "r38", "40": "r38", "41": "r38", "42": "r38", "43": "r38", "44": "r38", "45": "r38", "46": "s52", "47": "s50", "48": "s51", "49": "s53", "50": "s54", "51": "s55", "52": "r38", "53": "r38", "54": "r38", "55": "r38", "57": "r38" }, { "23": "r14", "24": "r14", "25": "r14", "26": "r14", "27": "r14", "28": "r14", "29": "r14", "30": "r14", "31": "r14", "32": "r14", "33": "r14", "34": "r14", "35": "r14", "36": "r14", "37": "r14", "38": "r14", "39": "r14", "40": "r14", "41": "r14", "42": "r14", "43": "r14", "44": "r14", "45": "r14", "52": "r14", "53": "r14", "54": "r14", "55": "r14", "57": "r14" }, { "23": "r15", "24": "r15", "25": "r15", "26": "r15", "27": "r15", "28": "r15", "29": "r15", "30": "r15", "31": "r15", "32": "r15", "33": "r15", "34": "r15", "35": "r15", "36": "r15", "37": "r15", "38": "r15", "39": "r15", "40": "r15", "41": "r15", "42": "r15", "43": "r15", "44": "r15", "45": "r15", "52": "r15", "53": "r15", "54": "r15", "55": "r15", "57": "r15" }, { "23": "r16", "24": "r16", "25": "r16", "26": "r16", "27": "r16", "28": "r16", "29": "r16", "30": "r16", "31": "r16", "32": "r16", "33": "r16", "34": "r16", "35": "r16", "36": "r16", "37": "r16", "38": "r16", "39": "r16", "40": "r16", "41": "r16", "42": "r16", "43": "r16", "44": "r16", "45": "r16", "52": "r16", "53": "r16", "54": "r16", "55": "r16", "57": "r16" }, { "23": "r17", "24": "r17", "25": "r17", "26": "r17", "27": "r17", "28": "r17", "29": "r17", "30": "r17", "31": "r17", "32": "r17", "33": "r17", "34": "r17", "35": "r17", "36": "r17", "37": "r17", "38": "r17", "39": "r17", "40": "r17", "41": "r17", "42": "r17", "43": "r17", "44": "r17", "45": "r17", "52": "r17", "53": "r17", "54": "r17", "55": "r17", "57": "r17" }, { "4": 57, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 59, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 61, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 63, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "23": "r22", "24": "r22", "25": "r22", "26": "r22", "27": "r22", "28": "r22", "29": "r22", "30": "r22", "31": "r22", "32": "r22", "33": "r22", "34": "r22", "35": "r22", "36": "r22", "37": "r22", "38": "r22", "39": "r22", "40": "r22", "41": "r22", "42": "r22", "43": "r22", "44": "r22", "45": "r22", "46": "r22", "47": "r22", "48": "r22", "49": "r22", "50": "r22", "51": "r22", "52": "r22", "53": "r22", "54": "r22", "55": "r22", "57": "r22" }, { "23": "r23", "24": "r23", "25": "r23", "26": "r23", "27": "r23", "28": "r23", "29": "r23", "30": "r23", "31": "r23", "32": "r23", "33": "r23", "34": "r23", "35": "r23", "36": "r23", "37": "r23", "38": "r23", "39": "r23", "40": "r23", "41": "r23", "42": "r23", "43": "r23", "44": "r23", "45": "r23", "46": "r23", "47": "r23", "48": "r23", "49": "r23", "50": "r23", "51": "r23", "52": "r23", "53": "r23", "54": "r23", "55": "r23", "57": "r23" }, { "23": "r24", "24": "r24", "25": "r24", "26": "r24", "27": "r24", "28": "r24", "29": "r24", "30": "r24", "31": "r24", "32": "r24", "33": "r24", "34": "r24", "35": "r24", "36": "r24", "37": "r24", "38": "r24", "39": "r24", "40": "r24", "41": "r24", "42": "r24", "43": "r24", "44": "r24", "45": "r24", "46": "r24", "47": "r24", "48": "r24", "49": "r24", "50": "r24", "51": "r24", "52": "r24", "53": "r24", "54": "r24", "55": "r24", "57": "r24" }, { "23": "r25", "24": "r25", "25": "r25", "26": "r25", "27": "r25", "28": "r25", "29": "r25", "30": "r25", "31": "r25", "32": "r25", "33": "r25", "34": "r25", "35": "r25", "36": "r25", "37": "r25", "38": "r25", "39": "r25", "40": "r25", "41": "r25", "42": "r25", "43": "r25", "44": "r25", "45": "r25", "46": "r25", "47": "r25", "48": "r25", "49": "r25", "50": "r25", "51": "r25", "52": "r25", "53": "r25", "54": "r25", "55": "r25", "56": "r25", "57": "r25", "58": "r25" }, { "23": "r26", "24": "r26", "25": "r26", "26": "r26", "27": "r26", "28": "r26", "29": "r26", "30": "r26", "31": "r26", "32": "r26", "33": "r26", "34": "r26", "35": "r26", "36": "r26", "37": "r26", "38": "r26", "39": "r26", "40": "r26", "41": "r26", "42": "r26", "43": "r26", "44": "r26", "45": "r26", "46": "r26", "47": "r26", "48": "r26", "49": "r26", "50": "r26", "51": "r26", "52": "r26", "53": "r26", "54": "r26", "55": "r26", "56": "r26", "57": "r26", "58": "r26" }, { "23": "r27", "24": "r27", "25": "r27", "26": "r27", "27": "r27", "28": "r27", "29": "r27", "30": "r27", "31": "r27", "32": "r27", "33": "r27", "34": "r27", "35": "r27", "36": "r27", "37": "r27", "38": "r27", "39": "r27", "40": "r27", "41": "r27", "42": "r27", "43": "r27", "44": "r27", "45": "r27", "46": "r27", "47": "r27", "48": "r27", "49": "r27", "50": "r27", "51": "r27", "52": "r27", "53": "r27", "54": "r27", "55": "r27", "56": "r27", "57": "r27", "58": "r27" }, { "23": "r28", "24": "r28", "25": "r28", "26": "r28", "27": "r28", "28": "r28", "29": "r28", "30": "r28", "31": "r28", "32": "r28", "33": "r28", "34": "r28", "35": "r28", "36": "r28", "37": "r28", "38": "r28", "39": "r28", "40": "r28", "41": "r28", "42": "r28", "43": "r28", "44": "r28", "45": "r28", "46": "r28", "47": "r28", "48": "r28", "49": "r28", "50": "r28", "51": "r28", "52": "r28", "53": "r28", "54": "r28", "55": "r28", "56": "r28", "57": "r28", "58": "r28" }, { "23": "r29", "24": "r29", "25": "r29", "26": "r29", "27": "r29", "28": "r29", "29": "r29", "30": "r29", "31": "r29", "32": "r29", "33": "r29", "34": "r29", "35": "r29", "36": "r29", "37": "r29", "38": "r29", "39": "r29", "40": "r29", "41": "r29", "42": "r29", "43": "r29", "44": "r29", "45": "r29", "46": "r29", "47": "r29", "48": "r29", "49": "r29", "50": "r29", "51": "r29", "52": "r29", "53": "r29", "54": "r29", "55": "r29", "56": "r29", "57": "r29", "58": "r29" }, { "23": "r30", "24": "r30", "25": "r30", "26": "r30", "27": "r30", "28": "r30", "29": "r30", "30": "r30", "31": "r30", "32": "r30", "33": "r30", "34": "r30", "35": "r30", "36": "r30", "37": "r30", "38": "r30", "39": "r30", "40": "r30", "41": "r30", "42": "r30", "43": "r30", "44": "r30", "45": "r30", "46": "r30", "47": "r30", "48": "r30", "49": "r30", "50": "r30", "51": "r30", "52": "r30", "53": "r30", "54": "r30", "55": "r30", "56": "r30", "57": "r30", "58": "r30" }, { "23": "r31", "24": "r31", "25": "r31", "26": "r31", "27": "r31", "28": "r31", "29": "r31", "30": "r31", "31": "r31", "32": "r31", "33": "r31", "34": "r31", "35": "r31", "36": "r31", "37": "r31", "38": "r31", "39": "r31", "40": "r31", "41": "r31", "42": "r31", "43": "r31", "44": "r31", "45": "r31", "46": "r31", "47": "r31", "48": "r31", "49": "r31", "50": "r31", "51": "r31", "52": "r31", "53": "r31", "54": "r31", "55": "r31", "56": "r31", "57": "r31", "58": "r31" }, { "23": "r32", "24": "r32", "25": "r32", "26": "r32", "27": "r32", "28": "r32", "29": "r32", "30": "r32", "31": "r32", "32": "r32", "33": "r32", "34": "r32", "35": "r32", "36": "r32", "37": "r32", "38": "r32", "39": "r32", "40": "r32", "41": "r32", "42": "r32", "43": "r32", "44": "r32", "45": "r32", "46": "r32", "47": "r32", "48": "r32", "49": "r32", "50": "r32", "51": "r32", "52": "r32", "53": "r32", "54": "r32", "55": "r32", "56": "r32", "57": "r32", "58": "r32" }, { "23": "r33", "24": "r33", "25": "r33", "26": "r33", "27": "r33", "28": "r33", "29": "r33", "30": "r33", "31": "r33", "32": "r33", "33": "r33", "34": "r33", "35": "r33", "36": "r33", "37": "r33", "38": "r33", "39": "r33", "40": "r33", "41": "r33", "42": "r33", "43": "r33", "44": "r33", "45": "r33", "46": "r33", "47": "r33", "48": "r33", "49": "r33", "50": "r33", "51": "r33", "52": "r33", "53": "r33", "54": "r33", "55": "r33", "56": "r33", "57": "r33", "58": "r33" }, { "23": "r34", "24": "r34", "25": "r34", "26": "r34", "27": "r34", "28": "r34", "29": "r34", "30": "r34", "31": "r34", "32": "r34", "33": "r34", "34": "r34", "35": "r34", "36": "r34", "37": "r34", "38": "r34", "39": "r34", "40": "r34", "41": "r34", "42": "r34", "43": "r34", "44": "r34", "45": "r34", "46": "r34", "47": "r34", "48": "r34", "49": "r34", "50": "r34", "51": "r34", "52": "r34", "53": "r34", "54": "r34", "55": "r34", "56": "r34", "57": "r34", "58": "r34" }, { "23": "r35", "24": "r35", "25": "r35", "26": "r35", "27": "r35", "28": "r35", "29": "r35", "30": "r35", "31": "r35", "32": "r35", "33": "r35", "34": "r35", "35": "r35", "36": "r35", "37": "r35", "38": "r35", "39": "r35", "40": "r35", "41": "r35", "42": "r35", "43": "r35", "44": "r35", "45": "r35", "46": "r35", "47": "r35", "48": "r35", "49": "r35", "50": "r35", "51": "r35", "52": "r35", "53": "r35", "54": "r35", "55": "r35", "56": "r35", "57": "r35", "58": "r35" }, { "23": "r36", "24": "r36", "25": "r36", "26": "r36", "27": "r36", "28": "r36", "29": "r36", "30": "r36", "31": "r36", "32": "r36", "33": "r36", "34": "r36", "35": "r36", "36": "r36", "37": "r36", "38": "r36", "39": "r36", "40": "r36", "41": "r36", "42": "r36", "43": "r36", "44": "r36", "45": "r36", "46": "r36", "47": "r36", "48": "r36", "49": "r36", "50": "r36", "51": "r36", "52": "r36", "53": "r36", "54": "r36", "55": "r36", "56": "r36", "57": "r36", "58": "r36" }, { "10": 70, "18": 65, "19": 66, "21": 67, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r54", "58": "s68" }, { "10": 70, "18": 83, "19": 66, "21": 67, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r54", "58": "s68" }, { "23": "r47", "24": "r47", "25": "r47", "26": "r47", "27": "r47", "28": "r47", "29": "r47", "30": "r47", "31": "r47", "32": "r47", "33": "r47", "34": "r47", "35": "r47", "36": "r47", "37": "r47", "38": "r47", "39": "r47", "40": "r47", "41": "r47", "42": "r47", "43": "r47", "44": "r47", "45": "r47", "46": "r47", "47": "r47", "48": "r47", "49": "r47", "50": "r47", "51": "r47", "52": "r47", "53": "r47", "54": "r47", "55": "r47", "57": "r47" }, { "23": "r48", "24": "r48", "25": "r48", "26": "r48", "27": "r48", "28": "r48", "29": "r48", "30": "r48", "31": "r48", "32": "r48", "33": "r48", "34": "r48", "35": "r48", "36": "r48", "37": "r48", "38": "r48", "39": "r48", "40": "r48", "41": "r48", "42": "r48", "43": "r48", "44": "r48", "45": "r48", "46": "r48", "47": "r48", "48": "r48", "49": "r48", "50": "r48", "51": "r48", "52": "r48", "53": "r48", "54": "r48", "55": "r48", "57": "r48" }, { "4": 85, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 87, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 89, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "23": "r13", "24": "r13", "25": "r13", "26": "r13", "27": "r13", "28": "r13", "29": "r13", "30": "r13", "31": "r13", "32": "r13", "33": "r13", "34": "r13", "35": "r13", "36": "r13", "37": "r13", "38": "r13", "39": "r13", "40": "r13", "41": "r13", "42": "r13", "43": "r13", "44": "r13", "45": "r13", "52": "r13", "53": "r13", "54": "r13", "55": "r13", "57": "r13" }, { "23": "r37", "24": "r37", "25": "r37", "26": "r37", "27": "r37", "28": "r37", "29": "r37", "30": "r37", "31": "r37", "32": "r37", "33": "r37", "34": "r37", "35": "r37", "36": "r37", "37": "r37", "38": "r37", "39": "r37", "40": "r37", "41": "r37", "42": "r37", "43": "r37", "44": "r37", "45": "r37", "52": "r37", "53": "r37", "54": "r37", "55": "r37", "57": "r37" }, { "23": "r39", "24": "r39", "25": "r39", "26": "r39", "27": "r39", "28": "r39", "29": "r39", "30": "r39", "31": "r39", "32": "r39", "33": "r39", "34": "r39", "35": "r39", "36": "r39", "37": "r39", "38": "r39", "39": "r39", "40": "r39", "41": "r39", "42": "r39", "43": "r39", "44": "r39", "45": "r39", "46": "s56", "52": "r39", "53": "r39", "54": "r39", "55": "r39", "57": "r39" }, { "23": "r41", "24": "r41", "25": "r41", "26": "r41", "27": "r41", "28": "r41", "29": "r41", "30": "r41", "31": "r41", "32": "r41", "33": "r41", "34": "r41", "35": "r41", "36": "r41", "37": "r41", "38": "r41", "39": "r41", "40": "r41", "41": "r41", "42": "r41", "43": "r41", "44": "r41", "45": "r41", "46": "r41", "52": "r41", "53": "r41", "54": "r41", "55": "r41", "57": "r41" }, { "23": "r42", "24": "r42", "25": "r42", "26": "r42", "27": "r42", "28": "r42", "29": "r42", "30": "r42", "31": "r42", "32": "r42", "33": "r42", "34": "r42", "35": "r42", "36": "r42", "37": "r42", "38": "r42", "39": "r42", "40": "r42", "41": "r42", "42": "r42", "43": "r42", "44": "r42", "45": "r42", "46": "r42", "52": "r42", "53": "r42", "54": "r42", "55": "r42", "57": "r42" }, { "23": "r43", "24": "r43", "25": "r43", "26": "r43", "27": "r43", "28": "r43", "29": "r43", "30": "r43", "31": "r43", "32": "r43", "33": "r43", "34": "r43", "35": "r43", "36": "r43", "37": "r43", "38": "r43", "39": "r43", "40": "r43", "41": "r43", "42": "r43", "43": "r43", "44": "r43", "45": "r43", "46": "r43", "52": "r43", "53": "r43", "54": "r43", "55": "r43", "57": "r43" }, { "23": "r44", "24": "r44", "25": "r44", "26": "r44", "27": "r44", "28": "r44", "29": "r44", "30": "r44", "31": "r44", "32": "r44", "33": "r44", "34": "r44", "35": "r44", "36": "r44", "37": "r44", "38": "r44", "39": "r44", "40": "r44", "41": "r44", "42": "r44", "43": "r44", "44": "r44", "45": "r44", "46": "r44", "52": "r44", "53": "r44", "54": "r44", "55": "r44", "57": "r44" }, { "23": "r45", "24": "r45", "25": "r45", "26": "r45", "27": "r45", "28": "r45", "29": "r45", "30": "r45", "31": "r45", "32": "r45", "33": "r45", "34": "r45", "35": "r45", "36": "r45", "37": "r45", "38": "r45", "39": "r45", "40": "r45", "41": "r45", "42": "r45", "43": "r45", "44": "r45", "45": "r45", "46": "r45", "52": "r45", "53": "r45", "54": "r45", "55": "r45", "57": "r45" }, { "23": "r46", "24": "r46", "25": "r46", "26": "r46", "27": "r46", "28": "r46", "29": "r46", "30": "r46", "31": "r46", "32": "r46", "33": "r46", "34": "r46", "35": "r46", "36": "r46", "37": "r46", "38": "r46", "39": "r46", "40": "r46", "41": "r46", "42": "r46", "43": "r46", "44": "r46", "45": "r46", "46": "r46", "52": "r46", "53": "r46", "54": "r46", "55": "r46", "57": "r46" }, { "23": "r40", "24": "r40", "25": "r40", "26": "r40", "27": "r40", "28": "r40", "29": "r40", "30": "r40", "31": "r40", "32": "r40", "33": "r40", "34": "r40", "35": "r40", "36": "r40", "37": "r40", "38": "r40", "39": "r40", "40": "r40", "41": "r40", "42": "r40", "43": "r40", "44": "r40", "45": "r40", "52": "r40", "53": "r40", "54": "r40", "55": "r40", "57": "r40" }, { "25": "s12", "31": "s58" }, { "23": "r18", "24": "r18", "25": "r18", "26": "r18", "27": "r18", "28": "r18", "29": "r18", "30": "r18", "31": "r18", "32": "r18", "33": "r18", "34": "r18", "35": "r18", "36": "r18", "37": "r18", "38": "r18", "39": "r18", "40": "r18", "41": "r18", "42": "r18", "43": "r18", "44": "r18", "45": "r18", "52": "r18", "53": "r18", "54": "r18", "55": "r18", "57": "r18" }, { "25": "s12", "31": "s60" }, { "23": "r19", "24": "r19", "25": "r19", "26": "r19", "27": "r19", "28": "r19", "29": "r19", "30": "r19", "31": "r19", "32": "r19", "33": "r19", "34": "r19", "35": "r19", "36": "r19", "37": "r19", "38": "r19", "39": "r19", "40": "r19", "41": "r19", "42": "r19", "43": "r19", "44": "r19", "45": "r19", "52": "r19", "53": "r19", "54": "r19", "55": "r19", "57": "r19" }, { "25": "s12", "31": "s62" }, { "23": "r20", "24": "r20", "25": "r20", "26": "r20", "27": "r20", "28": "r20", "29": "r20", "30": "r20", "31": "r20", "32": "r20", "33": "r20", "34": "r20", "35": "r20", "36": "r20", "37": "r20", "38": "r20", "39": "r20", "40": "r20", "41": "r20", "42": "r20", "43": "r20", "44": "r20", "45": "r20", "52": "r20", "53": "r20", "54": "r20", "55": "r20", "57": "r20" }, { "25": "s12", "31": "s64" }, { "23": "r21", "24": "r21", "25": "r21", "26": "r21", "27": "r21", "28": "r21", "29": "r21", "30": "r21", "31": "r21", "32": "r21", "33": "r21", "34": "r21", "35": "r21", "36": "r21", "37": "r21", "38": "r21", "39": "r21", "40": "r21", "41": "r21", "42": "r21", "43": "r21", "44": "r21", "45": "r21", "52": "r21", "53": "r21", "54": "r21", "55": "r21", "57": "r21" }, { "56": "s72" }, { "56": "r55" }, { "10": 70, "20": 73, "21": 75, "22": 76, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r56", "58": "s74" }, { "24": "r62", "28": "r62", "35": "r62", "36": "r62", "37": "r62", "38": "r62", "39": "r62", "40": "r62", "41": "r62", "42": "r62", "43": "r62", "44": "r62", "45": "r62", "56": "r62", "58": "r62" }, { "24": "r63", "28": "r63", "35": "r63", "36": "r63", "37": "r63", "38": "r63", "39": "r63", "40": "r63", "41": "r63", "42": "r63", "43": "r63", "44": "r63", "45": "r63", "56": "r63", "58": "r63" }, { "24": "r64", "28": "r64", "35": "r64", "36": "r64", "37": "r64", "38": "r64", "39": "r64", "40": "r64", "41": "r64", "42": "r64", "43": "r64", "44": "r64", "45": "r64", "56": "r64", "58": "r64" }, { "24": "r65", "28": "r65", "35": "r65", "36": "r65", "37": "r65", "38": "r65", "39": "r65", "40": "r65", "41": "r65", "42": "r65", "43": "r65", "44": "r65", "45": "r65", "56": "r65", "58": "r65" }, { "23": "r52", "24": "r52", "25": "r52", "26": "r52", "27": "r52", "28": "r52", "29": "r52", "30": "r52", "31": "r52", "32": "r52", "33": "r52", "34": "r52", "35": "r52", "36": "r52", "37": "r52", "38": "r52", "39": "r52", "40": "r52", "41": "r52", "42": "r52", "43": "r52", "44": "r52", "45": "r52", "46": "r52", "47": "r52", "48": "r52", "49": "r52", "50": "r52", "51": "r52", "52": "r52", "53": "r52", "54": "r52", "55": "r52", "57": "r52" }, { "56": "r57" }, { "10": 70, "21": 77, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r62", "58": "s68" }, { "56": "r59" }, { "10": 70, "20": 79, "21": 75, "22": 76, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r63", "58": "s80" }, { "10": 70, "18": 78, "19": 66, "21": 67, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r54", "58": "s68" }, { "56": "r58" }, { "56": "r60" }, { "10": 70, "21": 81, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r62", "58": "s68" }, { "10": 70, "18": 82, "19": 66, "21": 67, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r54", "58": "s68" }, { "56": "r61" }, { "56": "s84" }, { "23": "r53", "24": "r53", "25": "r53", "26": "r53", "27": "r53", "28": "r53", "29": "r53", "30": "r53", "31": "r53", "32": "r53", "33": "r53", "34": "r53", "35": "r53", "36": "r53", "37": "r53", "38": "r53", "39": "r53", "40": "r53", "41": "r53", "42": "r53", "43": "r53", "44": "r53", "45": "r53", "46": "r53", "47": "r53", "48": "r53", "49": "r53", "50": "r53", "51": "r53", "52": "r53", "53": "r53", "54": "r53", "55": "r53", "57": "r53" }, { "25": "s12", "31": "s86" }, { "23": "r49", "24": "r49", "25": "r49", "26": "r49", "27": "r49", "28": "r49", "29": "r49", "30": "r49", "31": "r49", "32": "r49", "33": "r49", "34": "r49", "35": "r49", "36": "r49", "37": "r49", "38": "r49", "39": "r49", "40": "r49", "41": "r49", "42": "r49", "43": "r49", "44": "r49", "45": "r49", "46": "r49", "47": "r49", "48": "r49", "49": "r49", "50": "r49", "51": "r49", "52": "r49", "53": "r49", "54": "r49", "55": "r49", "57": "r49" }, { "25": "s12", "31": "s88" }, { "23": "r50", "24": "r50", "25": "r50", "26": "r50", "27": "r50", "28": "r50", "29": "r50", "30": "r50", "31": "r50", "32": "r50", "33": "r50", "34": "r50", "35": "r50", "36": "r50", "37": "r50", "38": "r50", "39": "r50", "40": "r50", "41": "r50", "42": "r50", "43": "r50", "44": "r50", "45": "r50", "46": "r50", "47": "r50", "48": "r50", "49": "r50", "50": "r50", "51": "r50", "52": "r50", "53": "r50", "54": "r50", "55": "r50", "57": "r50" }, { "25": "s12", "31": "s90" }, { "23": "r51", "24": "r51", "25": "r51", "26": "r51", "27": "r51", "28": "r51", "29": "r51", "30": "r51", "31": "r51", "32": "r51", "33": "r51", "34": "r51", "35": "r51", "36": "r51", "37": "r51", "38": "r51", "39": "r51", "40": "r51", "41": "r51", "42": "r51", "43": "r51", "44": "r51", "45": "r51", "46": "r51", "47": "r51", "48": "r51", "49": "r51", "50": "r51", "51": "r51", "52": "r51", "53": "r51", "54": "r51", "55": "r51", "57": "r51" }];
var stack = [];
var tokenizer = void 0;
var lexRules = [[/^#[^\n]+/, function() {
}], [/^\s+/, function() {
}], [/^-/, function() {
  return "DASH";
}], [/^\//, function() {
  return "CHAR";
}], [/^#/, function() {
  return "CHAR";
}], [/^\|/, function() {
  return "CHAR";
}], [/^\./, function() {
  return "CHAR";
}], [/^\{/, function() {
  return "CHAR";
}], [/^\{\d+\}/, function() {
  return "RANGE_EXACT";
}], [/^\{\d+,\}/, function() {
  return "RANGE_OPEN";
}], [/^\{\d+,\d+\}/, function() {
  return "RANGE_CLOSED";
}], [/^\\k<(([\u0041-\u005a\u0061-\u007a\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e-\u066f\u0671-\u06d3\u06d5\u06e5-\u06e6\u06ee-\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4-\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc-\u09dd\u09df-\u09e1\u09f0-\u09f1\u09fc\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0-\u0ae1\u0af9\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3d\u0b5c-\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60-\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0-\u0ce1\u0cf1-\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32-\u0e33\u0e40-\u0e46\u0e81-\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2-\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065-\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae-\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5-\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a-\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd-\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5-\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c-\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\udd40-\udd74\ude80-\ude9c\udea0-\uded0\udf00-\udf1f\udf2d-\udf4a\udf50-\udf75\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf\udfd1-\udfd5]|\ud801[\udc00-\udc9d\udcb0-\udcd3\udcd8-\udcfb\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37-\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4-\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe-\uddbf\ude00\ude10-\ude13\ude15-\ude17\ude19-\ude35\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee4\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2\udd00-\udd23\udf00-\udf1c\udf27\udf30-\udf45\udfe0-\udff6]|\ud804[\udc03-\udc37\udc83-\udcaf\udcd0-\udce8\udd03-\udd26\udd44\udd50-\udd72\udd76\udd83-\uddb2\uddc1-\uddc4\uddda\udddc\ude00-\ude11\ude13-\ude2b\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udede\udf05-\udf0c\udf0f-\udf10\udf13-\udf28\udf2a-\udf30\udf32-\udf33\udf35-\udf39\udf3d\udf50\udf5d-\udf61]|\ud805[\udc00-\udc34\udc47-\udc4a\udc5f\udc80-\udcaf\udcc4-\udcc5\udcc7\udd80-\uddae\uddd8-\udddb\ude00-\ude2f\ude44\ude80-\udeaa\udeb8\udf00-\udf1a]|\ud806[\udc00-\udc2b\udca0-\udcdf\udcff\udda0-\udda7\uddaa-\uddd0\udde1\udde3\ude00\ude0b-\ude32\ude3a\ude50\ude5c-\ude89\ude9d\udec0-\udef8]|\ud807[\udc00-\udc08\udc0a-\udc2e\udc40\udc72-\udc8f\udd00-\udd06\udd08-\udd09\udd0b-\udd30\udd46\udd60-\udd65\udd67-\udd68\udd6a-\udd89\udd98\udee0-\udef2]|\ud808[\udc00-\udf99]|\ud809[\udc00-\udc6e\udc80-\udd43]|\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]|\ud811[\udc00-\ude46]|\ud81a[\udc00-\ude38\ude40-\ude5e\uded0-\udeed\udf00-\udf2f\udf40-\udf43\udf63-\udf77\udf7d-\udf8f]|\ud81b[\ude40-\ude7f\udf00-\udf4a\udf50\udf93-\udf9f\udfe0-\udfe1\udfe3]|\ud81c[\udc00-\udfff]|\ud81d[\udc00-\udfff]|\ud81e[\udc00-\udfff]|\ud81f[\udc00-\udfff]|\ud820[\udc00-\udfff]|\ud821[\udc00-\udff7]|\ud822[\udc00-\udef2]|\ud82c[\udc00-\udd1e\udd50-\udd52\udd64-\udd67\udd70-\udefb]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e-\udc9f\udca2\udca5-\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb]|\ud838[\udd00-\udd2c\udd37-\udd3d\udd4e\udec0-\udeeb]|\ud83a[\udc00-\udcc4\udd00-\udd43\udd4b]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21-\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51-\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61-\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud840[\udc00-\udfff]|\ud841[\udc00-\udfff]|\ud842[\udc00-\udfff]|\ud843[\udc00-\udfff]|\ud844[\udc00-\udfff]|\ud845[\udc00-\udfff]|\ud846[\udc00-\udfff]|\ud847[\udc00-\udfff]|\ud848[\udc00-\udfff]|\ud849[\udc00-\udfff]|\ud84a[\udc00-\udfff]|\ud84b[\udc00-\udfff]|\ud84c[\udc00-\udfff]|\ud84d[\udc00-\udfff]|\ud84e[\udc00-\udfff]|\ud84f[\udc00-\udfff]|\ud850[\udc00-\udfff]|\ud851[\udc00-\udfff]|\ud852[\udc00-\udfff]|\ud853[\udc00-\udfff]|\ud854[\udc00-\udfff]|\ud855[\udc00-\udfff]|\ud856[\udc00-\udfff]|\ud857[\udc00-\udfff]|\ud858[\udc00-\udfff]|\ud859[\udc00-\udfff]|\ud85a[\udc00-\udfff]|\ud85b[\udc00-\udfff]|\ud85c[\udc00-\udfff]|\ud85d[\udc00-\udfff]|\ud85e[\udc00-\udfff]|\ud85f[\udc00-\udfff]|\ud860[\udc00-\udfff]|\ud861[\udc00-\udfff]|\ud862[\udc00-\udfff]|\ud863[\udc00-\udfff]|\ud864[\udc00-\udfff]|\ud865[\udc00-\udfff]|\ud866[\udc00-\udfff]|\ud867[\udc00-\udfff]|\ud868[\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86a[\udc00-\udfff]|\ud86b[\udc00-\udfff]|\ud86c[\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86f[\udc00-\udfff]|\ud870[\udc00-\udfff]|\ud871[\udc00-\udfff]|\ud872[\udc00-\udfff]|\ud873[\udc00-\udea1\udeb0-\udfff]|\ud874[\udc00-\udfff]|\ud875[\udc00-\udfff]|\ud876[\udc00-\udfff]|\ud877[\udc00-\udfff]|\ud878[\udc00-\udfff]|\ud879[\udc00-\udfff]|\ud87a[\udc00-\udfe0]|\ud87e[\udc00-\ude1d])|[$_]|(\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]{1,}\}))(([\u0030-\u0039\u0041-\u005a\u005f\u0061-\u007a\u00aa\u00b5\u00b7\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05bd\u05bf\u05c1-\u05c2\u05c4-\u05c5\u05c7\u05d0-\u05ea\u05ef-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u07fd\u0800-\u082d\u0840-\u085b\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u08d3-\u08e1\u08e3-\u0963\u0966-\u096f\u0971-\u0983\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7-\u09c8\u09cb-\u09ce\u09d7\u09dc-\u09dd\u09df-\u09e3\u09e6-\u09f1\u09fc\u09fe\u0a01-\u0a03\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a3c\u0a3e-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0af9-\u0aff\u0b01-\u0b03\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47-\u0b48\u0b4b-\u0b4d\u0b56-\u0b57\u0b5c-\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82-\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c00-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56\u0c58-\u0c5a\u0c60-\u0c63\u0c66-\u0c6f\u0c80-\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5-\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1-\u0cf2\u0d00-\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d54-\u0d57\u0d5f-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82-\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2-\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81-\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18-\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1369-\u1371\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772-\u1773\u1780-\u17d3\u17d7\u17dc-\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1878\u1880-\u18aa\u18b0-\u18f5\u1900-\u191e\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19da\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1ab0-\u1abd\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1cd0-\u1cd2\u1cd4-\u1cfa\u1d00-\u1df9\u1dfb-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u203f-\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua827\ua840-\ua873\ua880-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua8fd-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\ua9e0-\ua9fe\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabea\uabec-\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe2f\ufe33-\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c-\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\udd40-\udd74\uddfd\ude80-\ude9c\udea0-\uded0\udee0\udf00-\udf1f\udf2d-\udf4a\udf50-\udf7a\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf\udfd1-\udfd5]|\ud801[\udc00-\udc9d\udca0-\udca9\udcb0-\udcd3\udcd8-\udcfb\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37-\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4-\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe-\uddbf\ude00-\ude03\ude05-\ude06\ude0c-\ude13\ude15-\ude17\ude19-\ude35\ude38-\ude3a\ude3f\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee6\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2\udd00-\udd27\udd30-\udd39\udf00-\udf1c\udf27\udf30-\udf50\udfe0-\udff6]|\ud804[\udc00-\udc46\udc66-\udc6f\udc7f-\udcba\udcd0-\udce8\udcf0-\udcf9\udd00-\udd34\udd36-\udd3f\udd44-\udd46\udd50-\udd73\udd76\udd80-\uddc4\uddc9-\uddcc\uddd0-\uddda\udddc\ude00-\ude11\ude13-\ude37\ude3e\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udeea\udef0-\udef9\udf00-\udf03\udf05-\udf0c\udf0f-\udf10\udf13-\udf28\udf2a-\udf30\udf32-\udf33\udf35-\udf39\udf3b-\udf44\udf47-\udf48\udf4b-\udf4d\udf50\udf57\udf5d-\udf63\udf66-\udf6c\udf70-\udf74]|\ud805[\udc00-\udc4a\udc50-\udc59\udc5e-\udc5f\udc80-\udcc5\udcc7\udcd0-\udcd9\udd80-\uddb5\uddb8-\uddc0\uddd8-\udddd\ude00-\ude40\ude44\ude50-\ude59\ude80-\udeb8\udec0-\udec9\udf00-\udf1a\udf1d-\udf2b\udf30-\udf39]|\ud806[\udc00-\udc3a\udca0-\udce9\udcff\udda0-\udda7\uddaa-\uddd7\uddda-\udde1\udde3-\udde4\ude00-\ude3e\ude47\ude50-\ude99\ude9d\udec0-\udef8]|\ud807[\udc00-\udc08\udc0a-\udc36\udc38-\udc40\udc50-\udc59\udc72-\udc8f\udc92-\udca7\udca9-\udcb6\udd00-\udd06\udd08-\udd09\udd0b-\udd36\udd3a\udd3c-\udd3d\udd3f-\udd47\udd50-\udd59\udd60-\udd65\udd67-\udd68\udd6a-\udd8e\udd90-\udd91\udd93-\udd98\udda0-\udda9\udee0-\udef6]|\ud808[\udc00-\udf99]|\ud809[\udc00-\udc6e\udc80-\udd43]|\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]|\ud811[\udc00-\ude46]|\ud81a[\udc00-\ude38\ude40-\ude5e\ude60-\ude69\uded0-\udeed\udef0-\udef4\udf00-\udf36\udf40-\udf43\udf50-\udf59\udf63-\udf77\udf7d-\udf8f]|\ud81b[\ude40-\ude7f\udf00-\udf4a\udf4f-\udf87\udf8f-\udf9f\udfe0-\udfe1\udfe3]|\ud81c[\udc00-\udfff]|\ud81d[\udc00-\udfff]|\ud81e[\udc00-\udfff]|\ud81f[\udc00-\udfff]|\ud820[\udc00-\udfff]|\ud821[\udc00-\udff7]|\ud822[\udc00-\udef2]|\ud82c[\udc00-\udd1e\udd50-\udd52\udd64-\udd67\udd70-\udefb]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99\udc9d-\udc9e]|\ud834[\udd65-\udd69\udd6d-\udd72\udd7b-\udd82\udd85-\udd8b\uddaa-\uddad\ude42-\ude44]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e-\udc9f\udca2\udca5-\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb\udfce-\udfff]|\ud836[\ude00-\ude36\ude3b-\ude6c\ude75\ude84\ude9b-\ude9f\udea1-\udeaf]|\ud838[\udc00-\udc06\udc08-\udc18\udc1b-\udc21\udc23-\udc24\udc26-\udc2a\udd00-\udd2c\udd30-\udd3d\udd40-\udd49\udd4e\udec0-\udef9]|\ud83a[\udc00-\udcc4\udcd0-\udcd6\udd00-\udd4b\udd50-\udd59]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21-\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51-\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61-\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud840[\udc00-\udfff]|\ud841[\udc00-\udfff]|\ud842[\udc00-\udfff]|\ud843[\udc00-\udfff]|\ud844[\udc00-\udfff]|\ud845[\udc00-\udfff]|\ud846[\udc00-\udfff]|\ud847[\udc00-\udfff]|\ud848[\udc00-\udfff]|\ud849[\udc00-\udfff]|\ud84a[\udc00-\udfff]|\ud84b[\udc00-\udfff]|\ud84c[\udc00-\udfff]|\ud84d[\udc00-\udfff]|\ud84e[\udc00-\udfff]|\ud84f[\udc00-\udfff]|\ud850[\udc00-\udfff]|\ud851[\udc00-\udfff]|\ud852[\udc00-\udfff]|\ud853[\udc00-\udfff]|\ud854[\udc00-\udfff]|\ud855[\udc00-\udfff]|\ud856[\udc00-\udfff]|\ud857[\udc00-\udfff]|\ud858[\udc00-\udfff]|\ud859[\udc00-\udfff]|\ud85a[\udc00-\udfff]|\ud85b[\udc00-\udfff]|\ud85c[\udc00-\udfff]|\ud85d[\udc00-\udfff]|\ud85e[\udc00-\udfff]|\ud85f[\udc00-\udfff]|\ud860[\udc00-\udfff]|\ud861[\udc00-\udfff]|\ud862[\udc00-\udfff]|\ud863[\udc00-\udfff]|\ud864[\udc00-\udfff]|\ud865[\udc00-\udfff]|\ud866[\udc00-\udfff]|\ud867[\udc00-\udfff]|\ud868[\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86a[\udc00-\udfff]|\ud86b[\udc00-\udfff]|\ud86c[\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86f[\udc00-\udfff]|\ud870[\udc00-\udfff]|\ud871[\udc00-\udfff]|\ud872[\udc00-\udfff]|\ud873[\udc00-\udea1\udeb0-\udfff]|\ud874[\udc00-\udfff]|\ud875[\udc00-\udfff]|\ud876[\udc00-\udfff]|\ud877[\udc00-\udfff]|\ud878[\udc00-\udfff]|\ud879[\udc00-\udfff]|\ud87a[\udc00-\udfe0]|\ud87e[\udc00-\ude1d]|\udb40[\udd00-\uddef])|[$_]|(\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]{1,}\})|[\u200c\u200d])*>/, function() {
  var groupName = yytext.slice(3, -1);
  validateUnicodeGroupName(groupName, this.getCurrentState());
  return "NAMED_GROUP_REF";
}], [/^\\b/, function() {
  return "ESC_b";
}], [/^\\B/, function() {
  return "ESC_B";
}], [/^\\c[a-zA-Z]/, function() {
  return "CTRL_CH";
}], [/^\\0\d{1,2}/, function() {
  return "OCT_CODE";
}], [/^\\0/, function() {
  return "DEC_CODE";
}], [/^\\\d{1,3}/, function() {
  return "DEC_CODE";
}], [/^\\u[dD][89abAB][0-9a-fA-F]{2}\\u[dD][c-fC-F][0-9a-fA-F]{2}/, function() {
  return "U_CODE_SURROGATE";
}], [/^\\u\{[0-9a-fA-F]{1,}\}/, function() {
  return "U_CODE";
}], [/^\\u[0-9a-fA-F]{4}/, function() {
  return "U_CODE";
}], [/^\\[pP]\{\w+(?:=\w+)?\}/, function() {
  return "U_PROP_VALUE_EXP";
}], [/^\\x[0-9a-fA-F]{2}/, function() {
  return "HEX_CODE";
}], [/^\\[tnrdDsSwWvf]/, function() {
  return "META_CHAR";
}], [/^\\\//, function() {
  return "ESC_CHAR";
}], [/^\\[ #]/, function() {
  return "ESC_CHAR";
}], [/^\\[\^\$\.\*\+\?\(\)\\\[\]\{\}\|\/]/, function() {
  return "ESC_CHAR";
}], [/^\\[^*?+\[()\\|]/, function() {
  var s = this.getCurrentState();
  if (s === "u_class" && yytext === "\\-") {
    return "ESC_CHAR";
  } else if (s === "u" || s === "xu" || s === "u_class") {
    throw new SyntaxError("invalid Unicode escape " + yytext);
  }
  return "ESC_CHAR";
}], [/^\(/, function() {
  return "CHAR";
}], [/^\)/, function() {
  return "CHAR";
}], [/^\(\?=/, function() {
  return "POS_LA_ASSERT";
}], [/^\(\?!/, function() {
  return "NEG_LA_ASSERT";
}], [/^\(\?<=/, function() {
  return "POS_LB_ASSERT";
}], [/^\(\?<!/, function() {
  return "NEG_LB_ASSERT";
}], [/^\(\?:/, function() {
  return "NON_CAPTURE_GROUP";
}], [/^\(\?<(([\u0041-\u005a\u0061-\u007a\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e-\u066f\u0671-\u06d3\u06d5\u06e5-\u06e6\u06ee-\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4-\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc-\u09dd\u09df-\u09e1\u09f0-\u09f1\u09fc\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0-\u0ae1\u0af9\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3d\u0b5c-\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60-\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0-\u0ce1\u0cf1-\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32-\u0e33\u0e40-\u0e46\u0e81-\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2-\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065-\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae-\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5-\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a-\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd-\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5-\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c-\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\udd40-\udd74\ude80-\ude9c\udea0-\uded0\udf00-\udf1f\udf2d-\udf4a\udf50-\udf75\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf\udfd1-\udfd5]|\ud801[\udc00-\udc9d\udcb0-\udcd3\udcd8-\udcfb\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37-\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4-\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe-\uddbf\ude00\ude10-\ude13\ude15-\ude17\ude19-\ude35\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee4\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2\udd00-\udd23\udf00-\udf1c\udf27\udf30-\udf45\udfe0-\udff6]|\ud804[\udc03-\udc37\udc83-\udcaf\udcd0-\udce8\udd03-\udd26\udd44\udd50-\udd72\udd76\udd83-\uddb2\uddc1-\uddc4\uddda\udddc\ude00-\ude11\ude13-\ude2b\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udede\udf05-\udf0c\udf0f-\udf10\udf13-\udf28\udf2a-\udf30\udf32-\udf33\udf35-\udf39\udf3d\udf50\udf5d-\udf61]|\ud805[\udc00-\udc34\udc47-\udc4a\udc5f\udc80-\udcaf\udcc4-\udcc5\udcc7\udd80-\uddae\uddd8-\udddb\ude00-\ude2f\ude44\ude80-\udeaa\udeb8\udf00-\udf1a]|\ud806[\udc00-\udc2b\udca0-\udcdf\udcff\udda0-\udda7\uddaa-\uddd0\udde1\udde3\ude00\ude0b-\ude32\ude3a\ude50\ude5c-\ude89\ude9d\udec0-\udef8]|\ud807[\udc00-\udc08\udc0a-\udc2e\udc40\udc72-\udc8f\udd00-\udd06\udd08-\udd09\udd0b-\udd30\udd46\udd60-\udd65\udd67-\udd68\udd6a-\udd89\udd98\udee0-\udef2]|\ud808[\udc00-\udf99]|\ud809[\udc00-\udc6e\udc80-\udd43]|\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]|\ud811[\udc00-\ude46]|\ud81a[\udc00-\ude38\ude40-\ude5e\uded0-\udeed\udf00-\udf2f\udf40-\udf43\udf63-\udf77\udf7d-\udf8f]|\ud81b[\ude40-\ude7f\udf00-\udf4a\udf50\udf93-\udf9f\udfe0-\udfe1\udfe3]|\ud81c[\udc00-\udfff]|\ud81d[\udc00-\udfff]|\ud81e[\udc00-\udfff]|\ud81f[\udc00-\udfff]|\ud820[\udc00-\udfff]|\ud821[\udc00-\udff7]|\ud822[\udc00-\udef2]|\ud82c[\udc00-\udd1e\udd50-\udd52\udd64-\udd67\udd70-\udefb]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e-\udc9f\udca2\udca5-\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb]|\ud838[\udd00-\udd2c\udd37-\udd3d\udd4e\udec0-\udeeb]|\ud83a[\udc00-\udcc4\udd00-\udd43\udd4b]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21-\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51-\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61-\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud840[\udc00-\udfff]|\ud841[\udc00-\udfff]|\ud842[\udc00-\udfff]|\ud843[\udc00-\udfff]|\ud844[\udc00-\udfff]|\ud845[\udc00-\udfff]|\ud846[\udc00-\udfff]|\ud847[\udc00-\udfff]|\ud848[\udc00-\udfff]|\ud849[\udc00-\udfff]|\ud84a[\udc00-\udfff]|\ud84b[\udc00-\udfff]|\ud84c[\udc00-\udfff]|\ud84d[\udc00-\udfff]|\ud84e[\udc00-\udfff]|\ud84f[\udc00-\udfff]|\ud850[\udc00-\udfff]|\ud851[\udc00-\udfff]|\ud852[\udc00-\udfff]|\ud853[\udc00-\udfff]|\ud854[\udc00-\udfff]|\ud855[\udc00-\udfff]|\ud856[\udc00-\udfff]|\ud857[\udc00-\udfff]|\ud858[\udc00-\udfff]|\ud859[\udc00-\udfff]|\ud85a[\udc00-\udfff]|\ud85b[\udc00-\udfff]|\ud85c[\udc00-\udfff]|\ud85d[\udc00-\udfff]|\ud85e[\udc00-\udfff]|\ud85f[\udc00-\udfff]|\ud860[\udc00-\udfff]|\ud861[\udc00-\udfff]|\ud862[\udc00-\udfff]|\ud863[\udc00-\udfff]|\ud864[\udc00-\udfff]|\ud865[\udc00-\udfff]|\ud866[\udc00-\udfff]|\ud867[\udc00-\udfff]|\ud868[\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86a[\udc00-\udfff]|\ud86b[\udc00-\udfff]|\ud86c[\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86f[\udc00-\udfff]|\ud870[\udc00-\udfff]|\ud871[\udc00-\udfff]|\ud872[\udc00-\udfff]|\ud873[\udc00-\udea1\udeb0-\udfff]|\ud874[\udc00-\udfff]|\ud875[\udc00-\udfff]|\ud876[\udc00-\udfff]|\ud877[\udc00-\udfff]|\ud878[\udc00-\udfff]|\ud879[\udc00-\udfff]|\ud87a[\udc00-\udfe0]|\ud87e[\udc00-\ude1d])|[$_]|(\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]{1,}\}))(([\u0030-\u0039\u0041-\u005a\u005f\u0061-\u007a\u00aa\u00b5\u00b7\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05bd\u05bf\u05c1-\u05c2\u05c4-\u05c5\u05c7\u05d0-\u05ea\u05ef-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u07fd\u0800-\u082d\u0840-\u085b\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u08d3-\u08e1\u08e3-\u0963\u0966-\u096f\u0971-\u0983\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7-\u09c8\u09cb-\u09ce\u09d7\u09dc-\u09dd\u09df-\u09e3\u09e6-\u09f1\u09fc\u09fe\u0a01-\u0a03\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a3c\u0a3e-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0af9-\u0aff\u0b01-\u0b03\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47-\u0b48\u0b4b-\u0b4d\u0b56-\u0b57\u0b5c-\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82-\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c00-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56\u0c58-\u0c5a\u0c60-\u0c63\u0c66-\u0c6f\u0c80-\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5-\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1-\u0cf2\u0d00-\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d54-\u0d57\u0d5f-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82-\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2-\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81-\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18-\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1369-\u1371\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772-\u1773\u1780-\u17d3\u17d7\u17dc-\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1878\u1880-\u18aa\u18b0-\u18f5\u1900-\u191e\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19da\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1ab0-\u1abd\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1cd0-\u1cd2\u1cd4-\u1cfa\u1d00-\u1df9\u1dfb-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u203f-\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua827\ua840-\ua873\ua880-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua8fd-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\ua9e0-\ua9fe\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabea\uabec-\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe2f\ufe33-\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c-\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\udd40-\udd74\uddfd\ude80-\ude9c\udea0-\uded0\udee0\udf00-\udf1f\udf2d-\udf4a\udf50-\udf7a\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf\udfd1-\udfd5]|\ud801[\udc00-\udc9d\udca0-\udca9\udcb0-\udcd3\udcd8-\udcfb\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37-\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4-\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe-\uddbf\ude00-\ude03\ude05-\ude06\ude0c-\ude13\ude15-\ude17\ude19-\ude35\ude38-\ude3a\ude3f\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee6\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2\udd00-\udd27\udd30-\udd39\udf00-\udf1c\udf27\udf30-\udf50\udfe0-\udff6]|\ud804[\udc00-\udc46\udc66-\udc6f\udc7f-\udcba\udcd0-\udce8\udcf0-\udcf9\udd00-\udd34\udd36-\udd3f\udd44-\udd46\udd50-\udd73\udd76\udd80-\uddc4\uddc9-\uddcc\uddd0-\uddda\udddc\ude00-\ude11\ude13-\ude37\ude3e\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udeea\udef0-\udef9\udf00-\udf03\udf05-\udf0c\udf0f-\udf10\udf13-\udf28\udf2a-\udf30\udf32-\udf33\udf35-\udf39\udf3b-\udf44\udf47-\udf48\udf4b-\udf4d\udf50\udf57\udf5d-\udf63\udf66-\udf6c\udf70-\udf74]|\ud805[\udc00-\udc4a\udc50-\udc59\udc5e-\udc5f\udc80-\udcc5\udcc7\udcd0-\udcd9\udd80-\uddb5\uddb8-\uddc0\uddd8-\udddd\ude00-\ude40\ude44\ude50-\ude59\ude80-\udeb8\udec0-\udec9\udf00-\udf1a\udf1d-\udf2b\udf30-\udf39]|\ud806[\udc00-\udc3a\udca0-\udce9\udcff\udda0-\udda7\uddaa-\uddd7\uddda-\udde1\udde3-\udde4\ude00-\ude3e\ude47\ude50-\ude99\ude9d\udec0-\udef8]|\ud807[\udc00-\udc08\udc0a-\udc36\udc38-\udc40\udc50-\udc59\udc72-\udc8f\udc92-\udca7\udca9-\udcb6\udd00-\udd06\udd08-\udd09\udd0b-\udd36\udd3a\udd3c-\udd3d\udd3f-\udd47\udd50-\udd59\udd60-\udd65\udd67-\udd68\udd6a-\udd8e\udd90-\udd91\udd93-\udd98\udda0-\udda9\udee0-\udef6]|\ud808[\udc00-\udf99]|\ud809[\udc00-\udc6e\udc80-\udd43]|\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]|\ud811[\udc00-\ude46]|\ud81a[\udc00-\ude38\ude40-\ude5e\ude60-\ude69\uded0-\udeed\udef0-\udef4\udf00-\udf36\udf40-\udf43\udf50-\udf59\udf63-\udf77\udf7d-\udf8f]|\ud81b[\ude40-\ude7f\udf00-\udf4a\udf4f-\udf87\udf8f-\udf9f\udfe0-\udfe1\udfe3]|\ud81c[\udc00-\udfff]|\ud81d[\udc00-\udfff]|\ud81e[\udc00-\udfff]|\ud81f[\udc00-\udfff]|\ud820[\udc00-\udfff]|\ud821[\udc00-\udff7]|\ud822[\udc00-\udef2]|\ud82c[\udc00-\udd1e\udd50-\udd52\udd64-\udd67\udd70-\udefb]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99\udc9d-\udc9e]|\ud834[\udd65-\udd69\udd6d-\udd72\udd7b-\udd82\udd85-\udd8b\uddaa-\uddad\ude42-\ude44]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e-\udc9f\udca2\udca5-\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb\udfce-\udfff]|\ud836[\ude00-\ude36\ude3b-\ude6c\ude75\ude84\ude9b-\ude9f\udea1-\udeaf]|\ud838[\udc00-\udc06\udc08-\udc18\udc1b-\udc21\udc23-\udc24\udc26-\udc2a\udd00-\udd2c\udd30-\udd3d\udd40-\udd49\udd4e\udec0-\udef9]|\ud83a[\udc00-\udcc4\udcd0-\udcd6\udd00-\udd4b\udd50-\udd59]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21-\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51-\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61-\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud840[\udc00-\udfff]|\ud841[\udc00-\udfff]|\ud842[\udc00-\udfff]|\ud843[\udc00-\udfff]|\ud844[\udc00-\udfff]|\ud845[\udc00-\udfff]|\ud846[\udc00-\udfff]|\ud847[\udc00-\udfff]|\ud848[\udc00-\udfff]|\ud849[\udc00-\udfff]|\ud84a[\udc00-\udfff]|\ud84b[\udc00-\udfff]|\ud84c[\udc00-\udfff]|\ud84d[\udc00-\udfff]|\ud84e[\udc00-\udfff]|\ud84f[\udc00-\udfff]|\ud850[\udc00-\udfff]|\ud851[\udc00-\udfff]|\ud852[\udc00-\udfff]|\ud853[\udc00-\udfff]|\ud854[\udc00-\udfff]|\ud855[\udc00-\udfff]|\ud856[\udc00-\udfff]|\ud857[\udc00-\udfff]|\ud858[\udc00-\udfff]|\ud859[\udc00-\udfff]|\ud85a[\udc00-\udfff]|\ud85b[\udc00-\udfff]|\ud85c[\udc00-\udfff]|\ud85d[\udc00-\udfff]|\ud85e[\udc00-\udfff]|\ud85f[\udc00-\udfff]|\ud860[\udc00-\udfff]|\ud861[\udc00-\udfff]|\ud862[\udc00-\udfff]|\ud863[\udc00-\udfff]|\ud864[\udc00-\udfff]|\ud865[\udc00-\udfff]|\ud866[\udc00-\udfff]|\ud867[\udc00-\udfff]|\ud868[\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86a[\udc00-\udfff]|\ud86b[\udc00-\udfff]|\ud86c[\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86f[\udc00-\udfff]|\ud870[\udc00-\udfff]|\ud871[\udc00-\udfff]|\ud872[\udc00-\udfff]|\ud873[\udc00-\udea1\udeb0-\udfff]|\ud874[\udc00-\udfff]|\ud875[\udc00-\udfff]|\ud876[\udc00-\udfff]|\ud877[\udc00-\udfff]|\ud878[\udc00-\udfff]|\ud879[\udc00-\udfff]|\ud87a[\udc00-\udfe0]|\ud87e[\udc00-\ude1d]|\udb40[\udd00-\uddef])|[$_]|(\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]{1,}\})|[\u200c\u200d])*>/, function() {
  yytext = yytext.slice(3, -1);
  validateUnicodeGroupName(yytext, this.getCurrentState());
  return "NAMED_CAPTURE_GROUP";
}], [/^\(/, function() {
  return "L_PAREN";
}], [/^\)/, function() {
  return "R_PAREN";
}], [/^[*?+[^$]/, function() {
  return "CHAR";
}], [/^\\\]/, function() {
  return "ESC_CHAR";
}], [/^\]/, function() {
  this.popState();
  return "R_BRACKET";
}], [/^\^/, function() {
  return "BOS";
}], [/^\$/, function() {
  return "EOS";
}], [/^\*/, function() {
  return "STAR";
}], [/^\?/, function() {
  return "Q_MARK";
}], [/^\+/, function() {
  return "PLUS";
}], [/^\|/, function() {
  return "BAR";
}], [/^\./, function() {
  return "ANY";
}], [/^\//, function() {
  return "SLASH";
}], [/^[^*?+\[()\\|]/, function() {
  return "CHAR";
}], [/^\[\^/, function() {
  var s = this.getCurrentState();
  this.pushState(s === "u" || s === "xu" ? "u_class" : "class");
  return "NEG_CLASS";
}], [/^\[/, function() {
  var s = this.getCurrentState();
  this.pushState(s === "u" || s === "xu" ? "u_class" : "class");
  return "L_BRACKET";
}]];
var lexRulesByConditions = { "INITIAL": [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 22, 23, 24, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "u": [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "xu": [0, 1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "x": [0, 1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 22, 23, 24, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "u_class": [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "class": [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 22, 23, 24, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51] };
var EOF_TOKEN = {
  type: EOF$1,
  value: ""
};
tokenizer = {
  initString: function initString(string) {
    this._string = string;
    this._cursor = 0;
    this._states = ["INITIAL"];
    this._tokensQueue = [];
    this._currentLine = 1;
    this._currentColumn = 0;
    this._currentLineBeginOffset = 0;
    this._tokenStartOffset = 0;
    this._tokenEndOffset = 0;
    this._tokenStartLine = 1;
    this._tokenEndLine = 1;
    this._tokenStartColumn = 0;
    this._tokenEndColumn = 0;
    return this;
  },
  /**
   * Returns tokenizer states.
   */
  getStates: function getStates() {
    return this._states;
  },
  getCurrentState: function getCurrentState() {
    return this._states[this._states.length - 1];
  },
  pushState: function pushState(state2) {
    this._states.push(state2);
  },
  begin: function begin(state2) {
    this.pushState(state2);
  },
  popState: function popState() {
    if (this._states.length > 1) {
      return this._states.pop();
    }
    return this._states[0];
  },
  getNextToken: function getNextToken() {
    if (this._tokensQueue.length > 0) {
      return this.onToken(this._toToken(this._tokensQueue.shift()));
    }
    if (!this.hasMoreTokens()) {
      return this.onToken(EOF_TOKEN);
    }
    var string = this._string.slice(this._cursor);
    var lexRulesForState = lexRulesByConditions[this.getCurrentState()];
    for (var i = 0; i < lexRulesForState.length; i++) {
      var lexRuleIndex = lexRulesForState[i];
      var lexRule = lexRules[lexRuleIndex];
      var matched = this._match(string, lexRule[0]);
      if (string === "" && matched === "") {
        this._cursor++;
      }
      if (matched !== null) {
        yytext = matched;
        yytext.length;
        var token = lexRule[1].call(this);
        if (!token) {
          return this.getNextToken();
        }
        if (Array.isArray(token)) {
          var tokensToQueue = token.slice(1);
          token = token[0];
          if (tokensToQueue.length > 0) {
            var _tokensQueue;
            (_tokensQueue = this._tokensQueue).unshift.apply(_tokensQueue, _toConsumableArray$8(tokensToQueue));
          }
        }
        return this.onToken(this._toToken(token, yytext));
      }
    }
    if (this.isEOF()) {
      this._cursor++;
      return EOF_TOKEN;
    }
    this.throwUnexpectedToken(string[0], this._currentLine, this._currentColumn);
  },
  /**
   * Throws default "Unexpected token" exception, showing the actual
   * line from the source, pointing with the ^ marker to the bad token.
   * In addition, shows `line:column` location.
   */
  throwUnexpectedToken: function throwUnexpectedToken(symbol, line, column) {
    var lineSource = this._string.split("\n")[line - 1];
    var lineData = "";
    if (lineSource) {
      var pad = " ".repeat(column);
      lineData = "\n\n" + lineSource + "\n" + pad + "^\n";
    }
    throw new SyntaxError(lineData + 'Unexpected token: "' + symbol + '" ' + ("at " + line + ":" + column + "."));
  },
  getCursor: function getCursor() {
    return this._cursor;
  },
  getCurrentLine: function getCurrentLine() {
    return this._currentLine;
  },
  getCurrentColumn: function getCurrentColumn() {
    return this._currentColumn;
  },
  _captureLocation: function _captureLocation(matched) {
    var nlRe = /\n/g;
    this._tokenStartOffset = this._cursor;
    this._tokenStartLine = this._currentLine;
    this._tokenStartColumn = this._tokenStartOffset - this._currentLineBeginOffset;
    var nlMatch = void 0;
    while ((nlMatch = nlRe.exec(matched)) !== null) {
      this._currentLine++;
      this._currentLineBeginOffset = this._tokenStartOffset + nlMatch.index + 1;
    }
    this._tokenEndOffset = this._cursor + matched.length;
    this._tokenEndLine = this._currentLine;
    this._tokenEndColumn = this._currentColumn = this._tokenEndOffset - this._currentLineBeginOffset;
  },
  _toToken: function _toToken(tokenType) {
    var yytext2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return {
      // Basic data.
      type: tokenType,
      value: yytext2,
      // Location data.
      startOffset: this._tokenStartOffset,
      endOffset: this._tokenEndOffset,
      startLine: this._tokenStartLine,
      endLine: this._tokenEndLine,
      startColumn: this._tokenStartColumn,
      endColumn: this._tokenEndColumn
    };
  },
  isEOF: function isEOF() {
    return this._cursor === this._string.length;
  },
  hasMoreTokens: function hasMoreTokens() {
    return this._cursor <= this._string.length;
  },
  _match: function _match(string, regexp) {
    var matched = string.match(regexp);
    if (matched) {
      this._captureLocation(matched[0]);
      this._cursor += matched[0].length;
      return matched[0];
    }
    return null;
  },
  /**
   * Allows analyzing, and transforming token. Default implementation
   * just passes the token through.
   */
  onToken: function onToken(token) {
    return token;
  }
};
yy.lexer = tokenizer;
yy.tokenizer = tokenizer;
yy.options = {
  captureLocations: true
};
var yyparse = {
  /**
   * Sets global parsing options.
   */
  setOptions: function setOptions(options) {
    yy.options = options;
    return this;
  },
  /**
   * Returns parsing options.
   */
  getOptions: function getOptions() {
    return yy.options;
  },
  /**
   * Parses a string.
   */
  parse: function parse(string, parseOptions) {
    if (!tokenizer) {
      throw new Error("Tokenizer instance wasn't specified.");
    }
    tokenizer.initString(string);
    var globalOptions = yy.options;
    if (parseOptions) {
      yy.options = Object.assign({}, yy.options, parseOptions);
    }
    yyparse.onParseBegin(string, tokenizer, yy.options);
    stack.length = 0;
    stack.push(0);
    var token = tokenizer.getNextToken();
    var shiftedToken = null;
    do {
      if (!token) {
        yy.options = globalOptions;
        unexpectedEndOfInput();
      }
      var state2 = stack[stack.length - 1];
      var column = tokens[token.type];
      if (!table[state2].hasOwnProperty(column)) {
        yy.options = globalOptions;
        unexpectedToken(token);
      }
      var entry = table[state2][column];
      if (entry[0] === "s") {
        var _loc2 = null;
        if (yy.options.captureLocations) {
          _loc2 = {
            startOffset: token.startOffset,
            endOffset: token.endOffset,
            startLine: token.startLine,
            endLine: token.endLine,
            startColumn: token.startColumn,
            endColumn: token.endColumn
          };
        }
        shiftedToken = this.onShift(token);
        stack.push({ symbol: tokens[shiftedToken.type], semanticValue: shiftedToken.value, loc: _loc2 }, Number(entry.slice(1)));
        token = tokenizer.getNextToken();
      } else if (entry[0] === "r") {
        var productionNumber = entry.slice(1);
        var production = productions[productionNumber];
        var hasSemanticAction = typeof production[2] === "function";
        var semanticValueArgs = hasSemanticAction ? [] : null;
        var locationArgs = hasSemanticAction && yy.options.captureLocations ? [] : null;
        if (production[1] !== 0) {
          var rhsLength = production[1];
          while (rhsLength-- > 0) {
            stack.pop();
            var stackEntry = stack.pop();
            if (hasSemanticAction) {
              semanticValueArgs.unshift(stackEntry.semanticValue);
              if (locationArgs) {
                locationArgs.unshift(stackEntry.loc);
              }
            }
          }
        }
        var reduceStackEntry = { symbol: production[0] };
        if (hasSemanticAction) {
          yytext = shiftedToken ? shiftedToken.value : null;
          shiftedToken ? shiftedToken.value.length : null;
          var semanticActionArgs = locationArgs !== null ? semanticValueArgs.concat(locationArgs) : semanticValueArgs;
          production[2].apply(production, _toConsumableArray$8(semanticActionArgs));
          reduceStackEntry.semanticValue = __;
          if (locationArgs) {
            reduceStackEntry.loc = __loc;
          }
        }
        var nextState = stack[stack.length - 1];
        var symbolToReduceWith = production[0];
        stack.push(reduceStackEntry, table[nextState][symbolToReduceWith]);
      } else if (entry === "acc") {
        stack.pop();
        var parsed = stack.pop();
        if (stack.length !== 1 || stack[0] !== 0 || tokenizer.hasMoreTokens()) {
          yy.options = globalOptions;
          unexpectedToken(token);
        }
        if (parsed.hasOwnProperty("semanticValue")) {
          yy.options = globalOptions;
          yyparse.onParseEnd(parsed.semanticValue);
          return parsed.semanticValue;
        }
        yyparse.onParseEnd();
        yy.options = globalOptions;
        return true;
      }
    } while (tokenizer.hasMoreTokens() || stack.length > 1);
  },
  setTokenizer: function setTokenizer(customTokenizer) {
    tokenizer = customTokenizer;
    return yyparse;
  },
  getTokenizer: function getTokenizer() {
    return tokenizer;
  },
  onParseBegin: function onParseBegin(string, tokenizer2, options) {
  },
  onParseEnd: function onParseEnd(parsed) {
  },
  /**
   * Allows analyzing, and transforming shifted token. Default implementation
   * just passes the token through.
   */
  onShift: function onShift(token) {
    return token;
  }
};
var capturingGroupsCount = 0;
var namedGroups = {};
var parsingString = "";
yyparse.onParseBegin = function(string, lexer) {
  parsingString = string;
  capturingGroupsCount = 0;
  namedGroups = {};
  var lastSlash = string.lastIndexOf("/");
  var flags = string.slice(lastSlash);
  if (flags.includes("x") && flags.includes("u")) {
    lexer.pushState("xu");
  } else {
    if (flags.includes("x")) {
      lexer.pushState("x");
    }
    if (flags.includes("u")) {
      lexer.pushState("u");
    }
  }
};
yyparse.onShift = function(token) {
  if (token.type === "L_PAREN" || token.type === "NAMED_CAPTURE_GROUP") {
    token.value = new String(token.value);
    token.value.groupNumber = ++capturingGroupsCount;
  }
  return token;
};
function getRange(text) {
  var range = text.match(/\d+/g).map(Number);
  if (Number.isFinite(range[1]) && range[1] < range[0]) {
    throw new SyntaxError("Numbers out of order in " + text + " quantifier");
  }
  return range;
}
function checkClassRange(from, to) {
  if (from.kind === "control" || to.kind === "control" || !isNaN(from.codePoint) && !isNaN(to.codePoint) && from.codePoint > to.codePoint) {
    throw new SyntaxError("Range " + from.value + "-" + to.value + " out of order in character class");
  }
}
var unicodeProperties = parserUnicodeProperties;
function UnicodeProperty2(matched, loc2) {
  var negative = matched[1] === "P";
  var separatorIdx = matched.indexOf("=");
  var name = matched.slice(3, separatorIdx !== -1 ? separatorIdx : -1);
  var value = void 0;
  var isShorthand = separatorIdx === -1 && unicodeProperties.isGeneralCategoryValue(name);
  var isBinaryProperty = separatorIdx === -1 && unicodeProperties.isBinaryPropertyName(name);
  if (isShorthand) {
    value = name;
    name = "General_Category";
  } else if (isBinaryProperty) {
    value = name;
  } else {
    if (!unicodeProperties.isValidName(name)) {
      throw new SyntaxError("Invalid unicode property name: " + name + ".");
    }
    value = matched.slice(separatorIdx + 1, -1);
    if (!unicodeProperties.isValidValue(name, value)) {
      throw new SyntaxError("Invalid " + name + " unicode property value: " + value + ".");
    }
  }
  return Node({
    type: "UnicodeProperty",
    name,
    value,
    negative,
    shorthand: isShorthand,
    binary: isBinaryProperty,
    canonicalName: unicodeProperties.getCanonicalName(name) || name,
    canonicalValue: unicodeProperties.getCanonicalValue(value) || value
  }, loc2);
}
function Char3(value, kind, loc2) {
  var symbol = void 0;
  var codePoint = void 0;
  switch (kind) {
    case "decimal": {
      codePoint = Number(value.slice(1));
      symbol = String.fromCodePoint(codePoint);
      break;
    }
    case "oct": {
      codePoint = parseInt(value.slice(1), 8);
      symbol = String.fromCodePoint(codePoint);
      break;
    }
    case "hex":
    case "unicode": {
      if (value.lastIndexOf("\\u") > 0) {
        var _value$split$slice = value.split("\\u").slice(1), _value$split$slice2 = _slicedToArray$2(_value$split$slice, 2), lead = _value$split$slice2[0], trail = _value$split$slice2[1];
        lead = parseInt(lead, 16);
        trail = parseInt(trail, 16);
        codePoint = (lead - 55296) * 1024 + (trail - 56320) + 65536;
        symbol = String.fromCodePoint(codePoint);
      } else {
        var hex = value.slice(2).replace("{", "");
        codePoint = parseInt(hex, 16);
        if (codePoint > 1114111) {
          throw new SyntaxError("Bad character escape sequence: " + value);
        }
        symbol = String.fromCodePoint(codePoint);
      }
      break;
    }
    case "meta": {
      switch (value) {
        case "\\t":
          symbol = "	";
          codePoint = symbol.codePointAt(0);
          break;
        case "\\n":
          symbol = "\n";
          codePoint = symbol.codePointAt(0);
          break;
        case "\\r":
          symbol = "\r";
          codePoint = symbol.codePointAt(0);
          break;
        case "\\v":
          symbol = "\v";
          codePoint = symbol.codePointAt(0);
          break;
        case "\\f":
          symbol = "\f";
          codePoint = symbol.codePointAt(0);
          break;
        case "\\b":
          symbol = "\b";
          codePoint = symbol.codePointAt(0);
        case "\\0":
          symbol = "\0";
          codePoint = 0;
        case ".":
          symbol = ".";
          codePoint = NaN;
          break;
        default:
          codePoint = NaN;
      }
      break;
    }
    case "simple": {
      symbol = value;
      codePoint = symbol.codePointAt(0);
      break;
    }
  }
  return Node({
    type: "Char",
    value,
    kind,
    symbol,
    codePoint
  }, loc2);
}
var validFlags = "gimsuxy";
function checkFlags(flags) {
  var seen2 = /* @__PURE__ */ new Set();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = void 0;
  try {
    for (var _iterator = flags[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var flag = _step.value;
      if (seen2.has(flag) || !validFlags.includes(flag)) {
        throw new SyntaxError("Invalid flags: " + flags);
      }
      seen2.add(flag);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
  return flags.split("").sort().join("");
}
function GroupRefOrDecChar(text, textLoc) {
  var reference = Number(text.slice(1));
  if (reference > 0 && reference <= capturingGroupsCount) {
    return Node({
      type: "Backreference",
      kind: "number",
      number: reference,
      reference
    }, textLoc);
  }
  return Char3(text, "decimal", textLoc);
}
var uReStart = /^\\u[0-9a-fA-F]{4}/;
var ucpReStart = /^\\u\{[0-9a-fA-F]{1,}\}/;
var ucpReAnywhere = /\\u\{[0-9a-fA-F]{1,}\}/;
function validateUnicodeGroupName(name, state2) {
  var isUnicodeName = ucpReAnywhere.test(name);
  var isUnicodeState = state2 === "u" || state2 === "xu" || state2 === "u_class";
  if (isUnicodeName && !isUnicodeState) {
    throw new SyntaxError('invalid group Unicode name "' + name + '", use `u` flag.');
  }
  return name;
}
var uidRe = /\\u(?:([dD][89aAbB][0-9a-fA-F]{2})\\u([dD][c-fC-F][0-9a-fA-F]{2})|([dD][89aAbB][0-9a-fA-F]{2})|([dD][c-fC-F][0-9a-fA-F]{2})|([0-9a-ce-fA-CE-F][0-9a-fA-F]{3}|[dD][0-7][0-9a-fA-F]{2})|\{(0*(?:[0-9a-fA-F]{1,5}|10[0-9a-fA-F]{4}))\})/;
function decodeUnicodeGroupName(name) {
  return name.replace(new RegExp(uidRe, "g"), function(_, leadSurrogate, trailSurrogate, leadSurrogateOnly, trailSurrogateOnly, nonSurrogate, codePoint) {
    if (leadSurrogate) {
      return String.fromCodePoint(parseInt(leadSurrogate, 16), parseInt(trailSurrogate, 16));
    }
    if (leadSurrogateOnly) {
      return String.fromCodePoint(parseInt(leadSurrogateOnly, 16));
    }
    if (trailSurrogateOnly) {
      return String.fromCodePoint(parseInt(trailSurrogateOnly, 16));
    }
    if (nonSurrogate) {
      return String.fromCodePoint(parseInt(nonSurrogate, 16));
    }
    if (codePoint) {
      return String.fromCodePoint(parseInt(codePoint, 16));
    }
    return _;
  });
}
function NamedGroupRefOrChars(text, textLoc) {
  var referenceRaw = text.slice(3, -1);
  var reference = decodeUnicodeGroupName(referenceRaw);
  if (namedGroups.hasOwnProperty(reference)) {
    return Node({
      type: "Backreference",
      kind: "name",
      number: namedGroups[reference],
      reference,
      referenceRaw
    }, textLoc);
  }
  var startOffset = null;
  var startLine = null;
  var endLine = null;
  var startColumn = null;
  if (textLoc) {
    startOffset = textLoc.startOffset;
    startLine = textLoc.startLine;
    endLine = textLoc.endLine;
    startColumn = textLoc.startColumn;
  }
  var charRe = /^[\w$<>]/;
  var loc2 = void 0;
  var chars = [
    // Init to first \k, taking 2 symbols.
    Char3(text.slice(1, 2), "simple", startOffset ? {
      startLine,
      endLine,
      startColumn,
      startOffset,
      endOffset: startOffset += 2,
      endColumn: startColumn += 2
    } : null)
  ];
  chars[0].escaped = true;
  text = text.slice(2);
  while (text.length > 0) {
    var matched = null;
    if ((matched = text.match(uReStart)) || (matched = text.match(ucpReStart))) {
      if (startOffset) {
        loc2 = {
          startLine,
          endLine,
          startColumn,
          startOffset,
          endOffset: startOffset += matched[0].length,
          endColumn: startColumn += matched[0].length
        };
      }
      chars.push(Char3(matched[0], "unicode", loc2));
      text = text.slice(matched[0].length);
    } else if (matched = text.match(charRe)) {
      if (startOffset) {
        loc2 = {
          startLine,
          endLine,
          startColumn,
          startOffset,
          endOffset: ++startOffset,
          endColumn: ++startColumn
        };
      }
      chars.push(Char3(matched[0], "simple", loc2));
      text = text.slice(1);
    }
  }
  return chars;
}
function Node(node, loc2) {
  if (yy.options.captureLocations) {
    node.loc = {
      source: parsingString.slice(loc2.startOffset, loc2.endOffset),
      start: {
        line: loc2.startLine,
        column: loc2.startColumn,
        offset: loc2.startOffset
      },
      end: {
        line: loc2.endLine,
        column: loc2.endColumn,
        offset: loc2.endOffset
      }
    };
  }
  return node;
}
function loc(start, end) {
  if (!yy.options.captureLocations) {
    return null;
  }
  return {
    startOffset: start.startOffset,
    endOffset: end.endOffset,
    startLine: start.startLine,
    endLine: end.endLine,
    startColumn: start.startColumn,
    endColumn: end.endColumn
  };
}
function unexpectedToken(token) {
  if (token.type === EOF$1) {
    unexpectedEndOfInput();
  }
  tokenizer.throwUnexpectedToken(token.value, token.startLine, token.startColumn);
}
function unexpectedEndOfInput() {
  parseError("Unexpected end of input.");
}
function parseError(message) {
  throw new SyntaxError(message);
}
var regexpTree$4 = yyparse;
var regexpTreeParser = regexpTree$4;
var generatedParseFn = regexpTreeParser.parse.bind(regexpTreeParser);
regexpTreeParser.parse = function(regexp, options) {
  return generatedParseFn("" + regexp, options);
};
regexpTreeParser.setOptions({ captureLocations: false });
var parser$5 = regexpTreeParser;
var _createClass$6 = /* @__PURE__ */ function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$6(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var DEFAULT_COLLECTION_PROP = "expressions";
var DEFAULT_SINGLE_PROP = "expression";
var NodePath$3 = function() {
  function NodePath2(node) {
    var parentPath = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    var property = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    var index2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
    _classCallCheck$6(this, NodePath2);
    this.node = node;
    this.parentPath = parentPath;
    this.parent = parentPath ? parentPath.node : null;
    this.property = property;
    this.index = index2;
  }
  _createClass$6(NodePath2, [{
    key: "_enforceProp",
    value: function _enforceProp(property) {
      if (!this.node.hasOwnProperty(property)) {
        throw new Error("Node of type " + this.node.type + ` doesn't have "` + property + '" collection.');
      }
    }
    /**
     * Sets a node into a children collection or the single child.
     * By default child nodes are supposed to be under `expressions` property.
     * An explicit property can be passed.
     *
     * @param Object node - a node to set into a collection or as single child
     * @param number index - index at which to set
     * @param string property - name of the collection or single property
     */
  }, {
    key: "setChild",
    value: function setChild(node) {
      var index2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var property = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      var childPath = void 0;
      if (index2 != null) {
        if (!property) {
          property = DEFAULT_COLLECTION_PROP;
        }
        this._enforceProp(property);
        this.node[property][index2] = node;
        childPath = NodePath2.getForNode(node, this, property, index2);
      } else {
        if (!property) {
          property = DEFAULT_SINGLE_PROP;
        }
        this._enforceProp(property);
        this.node[property] = node;
        childPath = NodePath2.getForNode(node, this, property, null);
      }
      return childPath;
    }
    /**
     * Appends a node to a children collection.
     * By default child nodes are supposed to be under `expressions` property.
     * An explicit property can be passed.
     *
     * @param Object node - a node to set into a collection or as single child
     * @param string property - name of the collection or single property
     */
  }, {
    key: "appendChild",
    value: function appendChild(node) {
      var property = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      if (!property) {
        property = DEFAULT_COLLECTION_PROP;
      }
      this._enforceProp(property);
      var end = this.node[property].length;
      return this.setChild(node, end, property);
    }
    /**
     * Inserts a node into a collection.
     * By default child nodes are supposed to be under `expressions` property.
     * An explicit property can be passed.
     *
     * @param Object node - a node to insert into a collection
     * @param number index - index at which to insert
     * @param string property - name of the collection property
     */
  }, {
    key: "insertChildAt",
    value: function insertChildAt(node, index2) {
      var property = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : DEFAULT_COLLECTION_PROP;
      this._enforceProp(property);
      this.node[property].splice(index2, 0, node);
      if (index2 <= NodePath2.getTraversingIndex()) {
        NodePath2.updateTraversingIndex(1);
      }
      this._rebuildIndex(this.node, property);
    }
    /**
     * Removes a node.
     */
  }, {
    key: "remove",
    value: function remove2() {
      if (this.isRemoved()) {
        return;
      }
      NodePath2.registry.delete(this.node);
      this.node = null;
      if (!this.parent) {
        return;
      }
      if (this.index !== null) {
        this.parent[this.property].splice(this.index, 1);
        if (this.index <= NodePath2.getTraversingIndex()) {
          NodePath2.updateTraversingIndex(-1);
        }
        this._rebuildIndex(this.parent, this.property);
        this.index = null;
        this.property = null;
        return;
      }
      delete this.parent[this.property];
      this.property = null;
    }
    /**
     * Rebuilds child nodes index (used on remove/insert).
     */
  }, {
    key: "_rebuildIndex",
    value: function _rebuildIndex(parent, property) {
      var parentPath = NodePath2.getForNode(parent);
      for (var i = 0; i < parent[property].length; i++) {
        var path = NodePath2.getForNode(parent[property][i], parentPath, property, i);
        path.index = i;
      }
    }
    /**
     * Whether the path was removed.
     */
  }, {
    key: "isRemoved",
    value: function isRemoved() {
      return this.node === null;
    }
    /**
     * Replaces a node with the passed one.
     */
  }, {
    key: "replace",
    value: function replace(newNode) {
      NodePath2.registry.delete(this.node);
      this.node = newNode;
      if (!this.parent) {
        return null;
      }
      if (this.index !== null) {
        this.parent[this.property][this.index] = newNode;
      } else {
        this.parent[this.property] = newNode;
      }
      return NodePath2.getForNode(newNode, this.parentPath, this.property, this.index);
    }
    /**
     * Updates a node inline.
     */
  }, {
    key: "update",
    value: function update(nodeProps) {
      Object.assign(this.node, nodeProps);
    }
    /**
     * Returns parent.
     */
  }, {
    key: "getParent",
    value: function getParent() {
      return this.parentPath;
    }
    /**
     * Returns nth child.
     */
  }, {
    key: "getChild",
    value: function getChild() {
      var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      if (this.node.expressions) {
        return NodePath2.getForNode(this.node.expressions[n], this, DEFAULT_COLLECTION_PROP, n);
      } else if (this.node.expression && n == 0) {
        return NodePath2.getForNode(this.node.expression, this, DEFAULT_SINGLE_PROP);
      }
      return null;
    }
    /**
     * Whether a path node is syntactically equal to the passed one.
     *
     * NOTE: we don't rely on `source` property from the `loc` data
     * (which would be the fastest comparison), since it might be unsync
     * after several modifications. We use here simple `JSON.stringify`
     * excluding the `loc` data.
     *
     * @param NodePath other - path to compare to.
     * @return boolean
     */
  }, {
    key: "hasEqualSource",
    value: function hasEqualSource(path) {
      return JSON.stringify(this.node, jsonSkipLoc) === JSON.stringify(path.node, jsonSkipLoc);
    }
    /**
     * JSON-encodes a node skipping location.
     */
  }, {
    key: "jsonEncode",
    value: function jsonEncode() {
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, format2 = _ref.format, useLoc = _ref.useLoc;
      return JSON.stringify(this.node, useLoc ? null : jsonSkipLoc, format2);
    }
    /**
     * Returns previous sibling.
     */
  }, {
    key: "getPreviousSibling",
    value: function getPreviousSibling() {
      if (!this.parent || this.index == null) {
        return null;
      }
      return NodePath2.getForNode(this.parent[this.property][this.index - 1], NodePath2.getForNode(this.parent), this.property, this.index - 1);
    }
    /**
     * Returns next sibling.
     */
  }, {
    key: "getNextSibling",
    value: function getNextSibling() {
      if (!this.parent || this.index == null) {
        return null;
      }
      return NodePath2.getForNode(this.parent[this.property][this.index + 1], NodePath2.getForNode(this.parent), this.property, this.index + 1);
    }
    /**
     * Returns a NodePath instance for a node.
     *
     * The same NodePath can be reused in several places, e.g.
     * a parent node passed for all its children.
     */
  }], [{
    key: "getForNode",
    value: function getForNode(node) {
      var parentPath = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var prop = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      var index2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : -1;
      if (!node) {
        return null;
      }
      if (!NodePath2.registry.has(node)) {
        NodePath2.registry.set(node, new NodePath2(node, parentPath, prop, index2 == -1 ? null : index2));
      }
      var path = NodePath2.registry.get(node);
      if (parentPath !== null) {
        path.parentPath = parentPath;
        path.parent = path.parentPath.node;
      }
      if (prop !== null) {
        path.property = prop;
      }
      if (index2 >= 0) {
        path.index = index2;
      }
      return path;
    }
    /**
     * Initializes the NodePath registry. The registry is a map from
     * a node to its NodePath instance.
     */
  }, {
    key: "initRegistry",
    value: function initRegistry() {
      if (!NodePath2.registry) {
        NodePath2.registry = /* @__PURE__ */ new Map();
      }
      NodePath2.registry.clear();
    }
    /**
     * Updates index of a currently traversing collection.
     */
  }, {
    key: "updateTraversingIndex",
    value: function updateTraversingIndex(dx) {
      return NodePath2.traversingIndexStack[NodePath2.traversingIndexStack.length - 1] += dx;
    }
    /**
     * Returns current traversing index.
     */
  }, {
    key: "getTraversingIndex",
    value: function getTraversingIndex() {
      return NodePath2.traversingIndexStack[NodePath2.traversingIndexStack.length - 1];
    }
  }]);
  return NodePath2;
}();
NodePath$3.initRegistry();
NodePath$3.traversingIndexStack = [];
function jsonSkipLoc(prop, value) {
  if (prop === "loc") {
    return void 0;
  }
  return value;
}
var nodePath = NodePath$3;
var NodePath$2 = nodePath;
function astTraverse(root) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var pre = options.pre;
  var post = options.post;
  var skipProperty = options.skipProperty;
  function visit(node, parent, prop, idx) {
    if (!node || typeof node.type !== "string") {
      return;
    }
    var res = void 0;
    if (pre) {
      res = pre(node, parent, prop, idx);
    }
    if (res !== false) {
      if (parent && parent[prop]) {
        if (!isNaN(idx)) {
          node = parent[prop][idx];
        } else {
          node = parent[prop];
        }
      }
      for (var _prop in node) {
        if (node.hasOwnProperty(_prop)) {
          if (skipProperty ? skipProperty(_prop, node) : _prop[0] === "$") {
            continue;
          }
          var child = node[_prop];
          if (Array.isArray(child)) {
            var index2 = 0;
            NodePath$2.traversingIndexStack.push(index2);
            while (index2 < child.length) {
              visit(child[index2], node, _prop, index2);
              index2 = NodePath$2.updateTraversingIndex(1);
            }
            NodePath$2.traversingIndexStack.pop();
          } else {
            visit(child, node, _prop);
          }
        }
      }
    }
    if (post) {
      post(node, parent, prop, idx);
    }
  }
  visit(root, null);
}
var traverse$1 = {
  /**
   * Traverses an AST.
   *
   * @param Object ast - an AST node
   *
   * @param Object | Array<Object> handlers:
   *
   *   an object (or an array of objects)
   *
   *   Each such object contains a handler function per node.
   *   In case of an array of handlers, they are applied in order.
   *   A handler may return a transformed node (or a different type).
   *
   *   The per-node function may instead be an object with functions pre and post.
   *   pre is called before visiting the node, post after.
   *   If a handler is a function, it is treated as the pre function, with an empty post.
   *
   * @param Object options:
   *
   *   a config object, specifying traversal options:
   *
   *   `asNodes`: boolean - whether handlers should receives raw AST nodes
   *   (false by default), instead of a `NodePath` wrapper. Note, by default
   *   `NodePath` wrapper provides a set of convenient method to manipulate
   *   a traversing AST, and also has access to all parents list. A raw
   *   nodes traversal should be used in rare cases, when no `NodePath`
   *   features are needed.
   *
   * Special hooks:
   *
   *   - `shouldRun(ast)` - a predicate determining whether the handler
   *                        should be applied.
   *
   * NOTE: Multiple handlers are used as an optimization of applying all of
   * them in one AST traversal pass.
   */
  traverse: function traverse(ast, handlers2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : { asNodes: false };
    if (!Array.isArray(handlers2)) {
      handlers2 = [handlers2];
    }
    handlers2 = handlers2.filter(function(handler) {
      if (typeof handler.shouldRun !== "function") {
        return true;
      }
      return handler.shouldRun(ast);
    });
    NodePath$2.initRegistry();
    handlers2.forEach(function(handler) {
      if (typeof handler.init === "function") {
        handler.init(ast);
      }
    });
    function getPathFor(node, parent, prop, index2) {
      var parentPath = NodePath$2.getForNode(parent);
      var nodePath2 = NodePath$2.getForNode(node, parentPath, prop, index2);
      return nodePath2;
    }
    astTraverse(ast, {
      /**
       * Handler on node enter.
       */
      pre: function pre(node, parent, prop, index2) {
        var nodePath2 = void 0;
        if (!options.asNodes) {
          nodePath2 = getPathFor(node, parent, prop, index2);
        }
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = handlers2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var handler = _step.value;
            if (typeof handler["*"] === "function") {
              if (nodePath2) {
                if (!nodePath2.isRemoved()) {
                  var handlerResult = handler["*"](nodePath2);
                  if (handlerResult === false) {
                    return false;
                  }
                }
              } else {
                handler["*"](node, parent, prop, index2);
              }
            }
            var handlerFuncPre = void 0;
            if (typeof handler[node.type] === "function") {
              handlerFuncPre = handler[node.type];
            } else if (typeof handler[node.type] === "object" && typeof handler[node.type].pre === "function") {
              handlerFuncPre = handler[node.type].pre;
            }
            if (handlerFuncPre) {
              if (nodePath2) {
                if (!nodePath2.isRemoved()) {
                  var _handlerResult = handlerFuncPre.call(handler, nodePath2);
                  if (_handlerResult === false) {
                    return false;
                  }
                }
              } else {
                handlerFuncPre.call(handler, node, parent, prop, index2);
              }
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      },
      // pre func
      /**
       * Handler on node exit.
       */
      post: function post(node, parent, prop, index2) {
        if (!node) {
          return;
        }
        var nodePath2 = void 0;
        if (!options.asNodes) {
          nodePath2 = getPathFor(node, parent, prop, index2);
        }
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = void 0;
        try {
          for (var _iterator2 = handlers2[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var handler = _step2.value;
            var handlerFuncPost = void 0;
            if (typeof handler[node.type] === "object" && typeof handler[node.type].post === "function") {
              handlerFuncPost = handler[node.type].post;
            }
            if (handlerFuncPost) {
              if (nodePath2) {
                if (!nodePath2.isRemoved()) {
                  var handlerResult = handlerFuncPost.call(handler, nodePath2);
                  if (handlerResult === false) {
                    return false;
                  }
                }
              } else {
                handlerFuncPost.call(handler, node, parent, prop, index2);
              }
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      },
      // post func
      /**
       * Skip locations by default.
       */
      skipProperty: function skipProperty(prop) {
        return prop === "loc";
      }
    });
  }
};
var _createClass$5 = /* @__PURE__ */ function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$5(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var generator$2 = generator_1;
var parser$4 = parser$5;
var traverse2 = traverse$1;
var TransformResult = function() {
  function TransformResult2(ast) {
    var extra = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    _classCallCheck$5(this, TransformResult2);
    this._ast = ast;
    this._source = null;
    this._string = null;
    this._regexp = null;
    this._extra = extra;
  }
  _createClass$5(TransformResult2, [{
    key: "getAST",
    value: function getAST() {
      return this._ast;
    }
  }, {
    key: "setExtra",
    value: function setExtra(extra) {
      this._extra = extra;
    }
  }, {
    key: "getExtra",
    value: function getExtra2() {
      return this._extra;
    }
  }, {
    key: "toRegExp",
    value: function toRegExp2() {
      if (!this._regexp) {
        this._regexp = new RegExp(this.getSource(), this._ast.flags);
      }
      return this._regexp;
    }
  }, {
    key: "getSource",
    value: function getSource() {
      if (!this._source) {
        this._source = generator$2.generate(this._ast.body);
      }
      return this._source;
    }
  }, {
    key: "getFlags",
    value: function getFlags() {
      return this._ast.flags;
    }
  }, {
    key: "toString",
    value: function toString2() {
      if (!this._string) {
        this._string = generator$2.generate(this._ast);
      }
      return this._string;
    }
  }]);
  return TransformResult2;
}();
var transform$5 = {
  /**
   * Expose `TransformResult`.
   */
  TransformResult,
  /**
   * Transforms a regular expression applying a set of
   * transformation handlers.
   *
   * @param string | AST | RegExp:
   *
   *   a regular expression in different representations: a string,
   *   a RegExp object, or an AST.
   *
   * @param Object | Array<Object>:
   *
   *   a handler (or a list of handlers) from `traverse` API.
   *
   * @return TransformResult instance.
   *
   * Example:
   *
   *   transform(/[a-z]/i, {
   *     onChar(path) {
   *       const {node} = path;
   *
   *       if (...) {
   *         path.remove();
   *       }
   *     }
   *   });
   */
  transform: function transform(regexp, handlers2) {
    var ast = regexp;
    if (regexp instanceof RegExp) {
      regexp = "" + regexp;
    }
    if (typeof regexp === "string") {
      ast = parser$4.parse(regexp, {
        captureLocations: true
      });
    }
    traverse2.traverse(ast, handlers2);
    return new TransformResult(ast);
  }
};
var compatTransforms = transforms$1;
var _transform$1 = transform$5;
var compatTranspiler$1 = {
  /**
   * Translates a regexp in new syntax to equivalent regexp in old syntax.
   *
   * @param string|RegExp|AST - regexp
   * @param Array transformsWhitelist - names of the transforms to apply
   */
  transform: function transform2(regexp) {
    var transformsWhitelist = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var transformToApply = transformsWhitelist.length > 0 ? transformsWhitelist : Object.keys(compatTransforms);
    var result = void 0;
    var extra = {};
    transformToApply.forEach(function(transformName) {
      if (!compatTransforms.hasOwnProperty(transformName)) {
        throw new Error("Unknown compat-transform: " + transformName + ". Available transforms are: " + Object.keys(compatTransforms).join(", "));
      }
      var handler = compatTransforms[transformName];
      result = _transform$1.transform(regexp, handler);
      regexp = result.getAST();
      if (typeof handler.getExtra === "function") {
        extra[transformName] = handler.getExtra();
      }
    });
    result.setExtra(extra);
    return result;
  }
};
var clone$1 = function clone(obj) {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  var res = void 0;
  if (Array.isArray(obj)) {
    res = [];
  } else {
    res = {};
  }
  for (var i in obj) {
    res[i] = clone(obj[i]);
  }
  return res;
};
var charSurrogatePairToSingleUnicodeTransform = {
  shouldRun: function shouldRun2(ast) {
    return ast.flags.includes("u");
  },
  Char: function Char4(path) {
    var node = path.node;
    if (node.kind !== "unicode" || !node.isSurrogatePair || isNaN(node.codePoint)) {
      return;
    }
    node.value = "\\u{" + node.codePoint.toString(16) + "}";
    delete node.isSurrogatePair;
  }
};
var UPPER_A_CP$1 = "A".codePointAt(0);
var UPPER_Z_CP$1 = "Z".codePointAt(0);
var LOWER_A_CP = "a".codePointAt(0);
var LOWER_Z_CP = "z".codePointAt(0);
var DIGIT_0_CP = "0".codePointAt(0);
var DIGIT_9_CP = "9".codePointAt(0);
var charCodeToSimpleCharTransform = {
  Char: function Char5(path) {
    var node = path.node, parent = path.parent;
    if (isNaN(node.codePoint) || node.kind === "simple") {
      return;
    }
    if (parent.type === "ClassRange") {
      if (!isSimpleRange(parent)) {
        return;
      }
    }
    if (!isPrintableASCIIChar(node.codePoint)) {
      return;
    }
    var symbol = String.fromCodePoint(node.codePoint);
    var newChar = {
      type: "Char",
      kind: "simple",
      value: symbol,
      symbol,
      codePoint: node.codePoint
    };
    if (needsEscape(symbol, parent.type)) {
      newChar.escaped = true;
    }
    path.replace(newChar);
  }
};
function isSimpleRange(classRange) {
  var from = classRange.from, to = classRange.to;
  return from.codePoint >= DIGIT_0_CP && from.codePoint <= DIGIT_9_CP && to.codePoint >= DIGIT_0_CP && to.codePoint <= DIGIT_9_CP || from.codePoint >= UPPER_A_CP$1 && from.codePoint <= UPPER_Z_CP$1 && to.codePoint >= UPPER_A_CP$1 && to.codePoint <= UPPER_Z_CP$1 || from.codePoint >= LOWER_A_CP && from.codePoint <= LOWER_Z_CP && to.codePoint >= LOWER_A_CP && to.codePoint <= LOWER_Z_CP;
}
function isPrintableASCIIChar(codePoint) {
  return codePoint >= 32 && codePoint <= 126;
}
function needsEscape(symbol, parentType) {
  if (parentType === "ClassRange" || parentType === "CharacterClass") {
    return /[\]\\^-]/.test(symbol);
  }
  return /[*[()+?^$./\\|{}]/.test(symbol);
}
var UPPER_A_CP = "A".codePointAt(0);
var UPPER_Z_CP = "Z".codePointAt(0);
var charCaseInsensitiveLowercaseTransform = {
  _AZClassRanges: null,
  _hasUFlag: false,
  init: function init2(ast) {
    this._AZClassRanges = /* @__PURE__ */ new Set();
    this._hasUFlag = ast.flags.includes("u");
  },
  shouldRun: function shouldRun3(ast) {
    return ast.flags.includes("i");
  },
  Char: function Char6(path) {
    var node = path.node, parent = path.parent;
    if (isNaN(node.codePoint)) {
      return;
    }
    if (!this._hasUFlag && node.codePoint >= 4096) {
      return;
    }
    if (parent.type === "ClassRange") {
      if (!this._AZClassRanges.has(parent) && !isAZClassRange(parent)) {
        return;
      }
      this._AZClassRanges.add(parent);
    }
    var lower = node.symbol.toLowerCase();
    if (lower !== node.symbol) {
      node.value = displaySymbolAsValue(lower, node);
      node.symbol = lower;
      node.codePoint = lower.codePointAt(0);
    }
  }
};
function isAZClassRange(classRange) {
  var from = classRange.from, to = classRange.to;
  return from.codePoint >= UPPER_A_CP && from.codePoint <= UPPER_Z_CP && to.codePoint >= UPPER_A_CP && to.codePoint <= UPPER_Z_CP;
}
function displaySymbolAsValue(symbol, node) {
  var codePoint = symbol.codePointAt(0);
  if (node.kind === "decimal") {
    return "\\" + codePoint;
  }
  if (node.kind === "oct") {
    return "\\0" + codePoint.toString(8);
  }
  if (node.kind === "hex") {
    return "\\x" + codePoint.toString(16);
  }
  if (node.kind === "unicode") {
    if (node.isSurrogatePair) {
      var _getSurrogatePairFrom = getSurrogatePairFromCodePoint(codePoint), lead = _getSurrogatePairFrom.lead, trail = _getSurrogatePairFrom.trail;
      return "\\u" + "0".repeat(4 - lead.length) + lead + "\\u" + "0".repeat(4 - trail.length) + trail;
    } else if (node.value.includes("{")) {
      return "\\u{" + codePoint.toString(16) + "}";
    } else {
      var code2 = codePoint.toString(16);
      return "\\u" + "0".repeat(4 - code2.length) + code2;
    }
  }
  return symbol;
}
function getSurrogatePairFromCodePoint(codePoint) {
  var lead = Math.floor((codePoint - 65536) / 1024) + 55296;
  var trail = (codePoint - 65536) % 1024 + 56320;
  return {
    lead: lead.toString(16),
    trail: trail.toString(16)
  };
}
var charClassRemoveDuplicatesTransform = {
  CharacterClass: function CharacterClass2(path) {
    var node = path.node;
    var sources = {};
    for (var i = 0; i < node.expressions.length; i++) {
      var childPath = path.getChild(i);
      var source = childPath.jsonEncode();
      if (sources.hasOwnProperty(source)) {
        childPath.remove();
        i--;
      }
      sources[source] = true;
    }
  }
};
function _toConsumableArray$7(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
function disjunctionToList$1(node) {
  if (node.type !== "Disjunction") {
    throw new TypeError('Expected "Disjunction" node, got "' + node.type + '"');
  }
  var list = [];
  if (node.left && node.left.type === "Disjunction") {
    list.push.apply(list, _toConsumableArray$7(disjunctionToList$1(node.left)).concat([node.right]));
  } else {
    list.push(node.left, node.right);
  }
  return list;
}
function listToDisjunction$1(list) {
  return list.reduce(function(left, right) {
    return {
      type: "Disjunction",
      left,
      right
    };
  });
}
function increaseQuantifierByOne$2(quantifier) {
  if (quantifier.kind === "*") {
    quantifier.kind = "+";
  } else if (quantifier.kind === "+") {
    quantifier.kind = "Range";
    quantifier.from = 2;
    delete quantifier.to;
  } else if (quantifier.kind === "?") {
    quantifier.kind = "Range";
    quantifier.from = 1;
    quantifier.to = 2;
  } else if (quantifier.kind === "Range") {
    quantifier.from += 1;
    if (quantifier.to) {
      quantifier.to += 1;
    }
  }
}
var utils = {
  disjunctionToList: disjunctionToList$1,
  listToDisjunction: listToDisjunction$1,
  increaseQuantifierByOne: increaseQuantifierByOne$2
};
var _require$8 = utils, increaseQuantifierByOne$1 = _require$8.increaseQuantifierByOne;
var quantifiersMergeTransform = {
  Repetition: function Repetition2(path) {
    var node = path.node, parent = path.parent;
    if (parent.type !== "Alternative" || !path.index) {
      return;
    }
    var previousSibling = path.getPreviousSibling();
    if (!previousSibling) {
      return;
    }
    if (previousSibling.node.type === "Repetition") {
      if (!previousSibling.getChild().hasEqualSource(path.getChild())) {
        return;
      }
      var _extractFromTo = extractFromTo(previousSibling.node.quantifier), previousSiblingFrom = _extractFromTo.from, previousSiblingTo = _extractFromTo.to;
      var _extractFromTo2 = extractFromTo(node.quantifier), nodeFrom = _extractFromTo2.from, nodeTo = _extractFromTo2.to;
      if (previousSibling.node.quantifier.greedy !== node.quantifier.greedy && !isGreedyOpenRange(previousSibling.node.quantifier) && !isGreedyOpenRange(node.quantifier)) {
        return;
      }
      node.quantifier.kind = "Range";
      node.quantifier.from = previousSiblingFrom + nodeFrom;
      if (previousSiblingTo && nodeTo) {
        node.quantifier.to = previousSiblingTo + nodeTo;
      } else {
        delete node.quantifier.to;
      }
      if (isGreedyOpenRange(previousSibling.node.quantifier) || isGreedyOpenRange(node.quantifier)) {
        node.quantifier.greedy = true;
      }
      previousSibling.remove();
    } else {
      if (!previousSibling.hasEqualSource(path.getChild())) {
        return;
      }
      increaseQuantifierByOne$1(node.quantifier);
      previousSibling.remove();
    }
  }
};
function isGreedyOpenRange(quantifier) {
  return quantifier.greedy && (quantifier.kind === "+" || quantifier.kind === "*" || quantifier.kind === "Range" && !quantifier.to);
}
function extractFromTo(quantifier) {
  var from = void 0, to = void 0;
  if (quantifier.kind === "*") {
    from = 0;
  } else if (quantifier.kind === "+") {
    from = 1;
  } else if (quantifier.kind === "?") {
    from = 0;
    to = 1;
  } else {
    from = quantifier.from;
    if (quantifier.to) {
      to = quantifier.to;
    }
  }
  return { from, to };
}
var quantifierRangeToSymbolTransform = {
  Quantifier: function Quantifier2(path) {
    var node = path.node;
    if (node.kind !== "Range") {
      return;
    }
    rewriteOpenZero(path);
    rewriteOpenOne(path);
    rewriteExactOne(path);
  }
};
function rewriteOpenZero(path) {
  var node = path.node;
  if (node.from !== 0 || node.to) {
    return;
  }
  node.kind = "*";
  delete node.from;
}
function rewriteOpenOne(path) {
  var node = path.node;
  if (node.from !== 1 || node.to) {
    return;
  }
  node.kind = "+";
  delete node.from;
}
function rewriteExactOne(path) {
  var node = path.node;
  if (node.from !== 1 || node.to !== 1) {
    return;
  }
  path.parentPath.replace(path.parentPath.node.expression);
}
var charClassClassrangesToCharsTransform = {
  ClassRange: function ClassRange2(path) {
    var node = path.node;
    if (node.from.codePoint === node.to.codePoint) {
      path.replace(node.from);
    } else if (node.from.codePoint === node.to.codePoint - 1) {
      path.getParent().insertChildAt(node.to, path.index + 1);
      path.replace(node.from);
    }
  }
};
function _toConsumableArray$6(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
var charClassToMetaTransform = {
  _hasIFlag: false,
  _hasUFlag: false,
  init: function init3(ast) {
    this._hasIFlag = ast.flags.includes("i");
    this._hasUFlag = ast.flags.includes("u");
  },
  CharacterClass: function CharacterClass3(path) {
    rewriteNumberRanges(path);
    rewriteWordRanges(path, this._hasIFlag, this._hasUFlag);
    rewriteWhitespaceRanges(path);
  }
};
function rewriteNumberRanges(path) {
  var node = path.node;
  node.expressions.forEach(function(expression, i) {
    if (isFullNumberRange(expression)) {
      path.getChild(i).replace({
        type: "Char",
        value: "\\d",
        kind: "meta"
      });
    }
  });
}
function rewriteWordRanges(path, hasIFlag, hasUFlag) {
  var node = path.node;
  var numberPath = null;
  var lowerCasePath = null;
  var upperCasePath = null;
  var underscorePath = null;
  var u017fPath = null;
  var u212aPath = null;
  node.expressions.forEach(function(expression, i) {
    if (isMetaChar(expression, "\\d")) {
      numberPath = path.getChild(i);
    } else if (isLowerCaseRange(expression)) {
      lowerCasePath = path.getChild(i);
    } else if (isUpperCaseRange(expression)) {
      upperCasePath = path.getChild(i);
    } else if (isUnderscore(expression)) {
      underscorePath = path.getChild(i);
    } else if (hasIFlag && hasUFlag && isCodePoint(expression, 383)) {
      u017fPath = path.getChild(i);
    } else if (hasIFlag && hasUFlag && isCodePoint(expression, 8490)) {
      u212aPath = path.getChild(i);
    }
  });
  if (numberPath && (lowerCasePath && upperCasePath || hasIFlag && (lowerCasePath || upperCasePath)) && underscorePath && (!hasUFlag || !hasIFlag || u017fPath && u212aPath)) {
    numberPath.replace({
      type: "Char",
      value: "\\w",
      kind: "meta"
    });
    if (lowerCasePath) {
      lowerCasePath.remove();
    }
    if (upperCasePath) {
      upperCasePath.remove();
    }
    underscorePath.remove();
    if (u017fPath) {
      u017fPath.remove();
    }
    if (u212aPath) {
      u212aPath.remove();
    }
  }
}
var whitespaceRangeTests = [function(node) {
  return isChar(node, " ");
}].concat(_toConsumableArray$6(["\\f", "\\n", "\\r", "\\t", "\\v"].map(function(char2) {
  return function(node) {
    return isMetaChar(node, char2);
  };
})), _toConsumableArray$6([160, 5760, 8232, 8233, 8239, 8287, 12288, 65279].map(function(codePoint) {
  return function(node) {
    return isCodePoint(node, codePoint);
  };
})), [function(node) {
  return node.type === "ClassRange" && isCodePoint(node.from, 8192) && isCodePoint(node.to, 8202);
}]);
function rewriteWhitespaceRanges(path) {
  var node = path.node;
  if (node.expressions.length < whitespaceRangeTests.length || !whitespaceRangeTests.every(function(test2) {
    return node.expressions.some(function(expression) {
      return test2(expression);
    });
  })) {
    return;
  }
  var nNode = node.expressions.find(function(expression) {
    return isMetaChar(expression, "\\n");
  });
  nNode.value = "\\s";
  nNode.symbol = void 0;
  nNode.codePoint = NaN;
  node.expressions.map(function(expression, i) {
    return whitespaceRangeTests.some(function(test2) {
      return test2(expression);
    }) ? path.getChild(i) : void 0;
  }).filter(Boolean).forEach(function(path2) {
    return path2.remove();
  });
}
function isFullNumberRange(node) {
  return node.type === "ClassRange" && node.from.value === "0" && node.to.value === "9";
}
function isChar(node, value) {
  var kind = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "simple";
  return node.type === "Char" && node.value === value && node.kind === kind;
}
function isMetaChar(node, value) {
  return isChar(node, value, "meta");
}
function isLowerCaseRange(node) {
  return node.type === "ClassRange" && node.from.value === "a" && node.to.value === "z";
}
function isUpperCaseRange(node) {
  return node.type === "ClassRange" && node.from.value === "A" && node.to.value === "Z";
}
function isUnderscore(node) {
  return node.type === "Char" && node.value === "_" && node.kind === "simple";
}
function isCodePoint(node, codePoint) {
  return node.type === "Char" && node.kind === "unicode" && node.codePoint === codePoint;
}
var charClassToSingleCharTransform = {
  CharacterClass: function CharacterClass4(path) {
    var node = path.node;
    if (node.expressions.length !== 1 || !hasAppropriateSiblings$1(path) || !isAppropriateChar(node.expressions[0])) {
      return;
    }
    var _node$expressions$ = node.expressions[0], value = _node$expressions$.value, kind = _node$expressions$.kind, escaped = _node$expressions$.escaped;
    if (node.negative) {
      if (!isMeta$1(value)) {
        return;
      }
      value = getInverseMeta(value);
    }
    path.replace({
      type: "Char",
      value,
      kind,
      escaped: escaped || shouldEscape(value)
    });
  }
};
function isAppropriateChar(node) {
  return node.type === "Char" && // We don't extract [\b] (backspace) since \b has different
  // semantics (word boundary).
  node.value !== "\\b";
}
function isMeta$1(value) {
  return /^\\[dwsDWS]$/.test(value);
}
function getInverseMeta(value) {
  return /[dws]/.test(value) ? value.toUpperCase() : value.toLowerCase();
}
function hasAppropriateSiblings$1(path) {
  var parent = path.parent, index2 = path.index;
  if (parent.type !== "Alternative") {
    return true;
  }
  var previousNode = parent.expressions[index2 - 1];
  if (previousNode == null) {
    return true;
  }
  if (previousNode.type === "Backreference" && previousNode.kind === "number") {
    return false;
  }
  if (previousNode.type === "Char" && previousNode.kind === "decimal") {
    return false;
  }
  return true;
}
function shouldEscape(value) {
  return /[*[()+?$./{}|]/.test(value);
}
var charEscapeUnescapeTransform = {
  _hasXFlag: false,
  init: function init4(ast) {
    this._hasXFlag = ast.flags.includes("x");
  },
  Char: function Char7(path) {
    var node = path.node;
    if (!node.escaped) {
      return;
    }
    if (shouldUnescape(path, this._hasXFlag)) {
      delete node.escaped;
    }
  }
};
function shouldUnescape(path, hasXFlag) {
  var value = path.node.value, index2 = path.index, parent = path.parent;
  if (parent.type !== "CharacterClass" && parent.type !== "ClassRange") {
    return !preservesEscape(value, index2, parent, hasXFlag);
  }
  return !preservesInCharClass(value, index2, parent);
}
function preservesInCharClass(value, index2, parent) {
  if (value === "^") {
    return index2 === 0 && !parent.negative;
  }
  if (value === "-") {
    return true;
  }
  return /[\]\\]/.test(value);
}
function preservesEscape(value, index2, parent, hasXFlag) {
  if (value === "{") {
    return preservesOpeningCurlyBraceEscape(index2, parent);
  }
  if (value === "}") {
    return preservesClosingCurlyBraceEscape(index2, parent);
  }
  if (hasXFlag && /[ #]/.test(value)) {
    return true;
  }
  return /[*[()+?^$./\\|]/.test(value);
}
function consumeNumbers(startIndex, parent, rtl) {
  var i = startIndex;
  var siblingNode = (rtl ? i >= 0 : i < parent.expressions.length) && parent.expressions[i];
  while (siblingNode && siblingNode.type === "Char" && siblingNode.kind === "simple" && !siblingNode.escaped && /\d/.test(siblingNode.value)) {
    rtl ? i-- : i++;
    siblingNode = (rtl ? i >= 0 : i < parent.expressions.length) && parent.expressions[i];
  }
  return Math.abs(startIndex - i);
}
function isSimpleChar(node, value) {
  return node && node.type === "Char" && node.kind === "simple" && !node.escaped && node.value === value;
}
function preservesOpeningCurlyBraceEscape(index2, parent) {
  if (index2 == null) {
    return false;
  }
  var nbFollowingNumbers = consumeNumbers(index2 + 1, parent);
  var i = index2 + nbFollowingNumbers + 1;
  var nextSiblingNode = i < parent.expressions.length && parent.expressions[i];
  if (nbFollowingNumbers) {
    if (isSimpleChar(nextSiblingNode, "}")) {
      return true;
    }
    if (isSimpleChar(nextSiblingNode, ",")) {
      nbFollowingNumbers = consumeNumbers(i + 1, parent);
      i = i + nbFollowingNumbers + 1;
      nextSiblingNode = i < parent.expressions.length && parent.expressions[i];
      return isSimpleChar(nextSiblingNode, "}");
    }
  }
  return false;
}
function preservesClosingCurlyBraceEscape(index2, parent) {
  if (index2 == null) {
    return false;
  }
  var nbPrecedingNumbers = consumeNumbers(index2 - 1, parent, true);
  var i = index2 - nbPrecedingNumbers - 1;
  var previousSiblingNode = i >= 0 && parent.expressions[i];
  if (nbPrecedingNumbers && isSimpleChar(previousSiblingNode, "{")) {
    return true;
  }
  if (isSimpleChar(previousSiblingNode, ",")) {
    nbPrecedingNumbers = consumeNumbers(i - 1, parent, true);
    i = i - nbPrecedingNumbers - 1;
    previousSiblingNode = i < parent.expressions.length && parent.expressions[i];
    return nbPrecedingNumbers && isSimpleChar(previousSiblingNode, "{");
  }
  return false;
}
var charClassClassrangesMergeTransform = {
  _hasIUFlags: false,
  init: function init5(ast) {
    this._hasIUFlags = ast.flags.includes("i") && ast.flags.includes("u");
  },
  CharacterClass: function CharacterClass5(path) {
    var node = path.node;
    var expressions = node.expressions;
    var metas = [];
    expressions.forEach(function(expression2) {
      if (isMeta(expression2)) {
        metas.push(expression2.value);
      }
    });
    expressions.sort(sortCharClass);
    for (var i = 0; i < expressions.length; i++) {
      var expression = expressions[i];
      if (fitsInMetas(expression, metas, this._hasIUFlags) || combinesWithPrecedingClassRange(expression, expressions[i - 1]) || combinesWithFollowingClassRange(expression, expressions[i + 1])) {
        expressions.splice(i, 1);
        i--;
      } else {
        var nbMergedChars = charCombinesWithPrecedingChars(expression, i, expressions);
        expressions.splice(i - nbMergedChars + 1, nbMergedChars);
        i -= nbMergedChars;
      }
    }
  }
};
function sortCharClass(a, b) {
  var aValue = getSortValue(a);
  var bValue = getSortValue(b);
  if (aValue === bValue) {
    if (a.type === "ClassRange" && b.type !== "ClassRange") {
      return -1;
    }
    if (b.type === "ClassRange" && a.type !== "ClassRange") {
      return 1;
    }
    if (a.type === "ClassRange" && b.type === "ClassRange") {
      return getSortValue(a.to) - getSortValue(b.to);
    }
    if (isMeta(a) && isMeta(b) || isControl(a) && isControl(b)) {
      return a.value < b.value ? -1 : 1;
    }
  }
  return aValue - bValue;
}
function getSortValue(expression) {
  if (expression.type === "Char") {
    if (expression.value === "-") {
      return Infinity;
    }
    if (expression.kind === "control") {
      return Infinity;
    }
    if (expression.kind === "meta" && isNaN(expression.codePoint)) {
      return -1;
    }
    return expression.codePoint;
  }
  return expression.from.codePoint;
}
function isMeta(expression) {
  var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  return expression.type === "Char" && expression.kind === "meta" && (value ? expression.value === value : /^\\[dws]$/i.test(expression.value));
}
function isControl(expression) {
  return expression.type === "Char" && expression.kind === "control";
}
function fitsInMetas(expression, metas, hasIUFlags) {
  for (var i = 0; i < metas.length; i++) {
    if (fitsInMeta(expression, metas[i], hasIUFlags)) {
      return true;
    }
  }
  return false;
}
function fitsInMeta(expression, meta, hasIUFlags) {
  if (expression.type === "ClassRange") {
    return fitsInMeta(expression.from, meta, hasIUFlags) && fitsInMeta(expression.to, meta, hasIUFlags);
  }
  if (meta === "\\S" && (isMeta(expression, "\\w") || isMeta(expression, "\\d"))) {
    return true;
  }
  if (meta === "\\D" && (isMeta(expression, "\\W") || isMeta(expression, "\\s"))) {
    return true;
  }
  if (meta === "\\w" && isMeta(expression, "\\d")) {
    return true;
  }
  if (meta === "\\W" && isMeta(expression, "\\s")) {
    return true;
  }
  if (expression.type !== "Char" || isNaN(expression.codePoint)) {
    return false;
  }
  if (meta === "\\s") {
    return fitsInMetaS(expression);
  }
  if (meta === "\\S") {
    return !fitsInMetaS(expression);
  }
  if (meta === "\\d") {
    return fitsInMetaD(expression);
  }
  if (meta === "\\D") {
    return !fitsInMetaD(expression);
  }
  if (meta === "\\w") {
    return fitsInMetaW(expression, hasIUFlags);
  }
  if (meta === "\\W") {
    return !fitsInMetaW(expression, hasIUFlags);
  }
  return false;
}
function fitsInMetaS(expression) {
  return expression.codePoint === 9 || // \t
  expression.codePoint === 10 || // \n
  expression.codePoint === 11 || // \v
  expression.codePoint === 12 || // \f
  expression.codePoint === 13 || // \r
  expression.codePoint === 32 || // space
  expression.codePoint === 160 || // nbsp
  expression.codePoint === 5760 || // part of Zs
  expression.codePoint >= 8192 && expression.codePoint <= 8202 || // part of Zs
  expression.codePoint === 8232 || // line separator
  expression.codePoint === 8233 || // paragraph separator
  expression.codePoint === 8239 || // part of Zs
  expression.codePoint === 8287 || // part of Zs
  expression.codePoint === 12288 || // part of Zs
  expression.codePoint === 65279;
}
function fitsInMetaD(expression) {
  return expression.codePoint >= 48 && expression.codePoint <= 57;
}
function fitsInMetaW(expression, hasIUFlags) {
  return fitsInMetaD(expression) || expression.codePoint >= 65 && expression.codePoint <= 90 || // A-Z
  expression.codePoint >= 97 && expression.codePoint <= 122 || // a-z
  expression.value === "_" || hasIUFlags && (expression.codePoint === 383 || expression.codePoint === 8490);
}
function combinesWithPrecedingClassRange(expression, classRange) {
  if (classRange && classRange.type === "ClassRange") {
    if (fitsInClassRange(expression, classRange)) {
      return true;
    } else if (
      // We only want \w chars or char codes to keep readability
      isMetaWCharOrCode(expression) && classRange.to.codePoint === expression.codePoint - 1
    ) {
      classRange.to = expression;
      return true;
    } else if (expression.type === "ClassRange" && expression.from.codePoint <= classRange.to.codePoint + 1 && expression.to.codePoint >= classRange.from.codePoint - 1) {
      if (expression.from.codePoint < classRange.from.codePoint) {
        classRange.from = expression.from;
      }
      if (expression.to.codePoint > classRange.to.codePoint) {
        classRange.to = expression.to;
      }
      return true;
    }
  }
  return false;
}
function combinesWithFollowingClassRange(expression, classRange) {
  if (classRange && classRange.type === "ClassRange") {
    if (
      // We only want \w chars or char codes to keep readability
      isMetaWCharOrCode(expression) && classRange.from.codePoint === expression.codePoint + 1
    ) {
      classRange.from = expression;
      return true;
    }
  }
  return false;
}
function fitsInClassRange(expression, classRange) {
  if (expression.type === "Char" && isNaN(expression.codePoint)) {
    return false;
  }
  if (expression.type === "ClassRange") {
    return fitsInClassRange(expression.from, classRange) && fitsInClassRange(expression.to, classRange);
  }
  return expression.codePoint >= classRange.from.codePoint && expression.codePoint <= classRange.to.codePoint;
}
function charCombinesWithPrecedingChars(expression, index2, expressions) {
  if (!isMetaWCharOrCode(expression)) {
    return 0;
  }
  var nbMergedChars = 0;
  while (index2 > 0) {
    var currentExpression = expressions[index2];
    var precedingExpresion = expressions[index2 - 1];
    if (isMetaWCharOrCode(precedingExpresion) && precedingExpresion.codePoint === currentExpression.codePoint - 1) {
      nbMergedChars++;
      index2--;
    } else {
      break;
    }
  }
  if (nbMergedChars > 1) {
    expressions[index2] = {
      type: "ClassRange",
      from: expressions[index2],
      to: expression
    };
    return nbMergedChars;
  }
  return 0;
}
function isMetaWCharOrCode(expression) {
  return expression && expression.type === "Char" && !isNaN(expression.codePoint) && (fitsInMetaW(expression, false) || expression.kind === "unicode" || expression.kind === "hex" || expression.kind === "oct" || expression.kind === "decimal");
}
var NodePath$1 = nodePath;
var _require$7 = utils, disjunctionToList = _require$7.disjunctionToList, listToDisjunction = _require$7.listToDisjunction;
var disjunctionRemoveDuplicatesTransform = {
  Disjunction: function Disjunction2(path) {
    var node = path.node;
    var uniqueNodesMap = {};
    var parts = disjunctionToList(node).filter(function(part) {
      var encoded = part ? NodePath$1.getForNode(part).jsonEncode() : "null";
      if (uniqueNodesMap.hasOwnProperty(encoded)) {
        return false;
      }
      uniqueNodesMap[encoded] = part;
      return true;
    });
    path.replace(listToDisjunction(parts));
  }
};
var groupSingleCharsToCharClass = {
  Disjunction: function Disjunction3(path) {
    var node = path.node, parent = path.parent;
    if (!handlers[parent.type]) {
      return;
    }
    var charset = /* @__PURE__ */ new Map();
    if (!shouldProcess(node, charset) || !charset.size) {
      return;
    }
    var characterClass = {
      type: "CharacterClass",
      expressions: Array.from(charset.keys()).sort().map(function(key) {
        return charset.get(key);
      })
    };
    handlers[parent.type](path.getParent(), characterClass);
  }
};
var handlers = {
  RegExp: function RegExp4(path, characterClass) {
    var node = path.node;
    node.body = characterClass;
  },
  Group: function Group3(path, characterClass) {
    var node = path.node;
    if (node.capturing) {
      node.expression = characterClass;
    } else {
      path.replace(characterClass);
    }
  }
};
function shouldProcess(expression, charset) {
  if (!expression) {
    return false;
  }
  var type2 = expression.type;
  if (type2 === "Disjunction") {
    var left = expression.left, right = expression.right;
    return shouldProcess(left, charset) && shouldProcess(right, charset);
  } else if (type2 === "Char") {
    if (expression.kind === "meta" && expression.symbol === ".") {
      return false;
    }
    var value = expression.value;
    charset.set(value, expression);
    return true;
  } else if (type2 === "CharacterClass" && !expression.negative) {
    return expression.expressions.every(function(expression2) {
      return shouldProcess(expression2, charset);
    });
  }
  return false;
}
var removeEmptyGroupTransform = {
  Group: function Group4(path) {
    var node = path.node, parent = path.parent;
    var childPath = path.getChild();
    if (node.capturing || childPath) {
      return;
    }
    if (parent.type === "Repetition") {
      path.getParent().replace(node);
    } else if (parent.type !== "RegExp") {
      path.remove();
    }
  }
};
function _toConsumableArray$5(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
var ungroupTransform = {
  Group: function Group5(path) {
    var node = path.node, parent = path.parent;
    var childPath = path.getChild();
    if (node.capturing || !childPath) {
      return;
    }
    if (!hasAppropriateSiblings(path)) {
      return;
    }
    if (childPath.node.type === "Disjunction" && parent.type !== "RegExp") {
      return;
    }
    if (parent.type === "Repetition" && childPath.node.type !== "Char" && childPath.node.type !== "CharacterClass") {
      return;
    }
    if (childPath.node.type === "Alternative") {
      var parentPath = path.getParent();
      if (parentPath.node.type === "Alternative") {
        parentPath.replace({
          type: "Alternative",
          expressions: [].concat(_toConsumableArray$5(parent.expressions.slice(0, path.index)), _toConsumableArray$5(childPath.node.expressions), _toConsumableArray$5(parent.expressions.slice(path.index + 1)))
        });
      }
    } else {
      path.replace(childPath.node);
    }
  }
};
function hasAppropriateSiblings(path) {
  var parent = path.parent, index2 = path.index;
  if (parent.type !== "Alternative") {
    return true;
  }
  var previousNode = parent.expressions[index2 - 1];
  if (previousNode == null) {
    return true;
  }
  if (previousNode.type === "Backreference" && previousNode.kind === "number") {
    return false;
  }
  if (previousNode.type === "Char" && previousNode.kind === "decimal") {
    return false;
  }
  return true;
}
function _toConsumableArray$4(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
var NodePath = nodePath;
var _require$6 = utils, increaseQuantifierByOne = _require$6.increaseQuantifierByOne;
var combineRepeatingPatternsTransform = {
  Alternative: function Alternative2(path) {
    var node = path.node;
    var index2 = 1;
    while (index2 < node.expressions.length) {
      var child = path.getChild(index2);
      index2 = Math.max(1, combineRepeatingPatternLeft(path, child, index2));
      if (index2 >= node.expressions.length) {
        break;
      }
      child = path.getChild(index2);
      index2 = Math.max(1, combineWithPreviousRepetition(path, child, index2));
      if (index2 >= node.expressions.length) {
        break;
      }
      child = path.getChild(index2);
      index2 = Math.max(1, combineRepetitionWithPrevious(path, child, index2));
      index2++;
    }
  }
};
function combineRepeatingPatternLeft(alternative, child, index2) {
  var node = alternative.node;
  var nbPossibleLengths = Math.ceil(index2 / 2);
  var i = 0;
  while (i < nbPossibleLengths) {
    var startIndex = index2 - 2 * i - 1;
    var right = void 0, left = void 0;
    if (i === 0) {
      right = child;
      left = alternative.getChild(startIndex);
    } else {
      right = NodePath.getForNode({
        type: "Alternative",
        expressions: [].concat(_toConsumableArray$4(node.expressions.slice(index2 - i, index2)), [child.node])
      });
      left = NodePath.getForNode({
        type: "Alternative",
        expressions: [].concat(_toConsumableArray$4(node.expressions.slice(startIndex, index2 - i)))
      });
    }
    if (right.hasEqualSource(left)) {
      for (var j = 0; j < 2 * i + 1; j++) {
        alternative.getChild(startIndex).remove();
      }
      child.replace({
        type: "Repetition",
        expression: i === 0 && right.node.type !== "Repetition" ? right.node : {
          type: "Group",
          capturing: false,
          expression: right.node
        },
        quantifier: {
          type: "Quantifier",
          kind: "Range",
          from: 2,
          to: 2,
          greedy: true
        }
      });
      return startIndex;
    }
    i++;
  }
  return index2;
}
function combineWithPreviousRepetition(alternative, child, index2) {
  var node = alternative.node;
  var i = 0;
  while (i < index2) {
    var previousChild = alternative.getChild(i);
    if (previousChild.node.type === "Repetition" && previousChild.node.quantifier.greedy) {
      var left = previousChild.getChild();
      var right = void 0;
      if (left.node.type === "Group" && !left.node.capturing) {
        left = left.getChild();
      }
      if (i + 1 === index2) {
        right = child;
        if (right.node.type === "Group" && !right.node.capturing) {
          right = right.getChild();
        }
      } else {
        right = NodePath.getForNode({
          type: "Alternative",
          expressions: [].concat(_toConsumableArray$4(node.expressions.slice(i + 1, index2 + 1)))
        });
      }
      if (left.hasEqualSource(right)) {
        for (var j = i; j < index2; j++) {
          alternative.getChild(i + 1).remove();
        }
        increaseQuantifierByOne(previousChild.node.quantifier);
        return i;
      }
    }
    i++;
  }
  return index2;
}
function combineRepetitionWithPrevious(alternative, child, index2) {
  var node = alternative.node;
  if (child.node.type === "Repetition" && child.node.quantifier.greedy) {
    var right = child.getChild();
    var left = void 0;
    if (right.node.type === "Group" && !right.node.capturing) {
      right = right.getChild();
    }
    var rightLength = void 0;
    if (right.node.type === "Alternative") {
      rightLength = right.node.expressions.length;
      left = NodePath.getForNode({
        type: "Alternative",
        expressions: [].concat(_toConsumableArray$4(node.expressions.slice(index2 - rightLength, index2)))
      });
    } else {
      rightLength = 1;
      left = alternative.getChild(index2 - 1);
      if (left.node.type === "Group" && !left.node.capturing) {
        left = left.getChild();
      }
    }
    if (left.hasEqualSource(right)) {
      for (var j = index2 - rightLength; j < index2; j++) {
        alternative.getChild(index2 - rightLength).remove();
      }
      increaseQuantifierByOne(child.node.quantifier);
      return index2 - rightLength;
    }
  }
  return index2;
}
var transforms = /* @__PURE__ */ new Map([
  // \ud83d\ude80 -> \u{1f680}
  ["charSurrogatePairToSingleUnicode", charSurrogatePairToSingleUnicodeTransform],
  // \u0061 -> a
  ["charCodeToSimpleChar", charCodeToSimpleCharTransform],
  // /Aa/i -> /aa/i
  ["charCaseInsensitiveLowerCaseTransform", charCaseInsensitiveLowercaseTransform],
  // [\d\d] -> [\d]
  ["charClassRemoveDuplicates", charClassRemoveDuplicatesTransform],
  // a{1,2}a{2,3} -> a{3,5}
  ["quantifiersMerge", quantifiersMergeTransform],
  // a{1,} -> a+, a{3,3} -> a{3}, a{1} -> a
  ["quantifierRangeToSymbol", quantifierRangeToSymbolTransform],
  // [a-a] -> [a], [a-b] -> [ab]
  ["charClassClassrangesToChars", charClassClassrangesToCharsTransform],
  // [0-9] -> [\d]
  ["charClassToMeta", charClassToMetaTransform],
  // [\d] -> \d, [^\w] -> \W
  ["charClassToSingleChar", charClassToSingleCharTransform],
  // \e -> e
  ["charEscapeUnescape", charEscapeUnescapeTransform],
  // [a-de-f] -> [a-f]
  ["charClassClassrangesMerge", charClassClassrangesMergeTransform],
  // (ab|ab) -> (ab)
  ["disjunctionRemoveDuplicates", disjunctionRemoveDuplicatesTransform],
  // (a|b|c) -> [abc]
  ["groupSingleCharsToCharClass", groupSingleCharsToCharClass],
  // (?:)a -> a
  ["removeEmptyGroup", removeEmptyGroupTransform],
  // (?:a) -> a
  ["ungroup", ungroupTransform],
  // abcabcabc -> (?:abc){3}
  ["combineRepeatingPatterns", combineRepeatingPatternsTransform]
]);
var clone2 = clone$1;
var parser$3 = parser$5;
var transform$4 = transform$5;
var optimizationTransforms = transforms;
var optimizer$1 = {
  /**
   * Optimizer transforms a regular expression into an optimized version,
   * replacing some sub-expressions with their idiomatic patterns.
   *
   * @param string | RegExp | AST - a regexp to optimize.
   *
   * @return TransformResult - an optimized regexp.
   *
   * Example:
   *
   *   /[a-zA-Z_0-9][a-zA-Z_0-9]*\e{1,}/
   *
   * Optimized to:
   *
   *   /\w+e+/
   */
  optimize: function optimize(regexp) {
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$whitelist = _ref.whitelist, whitelist = _ref$whitelist === void 0 ? [] : _ref$whitelist, _ref$blacklist = _ref.blacklist, blacklist = _ref$blacklist === void 0 ? [] : _ref$blacklist;
    var transformsRaw = whitelist.length > 0 ? whitelist : Array.from(optimizationTransforms.keys());
    var transformToApply = transformsRaw.filter(function(transform5) {
      return !blacklist.includes(transform5);
    });
    var ast = regexp;
    if (regexp instanceof RegExp) {
      regexp = "" + regexp;
    }
    if (typeof regexp === "string") {
      ast = parser$3.parse(regexp);
    }
    var result = new transform$4.TransformResult(ast);
    var prevResultString = void 0;
    do {
      prevResultString = result.toString();
      ast = clone2(result.getAST());
      transformToApply.forEach(function(transformName) {
        if (!optimizationTransforms.has(transformName)) {
          throw new Error("Unknown optimization-transform: " + transformName + ". Available transforms are: " + Array.from(optimizationTransforms.keys()).join(", "));
        }
        var transformer = optimizationTransforms.get(transformName);
        var newResult = transform$4.transform(ast, transformer);
        if (newResult.toString() !== result.toString()) {
          if (newResult.toString().length <= result.toString().length) {
            result = newResult;
          } else {
            ast = clone2(result.getAST());
          }
        }
      });
    } while (result.toString() !== prevResultString);
    return result;
  }
};
var EPSILON$3 = "";
var EPSILON_CLOSURE$2 = EPSILON$3 + "*";
var specialSymbols = {
  EPSILON: EPSILON$3,
  EPSILON_CLOSURE: EPSILON_CLOSURE$2
};
var _slicedToArray$1 = /* @__PURE__ */ function() {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"])
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  return function(arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
var _createClass$4 = /* @__PURE__ */ function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _toConsumableArray$3(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
function _classCallCheck$4(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var _require$5 = specialSymbols, EPSILON$2 = _require$5.EPSILON, EPSILON_CLOSURE$1 = _require$5.EPSILON_CLOSURE;
var NFA$2 = function() {
  function NFA2(inState, outState) {
    _classCallCheck$4(this, NFA2);
    this.in = inState;
    this.out = outState;
  }
  _createClass$4(NFA2, [{
    key: "matches",
    value: function matches(string) {
      return this.in.matches(string);
    }
    /**
     * Returns an alphabet for this NFA.
     */
  }, {
    key: "getAlphabet",
    value: function getAlphabet() {
      if (!this._alphabet) {
        this._alphabet = /* @__PURE__ */ new Set();
        var table2 = this.getTransitionTable();
        for (var state2 in table2) {
          var transitions = table2[state2];
          for (var symbol in transitions) {
            if (symbol !== EPSILON_CLOSURE$1) {
              this._alphabet.add(symbol);
            }
          }
        }
      }
      return this._alphabet;
    }
    /**
     * Returns set of accepting states.
     */
  }, {
    key: "getAcceptingStates",
    value: function getAcceptingStates() {
      if (!this._acceptingStates) {
        this.getTransitionTable();
      }
      return this._acceptingStates;
    }
    /**
     * Returns accepting state numbers.
     */
  }, {
    key: "getAcceptingStateNumbers",
    value: function getAcceptingStateNumbers() {
      if (!this._acceptingStateNumbers) {
        this._acceptingStateNumbers = /* @__PURE__ */ new Set();
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = this.getAcceptingStates()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var acceptingState = _step.value;
            this._acceptingStateNumbers.add(acceptingState.number);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
      return this._acceptingStateNumbers;
    }
    /**
     * Builds and returns transition table.
     */
  }, {
    key: "getTransitionTable",
    value: function getTransitionTable() {
      var _this = this;
      if (!this._transitionTable) {
        this._transitionTable = {};
        this._acceptingStates = /* @__PURE__ */ new Set();
        var visited = /* @__PURE__ */ new Set();
        var symbols = /* @__PURE__ */ new Set();
        var visitState = function visitState2(state2) {
          if (visited.has(state2)) {
            return;
          }
          visited.add(state2);
          state2.number = visited.size;
          _this._transitionTable[state2.number] = {};
          if (state2.accepting) {
            _this._acceptingStates.add(state2);
          }
          var transitions = state2.getTransitions();
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = transitions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var _ref = _step2.value;
              var _ref2 = _slicedToArray$1(_ref, 2);
              var symbol = _ref2[0];
              var symbolTransitions = _ref2[1];
              var combinedState = [];
              symbols.add(symbol);
              var _iteratorNormalCompletion3 = true;
              var _didIteratorError3 = false;
              var _iteratorError3 = void 0;
              try {
                for (var _iterator3 = symbolTransitions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                  var nextState = _step3.value;
                  visitState2(nextState);
                  combinedState.push(nextState.number);
                }
              } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion3 && _iterator3.return) {
                    _iterator3.return();
                  }
                } finally {
                  if (_didIteratorError3) {
                    throw _iteratorError3;
                  }
                }
              }
              _this._transitionTable[state2.number][symbol] = combinedState;
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        };
        visitState(this.in);
        visited.forEach(function(state2) {
          delete _this._transitionTable[state2.number][EPSILON$2];
          _this._transitionTable[state2.number][EPSILON_CLOSURE$1] = [].concat(_toConsumableArray$3(state2.getEpsilonClosure())).map(function(s) {
            return s.number;
          });
        });
      }
      return this._transitionTable;
    }
  }]);
  return NFA2;
}();
var nfa = NFA$2;
var _slicedToArray = /* @__PURE__ */ function() {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"])
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  return function(arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
function _toArray(arr) {
  return Array.isArray(arr) ? arr : Array.from(arr);
}
function _toConsumableArray$2(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
var currentTransitionMap = null;
function minimize(dfa2) {
  var table2 = dfa2.getTransitionTable();
  var allStates = Object.keys(table2);
  var alphabet2 = dfa2.getAlphabet();
  var accepting = dfa2.getAcceptingStateNumbers();
  currentTransitionMap = {};
  var nonAccepting = /* @__PURE__ */ new Set();
  allStates.forEach(function(state2) {
    state2 = Number(state2);
    var isAccepting = accepting.has(state2);
    if (isAccepting) {
      currentTransitionMap[state2] = accepting;
    } else {
      nonAccepting.add(state2);
      currentTransitionMap[state2] = nonAccepting;
    }
  });
  var all = [
    // 0-equivalent sets.
    [nonAccepting, accepting].filter(function(set3) {
      return set3.size > 0;
    })
  ];
  var current = void 0;
  var previous = void 0;
  current = all[all.length - 1];
  previous = all[all.length - 2];
  var _loop = function _loop2() {
    var newTransitionMap = {};
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = void 0;
    try {
      for (var _iterator3 = current[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var _set = _step3.value;
        var handledStates = {};
        var _set2 = _toArray(_set), first = _set2[0], rest = _set2.slice(1);
        handledStates[first] = /* @__PURE__ */ new Set([first]);
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = void 0;
        try {
          restSets:
            for (var _iterator4 = rest[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var state2 = _step4.value;
              var _iteratorNormalCompletion5 = true;
              var _didIteratorError5 = false;
              var _iteratorError5 = void 0;
              try {
                for (var _iterator5 = Object.keys(handledStates)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                  var handledState = _step5.value;
                  if (areEquivalent(state2, handledState, table2, alphabet2)) {
                    handledStates[handledState].add(state2);
                    handledStates[state2] = handledStates[handledState];
                    continue restSets;
                  }
                }
              } catch (err) {
                _didIteratorError5 = true;
                _iteratorError5 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion5 && _iterator5.return) {
                    _iterator5.return();
                  }
                } finally {
                  if (_didIteratorError5) {
                    throw _iteratorError5;
                  }
                }
              }
              handledStates[state2] = /* @__PURE__ */ new Set([state2]);
            }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
        Object.assign(newTransitionMap, handledStates);
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
    currentTransitionMap = newTransitionMap;
    var newSets = new Set(Object.keys(newTransitionMap).map(function(state3) {
      return newTransitionMap[state3];
    }));
    all.push([].concat(_toConsumableArray$2(newSets)));
    current = all[all.length - 1];
    previous = all[all.length - 2];
  };
  while (!sameRow(current, previous)) {
    _loop();
  }
  var remaped = /* @__PURE__ */ new Map();
  var idx = 1;
  current.forEach(function(set3) {
    return remaped.set(set3, idx++);
  });
  var minimizedTable = {};
  var minimizedAcceptingStates = /* @__PURE__ */ new Set();
  var updateAcceptingStates = function updateAcceptingStates2(set3, idx2) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = void 0;
    try {
      for (var _iterator = set3[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var state2 = _step.value;
        if (accepting.has(state2)) {
          minimizedAcceptingStates.add(idx2);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  };
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = void 0;
  try {
    for (var _iterator2 = remaped.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _ref = _step2.value;
      var _ref2 = _slicedToArray(_ref, 2);
      var set2 = _ref2[0];
      var _idx = _ref2[1];
      minimizedTable[_idx] = {};
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = void 0;
      try {
        for (var _iterator6 = alphabet2[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var symbol = _step6.value;
          updateAcceptingStates(set2, _idx);
          var originalTransition = void 0;
          var _iteratorNormalCompletion7 = true;
          var _didIteratorError7 = false;
          var _iteratorError7 = void 0;
          try {
            for (var _iterator7 = set2[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
              var originalState = _step7.value;
              originalTransition = table2[originalState][symbol];
              if (originalTransition) {
                break;
              }
            }
          } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion7 && _iterator7.return) {
                _iterator7.return();
              }
            } finally {
              if (_didIteratorError7) {
                throw _iteratorError7;
              }
            }
          }
          if (originalTransition) {
            minimizedTable[_idx][symbol] = remaped.get(currentTransitionMap[originalTransition]);
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
  dfa2.setTransitionTable(minimizedTable);
  dfa2.setAcceptingStateNumbers(minimizedAcceptingStates);
  return dfa2;
}
function sameRow(r1, r2) {
  if (!r2) {
    return false;
  }
  if (r1.length !== r2.length) {
    return false;
  }
  for (var i = 0; i < r1.length; i++) {
    var s1 = r1[i];
    var s2 = r2[i];
    if (s1.size !== s2.size) {
      return false;
    }
    if ([].concat(_toConsumableArray$2(s1)).sort().join(",") !== [].concat(_toConsumableArray$2(s2)).sort().join(",")) {
      return false;
    }
  }
  return true;
}
function areEquivalent(s1, s2, table2, alphabet2) {
  var _iteratorNormalCompletion8 = true;
  var _didIteratorError8 = false;
  var _iteratorError8 = void 0;
  try {
    for (var _iterator8 = alphabet2[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
      var symbol = _step8.value;
      if (!goToSameSet(s1, s2, table2, symbol)) {
        return false;
      }
    }
  } catch (err) {
    _didIteratorError8 = true;
    _iteratorError8 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion8 && _iterator8.return) {
        _iterator8.return();
      }
    } finally {
      if (_didIteratorError8) {
        throw _iteratorError8;
      }
    }
  }
  return true;
}
function goToSameSet(s1, s2, table2, symbol) {
  if (!currentTransitionMap[s1] || !currentTransitionMap[s2]) {
    return false;
  }
  var originalTransitionS1 = table2[s1][symbol];
  var originalTransitionS2 = table2[s2][symbol];
  if (!originalTransitionS1 && !originalTransitionS2) {
    return true;
  }
  return currentTransitionMap[s1].has(originalTransitionS1) && currentTransitionMap[s2].has(originalTransitionS2);
}
var dfaMinimizer = {
  minimize
};
var _createClass$3 = /* @__PURE__ */ function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _toConsumableArray$1(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
function _classCallCheck$3(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var DFAMinimizer = dfaMinimizer;
var _require$4 = specialSymbols, EPSILON_CLOSURE = _require$4.EPSILON_CLOSURE;
var DFA$1 = function() {
  function DFA2(nfa2) {
    _classCallCheck$3(this, DFA2);
    this._nfa = nfa2;
  }
  _createClass$3(DFA2, [{
    key: "minimize",
    value: function minimize2() {
      this.getTransitionTable();
      this._originalAcceptingStateNumbers = this._acceptingStateNumbers;
      this._originalTransitionTable = this._transitionTable;
      DFAMinimizer.minimize(this);
    }
    /**
     * Returns alphabet for this DFA.
     */
  }, {
    key: "getAlphabet",
    value: function getAlphabet() {
      return this._nfa.getAlphabet();
    }
    /**
     * Returns accepting states.
     */
  }, {
    key: "getAcceptingStateNumbers",
    value: function getAcceptingStateNumbers() {
      if (!this._acceptingStateNumbers) {
        this.getTransitionTable();
      }
      return this._acceptingStateNumbers;
    }
    /**
     * Returns original accepting states.
     */
  }, {
    key: "getOriginaAcceptingStateNumbers",
    value: function getOriginaAcceptingStateNumbers() {
      if (!this._originalAcceptingStateNumbers) {
        this.getTransitionTable();
      }
      return this._originalAcceptingStateNumbers;
    }
    /**
     * Sets transition table.
     */
  }, {
    key: "setTransitionTable",
    value: function setTransitionTable(table2) {
      this._transitionTable = table2;
    }
    /**
     * Sets accepting states.
     */
  }, {
    key: "setAcceptingStateNumbers",
    value: function setAcceptingStateNumbers(stateNumbers) {
      this._acceptingStateNumbers = stateNumbers;
    }
    /**
     * DFA transition table is built from NFA table.
     */
  }, {
    key: "getTransitionTable",
    value: function getTransitionTable() {
      var _this = this;
      if (this._transitionTable) {
        return this._transitionTable;
      }
      var nfaTable = this._nfa.getTransitionTable();
      var nfaStates = Object.keys(nfaTable);
      this._acceptingStateNumbers = /* @__PURE__ */ new Set();
      var startState = nfaTable[nfaStates[0]][EPSILON_CLOSURE];
      var worklist = [startState];
      var alphabet2 = this.getAlphabet();
      var nfaAcceptingStates = this._nfa.getAcceptingStateNumbers();
      var dfaTable = {};
      var updateAcceptingStates = function updateAcceptingStates2(states2) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = nfaAcceptingStates[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var nfaAcceptingState = _step.value;
            if (states2.indexOf(nfaAcceptingState) !== -1) {
              _this._acceptingStateNumbers.add(states2.join(","));
              break;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      };
      while (worklist.length > 0) {
        var states = worklist.shift();
        var dfaStateLabel = states.join(",");
        dfaTable[dfaStateLabel] = {};
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = void 0;
        try {
          for (var _iterator2 = alphabet2[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var symbol = _step2.value;
            var onSymbol = [];
            updateAcceptingStates(states);
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = void 0;
            try {
              for (var _iterator3 = states[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var state2 = _step3.value;
                var nfaStatesOnSymbol = nfaTable[state2][symbol];
                if (!nfaStatesOnSymbol) {
                  continue;
                }
                var _iteratorNormalCompletion4 = true;
                var _didIteratorError4 = false;
                var _iteratorError4 = void 0;
                try {
                  for (var _iterator4 = nfaStatesOnSymbol[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    var nfaStateOnSymbol = _step4.value;
                    if (!nfaTable[nfaStateOnSymbol]) {
                      continue;
                    }
                    onSymbol.push.apply(onSymbol, _toConsumableArray$1(nfaTable[nfaStateOnSymbol][EPSILON_CLOSURE]));
                  }
                } catch (err) {
                  _didIteratorError4 = true;
                  _iteratorError4 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
                      _iterator4.return();
                    }
                  } finally {
                    if (_didIteratorError4) {
                      throw _iteratorError4;
                    }
                  }
                }
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }
            var dfaStatesOnSymbolSet = new Set(onSymbol);
            var dfaStatesOnSymbol = [].concat(_toConsumableArray$1(dfaStatesOnSymbolSet));
            if (dfaStatesOnSymbol.length > 0) {
              var dfaOnSymbolStr = dfaStatesOnSymbol.join(",");
              dfaTable[dfaStateLabel][symbol] = dfaOnSymbolStr;
              if (!dfaTable.hasOwnProperty(dfaOnSymbolStr)) {
                worklist.unshift(dfaStatesOnSymbol);
              }
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
      return this._transitionTable = this._remapStateNumbers(dfaTable);
    }
    /**
     * Remaps state numbers in the resulting table:
     * combined states '1,2,3' -> 1, '3,4' -> 2, etc.
     */
  }, {
    key: "_remapStateNumbers",
    value: function _remapStateNumbers(calculatedDFATable) {
      var newStatesMap = {};
      this._originalTransitionTable = calculatedDFATable;
      var transitionTable = {};
      Object.keys(calculatedDFATable).forEach(function(originalNumber2, newNumber) {
        newStatesMap[originalNumber2] = newNumber + 1;
      });
      for (var originalNumber in calculatedDFATable) {
        var originalRow = calculatedDFATable[originalNumber];
        var row = {};
        for (var symbol in originalRow) {
          row[symbol] = newStatesMap[originalRow[symbol]];
        }
        transitionTable[newStatesMap[originalNumber]] = row;
      }
      this._originalAcceptingStateNumbers = this._acceptingStateNumbers;
      this._acceptingStateNumbers = /* @__PURE__ */ new Set();
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = void 0;
      try {
        for (var _iterator5 = this._originalAcceptingStateNumbers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var _originalNumber = _step5.value;
          this._acceptingStateNumbers.add(newStatesMap[_originalNumber]);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
      return transitionTable;
    }
    /**
     * Returns original DFA table, where state numbers
     * are combined numbers from NFA.
     */
  }, {
    key: "getOriginalTransitionTable",
    value: function getOriginalTransitionTable() {
      if (!this._originalTransitionTable) {
        this.getTransitionTable();
      }
      return this._originalTransitionTable;
    }
    /**
     * Checks whether this DFA accepts a string.
     */
  }, {
    key: "matches",
    value: function matches(string) {
      var state2 = 1;
      var i = 0;
      var table2 = this.getTransitionTable();
      while (string[i]) {
        state2 = table2[state2][string[i++]];
        if (!state2) {
          return false;
        }
      }
      if (!this.getAcceptingStateNumbers().has(state2)) {
        return false;
      }
      return true;
    }
  }]);
  return DFA2;
}();
var dfa = DFA$1;
var _createClass$2 = /* @__PURE__ */ function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$2(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var State$1 = function() {
  function State2() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$accepting = _ref.accepting, accepting = _ref$accepting === void 0 ? false : _ref$accepting;
    _classCallCheck$2(this, State2);
    this._transitions = /* @__PURE__ */ new Map();
    this.accepting = accepting;
  }
  _createClass$2(State2, [{
    key: "getTransitions",
    value: function getTransitions() {
      return this._transitions;
    }
    /**
     * Creates a transition on symbol.
     */
  }, {
    key: "addTransition",
    value: function addTransition(symbol, toState) {
      this.getTransitionsOnSymbol(symbol).add(toState);
      return this;
    }
    /**
     * Returns transitions set on symbol.
     */
  }, {
    key: "getTransitionsOnSymbol",
    value: function getTransitionsOnSymbol(symbol) {
      var transitions = this._transitions.get(symbol);
      if (!transitions) {
        transitions = /* @__PURE__ */ new Set();
        this._transitions.set(symbol, transitions);
      }
      return transitions;
    }
  }]);
  return State2;
}();
var state = State$1;
var _createClass$1 = /* @__PURE__ */ function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$1(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var State = state;
var _require$3 = specialSymbols, EPSILON$1 = _require$3.EPSILON;
var NFAState$1 = function(_State) {
  _inherits(NFAState2, _State);
  function NFAState2() {
    _classCallCheck$1(this, NFAState2);
    return _possibleConstructorReturn(this, (NFAState2.__proto__ || Object.getPrototypeOf(NFAState2)).apply(this, arguments));
  }
  _createClass$1(NFAState2, [{
    key: "matches",
    /**
     * Whether this state matches a string.
     *
     * We maintain set of visited epsilon-states to avoid infinite loops
     * when an epsilon-transition goes eventually to itself.
     *
     * NOTE: this function is rather "educational", since we use DFA for strings
     * matching. DFA is built on top of NFA, and uses fast transition table.
     */
    value: function matches(string) {
      var visited = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new Set();
      if (visited.has(this)) {
        return false;
      }
      visited.add(this);
      if (string.length === 0) {
        if (this.accepting) {
          return true;
        }
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = this.getTransitionsOnSymbol(EPSILON$1)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var nextState = _step.value;
            if (nextState.matches("", visited)) {
              return true;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        return false;
      }
      var symbol = string[0];
      var rest = string.slice(1);
      var symbolTransitions = this.getTransitionsOnSymbol(symbol);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = void 0;
      try {
        for (var _iterator2 = symbolTransitions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _nextState = _step2.value;
          if (_nextState.matches(rest)) {
            return true;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = void 0;
      try {
        for (var _iterator3 = this.getTransitionsOnSymbol(EPSILON$1)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _nextState2 = _step3.value;
          if (_nextState2.matches(string, visited)) {
            return true;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
      return false;
    }
    /**
     * Returns an -closure for this state:
     * self + all states following -transitions.
     */
  }, {
    key: "getEpsilonClosure",
    value: function getEpsilonClosure() {
      var _this2 = this;
      if (!this._epsilonClosure) {
        (function() {
          var epsilonTransitions = _this2.getTransitionsOnSymbol(EPSILON$1);
          var closure = _this2._epsilonClosure = /* @__PURE__ */ new Set();
          closure.add(_this2);
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = void 0;
          try {
            for (var _iterator4 = epsilonTransitions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var nextState = _step4.value;
              if (!closure.has(nextState)) {
                closure.add(nextState);
                var nextClosure = nextState.getEpsilonClosure();
                nextClosure.forEach(function(state2) {
                  return closure.add(state2);
                });
              }
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4.return) {
                _iterator4.return();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }
        })();
      }
      return this._epsilonClosure;
    }
  }]);
  return NFAState2;
}(State);
var nfaState = NFAState$1;
var NFA$1 = nfa;
var NFAState = nfaState;
var _require$2 = specialSymbols, EPSILON = _require$2.EPSILON;
function char$1(c) {
  var inState = new NFAState();
  var outState = new NFAState({
    accepting: true
  });
  return new NFA$1(inState.addTransition(c, outState), outState);
}
function e() {
  return char$1(EPSILON);
}
function altPair(first, second) {
  first.out.accepting = false;
  second.out.accepting = true;
  first.out.addTransition(EPSILON, second.in);
  return new NFA$1(first.in, second.out);
}
function alt$1(first) {
  for (var _len = arguments.length, fragments = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    fragments[_key - 1] = arguments[_key];
  }
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = void 0;
  try {
    for (var _iterator = fragments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var fragment = _step.value;
      first = altPair(first, fragment);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
  return first;
}
function orPair(first, second) {
  var inState = new NFAState();
  var outState = new NFAState();
  inState.addTransition(EPSILON, first.in);
  inState.addTransition(EPSILON, second.in);
  outState.accepting = true;
  first.out.accepting = false;
  second.out.accepting = false;
  first.out.addTransition(EPSILON, outState);
  second.out.addTransition(EPSILON, outState);
  return new NFA$1(inState, outState);
}
function or$1(first) {
  for (var _len2 = arguments.length, fragments = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    fragments[_key2 - 1] = arguments[_key2];
  }
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = void 0;
  try {
    for (var _iterator2 = fragments[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var fragment = _step2.value;
      first = orPair(first, fragment);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
  return first;
}
function repExplicit(fragment) {
  var inState = new NFAState();
  var outState = new NFAState({
    accepting: true
  });
  inState.addTransition(EPSILON, fragment.in);
  inState.addTransition(EPSILON, outState);
  fragment.out.accepting = false;
  fragment.out.addTransition(EPSILON, outState);
  outState.addTransition(EPSILON, fragment.in);
  return new NFA$1(inState, outState);
}
function rep$1(fragment) {
  fragment.in.addTransition(EPSILON, fragment.out);
  fragment.out.addTransition(EPSILON, fragment.in);
  return fragment;
}
function plusRep$1(fragment) {
  fragment.out.addTransition(EPSILON, fragment.in);
  return fragment;
}
function questionRep$1(fragment) {
  fragment.in.addTransition(EPSILON, fragment.out);
  return fragment;
}
var builders$1 = {
  alt: alt$1,
  char: char$1,
  e,
  or: or$1,
  rep: rep$1,
  repExplicit,
  plusRep: plusRep$1,
  questionRep: questionRep$1
};
function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
var parser$2 = parser$5;
var _require$1 = builders$1, alt = _require$1.alt, char = _require$1.char, or = _require$1.or, rep = _require$1.rep, plusRep = _require$1.plusRep, questionRep = _require$1.questionRep;
function gen(node) {
  if (node && !generator$1[node.type]) {
    throw new Error(node.type + " is not supported in NFA/DFA interpreter.");
  }
  return node ? generator$1[node.type](node) : "";
}
var generator$1 = {
  RegExp: function RegExp5(node) {
    if (node.flags !== "") {
      throw new Error("NFA/DFA: Flags are not supported yet.");
    }
    return gen(node.body);
  },
  Alternative: function Alternative3(node) {
    var fragments = (node.expressions || []).map(gen);
    return alt.apply(void 0, _toConsumableArray(fragments));
  },
  Disjunction: function Disjunction4(node) {
    return or(gen(node.left), gen(node.right));
  },
  Repetition: function Repetition3(node) {
    switch (node.quantifier.kind) {
      case "*":
        return rep(gen(node.expression));
      case "+":
        return plusRep(gen(node.expression));
      case "?":
        return questionRep(gen(node.expression));
      default:
        throw new Error("Unknown repeatition: " + node.quantifier.kind + ".");
    }
  },
  Char: function Char8(node) {
    if (node.kind !== "simple") {
      throw new Error("NFA/DFA: Only simple chars are supported yet.");
    }
    return char(node.value);
  },
  Group: function Group6(node) {
    return gen(node.expression);
  }
};
var nfaFromRegexp = {
  /**
   * Builds an NFA from the passed regexp.
   */
  build: function build(regexp) {
    var ast = regexp;
    if (regexp instanceof RegExp) {
      regexp = "" + regexp;
    }
    if (typeof regexp === "string") {
      ast = parser$2.parse(regexp, {
        captureLocations: true
      });
    }
    return gen(ast);
  }
};
var NFA = nfa;
var DFA = dfa;
var nfaFromRegExp = nfaFromRegexp;
var builders = builders$1;
var finiteAutomaton = {
  /**
   * Export NFA and DFA classes.
   */
  NFA,
  DFA,
  /**
   * Expose builders.
   */
  builders,
  /**
   * Builds an NFA for the passed regexp.
   *
   * @param string | AST | RegExp:
   *
   *   a regular expression in different representations: a string,
   *   a RegExp object, or an AST.
   */
  toNFA: function toNFA(regexp) {
    return nfaFromRegExp.build(regexp);
  },
  /**
   * Builds DFA for the passed regexp.
   *
   * @param string | AST | RegExp:
   *
   *   a regular expression in different representations: a string,
   *   a RegExp object, or an AST.
   */
  toDFA: function toDFA(regexp) {
    return new DFA(this.toNFA(regexp));
  },
  /**
   * Returns true if regexp accepts the string.
   */
  test: function test(regexp, string) {
    return this.toDFA(regexp).matches(string);
  }
};
var _createClass = /* @__PURE__ */ function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var RegExpTree$1 = function() {
  function RegExpTree2(re, _ref) {
    var flags = _ref.flags, groups = _ref.groups, source = _ref.source;
    _classCallCheck(this, RegExpTree2);
    this._re = re;
    this._groups = groups;
    this.flags = flags;
    this.source = source || re.source;
    this.dotAll = flags.includes("s");
    this.global = re.global;
    this.ignoreCase = re.ignoreCase;
    this.multiline = re.multiline;
    this.sticky = re.sticky;
    this.unicode = re.unicode;
  }
  _createClass(RegExpTree2, [{
    key: "test",
    value: function test2(string) {
      return this._re.test(string);
    }
    /**
     * Facade wrapper for RegExp `compile` method.
     */
  }, {
    key: "compile",
    value: function compile2(string) {
      return this._re.compile(string);
    }
    /**
     * Facade wrapper for RegExp `toString` method.
     */
  }, {
    key: "toString",
    value: function toString2() {
      if (!this._toStringResult) {
        this._toStringResult = "/" + this.source + "/" + this.flags;
      }
      return this._toStringResult;
    }
    /**
     * Facade wrapper for RegExp `exec` method.
     */
  }, {
    key: "exec",
    value: function exec2(string) {
      var result = this._re.exec(string);
      if (!this._groups || !result) {
        return result;
      }
      result.groups = {};
      for (var group in this._groups) {
        var groupNumber = this._groups[group];
        result.groups[group] = result[groupNumber];
      }
      return result;
    }
  }]);
  return RegExpTree2;
}();
var runtime = {
  RegExpTree: RegExpTree$1
};
var compatTranspiler = compatTranspiler$1;
var generator = generator_1;
var optimizer = optimizer$1;
var parser$1 = parser$5;
var _transform = transform$5;
var _traverse = traverse$1;
var fa = finiteAutomaton;
var _require = runtime, RegExpTree = _require.RegExpTree;
var regexpTree$3 = {
  /**
   * Parser module exposed.
   */
  parser: parser$1,
  /**
   * Expose finite-automaton module.
   */
  fa,
  /**
   * `TransformResult` exposed.
   */
  TransformResult: _transform.TransformResult,
  /**
   * Parses a regexp string, producing an AST.
   *
   * @param string regexp
   *
   *   a regular expression in different formats: string, AST, RegExp.
   *
   * @param Object options
   *
   *   parsing options for this parse call. Default are:
   *
   *     - captureLocations: boolean
   *     - any other custom options
   *
   * @return Object AST
   */
  parse: function parse2(regexp, options) {
    return parser$1.parse("" + regexp, options);
  },
  /**
   * Traverses a RegExp AST.
   *
   * @param Object ast
   * @param Object | Array<Object> handlers
   *
   * Each `handler` is an object containing handler function for needed
   * node types. Example:
   *
   *   regexpTree.traverse(ast, {
   *     onChar(node) {
   *       ...
   *     },
   *   });
   *
   * The value for a node type may also be an object with functions pre and post.
   * This enables more context-aware analyses, e.g. measuring star height.
   */
  traverse: function traverse3(ast, handlers2, options) {
    return _traverse.traverse(ast, handlers2, options);
  },
  /**
   * Transforms a regular expression.
   *
   * A regexp can be passed in different formats (string, regexp or AST),
   * applying a set of transformations. It is a convenient wrapper
   * on top of "parse-traverse-generate" tool chain.
   *
   * @param string | AST | RegExp regexp - a regular expression;
   * @param Object | Array<Object> handlers - a list of handlers.
   *
   * @return TransformResult - a transformation result.
   */
  transform: function transform3(regexp, handlers2) {
    return _transform.transform(regexp, handlers2);
  },
  /**
   * Generates a RegExp string from an AST.
   *
   * @param Object ast
   *
   * Invariant:
   *
   *   regexpTree.generate(regexpTree.parse('/[a-z]+/i')); // '/[a-z]+/i'
   */
  generate: function generate(ast) {
    return generator.generate(ast);
  },
  /**
   * Creates a RegExp object from a regexp string.
   *
   * @param string regexp
   */
  toRegExp: function toRegExp(regexp) {
    var compat = this.compatTranspile(regexp);
    return new RegExp(compat.getSource(), compat.getFlags());
  },
  /**
   * Optimizes a regular expression by replacing some
   * sub-expressions with their idiomatic patterns.
   *
   * @param string regexp
   *
   * @return TransformResult object
   */
  optimize: function optimize2(regexp, whitelist) {
    var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, blacklist = _ref.blacklist;
    return optimizer.optimize(regexp, { whitelist, blacklist });
  },
  /**
   * Translates a regular expression in new syntax or in new format
   * into equivalent expressions in old syntax.
   *
   * @param string regexp
   *
   * @return TransformResult object
   */
  compatTranspile: function compatTranspile(regexp, whitelist) {
    return compatTranspiler.transform(regexp, whitelist);
  },
  /**
   * Executes a regular expression on a string.
   *
   * @param RegExp|string re - a regular expression.
   * @param string string - a testing string.
   */
  exec: function exec(re, string) {
    if (typeof re === "string") {
      var compat = this.compatTranspile(re);
      var extra = compat.getExtra();
      if (extra.namedCapturingGroups) {
        re = new RegExpTree(compat.toRegExp(), {
          flags: compat.getFlags(),
          source: compat.getSource(),
          groups: extra.namedCapturingGroups
        });
      } else {
        re = compat.toRegExp();
      }
    }
    return re.exec(string);
  }
};
var regexpTree_1 = regexpTree$3;
var regexpTree$2 = regexpTree_1;
const regexpTree$1 = regexpTree$2;
const analyzer$1 = analyzer$2;
class HeuristicAnalyzer extends analyzer$1.Analyzer {
  constructor(analyzerOptions) {
    super(analyzerOptions);
  }
  isVulnerable(regExp) {
    const starHeight = this._measureStarHeight(regExp);
    if (starHeight > 1) {
      return true;
    }
    const nRepetitions = this._measureRepetitions(regExp);
    if (nRepetitions > this.options.heuristic_replimit) {
      return true;
    }
    return false;
  }
  genAttackString(regExp) {
    return null;
  }
  _measureStarHeight(regExp) {
    let currentStarHeight = 0;
    let maxObservedStarHeight = 0;
    const ast = regexpTree$1.parse(regExp);
    regexpTree$1.traverse(ast, {
      Repetition: {
        pre({ node }) {
          currentStarHeight++;
          if (maxObservedStarHeight < currentStarHeight) {
            maxObservedStarHeight = currentStarHeight;
          }
        },
        post({ node }) {
          currentStarHeight--;
        }
      }
    });
    return maxObservedStarHeight;
  }
  _measureRepetitions(regExp) {
    let nRepetitions = 0;
    const ast = regexpTree$1.parse(regExp);
    regexpTree$1.traverse(ast, {
      Repetition: {
        pre({ node }) {
          nRepetitions++;
        }
      }
    });
    return nRepetitions;
  }
}
var heuristicAnalyzer$1 = HeuristicAnalyzer;
const heuristicAnalyzer = heuristicAnalyzer$1;
var analyzerFamily$1 = [heuristicAnalyzer];
const analyzer = analyzer$2;
const analyzerFamily = analyzerFamily$1;
const DEFAULT_SAFE_REP_LIMIT = 25;
const RET_IS_SAFE = true;
const RET_IS_VULNERABLE = false;
class Args {
  constructor(regExp, analyzerOptions) {
    this.regExp = regExp;
    this.analyzerOptions = analyzerOptions;
  }
}
function safeRegex(re, opts) {
  try {
    const args = buildArgs(re, opts);
    const analyzerResponses = askAnalyzersIfVulnerable(args);
    if (analyzerResponses.find((isVulnerable) => isVulnerable)) {
      return RET_IS_VULNERABLE;
    } else {
      return RET_IS_SAFE;
    }
  } catch (err) {
    return false;
  }
}
function buildArgs(re, opts) {
  if (!opts)
    opts = {};
  const heuristic_replimit = opts.limit === void 0 ? DEFAULT_SAFE_REP_LIMIT : opts.limit;
  const analyzerOptions = new analyzer.AnalyzerOptions(heuristic_replimit);
  let regExp = null;
  if (re instanceof RegExp) {
    regExp = re;
  } else if (typeof re === "string") {
    regExp = new RegExp(re);
  } else {
    regExp = new RegExp(String(re));
  }
  return new Args(regExp, analyzerOptions);
}
function askAnalyzersIfVulnerable(args) {
  let analyzerSaysVulnerable = [];
  let Analyzer2;
  for (Analyzer2 of analyzerFamily) {
    try {
      const analyzer2 = new Analyzer2(args.analyzerOptions);
      analyzerSaysVulnerable.push(analyzer2.isVulnerable(args.regExp));
    } catch (err) {
      analyzerSaysVulnerable.push(false);
    }
  }
  return analyzerSaysVulnerable;
}
var safeRegex_1 = safeRegex;
const safe = /* @__PURE__ */ getDefaultExportFromCjs(safeRegex_1);
var objectPath$1 = { exports: {} };
(function(module) {
  (function(root, factory2) {
    {
      module.exports = factory2();
    }
  })(commonjsGlobal, function() {
    var toStr = Object.prototype.toString, _hasOwnProperty = Object.prototype.hasOwnProperty;
    function isEmpty2(value) {
      if (!value) {
        return true;
      }
      if (isArray2(value) && value.length === 0) {
        return true;
      } else {
        for (var i in value) {
          if (_hasOwnProperty.call(value, i)) {
            return false;
          }
        }
        return true;
      }
    }
    function toString2(type2) {
      return toStr.call(type2);
    }
    function isNumber2(value) {
      return typeof value === "number" || toString2(value) === "[object Number]";
    }
    function isString2(obj) {
      return typeof obj === "string" || toString2(obj) === "[object String]";
    }
    function isObject2(obj) {
      return typeof obj === "object" && toString2(obj) === "[object Object]";
    }
    function isArray2(obj) {
      return typeof obj === "object" && typeof obj.length === "number" && toString2(obj) === "[object Array]";
    }
    function isBoolean2(obj) {
      return typeof obj === "boolean" || toString2(obj) === "[object Boolean]";
    }
    function getKey(key) {
      var intKey = parseInt(key);
      if (intKey.toString() === key) {
        return intKey;
      }
      return key;
    }
    function set2(obj, path, value, doNotReplace) {
      if (isNumber2(path)) {
        path = [path];
      }
      if (isEmpty2(path)) {
        return obj;
      }
      if (isString2(path)) {
        return set2(obj, path.split("."), value, doNotReplace);
      }
      var currentPath = getKey(path[0]);
      if (path.length === 1) {
        var oldVal = obj[currentPath];
        if (oldVal === void 0 || !doNotReplace) {
          obj[currentPath] = value;
        }
        return oldVal;
      }
      if (obj[currentPath] === void 0) {
        if (isNumber2(currentPath)) {
          obj[currentPath] = [];
        } else {
          obj[currentPath] = {};
        }
      }
      return set2(obj[currentPath], path.slice(1), value, doNotReplace);
    }
    function del(obj, path) {
      if (isNumber2(path)) {
        path = [path];
      }
      if (isEmpty2(obj)) {
        return void 0;
      }
      if (isEmpty2(path)) {
        return obj;
      }
      if (isString2(path)) {
        return del(obj, path.split("."));
      }
      var currentPath = getKey(path[0]);
      var oldVal = obj[currentPath];
      if (path.length === 1) {
        if (oldVal !== void 0) {
          if (isArray2(obj)) {
            obj.splice(currentPath, 1);
          } else {
            delete obj[currentPath];
          }
        }
      } else {
        if (obj[currentPath] !== void 0) {
          return del(obj[currentPath], path.slice(1));
        }
      }
      return obj;
    }
    var objectPath2 = {};
    objectPath2.ensureExists = function(obj, path, value) {
      return set2(obj, path, value, true);
    };
    objectPath2.set = function(obj, path, value, doNotReplace) {
      return set2(obj, path, value, doNotReplace);
    };
    objectPath2.insert = function(obj, path, value, at) {
      var arr = objectPath2.get(obj, path);
      at = ~~at;
      if (!isArray2(arr)) {
        arr = [];
        objectPath2.set(obj, path, arr);
      }
      arr.splice(at, 0, value);
    };
    objectPath2.empty = function(obj, path) {
      if (isEmpty2(path)) {
        return obj;
      }
      if (isEmpty2(obj)) {
        return void 0;
      }
      var value, i;
      if (!(value = objectPath2.get(obj, path))) {
        return obj;
      }
      if (isString2(value)) {
        return objectPath2.set(obj, path, "");
      } else if (isBoolean2(value)) {
        return objectPath2.set(obj, path, false);
      } else if (isNumber2(value)) {
        return objectPath2.set(obj, path, 0);
      } else if (isArray2(value)) {
        value.length = 0;
      } else if (isObject2(value)) {
        for (i in value) {
          if (_hasOwnProperty.call(value, i)) {
            delete value[i];
          }
        }
      } else {
        return objectPath2.set(obj, path, null);
      }
    };
    objectPath2.push = function(obj, path) {
      var arr = objectPath2.get(obj, path);
      if (!isArray2(arr)) {
        arr = [];
        objectPath2.set(obj, path, arr);
      }
      arr.push.apply(arr, Array.prototype.slice.call(arguments, 2));
    };
    objectPath2.coalesce = function(obj, paths, defaultValue) {
      var value;
      for (var i = 0, len = paths.length; i < len; i++) {
        if ((value = objectPath2.get(obj, paths[i])) !== void 0) {
          return value;
        }
      }
      return defaultValue;
    };
    objectPath2.get = function(obj, path, defaultValue) {
      if (isNumber2(path)) {
        path = [path];
      }
      if (isEmpty2(path)) {
        return obj;
      }
      if (isEmpty2(obj)) {
        return defaultValue;
      }
      if (isString2(path)) {
        return objectPath2.get(obj, path.split("."), defaultValue);
      }
      var currentPath = getKey(path[0]);
      if (path.length === 1) {
        if (obj[currentPath] === void 0) {
          return defaultValue;
        }
        return obj[currentPath];
      }
      return objectPath2.get(obj[currentPath], path.slice(1), defaultValue);
    };
    objectPath2.del = function(obj, path) {
      return del(obj, path);
    };
    return objectPath2;
  });
})(objectPath$1);
var objectPathExports = objectPath$1.exports;
var objectPath = objectPathExports;
var sortBy;
var sort;
var type;
type = function(type2) {
  return function(arg) {
    return typeof arg === type2;
  };
};
sort = function sort2(property, map) {
  var sortOrder = 1;
  var apply2 = map || function(_, value) {
    return value;
  };
  if (property[0] === "-") {
    sortOrder = -1;
    property = property.substr(1);
  }
  return function fn(a, b) {
    var result;
    var am = apply2(property, objectPath.get(a, property));
    var bm = apply2(property, objectPath.get(b, property));
    if (am < bm)
      result = -1;
    if (am > bm)
      result = 1;
    if (am === bm)
      result = 0;
    return result * sortOrder;
  };
};
sortBy = function sortBy2() {
  var args = Array.prototype.slice.call(arguments);
  var properties = args.filter(type("string"));
  var map = args.filter(type("function"))[0];
  return function fn(obj1, obj2) {
    var numberOfProperties = properties.length, result = 0, i = 0;
    while (result === 0 && i < numberOfProperties) {
      result = sort(properties[i], map)(obj1, obj2);
      i++;
    }
    return result;
  };
};
var sortBy_1 = sortBy;
const sortby = /* @__PURE__ */ getDefaultExportFromCjs(sortBy_1);
var twig_core;
var hasRequiredTwig_core;
function requireTwig_core() {
  if (hasRequiredTwig_core)
    return twig_core;
  hasRequiredTwig_core = 1;
  twig_core = function(Twig2) {
    Twig2.trace = false;
    Twig2.debug = false;
    Twig2.cache = true;
    Twig2.noop = function() {
    };
    Twig2.merge = function(target, source, onlyChanged) {
      Object.keys(source).forEach((key) => {
        if (onlyChanged && !(key in target)) {
          return;
        }
        target[key] = source[key];
      });
      return target;
    };
    Twig2.Error = function(message, file) {
      this.message = message;
      this.name = "TwigException";
      this.type = "TwigException";
      this.file = file;
    };
    Twig2.Error.prototype.toString = function() {
      const output = this.name + ": " + this.message;
      return output;
    };
    Twig2.log = {
      trace(...args) {
        if (Twig2.trace && console) {
          console.log(Array.prototype.slice.call(args));
        }
      },
      debug(...args) {
        if (Twig2.debug && console) {
          console.log(Array.prototype.slice.call(args));
        }
      }
    };
    if (typeof console === "undefined") {
      Twig2.log.error = function() {
      };
    } else if (typeof console.error !== "undefined") {
      Twig2.log.error = function(...args) {
        console.error(...args);
      };
    } else if (typeof console.log !== "undefined") {
      Twig2.log.error = function(...args) {
        console.log(...args);
      };
    }
    Twig2.token = {};
    Twig2.token.type = {
      output: "output",
      logic: "logic",
      comment: "comment",
      raw: "raw",
      outputWhitespacePre: "output_whitespace_pre",
      outputWhitespacePost: "output_whitespace_post",
      outputWhitespaceBoth: "output_whitespace_both",
      logicWhitespacePre: "logic_whitespace_pre",
      logicWhitespacePost: "logic_whitespace_post",
      logicWhitespaceBoth: "logic_whitespace_both"
    };
    Twig2.token.definitions = [
      {
        type: Twig2.token.type.raw,
        open: "{% raw %}",
        close: "{% endraw %}"
      },
      {
        type: Twig2.token.type.raw,
        open: "{% verbatim %}",
        close: "{% endverbatim %}"
      },
      // *Whitespace type tokens*
      //
      // These typically take the form `{{- expression -}}` or `{{- expression }}` or `{{ expression -}}`.
      {
        type: Twig2.token.type.outputWhitespacePre,
        open: "{{-",
        close: "}}"
      },
      {
        type: Twig2.token.type.outputWhitespacePost,
        open: "{{",
        close: "-}}"
      },
      {
        type: Twig2.token.type.outputWhitespaceBoth,
        open: "{{-",
        close: "-}}"
      },
      {
        type: Twig2.token.type.logicWhitespacePre,
        open: "{%-",
        close: "%}"
      },
      {
        type: Twig2.token.type.logicWhitespacePost,
        open: "{%",
        close: "-%}"
      },
      {
        type: Twig2.token.type.logicWhitespaceBoth,
        open: "{%-",
        close: "-%}"
      },
      // *Output type tokens*
      //
      // These typically take the form `{{ expression }}`.
      {
        type: Twig2.token.type.output,
        open: "{{",
        close: "}}"
      },
      // *Logic type tokens*
      //
      // These typically take a form like `{% if expression %}` or `{% endif %}`
      {
        type: Twig2.token.type.logic,
        open: "{%",
        close: "%}"
      },
      // *Comment type tokens*
      //
      // These take the form `{# anything #}`
      {
        type: Twig2.token.type.comment,
        open: "{#",
        close: "#}"
      }
    ];
    Twig2.token.strings = ['"', "'"];
    Twig2.token.findStart = function(template) {
      const output = {
        position: null,
        def: null
      };
      let closePosition = null;
      const len = Twig2.token.definitions.length;
      let i;
      let tokenTemplate;
      let firstKeyPosition;
      let closeKeyPosition;
      for (i = 0; i < len; i++) {
        tokenTemplate = Twig2.token.definitions[i];
        firstKeyPosition = template.indexOf(tokenTemplate.open);
        closeKeyPosition = template.indexOf(tokenTemplate.close);
        Twig2.log.trace("Twig.token.findStart: ", "Searching for ", tokenTemplate.open, " found at ", firstKeyPosition);
        if (firstKeyPosition >= 0) {
          if (tokenTemplate.open.length !== tokenTemplate.close.length) {
            if (closeKeyPosition < 0) {
              continue;
            }
          }
        }
        if (firstKeyPosition >= 0 && (output.position === null || firstKeyPosition < output.position)) {
          output.position = firstKeyPosition;
          output.def = tokenTemplate;
          closePosition = closeKeyPosition;
        } else if (firstKeyPosition >= 0 && output.position !== null && firstKeyPosition === output.position) {
          if (tokenTemplate.open.length > output.def.open.length) {
            output.position = firstKeyPosition;
            output.def = tokenTemplate;
            closePosition = closeKeyPosition;
          } else if (tokenTemplate.open.length === output.def.open.length) {
            if (tokenTemplate.close.length > output.def.close.length) {
              if (closeKeyPosition >= 0 && closeKeyPosition < closePosition) {
                output.position = firstKeyPosition;
                output.def = tokenTemplate;
                closePosition = closeKeyPosition;
              }
            } else if (closeKeyPosition >= 0 && closeKeyPosition < closePosition) {
              output.position = firstKeyPosition;
              output.def = tokenTemplate;
              closePosition = closeKeyPosition;
            }
          }
        }
      }
      return output;
    };
    Twig2.token.findEnd = function(template, tokenDef, start) {
      let end = null;
      let found = false;
      let offset2 = 0;
      let strPos = null;
      let strFound = null;
      let pos = null;
      let endOffset = null;
      let thisStrPos = null;
      let endStrPos = null;
      let i;
      let l;
      while (!found) {
        strPos = null;
        strFound = null;
        pos = template.indexOf(tokenDef.close, offset2);
        if (pos >= 0) {
          end = pos;
          found = true;
        } else {
          throw new Twig2.Error("Unable to find closing bracket '" + tokenDef.close + "' opened near template position " + start);
        }
        if (tokenDef.type === Twig2.token.type.comment) {
          break;
        }
        if (tokenDef.type === Twig2.token.type.raw) {
          break;
        }
        l = Twig2.token.strings.length;
        for (i = 0; i < l; i += 1) {
          thisStrPos = template.indexOf(Twig2.token.strings[i], offset2);
          if (thisStrPos > 0 && thisStrPos < pos && (strPos === null || thisStrPos < strPos)) {
            strPos = thisStrPos;
            strFound = Twig2.token.strings[i];
          }
        }
        if (strPos !== null) {
          endOffset = strPos + 1;
          end = null;
          found = false;
          for (; ; ) {
            endStrPos = template.indexOf(strFound, endOffset);
            if (endStrPos < 0) {
              throw Twig2.Error("Unclosed string in template");
            }
            if (template.slice(endStrPos - 1, endStrPos) === "\\") {
              endOffset = endStrPos + 1;
            } else {
              offset2 = endStrPos + 1;
              break;
            }
          }
        }
      }
      return end;
    };
    Twig2.tokenize = function(template) {
      const tokens2 = [];
      let currentPosition = 0;
      let foundToken = null;
      let end = null;
      while (template.length > 0) {
        foundToken = Twig2.token.findStart(template);
        Twig2.log.trace("Twig.tokenize: ", "Found token: ", foundToken);
        if (foundToken.position === null) {
          tokens2.push({
            type: Twig2.token.type.raw,
            value: template,
            position: {
              start: currentPosition,
              end: currentPosition + foundToken.position
            }
          });
          template = "";
        } else {
          if (foundToken.position > 0) {
            tokens2.push({
              type: Twig2.token.type.raw,
              value: template.slice(0, Math.max(0, foundToken.position)),
              position: {
                start: currentPosition,
                end: currentPosition + Math.max(0, foundToken.position)
              }
            });
          }
          template = template.slice(foundToken.position + foundToken.def.open.length);
          currentPosition += foundToken.position + foundToken.def.open.length;
          end = Twig2.token.findEnd(template, foundToken.def, currentPosition);
          Twig2.log.trace("Twig.tokenize: ", "Token ends at ", end);
          tokens2.push({
            type: foundToken.def.type,
            value: template.slice(0, Math.max(0, end)).trim(),
            position: {
              start: currentPosition - foundToken.def.open.length,
              end: currentPosition + end + foundToken.def.close.length
            }
          });
          if (template.slice(end + foundToken.def.close.length, end + foundToken.def.close.length + 1) === "\n") {
            switch (foundToken.def.type) {
              case "logic_whitespace_pre":
              case "logic_whitespace_post":
              case "logic_whitespace_both":
              case "logic":
                end += 1;
                break;
            }
          }
          template = template.slice(end + foundToken.def.close.length);
          currentPosition += end + foundToken.def.close.length;
        }
      }
      return tokens2;
    };
    Twig2.compile = function(tokens2) {
      const self2 = this;
      try {
        const output = [];
        const stack2 = [];
        let intermediateOutput = [];
        let token = null;
        let logicToken = null;
        let unclosedToken = null;
        let prevToken = null;
        let prevOutput = null;
        let prevIntermediateOutput = null;
        let prevTemplate = null;
        let nextToken = null;
        let tokOutput = null;
        let type2 = null;
        let open = null;
        let next = null;
        const compileOutput = function(token2) {
          Twig2.expression.compile.call(self2, token2);
          if (stack2.length > 0) {
            intermediateOutput.push(token2);
          } else {
            output.push(token2);
          }
        };
        const compileLogic = function(token2) {
          logicToken = Twig2.logic.compile.call(self2, token2);
          logicToken.position = token2.position;
          type2 = logicToken.type;
          open = Twig2.logic.handler[type2].open;
          next = Twig2.logic.handler[type2].next;
          Twig2.log.trace(
            "Twig.compile: ",
            "Compiled logic token to ",
            logicToken,
            " next is: ",
            next,
            " open is : ",
            open
          );
          if (open !== void 0 && !open) {
            prevToken = stack2.pop();
            prevTemplate = Twig2.logic.handler[prevToken.type];
            if (!prevTemplate.next.includes(type2)) {
              throw new Error(type2 + " not expected after a " + prevToken.type);
            }
            prevToken.output = prevToken.output || [];
            prevToken.output = prevToken.output.concat(intermediateOutput);
            intermediateOutput = [];
            tokOutput = {
              type: Twig2.token.type.logic,
              token: prevToken,
              position: {
                open: prevToken.position,
                close: token2.position
              }
            };
            if (stack2.length > 0) {
              intermediateOutput.push(tokOutput);
            } else {
              output.push(tokOutput);
            }
          }
          if (next !== void 0 && next.length > 0) {
            Twig2.log.trace("Twig.compile: ", "Pushing ", logicToken, " to logic stack.");
            if (stack2.length > 0) {
              prevToken = stack2.pop();
              prevToken.output = prevToken.output || [];
              prevToken.output = prevToken.output.concat(intermediateOutput);
              stack2.push(prevToken);
              intermediateOutput = [];
            }
            stack2.push(logicToken);
          } else if (open !== void 0 && open) {
            tokOutput = {
              type: Twig2.token.type.logic,
              token: logicToken,
              position: logicToken.position
            };
            if (stack2.length > 0) {
              intermediateOutput.push(tokOutput);
            } else {
              output.push(tokOutput);
            }
          }
        };
        while (tokens2.length > 0) {
          token = tokens2.shift();
          prevOutput = output[output.length - 1];
          prevIntermediateOutput = intermediateOutput[intermediateOutput.length - 1];
          nextToken = tokens2[0];
          Twig2.log.trace("Compiling token ", token);
          switch (token.type) {
            case Twig2.token.type.raw:
              if (stack2.length > 0) {
                intermediateOutput.push(token);
              } else {
                output.push(token);
              }
              break;
            case Twig2.token.type.logic:
              compileLogic.call(self2, token);
              break;
            case Twig2.token.type.comment:
              break;
            case Twig2.token.type.output:
              compileOutput.call(self2, token);
              break;
            case Twig2.token.type.logicWhitespacePre:
            case Twig2.token.type.logicWhitespacePost:
            case Twig2.token.type.logicWhitespaceBoth:
            case Twig2.token.type.outputWhitespacePre:
            case Twig2.token.type.outputWhitespacePost:
            case Twig2.token.type.outputWhitespaceBoth:
              if (token.type !== Twig2.token.type.outputWhitespacePost && token.type !== Twig2.token.type.logicWhitespacePost) {
                if (prevOutput) {
                  if (prevOutput.type === Twig2.token.type.raw) {
                    output.pop();
                    prevOutput.value = prevOutput.value.trimEnd();
                    output.push(prevOutput);
                  }
                }
                if (prevIntermediateOutput) {
                  if (prevIntermediateOutput.type === Twig2.token.type.raw) {
                    intermediateOutput.pop();
                    prevIntermediateOutput.value = prevIntermediateOutput.value.trimEnd();
                    intermediateOutput.push(prevIntermediateOutput);
                  }
                }
              }
              switch (token.type) {
                case Twig2.token.type.outputWhitespacePre:
                case Twig2.token.type.outputWhitespacePost:
                case Twig2.token.type.outputWhitespaceBoth:
                  compileOutput.call(self2, token);
                  break;
                case Twig2.token.type.logicWhitespacePre:
                case Twig2.token.type.logicWhitespacePost:
                case Twig2.token.type.logicWhitespaceBoth:
                  compileLogic.call(self2, token);
                  break;
                default:
                  break;
              }
              if (token.type !== Twig2.token.type.outputWhitespacePre && token.type !== Twig2.token.type.logicWhitespacePre) {
                if (nextToken) {
                  if (nextToken.type === Twig2.token.type.raw) {
                    tokens2.shift();
                    nextToken.value = nextToken.value.trimStart();
                    tokens2.unshift(nextToken);
                  }
                }
              }
              break;
            default:
              break;
          }
          Twig2.log.trace(
            "Twig.compile: ",
            " Output: ",
            output,
            " Logic Stack: ",
            stack2,
            " Pending Output: ",
            intermediateOutput
          );
        }
        if (stack2.length > 0) {
          unclosedToken = stack2.pop();
          throw new Error("Unable to find an end tag for " + unclosedToken.type + ", expecting one of " + unclosedToken.next);
        }
        return output;
      } catch (error) {
        if (self2.options.rethrow) {
          if (error.type === "TwigException" && !error.file) {
            error.file = self2.id;
          }
          throw error;
        } else {
          Twig2.log.error("Error compiling twig template " + self2.id + ": ");
          if (error.stack) {
            Twig2.log.error(error.stack);
          } else {
            Twig2.log.error(error.toString());
          }
        }
      }
    };
    function handleException(state2, ex) {
      if (state2.template.options.rethrow) {
        if (typeof ex === "string") {
          ex = new Twig2.Error(ex);
        }
        if (ex.type === "TwigException" && !ex.file) {
          ex.file = state2.template.id;
        }
        throw ex;
      } else {
        Twig2.log.error("Error parsing twig template " + state2.template.id + ": ");
        if (ex.stack) {
          Twig2.log.error(ex.stack);
        } else {
          Twig2.log.error(ex.toString());
        }
        if (Twig2.debug) {
          return ex.toString();
        }
      }
    }
    Twig2.prepare = function(data) {
      Twig2.log.debug("Twig.prepare: ", "Tokenizing ", data);
      const rawTokens = Twig2.tokenize.call(this, data);
      Twig2.log.debug("Twig.prepare: ", "Compiling ", rawTokens);
      const tokens2 = Twig2.compile.call(this, rawTokens);
      Twig2.log.debug("Twig.prepare: ", "Compiled ", tokens2);
      return tokens2;
    };
    Twig2.output = function(output) {
      const { autoescape } = this.options;
      if (!autoescape) {
        return output.join("");
      }
      const strategy = typeof autoescape === "string" ? autoescape : "html";
      const escapedOutput = output.map((str) => {
        if (str && (str.twigMarkup !== true && str.twigMarkup !== strategy) && !(strategy === "html" && str.twigMarkup === "html_attr")) {
          str = Twig2.filters.escape(str, [strategy]);
        }
        return str;
      });
      if (escapedOutput.length === 0) {
        return "";
      }
      const joinedOutput = escapedOutput.join("");
      if (joinedOutput.length === 0) {
        return "";
      }
      return new Twig2.Markup(joinedOutput, true);
    };
    Twig2.Templates = {
      /**
       * Registered template loaders - use Twig.Templates.registerLoader to add supported loaders
       * @type {Object}
       */
      loaders: {},
      /**
       * Registered template parsers - use Twig.Templates.registerParser to add supported parsers
       * @type {Object}
       */
      parsers: {},
      /**
       * Cached / loaded templates
       * @type {Object}
       */
      registry: {}
    };
    Twig2.validateId = function(id) {
      if (id === "prototype") {
        throw new Twig2.Error(id + " is not a valid twig identifier");
      } else if (Twig2.cache && Object.hasOwnProperty.call(Twig2.Templates.registry, id)) {
        throw new Twig2.Error("There is already a template with the ID " + id);
      }
      return true;
    };
    Twig2.Templates.registerLoader = function(methodName, func, scope) {
      if (typeof func !== "function") {
        throw new Twig2.Error("Unable to add loader for " + methodName + ": Invalid function reference given.");
      }
      if (scope) {
        func = func.bind(scope);
      }
      this.loaders[methodName] = func;
    };
    Twig2.Templates.unRegisterLoader = function(methodName) {
      if (this.isRegisteredLoader(methodName)) {
        delete this.loaders[methodName];
      }
    };
    Twig2.Templates.isRegisteredLoader = function(methodName) {
      return Object.hasOwnProperty.call(this.loaders, methodName);
    };
    Twig2.Templates.registerParser = function(methodName, func, scope) {
      if (typeof func !== "function") {
        throw new Twig2.Error("Unable to add parser for " + methodName + ": Invalid function regerence given.");
      }
      if (scope) {
        func = func.bind(scope);
      }
      this.parsers[methodName] = func;
    };
    Twig2.Templates.unRegisterParser = function(methodName) {
      if (this.isRegisteredParser(methodName)) {
        delete this.parsers[methodName];
      }
    };
    Twig2.Templates.isRegisteredParser = function(methodName) {
      return Object.hasOwnProperty.call(this.parsers, methodName);
    };
    Twig2.Templates.save = function(template) {
      if (template.id === void 0) {
        throw new Twig2.Error("Unable to save template with no id");
      }
      Twig2.Templates.registry[template.id] = template;
    };
    Twig2.Templates.load = function(id) {
      if (!Object.hasOwnProperty.call(Twig2.Templates.registry, id)) {
        return null;
      }
      return Twig2.Templates.registry[id];
    };
    Twig2.Templates.loadRemote = function(location2, params, callback, errorCallback) {
      const id = typeof params.id === "undefined" ? location2 : params.id;
      const cached = Twig2.Templates.registry[id];
      if (Twig2.cache && typeof cached !== "undefined") {
        if (typeof callback === "function") {
          callback(cached);
        }
        return cached;
      }
      params.parser = params.parser || "twig";
      params.id = id;
      if (typeof params.async === "undefined") {
        params.async = true;
      }
      const loader = this.loaders[params.method] || this.loaders.fs;
      return loader.call(this, location2, params, callback, errorCallback);
    };
    function is(type2, obj) {
      const clas = Object.prototype.toString.call(obj).slice(8, -1);
      return obj !== void 0 && obj !== null && clas === type2;
    }
    Twig2.Block = function(template, token) {
      this.template = template;
      this.token = token;
    };
    Twig2.Block.prototype.render = function(parseState, context) {
      const originalTemplate = parseState.template;
      let promise;
      parseState.template = this.template;
      if (this.token.expression) {
        promise = Twig2.expression.parseAsync.call(parseState, this.token.output, context);
      } else {
        promise = parseState.parseAsync(this.token.output, context);
      }
      return promise.then((value) => {
        return Twig2.expression.parseAsync.call(
          parseState,
          {
            type: Twig2.expression.type.string,
            value
          },
          context
        );
      }).then((output) => {
        parseState.template = originalTemplate;
        return output;
      });
    };
    Twig2.ParseState = function(template, blockOverrides, context) {
      this.renderedBlocks = {};
      this.overrideBlocks = blockOverrides === void 0 ? {} : blockOverrides;
      this.context = context === void 0 ? {} : context;
      this.macros = {};
      this.nestingStack = [];
      this.template = template;
    };
    Twig2.ParseState.prototype.getBlock = function(name, checkOnlyInheritedBlocks) {
      let block;
      if (checkOnlyInheritedBlocks !== true) {
        block = this.overrideBlocks[name];
      }
      if (block === void 0) {
        block = this.template.getBlock(name, checkOnlyInheritedBlocks);
      }
      if (block === void 0 && this.template.parentTemplate !== null) {
        block = this.template.parentTemplate.getBlock(name);
      }
      return block;
    };
    Twig2.ParseState.prototype.getBlocks = function(includeParentBlocks) {
      let blocks = {};
      if (includeParentBlocks !== false && this.template.parentTemplate !== null && // Prevent infinite loop
      this.template.parentTemplate !== this.template) {
        blocks = this.template.parentTemplate.getBlocks();
      }
      blocks = {
        ...blocks,
        // Override with any blocks defined within the associated template
        ...this.template.getBlocks(),
        // Override with any blocks specified when initialized
        ...this.overrideBlocks
      };
      return blocks;
    };
    Twig2.ParseState.prototype.getNestingStackToken = function(type2) {
      let matchingToken;
      this.nestingStack.forEach((token) => {
        if (matchingToken === void 0 && token.type === type2) {
          matchingToken = token;
        }
      });
      return matchingToken;
    };
    Twig2.ParseState.prototype.parse = function(tokens2, context, allowAsync) {
      const state2 = this;
      let output = [];
      let err = null;
      let isAsync = true;
      let promise = null;
      let chain = true;
      if (context) {
        state2.context = context;
      }
      function outputPush(o) {
        output.push(o);
      }
      function parseTokenLogic(logic) {
        if (typeof logic.chain !== "undefined") {
          chain = logic.chain;
        }
        if (typeof logic.context !== "undefined") {
          state2.context = logic.context;
        }
        if (typeof logic.output !== "undefined") {
          output.push(logic.output);
        }
      }
      promise = Twig2.async.forEach(tokens2, (token) => {
        Twig2.log.debug("Twig.ParseState.parse: ", "Parsing token: ", token);
        switch (token.type) {
          case Twig2.token.type.raw:
            output.push(Twig2.filters.raw(token.value));
            break;
          case Twig2.token.type.logic:
            return Twig2.logic.parseAsync.call(state2, token.token, state2.context, chain).then(parseTokenLogic);
          case Twig2.token.type.comment:
            break;
          case Twig2.token.type.outputWhitespacePre:
          case Twig2.token.type.outputWhitespacePost:
          case Twig2.token.type.outputWhitespaceBoth:
          case Twig2.token.type.output:
            Twig2.log.debug("Twig.ParseState.parse: ", "Output token: ", token.stack);
            return Twig2.expression.parseAsync.call(state2, token.stack, state2.context).then(outputPush);
        }
      }).then(() => {
        output = Twig2.output.call(state2.template, output);
        isAsync = false;
        return output;
      }).catch((error) => {
        if (allowAsync) {
          handleException(state2, error);
        }
        err = error;
      });
      if (allowAsync) {
        return promise;
      }
      if (err !== null) {
        return handleException(state2, err);
      }
      if (isAsync) {
        throw new Twig2.Error("You are using Twig.js in sync mode in combination with async extensions.");
      }
      return output;
    };
    Twig2.Template = function(params) {
      const { data, id, base, path, url, name, method, options } = params;
      this.base = base;
      this.blocks = {
        defined: {},
        imported: {}
      };
      this.id = id;
      this.method = method;
      this.name = name;
      this.options = options;
      this.parentTemplate = null;
      this.path = path;
      this.url = url;
      if (is("String", data)) {
        this.tokens = Twig2.prepare.call(this, data);
      } else {
        this.tokens = data;
      }
      if (id !== void 0) {
        Twig2.Templates.save(this);
      }
    };
    Twig2.Template.prototype.getBlock = function(name, checkOnlyInheritedBlocks, checkImports = true) {
      let block;
      if (checkOnlyInheritedBlocks !== true) {
        block = this.blocks.defined[name];
      }
      if (checkImports && block === void 0) {
        block = this.blocks.imported[name];
      }
      if (block === void 0 && this.parentTemplate !== null) {
        block = this.parentTemplate.getBlock(name, checkOnlyInheritedBlocks, checkImports = false);
      }
      return block;
    };
    Twig2.Template.prototype.getBlocks = function() {
      let blocks = {};
      blocks = {
        ...blocks,
        // Get any blocks imported from other templates
        ...this.blocks.imported,
        // Override with any blocks defined within the template itself
        ...this.blocks.defined
      };
      return blocks;
    };
    Twig2.Template.prototype.render = function(context, params, allowAsync) {
      const template = this;
      params = params || {};
      return Twig2.async.potentiallyAsync(template, allowAsync, () => {
        const state2 = new Twig2.ParseState(template, params.blocks, context);
        return state2.parseAsync(template.tokens).then((output) => {
          let parentTemplate;
          let url;
          if (template.parentTemplate !== null) {
            if (template.options.allowInlineIncludes) {
              parentTemplate = Twig2.Templates.load(template.parentTemplate);
              if (parentTemplate) {
                parentTemplate.options = template.options;
              }
            }
            if (!parentTemplate) {
              url = Twig2.path.parsePath(template, template.parentTemplate);
              parentTemplate = Twig2.Templates.loadRemote(url, {
                method: template.getLoaderMethod(),
                base: template.base,
                async: false,
                id: url,
                options: template.options
              });
            }
            template.parentTemplate = parentTemplate;
            return template.parentTemplate.renderAsync(
              state2.context,
              {
                blocks: state2.getBlocks(false),
                isInclude: true
              }
            );
          }
          if (params.isInclude === true) {
            return output;
          }
          return output.valueOf();
        });
      });
    };
    Twig2.Template.prototype.importFile = function(file) {
      let url = null;
      let subTemplate;
      if (!this.url && this.options.allowInlineIncludes) {
        file = this.path ? Twig2.path.parsePath(this, file) : file;
        subTemplate = Twig2.Templates.load(file);
        if (!subTemplate) {
          subTemplate = Twig2.Templates.loadRemote(url, {
            id: file,
            method: this.getLoaderMethod(),
            async: false,
            path: file,
            options: this.options
          });
          if (!subTemplate) {
            throw new Twig2.Error("Unable to find the template " + file);
          }
        }
        subTemplate.options = this.options;
        return subTemplate;
      }
      url = Twig2.path.parsePath(this, file);
      subTemplate = Twig2.Templates.loadRemote(url, {
        method: this.getLoaderMethod(),
        base: this.base,
        async: false,
        options: this.options,
        id: url
      });
      return subTemplate;
    };
    Twig2.Template.prototype.getLoaderMethod = function() {
      if (this.path) {
        return "fs";
      }
      if (this.url) {
        return "ajax";
      }
      return this.method || "fs";
    };
    Twig2.Template.prototype.compile = function(options) {
      return Twig2.compiler.compile(this, options);
    };
    Twig2.Markup = function(content, strategy) {
      if (typeof content !== "string") {
        return content;
      }
      const output = new String(content);
      output.twigMarkup = typeof strategy === "undefined" ? true : strategy;
      return output;
    };
    return Twig2;
  };
  return twig_core;
}
var twig_compiler;
var hasRequiredTwig_compiler;
function requireTwig_compiler() {
  if (hasRequiredTwig_compiler)
    return twig_compiler;
  hasRequiredTwig_compiler = 1;
  twig_compiler = function(Twig2) {
    Twig2.compiler = {
      module: {}
    };
    Twig2.compiler.compile = function(template, options) {
      const tokens2 = JSON.stringify(template.tokens);
      const { id } = template;
      let output = null;
      if (options.module) {
        if (Twig2.compiler.module[options.module] === void 0) {
          throw new Twig2.Error("Unable to find module type " + options.module);
        }
        output = Twig2.compiler.module[options.module](id, tokens2, options.twig);
      } else {
        output = Twig2.compiler.wrap(id, tokens2);
      }
      return output;
    };
    Twig2.compiler.module = {
      amd(id, tokens2, pathToTwig) {
        return 'define(["' + pathToTwig + '"], function (Twig) {\n	var twig, templates;\ntwig = Twig.twig;\ntemplates = ' + Twig2.compiler.wrap(id, tokens2) + "\n	return templates;\n});";
      },
      node(id, tokens2) {
        return 'var twig = require("twig").twig;\nexports.template = ' + Twig2.compiler.wrap(id, tokens2);
      },
      cjs2(id, tokens2, pathToTwig) {
        return 'module.declare([{ twig: "' + pathToTwig + '" }], function (require, exports, module) {\n	var twig = require("twig").twig;\n	exports.template = ' + Twig2.compiler.wrap(id, tokens2) + "\n});";
      }
    };
    Twig2.compiler.wrap = function(id, tokens2) {
      return 'twig({id:"' + id.replace('"', '\\"') + '", data:' + tokens2 + ", precompiled: true});\n";
    };
    return Twig2;
  };
  return twig_compiler;
}
var twig_expression_operator;
var hasRequiredTwig_expression_operator;
function requireTwig_expression_operator() {
  if (hasRequiredTwig_expression_operator)
    return twig_expression_operator;
  hasRequiredTwig_expression_operator = 1;
  twig_expression_operator = function(Twig2) {
    Twig2.expression.operator = {
      leftToRight: "leftToRight",
      rightToLeft: "rightToLeft"
    };
    const containment = function(a, b) {
      if (b === void 0 || b === null) {
        return null;
      }
      if (b.indexOf !== void 0) {
        return (a === b || a !== "") && b.includes(a);
      }
      let el;
      for (el in b) {
        if (Object.hasOwnProperty.call(b, el) && b[el] === a) {
          return true;
        }
      }
      return false;
    };
    Twig2.expression.operator.lookup = function(operator, token) {
      switch (operator) {
        case "..":
          token.precidence = 20;
          token.associativity = Twig2.expression.operator.leftToRight;
          break;
        case ",":
          token.precidence = 18;
          token.associativity = Twig2.expression.operator.leftToRight;
          break;
        case "?:":
        case "?":
        case ":":
          token.precidence = 16;
          token.associativity = Twig2.expression.operator.rightToLeft;
          break;
        case "??":
          token.precidence = 15;
          token.associativity = Twig2.expression.operator.rightToLeft;
          break;
        case "or":
          token.precidence = 14;
          token.associativity = Twig2.expression.operator.leftToRight;
          break;
        case "and":
          token.precidence = 13;
          token.associativity = Twig2.expression.operator.leftToRight;
          break;
        case "b-or":
          token.precidence = 12;
          token.associativity = Twig2.expression.operator.leftToRight;
          break;
        case "b-xor":
          token.precidence = 11;
          token.associativity = Twig2.expression.operator.leftToRight;
          break;
        case "b-and":
          token.precidence = 10;
          token.associativity = Twig2.expression.operator.leftToRight;
          break;
        case "==":
        case "!=":
          token.precidence = 9;
          token.associativity = Twig2.expression.operator.leftToRight;
          break;
        case "<=>":
          token.precidence = 9;
          token.associativity = Twig2.expression.operator.leftToRight;
          break;
        case "<":
        case "<=":
        case ">":
        case ">=":
        case "not in":
        case "in":
          token.precidence = 8;
          token.associativity = Twig2.expression.operator.leftToRight;
          break;
        case "~":
        case "+":
        case "-":
          token.precidence = 6;
          token.associativity = Twig2.expression.operator.leftToRight;
          break;
        case "//":
        case "**":
        case "*":
        case "/":
        case "%":
          token.precidence = 5;
          token.associativity = Twig2.expression.operator.leftToRight;
          break;
        case "not":
          token.precidence = 3;
          token.associativity = Twig2.expression.operator.rightToLeft;
          break;
        case "matches":
          token.precidence = 8;
          token.associativity = Twig2.expression.operator.leftToRight;
          break;
        case "starts with":
          token.precidence = 8;
          token.associativity = Twig2.expression.operator.leftToRight;
          break;
        case "ends with":
          token.precidence = 8;
          token.associativity = Twig2.expression.operator.leftToRight;
          break;
        default:
          throw new Twig2.Error("Failed to lookup operator: " + operator + " is an unknown operator.");
      }
      token.operator = operator;
      return token;
    };
    Twig2.expression.operator.parse = function(operator, stack2) {
      Twig2.log.trace("Twig.expression.operator.parse: ", "Handling ", operator);
      let a;
      let b;
      let c;
      if (operator === "?") {
        c = stack2.pop();
      }
      b = stack2.pop();
      if (operator !== "not") {
        a = stack2.pop();
      }
      if (operator !== "in" && operator !== "not in" && operator !== "??") {
        if (a && Array.isArray(a)) {
          a = a.length;
        }
        if (operator !== "?" && (b && Array.isArray(b))) {
          b = b.length;
        }
      }
      if (operator === "matches") {
        if (b && typeof b === "string") {
          const reParts = b.match(/^\/(.*)\/([gims]?)$/);
          const reBody = reParts[1];
          const reFlags = reParts[2];
          b = new RegExp(reBody, reFlags);
        }
      }
      switch (operator) {
        case ":":
          break;
        case "??":
          if (a === void 0) {
            a = b;
            b = c;
            c = void 0;
          }
          if (a !== void 0 && a !== null) {
            stack2.push(a);
          } else {
            stack2.push(b);
          }
          break;
        case "?:":
          if (Twig2.lib.boolval(a)) {
            stack2.push(a);
          } else {
            stack2.push(b);
          }
          break;
        case "?":
          if (a === void 0) {
            a = b;
            b = c;
            c = void 0;
          }
          if (Twig2.lib.boolval(a)) {
            stack2.push(b);
          } else {
            stack2.push(c);
          }
          break;
        case "+":
          b = parseFloat(b);
          a = parseFloat(a);
          stack2.push(a + b);
          break;
        case "-":
          b = parseFloat(b);
          a = parseFloat(a);
          stack2.push(a - b);
          break;
        case "*":
          b = parseFloat(b);
          a = parseFloat(a);
          stack2.push(a * b);
          break;
        case "/":
          b = parseFloat(b);
          a = parseFloat(a);
          stack2.push(a / b);
          break;
        case "//":
          b = parseFloat(b);
          a = parseFloat(a);
          stack2.push(Math.floor(a / b));
          break;
        case "%":
          b = parseFloat(b);
          a = parseFloat(a);
          stack2.push(a % b);
          break;
        case "~":
          stack2.push((typeof a !== "undefined" && a !== null ? a.toString() : "") + (typeof b !== "undefined" && b !== null ? b.toString() : ""));
          break;
        case "not":
        case "!":
          stack2.push(!Twig2.lib.boolval(b));
          break;
        case "<=>":
          stack2.push(a === b ? 0 : a < b ? -1 : 1);
          break;
        case "<":
          stack2.push(a < b);
          break;
        case "<=":
          stack2.push(a <= b);
          break;
        case ">":
          stack2.push(a > b);
          break;
        case ">=":
          stack2.push(a >= b);
          break;
        case "===":
          stack2.push(a === b);
          break;
        case "==":
          stack2.push(a == b);
          break;
        case "!==":
          stack2.push(a !== b);
          break;
        case "!=":
          stack2.push(a != b);
          break;
        case "or":
          stack2.push(Twig2.lib.boolval(a) || Twig2.lib.boolval(b));
          break;
        case "b-or":
          stack2.push(a | b);
          break;
        case "b-xor":
          stack2.push(a ^ b);
          break;
        case "and":
          stack2.push(Twig2.lib.boolval(a) && Twig2.lib.boolval(b));
          break;
        case "b-and":
          stack2.push(a & b);
          break;
        case "**":
          stack2.push(a ** b);
          break;
        case "not in":
          stack2.push(!containment(a, b));
          break;
        case "in":
          stack2.push(containment(a, b));
          break;
        case "matches":
          stack2.push(b.test(a));
          break;
        case "starts with":
          stack2.push(typeof a === "string" && a.indexOf(b) === 0);
          break;
        case "ends with":
          stack2.push(typeof a === "string" && a.includes(b, a.length - b.length));
          break;
        case "..":
          stack2.push(Twig2.functions.range(a, b));
          break;
        default:
          throw new Twig2.Error("Failed to parse operator: " + operator + " is an unknown operator.");
      }
    };
    return Twig2;
  };
  return twig_expression_operator;
}
var twig_expression;
var hasRequiredTwig_expression;
function requireTwig_expression() {
  if (hasRequiredTwig_expression)
    return twig_expression;
  hasRequiredTwig_expression = 1;
  twig_expression = function(Twig2) {
    function parseParams(state2, params, context) {
      if (params) {
        return Twig2.expression.parseAsync.call(state2, params, context);
      }
      return Twig2.Promise.resolve(false);
    }
    Twig2.expression = {};
    requireTwig_expression_operator()(Twig2);
    Twig2.expression.reservedWords = [
      "true",
      "false",
      "null",
      "TRUE",
      "FALSE",
      "NULL",
      "_context",
      "and",
      "b-and",
      "or",
      "b-or",
      "b-xor",
      "in",
      "not in",
      "if",
      "matches",
      "starts",
      "ends",
      "with"
    ];
    Twig2.expression.type = {
      comma: "Twig.expression.type.comma",
      operator: {
        unary: "Twig.expression.type.operator.unary",
        binary: "Twig.expression.type.operator.binary"
      },
      string: "Twig.expression.type.string",
      bool: "Twig.expression.type.bool",
      slice: "Twig.expression.type.slice",
      array: {
        start: "Twig.expression.type.array.start",
        end: "Twig.expression.type.array.end"
      },
      object: {
        start: "Twig.expression.type.object.start",
        end: "Twig.expression.type.object.end"
      },
      parameter: {
        start: "Twig.expression.type.parameter.start",
        end: "Twig.expression.type.parameter.end"
      },
      subexpression: {
        start: "Twig.expression.type.subexpression.start",
        end: "Twig.expression.type.subexpression.end"
      },
      key: {
        period: "Twig.expression.type.key.period",
        brackets: "Twig.expression.type.key.brackets"
      },
      filter: "Twig.expression.type.filter",
      _function: "Twig.expression.type._function",
      variable: "Twig.expression.type.variable",
      number: "Twig.expression.type.number",
      _null: "Twig.expression.type.null",
      context: "Twig.expression.type.context",
      test: "Twig.expression.type.test"
    };
    Twig2.expression.set = {
      // What can follow an expression (in general)
      operations: [
        Twig2.expression.type.filter,
        Twig2.expression.type.operator.unary,
        Twig2.expression.type.operator.binary,
        Twig2.expression.type.array.end,
        Twig2.expression.type.object.end,
        Twig2.expression.type.parameter.end,
        Twig2.expression.type.subexpression.end,
        Twig2.expression.type.comma,
        Twig2.expression.type.test
      ],
      expressions: [
        Twig2.expression.type._function,
        Twig2.expression.type.bool,
        Twig2.expression.type.string,
        Twig2.expression.type.variable,
        Twig2.expression.type.number,
        Twig2.expression.type._null,
        Twig2.expression.type.context,
        Twig2.expression.type.parameter.start,
        Twig2.expression.type.array.start,
        Twig2.expression.type.object.start,
        Twig2.expression.type.subexpression.start,
        Twig2.expression.type.operator.unary
      ]
    };
    Twig2.expression.set.operationsExtended = Twig2.expression.set.operations.concat([
      Twig2.expression.type.key.period,
      Twig2.expression.type.key.brackets,
      Twig2.expression.type.slice
    ]);
    Twig2.expression.fn = {
      compile: {
        push(token, stack2, output) {
          output.push(token);
        },
        pushBoth(token, stack2, output) {
          output.push(token);
          stack2.push(token);
        }
      },
      parse: {
        push(token, stack2) {
          stack2.push(token);
        },
        pushValue(token, stack2) {
          stack2.push(token.value);
        }
      }
    };
    Twig2.expression.definitions = [
      {
        type: Twig2.expression.type.test,
        regex: /^is\s+(not)?\s*([a-zA-Z_]\w*(\s?(?:as|by))?)/,
        next: Twig2.expression.set.operations.concat([Twig2.expression.type.parameter.start]),
        compile(token, stack2, output) {
          token.filter = token.match[2];
          token.modifier = token.match[1];
          delete token.match;
          delete token.value;
          output.push(token);
        },
        parse(token, stack2, context) {
          const value = stack2.pop();
          const state2 = this;
          return parseParams(state2, token.params, context).then((params) => {
            const result = Twig2.test(token.filter, value, params);
            if (token.modifier === "not") {
              stack2.push(!result);
            } else {
              stack2.push(result);
            }
          });
        }
      },
      {
        type: Twig2.expression.type.comma,
        // Match a comma
        regex: /^,/,
        next: Twig2.expression.set.expressions.concat([Twig2.expression.type.array.end, Twig2.expression.type.object.end]),
        compile(token, stack2, output) {
          let i = stack2.length - 1;
          let stackToken;
          delete token.match;
          delete token.value;
          for (; i >= 0; i--) {
            stackToken = stack2.pop();
            if (stackToken.type === Twig2.expression.type.object.start || stackToken.type === Twig2.expression.type.parameter.start || stackToken.type === Twig2.expression.type.array.start) {
              stack2.push(stackToken);
              break;
            }
            output.push(stackToken);
          }
          output.push(token);
        }
      },
      {
        /**
         * Match a number (integer or decimal)
         */
        type: Twig2.expression.type.number,
        // Match a number
        regex: /^-?\d+(\.\d+)?/,
        next: Twig2.expression.set.operations,
        compile(token, stack2, output) {
          token.value = Number(token.value);
          output.push(token);
        },
        parse: Twig2.expression.fn.parse.pushValue
      },
      {
        type: Twig2.expression.type.operator.binary,
        // Match any of ??, ?:, +, *, /, -, %, ~, <=>, <, <=, >, >=, !=, ==, **, ?, :, and, b-and, or, b-or, b-xor, in, not in
        // and, or, in, not in, matches, starts with, ends with can be followed by a space or parenthesis
        regex: /(^\?\?|^\?:|^(b-and)|^(b-or)|^(b-xor)|^[+\-~%?]|^(<=>)|^[:](?!\d\])|^[!=]==?|^[!<>]=?|^\*\*?|^\/\/?|^(and)[(|\s+]|^(or)[(|\s+]|^(in)[(|\s+]|^(not in)[(|\s+]|^(matches)|^(starts with)|^(ends with)|^\.\.)/,
        next: Twig2.expression.set.expressions,
        transform(match, tokens2) {
          switch (match[0]) {
            case "and(":
            case "or(":
            case "in(":
            case "not in(":
              tokens2[tokens2.length - 1].value = match[2];
              return match[0];
            default:
              return "";
          }
        },
        compile(token, stack2, output) {
          delete token.match;
          token.value = token.value.trim();
          const { value } = token;
          const operator = Twig2.expression.operator.lookup(value, token);
          Twig2.log.trace("Twig.expression.compile: ", "Operator: ", operator, " from ", value);
          while (stack2.length > 0 && (stack2[stack2.length - 1].type === Twig2.expression.type.operator.unary || stack2[stack2.length - 1].type === Twig2.expression.type.operator.binary) && (operator.associativity === Twig2.expression.operator.leftToRight && operator.precidence >= stack2[stack2.length - 1].precidence || operator.associativity === Twig2.expression.operator.rightToLeft && operator.precidence > stack2[stack2.length - 1].precidence)) {
            const temp = stack2.pop();
            output.push(temp);
          }
          if (value === ":") {
            if (stack2[stack2.length - 1] && stack2[stack2.length - 1].value === "?")
              ;
            else {
              const keyToken = output.pop();
              if (keyToken.type === Twig2.expression.type.string || keyToken.type === Twig2.expression.type.variable) {
                token.key = keyToken.value;
              } else if (keyToken.type === Twig2.expression.type.number) {
                token.key = keyToken.value.toString();
              } else if (keyToken.expression && (keyToken.type === Twig2.expression.type.parameter.end || keyToken.type === Twig2.expression.type.subexpression.end)) {
                token.params = keyToken.params;
              } else {
                throw new Twig2.Error("Unexpected value before ':' of " + keyToken.type + " = " + keyToken.value);
              }
              output.push(token);
            }
          } else {
            stack2.push(operator);
          }
        },
        parse(token, stack2, context) {
          const state2 = this;
          if (token.key) {
            stack2.push(token);
          } else if (token.params) {
            return Twig2.expression.parseAsync.call(state2, token.params, context).then((key) => {
              token.key = key;
              stack2.push(token);
              if (!context.loop) {
                delete token.params;
              }
            });
          } else {
            Twig2.expression.operator.parse(token.value, stack2);
          }
        }
      },
      {
        type: Twig2.expression.type.operator.unary,
        // Match any of not
        regex: /(^not\s+)/,
        next: Twig2.expression.set.expressions,
        compile(token, stack2, output) {
          delete token.match;
          token.value = token.value.trim();
          const { value } = token;
          const operator = Twig2.expression.operator.lookup(value, token);
          Twig2.log.trace("Twig.expression.compile: ", "Operator: ", operator, " from ", value);
          while (stack2.length > 0 && (stack2[stack2.length - 1].type === Twig2.expression.type.operator.unary || stack2[stack2.length - 1].type === Twig2.expression.type.operator.binary) && (operator.associativity === Twig2.expression.operator.leftToRight && operator.precidence >= stack2[stack2.length - 1].precidence || operator.associativity === Twig2.expression.operator.rightToLeft && operator.precidence > stack2[stack2.length - 1].precidence)) {
            const temp = stack2.pop();
            output.push(temp);
          }
          stack2.push(operator);
        },
        parse(token, stack2) {
          Twig2.expression.operator.parse(token.value, stack2);
        }
      },
      {
        /**
         * Match a string. This is anything between a pair of single or double quotes.
         */
        type: Twig2.expression.type.string,
        // See: http://blog.stevenlevithan.com/archives/match-quoted-string
        regex: /^(["'])(?:(?=(\\?))\2[\s\S])*?\1/,
        next: Twig2.expression.set.operationsExtended,
        compile(token, stack2, output) {
          let { value } = token;
          delete token.match;
          if (value.slice(0, 1) === '"') {
            value = value.replace('\\"', '"');
          } else {
            value = value.replace("\\'", "'");
          }
          token.value = value.slice(1, -1).replace(/\\n/g, "\n").replace(/\\r/g, "\r");
          Twig2.log.trace("Twig.expression.compile: ", "String value: ", token.value);
          output.push(token);
        },
        parse: Twig2.expression.fn.parse.pushValue
      },
      {
        /**
         * Match a subexpression set start.
         */
        type: Twig2.expression.type.subexpression.start,
        regex: /^\(/,
        next: Twig2.expression.set.expressions.concat([Twig2.expression.type.subexpression.end]),
        compile(token, stack2, output) {
          token.value = "(";
          output.push(token);
          stack2.push(token);
        },
        parse: Twig2.expression.fn.parse.push
      },
      {
        /**
         * Match a subexpression set end.
         */
        type: Twig2.expression.type.subexpression.end,
        regex: /^\)/,
        next: Twig2.expression.set.operationsExtended,
        validate(match, tokens2) {
          let i = tokens2.length - 1;
          let foundSubexpressionStart = false;
          let nextSubexpressionStartInvalid = false;
          let unclosedParameterCount = 0;
          while (!foundSubexpressionStart && i >= 0) {
            const token = tokens2[i];
            foundSubexpressionStart = token.type === Twig2.expression.type.subexpression.start;
            if (foundSubexpressionStart && nextSubexpressionStartInvalid) {
              nextSubexpressionStartInvalid = false;
              foundSubexpressionStart = false;
            }
            if (token.type === Twig2.expression.type.parameter.start) {
              unclosedParameterCount++;
            } else if (token.type === Twig2.expression.type.parameter.end) {
              unclosedParameterCount--;
            } else if (token.type === Twig2.expression.type.subexpression.end) {
              nextSubexpressionStartInvalid = true;
            }
            i--;
          }
          return foundSubexpressionStart && unclosedParameterCount === 0;
        },
        compile(token, stack2, output) {
          let stackToken;
          const endToken = token;
          stackToken = stack2.pop();
          while (stack2.length > 0 && stackToken.type !== Twig2.expression.type.subexpression.start) {
            output.push(stackToken);
            stackToken = stack2.pop();
          }
          const paramStack = [];
          while (token.type !== Twig2.expression.type.subexpression.start) {
            paramStack.unshift(token);
            token = output.pop();
          }
          paramStack.unshift(token);
          stackToken = stack2[stack2.length - 1];
          if (stackToken === void 0 || stackToken.type !== Twig2.expression.type._function && stackToken.type !== Twig2.expression.type.filter && stackToken.type !== Twig2.expression.type.test && stackToken.type !== Twig2.expression.type.key.brackets) {
            endToken.expression = true;
            paramStack.pop();
            paramStack.shift();
            endToken.params = paramStack;
            output.push(endToken);
          } else {
            endToken.expression = false;
            stackToken.params = paramStack;
          }
        },
        parse(token, stack2, context) {
          const state2 = this;
          if (token.expression) {
            return Twig2.expression.parseAsync.call(state2, token.params, context).then((value) => {
              stack2.push(value);
            });
          }
          throw new Twig2.Error("Unexpected subexpression end when token is not marked as an expression");
        }
      },
      {
        /**
         * Match a parameter set start.
         */
        type: Twig2.expression.type.parameter.start,
        regex: /^\(/,
        next: Twig2.expression.set.expressions.concat([Twig2.expression.type.parameter.end]),
        validate(match, tokens2) {
          const lastToken = tokens2[tokens2.length - 1];
          return lastToken && !Twig2.expression.reservedWords.includes(lastToken.value.trim());
        },
        compile: Twig2.expression.fn.compile.pushBoth,
        parse: Twig2.expression.fn.parse.push
      },
      {
        /**
         * Match a parameter set end.
         */
        type: Twig2.expression.type.parameter.end,
        regex: /^\)/,
        next: Twig2.expression.set.operationsExtended,
        compile(token, stack2, output) {
          let stackToken;
          const endToken = token;
          stackToken = stack2.pop();
          while (stack2.length > 0 && stackToken.type !== Twig2.expression.type.parameter.start) {
            output.push(stackToken);
            stackToken = stack2.pop();
          }
          const paramStack = [];
          while (token.type !== Twig2.expression.type.parameter.start) {
            paramStack.unshift(token);
            token = output.pop();
          }
          paramStack.unshift(token);
          token = output[output.length - 1];
          if (token === void 0 || token.type !== Twig2.expression.type._function && token.type !== Twig2.expression.type.filter && token.type !== Twig2.expression.type.test && token.type !== Twig2.expression.type.key.brackets) {
            endToken.expression = true;
            paramStack.pop();
            paramStack.shift();
            endToken.params = paramStack;
            output.push(endToken);
          } else {
            endToken.expression = false;
            token.params = paramStack;
          }
        },
        parse(token, stack2, context) {
          const newArray = [];
          let arrayEnded = false;
          let value = null;
          const state2 = this;
          if (token.expression) {
            return Twig2.expression.parseAsync.call(state2, token.params, context).then((value2) => {
              stack2.push(value2);
            });
          }
          while (stack2.length > 0) {
            value = stack2.pop();
            if (value && value.type && value.type === Twig2.expression.type.parameter.start) {
              arrayEnded = true;
              break;
            }
            newArray.unshift(value);
          }
          if (!arrayEnded) {
            throw new Twig2.Error("Expected end of parameter set.");
          }
          stack2.push(newArray);
        }
      },
      {
        type: Twig2.expression.type.slice,
        regex: /^\[(-?\w*:-?\w*)\]/,
        next: Twig2.expression.set.operationsExtended,
        compile(token, stack2, output) {
          const sliceRange = token.match[1].split(":");
          const sliceStart = sliceRange[0];
          const sliceEnd = sliceRange[1];
          token.value = "slice";
          token.params = [sliceStart, sliceEnd];
          if (!sliceEnd) {
            token.params = [sliceStart];
          }
          output.push(token);
        },
        parse(token, stack2, context) {
          const input = stack2.pop();
          let { params } = token;
          const state2 = this;
          if (parseInt(params[0], 10).toString() === params[0]) {
            params[0] = parseInt(params[0], 10);
          } else {
            const value = context[params[0]];
            if (state2.template.options.strictVariables && value === void 0) {
              throw new Twig2.Error('Variable "' + params[0] + '" does not exist.');
            }
            params[0] = value;
          }
          if (params[1]) {
            if (parseInt(params[1], 10).toString() === params[1]) {
              params[1] = parseInt(params[1], 10);
            } else {
              const value = context[params[1]];
              if (state2.template.options.strictVariables && value === void 0) {
                throw new Twig2.Error('Variable "' + params[1] + '" does not exist.');
              }
              if (value === void 0) {
                params = [params[0]];
              } else {
                params[1] = value;
              }
            }
          }
          stack2.push(Twig2.filter.call(state2, token.value, input, params));
        }
      },
      {
        /**
         * Match an array start.
         */
        type: Twig2.expression.type.array.start,
        regex: /^\[/,
        next: Twig2.expression.set.expressions.concat([Twig2.expression.type.array.end]),
        compile: Twig2.expression.fn.compile.pushBoth,
        parse: Twig2.expression.fn.parse.push
      },
      {
        /**
         * Match an array end.
         */
        type: Twig2.expression.type.array.end,
        regex: /^\]/,
        next: Twig2.expression.set.operationsExtended,
        compile(token, stack2, output) {
          let i = stack2.length - 1;
          let stackToken;
          for (; i >= 0; i--) {
            stackToken = stack2.pop();
            if (stackToken.type === Twig2.expression.type.array.start) {
              break;
            }
            output.push(stackToken);
          }
          output.push(token);
        },
        parse(token, stack2) {
          const newArray = [];
          let arrayEnded = false;
          let value = null;
          while (stack2.length > 0) {
            value = stack2.pop();
            if (value && value.type && value.type === Twig2.expression.type.array.start) {
              arrayEnded = true;
              break;
            }
            newArray.unshift(value);
          }
          if (!arrayEnded) {
            throw new Twig2.Error("Expected end of array.");
          }
          stack2.push(newArray);
        }
      },
      // Token that represents the start of a hash map '}'
      //
      // Hash maps take the form:
      //    { "key": 'value', "another_key": item }
      //
      // Keys must be quoted (either single or double) and values can be any expression.
      {
        type: Twig2.expression.type.object.start,
        regex: /^\{/,
        next: Twig2.expression.set.expressions.concat([Twig2.expression.type.object.end]),
        compile: Twig2.expression.fn.compile.pushBoth,
        parse: Twig2.expression.fn.parse.push
      },
      // Token that represents the end of a Hash Map '}'
      //
      // This is where the logic for building the internal
      // representation of a hash map is defined.
      {
        type: Twig2.expression.type.object.end,
        regex: /^\}/,
        next: Twig2.expression.set.operationsExtended,
        compile(token, stack2, output) {
          let i = stack2.length - 1;
          let stackToken;
          for (; i >= 0; i--) {
            stackToken = stack2.pop();
            if (stackToken && stackToken.type === Twig2.expression.type.object.start) {
              break;
            }
            output.push(stackToken);
          }
          output.push(token);
        },
        parse(endToken, stack2) {
          const newObject = {};
          let objectEnded = false;
          let token = null;
          let hasValue = false;
          let value = null;
          while (stack2.length > 0) {
            token = stack2.pop();
            if (token && token.type && token.type === Twig2.expression.type.object.start) {
              objectEnded = true;
              break;
            }
            if (token && token.type && (token.type === Twig2.expression.type.operator.binary || token.type === Twig2.expression.type.operator.unary) && token.key) {
              if (!hasValue) {
                throw new Twig2.Error("Missing value for key '" + token.key + "' in object definition.");
              }
              newObject[token.key] = value;
              if (newObject._keys === void 0) {
                newObject._keys = [];
              }
              newObject._keys.unshift(token.key);
              value = null;
              hasValue = false;
            } else {
              hasValue = true;
              value = token;
            }
          }
          if (!objectEnded) {
            throw new Twig2.Error("Unexpected end of object.");
          }
          stack2.push(newObject);
        }
      },
      // Token representing a filter
      //
      // Filters can follow any expression and take the form:
      //    expression|filter(optional, args)
      //
      // Filter parsing is done in the Twig.filters namespace.
      {
        type: Twig2.expression.type.filter,
        // Match a | then a letter or _, then any number of letters, numbers, _ or -
        regex: /^\|\s?([a-zA-Z_][a-zA-Z0-9_-]*)/,
        next: Twig2.expression.set.operationsExtended.concat([
          Twig2.expression.type.parameter.start
        ]),
        compile(token, stack2, output) {
          token.value = token.match[1];
          output.push(token);
        },
        parse(token, stack2, context) {
          const input = stack2.pop();
          const state2 = this;
          return parseParams(state2, token.params, context).then((params) => {
            return Twig2.filter.call(state2, token.value, input, params);
          }).then((value) => {
            stack2.push(value);
          });
        }
      },
      {
        type: Twig2.expression.type._function,
        // Match any letter or _, then any number of letters, numbers, _ or - followed by (
        regex: /^([a-zA-Z_]\w*)\s*\(/,
        next: Twig2.expression.type.parameter.start,
        validate(match) {
          return match[1] && !Twig2.expression.reservedWords.includes(match[1]);
        },
        transform() {
          return "(";
        },
        compile(token, stack2, output) {
          const fn = token.match[1];
          token.fn = fn;
          delete token.match;
          delete token.value;
          output.push(token);
        },
        parse(token, stack2, context) {
          const state2 = this;
          const { fn } = token;
          let value;
          return parseParams(state2, token.params, context).then((params) => {
            if (Twig2.functions[fn]) {
              value = Twig2.functions[fn].apply(state2, params);
            } else if (typeof context[fn] === "function") {
              value = context[fn](...params);
            } else {
              throw new Twig2.Error(fn + " function does not exist and is not defined in the context");
            }
            return value;
          }).then((result) => {
            stack2.push(result);
          });
        }
      },
      // Token representing a variable.
      //
      // Variables can contain letters, numbers, underscores and
      // dashes, but must start with a letter or underscore.
      //
      // Variables are retrieved from the render context and take
      // the value of 'undefined' if the given variable doesn't
      // exist in the context.
      {
        type: Twig2.expression.type.variable,
        // Match any letter or _, then any number of letters, numbers, _ or -
        regex: /^[a-zA-Z_]\w*/,
        next: Twig2.expression.set.operationsExtended.concat([
          Twig2.expression.type.parameter.start
        ]),
        compile: Twig2.expression.fn.compile.push,
        validate(match) {
          return !Twig2.expression.reservedWords.includes(match[0]);
        },
        parse(token, stack2, context) {
          const state2 = this;
          return Twig2.expression.resolveAsync.call(state2, context[token.value], context).then((value) => {
            if (state2.template.options.strictVariables && value === void 0) {
              throw new Twig2.Error('Variable "' + token.value + '" does not exist.');
            }
            stack2.push(value);
          });
        }
      },
      {
        type: Twig2.expression.type.key.period,
        regex: /^\.(\w+)/,
        next: Twig2.expression.set.operationsExtended.concat([
          Twig2.expression.type.parameter.start
        ]),
        compile(token, stack2, output) {
          token.key = token.match[1];
          delete token.match;
          delete token.value;
          output.push(token);
        },
        parse(token, stack2, context, nextToken) {
          const state2 = this;
          const { key } = token;
          const object = stack2.pop();
          let value;
          if (object && !Object.prototype.hasOwnProperty.call(object, key) && state2.template.options.strictVariables) {
            const keys = Object.keys(object);
            if (keys.length > 0) {
              throw new Twig2.Error('Key "' + key + '" for object with keys "' + Object.keys(object).join(", ") + '" does not exist.');
            } else {
              throw new Twig2.Error('Key "' + key + '" does not exist as the object is empty.');
            }
          }
          return parseParams(state2, token.params, context).then((params) => {
            if (object === null || object === void 0) {
              value = void 0;
            } else {
              const capitalize2 = function(value2) {
                return value2.slice(0, 1).toUpperCase() + value2.slice(1);
              };
              if (typeof object === "object" && key in object) {
                value = object[key];
              } else if (object["get" + capitalize2(key)]) {
                value = object["get" + capitalize2(key)];
              } else if (object["is" + capitalize2(key)]) {
                value = object["is" + capitalize2(key)];
              } else {
                value = void 0;
              }
            }
            return Twig2.expression.resolveAsync.call(state2, value, context, params, nextToken, object);
          }).then((result) => {
            stack2.push(result);
          });
        }
      },
      {
        type: Twig2.expression.type.key.brackets,
        regex: /^\[([^\]]*)\]/,
        next: Twig2.expression.set.operationsExtended.concat([
          Twig2.expression.type.parameter.start
        ]),
        compile(token, stack2, output) {
          const match = token.match[1];
          delete token.value;
          delete token.match;
          token.stack = Twig2.expression.compile({
            value: match
          }).stack;
          output.push(token);
        },
        parse(token, stack2, context, nextToken) {
          const state2 = this;
          let params = null;
          let object;
          let value;
          return parseParams(state2, token.params, context).then((parameters) => {
            params = parameters;
            return Twig2.expression.parseAsync.call(state2, token.stack, context);
          }).then((key) => {
            object = stack2.pop();
            if (object && !Object.prototype.hasOwnProperty.call(object, key) && state2.template.options.strictVariables) {
              const keys = Object.keys(object);
              if (keys.length > 0) {
                throw new Twig2.Error('Key "' + key + '" for array with keys "' + keys.join(", ") + '" does not exist.');
              } else {
                throw new Twig2.Error('Key "' + key + '" does not exist as the array is empty.');
              }
            } else if (object === null || object === void 0) {
              return null;
            }
            if (typeof object === "object" && key in object) {
              value = object[key];
            } else {
              value = null;
            }
            return Twig2.expression.resolveAsync.call(state2, value, object, params, nextToken);
          }).then((result) => {
            stack2.push(result);
          });
        }
      },
      {
        /**
         * Match a null value.
         */
        type: Twig2.expression.type._null,
        // Match a number
        regex: /^(null|NULL|none|NONE)/,
        next: Twig2.expression.set.operations,
        compile(token, stack2, output) {
          delete token.match;
          token.value = null;
          output.push(token);
        },
        parse: Twig2.expression.fn.parse.pushValue
      },
      {
        /**
         * Match the context
         */
        type: Twig2.expression.type.context,
        regex: /^_context/,
        next: Twig2.expression.set.operationsExtended.concat([
          Twig2.expression.type.parameter.start
        ]),
        compile: Twig2.expression.fn.compile.push,
        parse(token, stack2, context) {
          stack2.push(context);
        }
      },
      {
        /**
         * Match a boolean
         */
        type: Twig2.expression.type.bool,
        regex: /^(true|TRUE|false|FALSE)/,
        next: Twig2.expression.set.operations,
        compile(token, stack2, output) {
          token.value = token.match[0].toLowerCase() === "true";
          delete token.match;
          output.push(token);
        },
        parse: Twig2.expression.fn.parse.pushValue
      }
    ];
    Twig2.expression.resolveAsync = function(value, context, params, nextToken, object) {
      const state2 = this;
      if (typeof value !== "function") {
        return Twig2.Promise.resolve(value);
      }
      let promise = Twig2.Promise.resolve(params);
      if (nextToken && nextToken.type === Twig2.expression.type.parameter.end) {
        const tokensAreParameters = true;
        promise = promise.then(() => {
          return nextToken.params && Twig2.expression.parseAsync.call(state2, nextToken.params, context, tokensAreParameters);
        }).then((p2) => {
          nextToken.cleanup = true;
          return p2;
        });
      }
      return promise.then((params2) => {
        return value.apply(object || context, params2 || []);
      });
    };
    Twig2.expression.resolve = function(value, context, params, nextToken, object) {
      return Twig2.async.potentiallyAsync(this, false, function() {
        return Twig2.expression.resolveAsync.call(this, value, context, params, nextToken, object);
      });
    };
    Twig2.expression.handler = {};
    Twig2.expression.extendType = function(type2) {
      Twig2.expression.type[type2] = "Twig.expression.type." + type2;
    };
    Twig2.expression.extend = function(definition) {
      if (!definition.type) {
        throw new Twig2.Error("Unable to extend logic definition. No type provided for " + definition);
      }
      Twig2.expression.handler[definition.type] = definition;
    };
    while (Twig2.expression.definitions.length > 0) {
      Twig2.expression.extend(Twig2.expression.definitions.shift());
    }
    Twig2.expression.tokenize = function(rawToken) {
      let expression = rawToken.value;
      const tokens2 = [];
      let expOffset = 0;
      let next = null;
      let type2;
      let regex;
      let regexI;
      let tokenNext;
      let matchFound;
      let invalidMatches = [];
      const matchFunction = function(...args) {
        let matchI = arguments.length - 2;
        const match = new Array(matchI);
        while (matchI-- > 0) {
          match[matchI] = args[matchI];
        }
        Twig2.log.trace(
          "Twig.expression.tokenize",
          "Matched a ",
          type2,
          " regular expression of ",
          match
        );
        if (next && !next.includes(type2)) {
          invalidMatches.push(
            type2 + " cannot follow a " + tokens2[tokens2.length - 1].type + " at template:" + expOffset + " near '" + match[0].slice(0, 20) + "...'"
          );
          return match[0];
        }
        const handler = Twig2.expression.handler[type2];
        if (handler.validate && !handler.validate(match, tokens2)) {
          return match[0];
        }
        invalidMatches = [];
        const token = {
          type: type2,
          value: match[0],
          match
        };
        if (rawToken.position) {
          token.position = rawToken.position;
        }
        tokens2.push(token);
        matchFound = true;
        next = tokenNext;
        expOffset += match[0].length;
        if (handler.transform) {
          return handler.transform(match, tokens2);
        }
        return "";
      };
      Twig2.log.debug("Twig.expression.tokenize", "Tokenizing expression ", expression);
      while (expression.length > 0) {
        expression = expression.trim();
        for (type2 in Twig2.expression.handler) {
          if (Object.hasOwnProperty.call(Twig2.expression.handler, type2)) {
            tokenNext = Twig2.expression.handler[type2].next;
            regex = Twig2.expression.handler[type2].regex;
            Twig2.log.trace("Checking type ", type2, " on ", expression);
            matchFound = false;
            if (Array.isArray(regex)) {
              regexI = regex.length;
              while (regexI-- > 0) {
                expression = expression.replace(regex[regexI], matchFunction);
              }
            } else {
              expression = expression.replace(regex, matchFunction);
            }
            if (matchFound) {
              break;
            }
          }
        }
        if (!matchFound) {
          if (invalidMatches.length > 0) {
            throw new Twig2.Error(invalidMatches.join(" OR "));
          } else {
            throw new Twig2.Error("Unable to parse '" + expression + "' at template position" + expOffset);
          }
        }
      }
      Twig2.log.trace("Twig.expression.tokenize", "Tokenized to ", tokens2);
      return tokens2;
    };
    Twig2.expression.compile = function(rawToken) {
      const tokens2 = Twig2.expression.tokenize(rawToken);
      let token = null;
      const output = [];
      const stack2 = [];
      let tokenTemplate = null;
      Twig2.log.trace("Twig.expression.compile: ", "Compiling ", rawToken.value);
      while (tokens2.length > 0) {
        token = tokens2.shift();
        tokenTemplate = Twig2.expression.handler[token.type];
        Twig2.log.trace("Twig.expression.compile: ", "Compiling ", token);
        tokenTemplate.compile(token, stack2, output);
        Twig2.log.trace("Twig.expression.compile: ", "Stack is", stack2);
        Twig2.log.trace("Twig.expression.compile: ", "Output is", output);
      }
      while (stack2.length > 0) {
        output.push(stack2.pop());
      }
      Twig2.log.trace("Twig.expression.compile: ", "Final output is", output);
      rawToken.stack = output;
      delete rawToken.value;
      return rawToken;
    };
    Twig2.expression.parse = function(tokens2, context, tokensAreParameters, allowAsync) {
      const state2 = this;
      if (!Array.isArray(tokens2)) {
        tokens2 = [tokens2];
      }
      const stack2 = [];
      const loopTokenFixups = [];
      const binaryOperator = Twig2.expression.type.operator.binary;
      return Twig2.async.potentiallyAsync(state2, allowAsync, () => {
        return Twig2.async.forEach(tokens2, (token, index2) => {
          let tokenTemplate = null;
          let nextToken = null;
          let result;
          if (token.cleanup) {
            return;
          }
          if (tokens2.length > index2 + 1) {
            nextToken = tokens2[index2 + 1];
          }
          tokenTemplate = Twig2.expression.handler[token.type];
          if (tokenTemplate.parse) {
            result = tokenTemplate.parse.call(state2, token, stack2, context, nextToken);
          }
          if (token.type === binaryOperator && context.loop) {
            loopTokenFixups.push(token);
          }
          return result;
        }).then(() => {
          let len = loopTokenFixups.length;
          let loopTokenFixup = null;
          while (len-- > 0) {
            loopTokenFixup = loopTokenFixups[len];
            if (loopTokenFixup.params && loopTokenFixup.key) {
              delete loopTokenFixup.key;
            }
          }
          if (tokensAreParameters) {
            const params = stack2.splice(0);
            stack2.push(params);
          }
          return stack2.pop();
        });
      });
    };
    return Twig2;
  };
  return twig_expression;
}
var twig_filters;
var hasRequiredTwig_filters;
function requireTwig_filters() {
  if (hasRequiredTwig_filters)
    return twig_filters;
  hasRequiredTwig_filters = 1;
  twig_filters = function(Twig2) {
    function is(type2, obj) {
      const clas = Object.prototype.toString.call(obj).slice(8, -1);
      return obj !== void 0 && obj !== null && clas === type2;
    }
    Twig2.filters = {
      // String Filters
      upper(value) {
        if (typeof value !== "string") {
          return value;
        }
        return value.toUpperCase();
      },
      lower(value) {
        if (typeof value !== "string") {
          return value;
        }
        return value.toLowerCase();
      },
      capitalize(value) {
        if (typeof value !== "string") {
          return value;
        }
        return value.slice(0, 1).toUpperCase() + value.toLowerCase().slice(1);
      },
      title(value) {
        if (typeof value !== "string") {
          return value;
        }
        return value.toLowerCase().replace(/(^|\s)([a-z])/g, (m, p1, p2) => {
          return p1 + p2.toUpperCase();
        });
      },
      length(value) {
        if (Twig2.lib.is("Array", value) || typeof value === "string") {
          return value.length;
        }
        if (Twig2.lib.is("Object", value)) {
          if (value._keys === void 0) {
            return Object.keys(value).length;
          }
          return value._keys.length;
        }
        return 0;
      },
      // Array/Object Filters
      reverse(value) {
        if (is("Array", value)) {
          return value.reverse();
        }
        if (is("String", value)) {
          return value.split("").reverse().join("");
        }
        if (is("Object", value)) {
          const keys = value._keys || Object.keys(value).reverse();
          value._keys = keys;
          return value;
        }
      },
      sort(value) {
        if (is("Array", value)) {
          return value.sort();
        }
        if (is("Object", value)) {
          delete value._keys;
          const keys = Object.keys(value);
          const sortedKeys = keys.sort((a, b) => {
            let a1;
            let b1;
            if (value[a] > value[b] === !(value[a] <= value[b])) {
              return value[a] > value[b] ? 1 : value[a] < value[b] ? -1 : 0;
            }
            if (!isNaN(a1 = parseFloat(value[a])) && !isNaN(b1 = parseFloat(value[b]))) {
              return a1 > b1 ? 1 : a1 < b1 ? -1 : 0;
            }
            if (typeof value[a] === "string") {
              return value[a] > value[b].toString() ? 1 : value[a] < value[b].toString() ? -1 : 0;
            }
            if (typeof value[b] === "string") {
              return value[a].toString() > value[b] ? 1 : value[a].toString() < value[b] ? -1 : 0;
            }
            return null;
          });
          value._keys = sortedKeys;
          return value;
        }
      },
      keys(value) {
        if (value === void 0 || value === null) {
          return;
        }
        const keyset = value._keys || Object.keys(value);
        const output = [];
        keyset.forEach((key) => {
          if (key === "_keys") {
            return;
          }
          if (Object.hasOwnProperty.call(value, key)) {
            output.push(key);
          }
        });
        return output;
      },
      /* eslint-disable-next-line camelcase */
      url_encode(value) {
        if (value === void 0 || value === null) {
          return;
        }
        if (Twig2.lib.is("Object", value)) {
          const serialize = function(obj, prefix) {
            const result2 = [];
            const keyset = obj._keys || Object.keys(obj);
            keyset.forEach((key) => {
              if (!Object.prototype.hasOwnProperty.call(obj, key)) {
                return;
              }
              const resultKey = prefix ? prefix + "[" + key + "]" : key;
              const resultValue = obj[key];
              result2.push(
                Twig2.lib.is("Object", resultValue) || Array.isArray(resultValue) ? serialize(resultValue, resultKey) : encodeURIComponent(resultKey) + "=" + encodeURIComponent(resultValue)
              );
            });
            return result2.join("&amp;");
          };
          return serialize(value);
        }
        let result = encodeURIComponent(value);
        result = result.replace("'", "%27");
        return result;
      },
      join(value, params) {
        if (value === void 0 || value === null) {
          return;
        }
        let joinStr = "";
        let output = [];
        let keyset = null;
        if (params && params[0]) {
          joinStr = params[0];
        }
        if (is("Array", value)) {
          output = value;
        } else {
          keyset = value._keys || Object.keys(value);
          keyset.forEach((key) => {
            if (key === "_keys") {
              return;
            }
            if (Object.hasOwnProperty.call(value, key)) {
              output.push(value[key]);
            }
          });
        }
        return output.join(joinStr);
      },
      default(value, params) {
        if (params !== void 0 && params.length > 1) {
          throw new Twig2.Error("default filter expects one argument");
        }
        if (value === void 0 || value === null || value === "") {
          if (params === void 0) {
            return "";
          }
          return params[0];
        }
        return value;
      },
      /* eslint-disable-next-line camelcase */
      json_encode(value) {
        if (value === void 0 || value === null) {
          return "null";
        }
        if (typeof value === "object" && is("Array", value)) {
          const output = [];
          value.forEach((v) => {
            output.push(Twig2.filters.json_encode(v));
          });
          return "[" + output.join(",") + "]";
        }
        if (typeof value === "object" && is("Date", value)) {
          return '"' + value.toISOString() + '"';
        }
        if (typeof value === "object") {
          const keyset = value._keys || Object.keys(value);
          const output = [];
          keyset.forEach((key) => {
            output.push(JSON.stringify(key) + ":" + Twig2.filters.json_encode(value[key]));
          });
          return "{" + output.join(",") + "}";
        }
        return JSON.stringify(value);
      },
      merge(value, params) {
        let obj = [];
        let arrIndex = 0;
        let keyset = [];
        if (is("Array", value)) {
          params.forEach((param) => {
            if (!is("Array", param)) {
              obj = {};
            }
          });
        } else {
          obj = {};
        }
        if (!is("Array", obj)) {
          obj._keys = [];
        }
        if (is("Array", value)) {
          value.forEach((val) => {
            if (obj._keys) {
              obj._keys.push(arrIndex);
            }
            obj[arrIndex] = val;
            arrIndex++;
          });
        } else {
          keyset = value._keys || Object.keys(value);
          keyset.forEach((key) => {
            obj[key] = value[key];
            obj._keys.push(key);
            const intKey = parseInt(key, 10);
            if (!isNaN(intKey) && intKey >= arrIndex) {
              arrIndex = intKey + 1;
            }
          });
        }
        params.forEach((param) => {
          if (is("Array", param)) {
            param.forEach((val) => {
              if (obj._keys) {
                obj._keys.push(arrIndex);
              }
              obj[arrIndex] = val;
              arrIndex++;
            });
          } else {
            keyset = param._keys || Object.keys(param);
            keyset.forEach((key) => {
              if (!obj[key]) {
                obj._keys.push(key);
              }
              obj[key] = param[key];
              const intKey = parseInt(key, 10);
              if (!isNaN(intKey) && intKey >= arrIndex) {
                arrIndex = intKey + 1;
              }
            });
          }
        });
        if (params.length === 0) {
          throw new Twig2.Error("Filter merge expects at least one parameter");
        }
        return obj;
      },
      date(value, params) {
        const date2 = Twig2.functions.date(value);
        const format2 = params && Boolean(params.length) ? params[0] : "F j, Y H:i";
        return Twig2.lib.date(format2.replace(/\\\\/g, "\\"), date2);
      },
      /* eslint-disable-next-line camelcase */
      date_modify(value, params) {
        if (value === void 0 || value === null) {
          return;
        }
        if (params === void 0 || params.length !== 1) {
          throw new Twig2.Error("date_modify filter expects 1 argument");
        }
        const modifyText = params[0];
        let time;
        if (Twig2.lib.is("Date", value)) {
          time = Twig2.lib.strtotime(modifyText, value.getTime() / 1e3);
        }
        if (Twig2.lib.is("String", value)) {
          time = Twig2.lib.strtotime(modifyText, Twig2.lib.strtotime(value));
        }
        if (Twig2.lib.is("Number", value)) {
          time = Twig2.lib.strtotime(modifyText, value);
        }
        return new Date(time * 1e3);
      },
      replace(value, params) {
        if (value === void 0 || value === null) {
          return;
        }
        const pairs = params[0];
        let tag;
        for (tag in pairs) {
          if (Object.hasOwnProperty.call(pairs, tag) && tag !== "_keys") {
            value = Twig2.lib.replaceAll(value, tag, pairs[tag]);
          }
        }
        return value;
      },
      format(value, params) {
        if (value === void 0 || value === null) {
          return;
        }
        return Twig2.lib.vsprintf(value, params);
      },
      striptags(value, allowed) {
        if (value === void 0 || value === null) {
          return;
        }
        return Twig2.lib.stripTags(value, allowed);
      },
      escape(value, params) {
        if (value === void 0 || value === null || value === "") {
          return;
        }
        let strategy = "html";
        if (params && Boolean(params.length) && params[0] !== true) {
          strategy = params[0];
        }
        if (strategy === "html") {
          const rawValue = value.toString().replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
          return new Twig2.Markup(rawValue, "html");
        }
        if (strategy === "js") {
          const rawValue = value.toString();
          let result = "";
          for (let i = 0; i < rawValue.length; i++) {
            if (rawValue[i].match(/^[a-zA-Z0-9,._]$/)) {
              result += rawValue[i];
            } else {
              const char2 = rawValue.charAt(i);
              const charCode = rawValue.charCodeAt(i);
              const shortMap = {
                "\\": "\\\\",
                "/": "\\/",
                "\b": "\\b",
                "\f": "\\f",
                "\n": "\\n",
                "\r": "\\r",
                "	": "\\t"
              };
              if (shortMap[char2]) {
                result += shortMap[char2];
              } else {
                result += Twig2.lib.sprintf("\\u%04s", charCode.toString(16).toUpperCase());
              }
            }
          }
          return new Twig2.Markup(result, "js");
        }
        if (strategy === "css") {
          const rawValue = value.toString();
          let result = "";
          for (let i = 0; i < rawValue.length; i++) {
            if (rawValue[i].match(/^[a-zA-Z0-9]$/)) {
              result += rawValue[i];
            } else {
              const charCode = rawValue.charCodeAt(i);
              result += "\\" + charCode.toString(16).toUpperCase() + " ";
            }
          }
          return new Twig2.Markup(result, "css");
        }
        if (strategy === "url") {
          const result = Twig2.filters.url_encode(value);
          return new Twig2.Markup(result, "url");
        }
        if (strategy === "html_attr") {
          const rawValue = value.toString();
          let result = "";
          for (let i = 0; i < rawValue.length; i++) {
            if (rawValue[i].match(/^[a-zA-Z0-9,.\-_]$/)) {
              result += rawValue[i];
            } else if (rawValue[i].match(/^[&<>"]$/)) {
              result += rawValue[i].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
            } else {
              const charCode = rawValue.charCodeAt(i);
              if (charCode <= 31 && charCode !== 9 && charCode !== 10 && charCode !== 13) {
                result += "&#xFFFD;";
              } else if (charCode < 128) {
                result += Twig2.lib.sprintf("&#x%02s;", charCode.toString(16).toUpperCase());
              } else {
                result += Twig2.lib.sprintf("&#x%04s;", charCode.toString(16).toUpperCase());
              }
            }
          }
          return new Twig2.Markup(result, "html_attr");
        }
        throw new Twig2.Error("escape strategy unsupported");
      },
      /* Alias of escape */
      e(value, params) {
        return Twig2.filters.escape(value, params);
      },
      nl2br(value) {
        if (value === void 0 || value === null || value === "") {
          return;
        }
        const linebreakTag = "BACKSLASH_n_replace";
        const br = "<br />" + linebreakTag;
        value = Twig2.filters.escape(value).replace(/\r\n/g, br).replace(/\r/g, br).replace(/\n/g, br);
        value = Twig2.lib.replaceAll(value, linebreakTag, "\n");
        return new Twig2.Markup(value);
      },
      /**
       * Adapted from: http://phpjs.org/functions/number_format:481
       */
      /* eslint-disable-next-line camelcase */
      number_format(value, params) {
        let number2 = value;
        const decimals = params && params[0] ? params[0] : void 0;
        const dec = params && params[1] !== void 0 ? params[1] : ".";
        const sep = params && params[2] !== void 0 ? params[2] : ",";
        number2 = String(number2).replace(/[^0-9+\-Ee.]/g, "");
        const n = isFinite(Number(number2)) ? Number(number2) : 0;
        const prec = isFinite(Number(decimals)) ? Math.abs(decimals) : 0;
        let s = "";
        const toFixedFix = function(n2, prec2) {
          const k = 10 ** prec2;
          return String(Math.round(n2 * k) / k);
        };
        s = (prec ? toFixedFix(n, prec) : String(Math.round(n))).split(".");
        if (s[0].length > 3) {
          s[0] = s[0].replace(/\B(?=(?:\d{3})+(?!\d))/g, sep);
        }
        if ((s[1] || "").length < prec) {
          s[1] = s[1] || "";
          s[1] += new Array(prec - s[1].length + 1).join("0");
        }
        return s.join(dec);
      },
      trim(value, params) {
        if (value === void 0 || value === null) {
          return;
        }
        let str = String(value);
        let whitespace;
        if (params && params[0]) {
          whitespace = String(params[0]);
        } else {
          whitespace = " \n\r	\f\v\u2028\u2029";
        }
        for (let i = 0; i < str.length; i++) {
          if (!whitespace.includes(str.charAt(i))) {
            str = str.slice(Math.max(0, i));
            break;
          }
        }
        for (let i = str.length - 1; i >= 0; i--) {
          if (!whitespace.includes(str.charAt(i))) {
            str = str.slice(0, Math.max(0, i + 1));
            break;
          }
        }
        return whitespace.includes(str.charAt(0)) ? "" : str;
      },
      truncate(value, params) {
        let length = 30;
        let preserve = false;
        let separator = "...";
        value = String(value);
        if (params) {
          if (params[0]) {
            length = params[0];
          }
          if (params[1]) {
            preserve = params[1];
          }
          if (params[2]) {
            separator = params[2];
          }
        }
        if (value.length > length) {
          if (preserve) {
            length = value.indexOf(" ", length);
            if (length === -1) {
              return value;
            }
          }
          value = value.slice(0, length) + separator;
        }
        return value;
      },
      slice(value, params) {
        if (value === void 0 || value === null) {
          return;
        }
        if (params === void 0 || params.length === 0) {
          throw new Twig2.Error("slice filter expects at least 1 argument");
        }
        const start = params[0] || 0;
        let length = params.length > 1 ? params[1] : value.length;
        const startIndex = start >= 0 ? start : Math.max(value.length + start, 0);
        if (length < 0) {
          length = value.length - startIndex + length;
        }
        if (Twig2.lib.is("Array", value)) {
          const output = [];
          for (let i = startIndex; i < startIndex + length && i < value.length; i++) {
            output.push(value[i]);
          }
          return output;
        }
        if (Twig2.lib.is("String", value)) {
          return value.slice(startIndex, startIndex + length);
        }
        throw new Twig2.Error("slice filter expects value to be an array or string");
      },
      abs(value) {
        if (value === void 0 || value === null) {
          return;
        }
        return Math.abs(value);
      },
      first(value) {
        if (is("Array", value)) {
          return value[0];
        }
        if (is("Object", value)) {
          if ("_keys" in value) {
            return value[value._keys[0]];
          }
        } else if (typeof value === "string") {
          return value.slice(0, 1);
        }
      },
      split(value, params) {
        if (value === void 0 || value === null) {
          return;
        }
        if (params === void 0 || params.length === 0 || params.length > 2) {
          throw new Twig2.Error("split filter expects 1 or 2 argument");
        }
        if (Twig2.lib.is("String", value)) {
          const delimiter = params[0];
          const limit = params[1];
          const split = value.split(delimiter);
          if (limit === void 0) {
            return split;
          }
          if (limit < 0) {
            return value.split(delimiter, split.length + limit);
          }
          const limitedSplit = [];
          if (delimiter === "") {
            while (split.length > 0) {
              let temp = "";
              for (let i = 0; i < limit && split.length > 0; i++) {
                temp += split.shift();
              }
              limitedSplit.push(temp);
            }
          } else {
            for (let i = 0; i < limit - 1 && split.length > 0; i++) {
              limitedSplit.push(split.shift());
            }
            if (split.length > 0) {
              limitedSplit.push(split.join(delimiter));
            }
          }
          return limitedSplit;
        }
        throw new Twig2.Error("split filter expects value to be a string");
      },
      last(value) {
        if (Twig2.lib.is("Object", value)) {
          let keys;
          if (value._keys === void 0) {
            keys = Object.keys(value);
          } else {
            keys = value._keys;
          }
          return value[keys[keys.length - 1]];
        }
        if (Twig2.lib.is("Number", value)) {
          return value.toString().slice(-1);
        }
        return value[value.length - 1];
      },
      raw(value) {
        return new Twig2.Markup(value || "");
      },
      batch(items, params) {
        let size2 = params.shift();
        const fill = params.shift();
        let last;
        let missing;
        if (!Twig2.lib.is("Array", items)) {
          throw new Twig2.Error("batch filter expects items to be an array");
        }
        if (!Twig2.lib.is("Number", size2)) {
          throw new Twig2.Error("batch filter expects size to be a number");
        }
        size2 = Math.ceil(size2);
        const result = Twig2.lib.chunkArray(items, size2);
        if (fill && items.length % size2 !== 0) {
          last = result.pop();
          missing = size2 - last.length;
          while (missing--) {
            last.push(fill);
          }
          result.push(last);
        }
        return result;
      },
      round(value, params) {
        params = params || [];
        const precision = params.length > 0 ? params[0] : 0;
        const method = params.length > 1 ? params[1] : "common";
        value = parseFloat(value);
        if (precision && !Twig2.lib.is("Number", precision)) {
          throw new Twig2.Error("round filter expects precision to be a number");
        }
        if (method === "common") {
          return Twig2.lib.round(value, precision);
        }
        if (!Twig2.lib.is("Function", Math[method])) {
          throw new Twig2.Error("round filter expects method to be 'floor', 'ceil', or 'common'");
        }
        return Math[method](value * 10 ** precision) / 10 ** precision;
      },
      spaceless(value) {
        return value.replace(/>\s+</g, "><").trim();
      }
    };
    Twig2.filter = function(filter, value, params) {
      const state2 = this;
      if (!Twig2.filters[filter]) {
        throw new Twig2.Error("Unable to find filter " + filter);
      }
      return Twig2.filters[filter].call(state2, value, params);
    };
    Twig2.filter.extend = function(filter, definition) {
      Twig2.filters[filter] = definition;
    };
    return Twig2;
  };
  return twig_filters;
}
var twig_functions = { exports: {} };
var hasRequiredTwig_functions;
function requireTwig_functions() {
  if (hasRequiredTwig_functions)
    return twig_functions.exports;
  hasRequiredTwig_functions = 1;
  (function(module) {
    module.exports = function(Twig2) {
      const TEMPLATE_NOT_FOUND_MESSAGE = 'Template "{name}" is not defined.';
      Twig2.functions = {
        //  Attribute, block, constant, date, dump, parent, random,.
        // Range function from http://phpjs.org/functions/range:499
        // Used under an MIT License
        range(low, high, step) {
          const matrix = [];
          let inival;
          let endval;
          const walker = step || 1;
          let chars = false;
          if (!isNaN(low) && !isNaN(high)) {
            inival = parseInt(low, 10);
            endval = parseInt(high, 10);
          } else if (isNaN(low) && isNaN(high)) {
            chars = true;
            inival = low.charCodeAt(0);
            endval = high.charCodeAt(0);
          } else {
            inival = isNaN(low) ? 0 : low;
            endval = isNaN(high) ? 0 : high;
          }
          const plus = !(inival > endval);
          if (plus) {
            while (inival <= endval) {
              matrix.push(chars ? String.fromCharCode(inival) : inival);
              inival += walker;
            }
          } else {
            while (inival >= endval) {
              matrix.push(chars ? String.fromCharCode(inival) : inival);
              inival -= walker;
            }
          }
          return matrix;
        },
        cycle(arr, i) {
          const pos = i % arr.length;
          return arr[pos];
        },
        dump(...args) {
          const argsCopy = [...args];
          const state2 = this;
          const EOL = "\n";
          const indentChar = "  ";
          let indentTimes = 0;
          let out = "";
          const indent = function(times) {
            let ind = "";
            while (times > 0) {
              times--;
              ind += indentChar;
            }
            return ind;
          };
          const displayVar = function(variable) {
            out += indent(indentTimes);
            if (typeof variable === "object") {
              dumpVar(variable);
            } else if (typeof variable === "function") {
              out += "function()" + EOL;
            } else if (typeof variable === "string") {
              out += "string(" + variable.length + ') "' + variable + '"' + EOL;
            } else if (typeof variable === "number") {
              out += "number(" + variable + ")" + EOL;
            } else if (typeof variable === "boolean") {
              out += "bool(" + variable + ")" + EOL;
            }
          };
          const dumpVar = function(variable) {
            let i;
            if (variable === null) {
              out += "NULL" + EOL;
            } else if (variable === void 0) {
              out += "undefined" + EOL;
            } else if (typeof variable === "object") {
              out += indent(indentTimes) + typeof variable;
              indentTimes++;
              out += "(" + function(obj) {
                let size2 = 0;
                let key;
                for (key in obj) {
                  if (Object.hasOwnProperty.call(obj, key)) {
                    size2++;
                  }
                }
                return size2;
              }(variable) + ") {" + EOL;
              for (i in variable) {
                if (Object.hasOwnProperty.call(variable, i)) {
                  out += indent(indentTimes) + "[" + i + "]=> " + EOL;
                  displayVar(variable[i]);
                }
              }
              indentTimes--;
              out += indent(indentTimes) + "}" + EOL;
            } else {
              displayVar(variable);
            }
          };
          if (argsCopy.length === 0) {
            argsCopy.push(state2.context);
          }
          argsCopy.forEach((variable) => {
            dumpVar(variable);
          });
          return out;
        },
        date(date2) {
          let dateObj;
          if (date2 === void 0 || date2 === null || date2 === "") {
            dateObj = /* @__PURE__ */ new Date();
          } else if (Twig2.lib.is("Date", date2)) {
            dateObj = date2;
          } else if (Twig2.lib.is("String", date2)) {
            if (date2.match(/^\d+$/)) {
              dateObj = new Date(date2 * 1e3);
            } else {
              dateObj = new Date(Twig2.lib.strtotime(date2) * 1e3);
            }
          } else if (Twig2.lib.is("Number", date2)) {
            dateObj = new Date(date2 * 1e3);
          } else {
            throw new Twig2.Error("Unable to parse date " + date2);
          }
          return dateObj;
        },
        block(blockName) {
          const state2 = this;
          const block = state2.getBlock(blockName);
          if (block !== void 0) {
            return block.render(state2, state2.context);
          }
        },
        parent() {
          const state2 = this;
          return state2.getBlock(state2.getNestingStackToken(Twig2.logic.type.block).blockName, true).render(state2, state2.context);
        },
        attribute(object, method, params) {
          if (Twig2.lib.is("Object", object)) {
            if (Object.hasOwnProperty.call(object, method)) {
              if (typeof object[method] === "function") {
                return object[method].apply(void 0, params);
              }
              return object[method];
            }
          }
          return object ? object[method] || void 0 : void 0;
        },
        max(values, ...args) {
          if (Twig2.lib.is("Object", values)) {
            delete values._keys;
            return Twig2.lib.max(values);
          }
          return Reflect.apply(Twig2.lib.max, null, [values, ...args]);
        },
        min(values, ...args) {
          if (Twig2.lib.is("Object", values)) {
            delete values._keys;
            return Twig2.lib.min(values);
          }
          return Reflect.apply(Twig2.lib.min, null, [values, ...args]);
        },
        /* eslint-disable-next-line camelcase */
        template_from_string(template) {
          const state2 = this;
          if (template === void 0) {
            template = "";
          }
          return Twig2.Templates.parsers.twig({
            options: state2.template.options,
            data: template
          });
        },
        random(value) {
          const LIMIT_INT31 = 2147483648;
          function getRandomNumber(n) {
            const random2 = Math.floor(Math.random() * LIMIT_INT31);
            const min2 = Math.min.call(null, 0, n);
            const max2 = Math.max.call(null, 0, n);
            return min2 + Math.floor((max2 - min2 + 1) * random2 / LIMIT_INT31);
          }
          if (Twig2.lib.is("Number", value)) {
            return getRandomNumber(value);
          }
          if (Twig2.lib.is("String", value)) {
            return value.charAt(getRandomNumber(value.length - 1));
          }
          if (Twig2.lib.is("Array", value)) {
            return value[getRandomNumber(value.length - 1)];
          }
          if (Twig2.lib.is("Object", value)) {
            const keys = Object.keys(value);
            return value[keys[getRandomNumber(keys.length - 1)]];
          }
          return getRandomNumber(LIMIT_INT31 - 1);
        },
        /**
         * Returns the content of a template without rendering it
         * @param {string} name
         * @param {boolean} [ignoreMissing=false]
         * @returns {string}
         */
        source(name, ignoreMissing) {
          const state2 = this;
          const { namespaces } = state2.template.options;
          let templateSource;
          let templateFound = false;
          const isNodeEnvironment = typeof window === "undefined";
          let loader;
          let path = name;
          if (namespaces && typeof namespaces === "object") {
            path = Twig2.path.expandNamespace(namespaces, path);
          }
          if (isNodeEnvironment) {
            loader = "fs";
          } else {
            loader = "ajax";
          }
          const params = {
            id: name,
            path,
            method: loader,
            parser: "source",
            async: false,
            fetchTemplateSource: true
          };
          if (typeof ignoreMissing === "undefined") {
            ignoreMissing = false;
          }
          try {
            templateSource = Twig2.Templates.loadRemote(name, params);
            if (typeof templateSource === "undefined" || templateSource === null) {
              templateSource = "";
            } else {
              templateFound = true;
            }
          } catch (error) {
            Twig2.log.debug("Twig.functions.source: ", "Problem loading template  ", error);
          }
          if (!templateFound && !ignoreMissing) {
            return TEMPLATE_NOT_FOUND_MESSAGE.replace("{name}", name);
          }
          return templateSource;
        }
      };
      Twig2._function = function(_function, value, params) {
        if (!Twig2.functions[_function]) {
          throw new Twig2.Error("Unable to find function " + _function);
        }
        return Twig2.functions[_function](value, params);
      };
      Twig2._function.extend = function(_function, definition) {
        Twig2.functions[_function] = definition;
      };
      return Twig2;
    };
  })(twig_functions);
  return twig_functions.exports;
}
var sprintf;
var hasRequiredSprintf;
function requireSprintf() {
  if (hasRequiredSprintf)
    return sprintf;
  hasRequiredSprintf = 1;
  sprintf = function sprintf2() {
    var regex = /%%|%(?:(\d+)\$)?((?:[-+#0 ]|'[\s\S])*)(\d+)?(?:\.(\d*))?([\s\S])/g;
    var args = arguments;
    var i = 0;
    var format2 = args[i++];
    var _pad = function _pad2(str, len, chr, leftJustify) {
      if (!chr) {
        chr = " ";
      }
      var padding = str.length >= len ? "" : new Array(1 + len - str.length >>> 0).join(chr);
      return leftJustify ? str + padding : padding + str;
    };
    var justify = function justify2(value, prefix, leftJustify, minWidth, padChar) {
      var diff2 = minWidth - value.length;
      if (diff2 > 0) {
        if (!leftJustify && padChar === "0") {
          value = [value.slice(0, prefix.length), _pad("", diff2, "0", true), value.slice(prefix.length)].join("");
        } else {
          value = _pad(value, minWidth, padChar, leftJustify);
        }
      }
      return value;
    };
    var _formatBaseX = function _formatBaseX2(value, base, leftJustify, minWidth, precision, padChar) {
      var number2 = value >>> 0;
      value = _pad(number2.toString(base), precision || 0, "0", false);
      return justify(value, "", leftJustify, minWidth, padChar);
    };
    var _formatString = function _formatString2(value, leftJustify, minWidth, precision, customPadChar) {
      if (precision !== null && precision !== void 0) {
        value = value.slice(0, precision);
      }
      return justify(value, "", leftJustify, minWidth, customPadChar);
    };
    var doFormat = function doFormat2(substring, argIndex, modifiers, minWidth, precision, specifier) {
      var number2 = void 0, prefix = void 0, method = void 0, textTransform = void 0, value = void 0;
      if (substring === "%%") {
        return "%";
      }
      var padChar = " ";
      var leftJustify = false;
      var positiveNumberPrefix = "";
      var j = void 0, l = void 0;
      for (j = 0, l = modifiers.length; j < l; j++) {
        switch (modifiers.charAt(j)) {
          case " ":
          case "0":
            padChar = modifiers.charAt(j);
            break;
          case "+":
            positiveNumberPrefix = "+";
            break;
          case "-":
            leftJustify = true;
            break;
          case "'":
            if (j + 1 < l) {
              padChar = modifiers.charAt(j + 1);
              j++;
            }
            break;
        }
      }
      if (!minWidth) {
        minWidth = 0;
      } else {
        minWidth = +minWidth;
      }
      if (!isFinite(minWidth)) {
        throw new Error("Width must be finite");
      }
      if (!precision) {
        precision = specifier === "d" ? 0 : "fFeE".indexOf(specifier) > -1 ? 6 : void 0;
      } else {
        precision = +precision;
      }
      if (argIndex && +argIndex === 0) {
        throw new Error("Argument number must be greater than zero");
      }
      if (argIndex && +argIndex >= args.length) {
        throw new Error("Too few arguments");
      }
      value = argIndex ? args[+argIndex] : args[i++];
      switch (specifier) {
        case "%":
          return "%";
        case "s":
          return _formatString(value + "", leftJustify, minWidth, precision, padChar);
        case "c":
          return _formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, padChar);
        case "b":
          return _formatBaseX(value, 2, leftJustify, minWidth, precision, padChar);
        case "o":
          return _formatBaseX(value, 8, leftJustify, minWidth, precision, padChar);
        case "x":
          return _formatBaseX(value, 16, leftJustify, minWidth, precision, padChar);
        case "X":
          return _formatBaseX(value, 16, leftJustify, minWidth, precision, padChar).toUpperCase();
        case "u":
          return _formatBaseX(value, 10, leftJustify, minWidth, precision, padChar);
        case "i":
        case "d":
          number2 = +value || 0;
          number2 = Math.round(number2 - number2 % 1);
          prefix = number2 < 0 ? "-" : positiveNumberPrefix;
          value = prefix + _pad(String(Math.abs(number2)), precision, "0", false);
          if (leftJustify && padChar === "0") {
            padChar = " ";
          }
          return justify(value, prefix, leftJustify, minWidth, padChar);
        case "e":
        case "E":
        case "f":
        case "F":
        case "g":
        case "G":
          number2 = +value;
          prefix = number2 < 0 ? "-" : positiveNumberPrefix;
          method = ["toExponential", "toFixed", "toPrecision"]["efg".indexOf(specifier.toLowerCase())];
          textTransform = ["toString", "toUpperCase"]["eEfFgG".indexOf(specifier) % 2];
          value = prefix + Math.abs(number2)[method](precision);
          return justify(value, prefix, leftJustify, minWidth, padChar)[textTransform]();
        default:
          return "";
      }
    };
    try {
      return format2.replace(regex, doFormat);
    } catch (err) {
      return false;
    }
  };
  return sprintf;
}
var vsprintf;
var hasRequiredVsprintf;
function requireVsprintf() {
  if (hasRequiredVsprintf)
    return vsprintf;
  hasRequiredVsprintf = 1;
  vsprintf = function vsprintf2(format2, args) {
    var sprintf2 = requireSprintf();
    return sprintf2.apply(this, [format2].concat(args));
  };
  return vsprintf;
}
var _php_cast_int;
var hasRequired_php_cast_int;
function require_php_cast_int() {
  if (hasRequired_php_cast_int)
    return _php_cast_int;
  hasRequired_php_cast_int = 1;
  var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  _php_cast_int = function _php_cast_int2(value) {
    var type2 = typeof value === "undefined" ? "undefined" : _typeof2(value);
    switch (type2) {
      case "number":
        if (isNaN(value) || !isFinite(value)) {
          return 0;
        }
        return value < 0 ? Math.ceil(value) : Math.floor(value);
      case "string":
        return parseInt(value, 10) || 0;
      case "boolean":
      default:
        return +!!value;
    }
  };
  return _php_cast_int;
}
var _php_cast_float;
var hasRequired_php_cast_float;
function require_php_cast_float() {
  if (hasRequired_php_cast_float)
    return _php_cast_float;
  hasRequired_php_cast_float = 1;
  var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  _php_cast_float = function _php_cast_float2(value) {
    var type2 = typeof value === "undefined" ? "undefined" : _typeof2(value);
    switch (type2) {
      case "number":
        return value;
      case "string":
        return parseFloat(value) || 0;
      case "boolean":
      default:
        return require_php_cast_int()(value);
    }
  };
  return _php_cast_float;
}
var round$1;
var hasRequiredRound;
function requireRound() {
  if (hasRequiredRound)
    return round$1;
  hasRequiredRound = 1;
  function roundToInt(value, mode) {
    var tmp = Math.floor(Math.abs(value) + 0.5);
    if (mode === "PHP_ROUND_HALF_DOWN" && value === tmp - 0.5 || mode === "PHP_ROUND_HALF_EVEN" && value === 0.5 + 2 * Math.floor(tmp / 2) || mode === "PHP_ROUND_HALF_ODD" && value === 0.5 + 2 * Math.floor(tmp / 2) - 1) {
      tmp -= 1;
    }
    return value < 0 ? -tmp : tmp;
  }
  round$1 = function round2(value) {
    var precision = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "PHP_ROUND_HALF_UP";
    var floatCast = require_php_cast_float();
    var intCast = require_php_cast_int();
    var p2 = void 0;
    value = floatCast(value);
    precision = intCast(precision);
    p2 = Math.pow(10, precision);
    if (isNaN(value) || !isFinite(value)) {
      return value;
    }
    if (Math.trunc(value) === value && precision >= 0) {
      return value;
    }
    var preRoundPrecision = 14 - Math.floor(Math.log10(Math.abs(value)));
    if (preRoundPrecision > precision && preRoundPrecision - 15 < precision) {
      value = roundToInt(value * Math.pow(10, preRoundPrecision), mode);
      value /= Math.pow(10, Math.abs(precision - preRoundPrecision));
    } else {
      value *= p2;
    }
    value = roundToInt(value, mode);
    return value / p2;
  };
  return round$1;
}
var max;
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax)
    return max;
  hasRequiredMax = 1;
  var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  max = function max2() {
    var ar = void 0;
    var retVal = void 0;
    var i = 0;
    var n = 0;
    var argv = arguments;
    var argc = argv.length;
    var _obj2Array = function _obj2Array2(obj) {
      if (Object.prototype.toString.call(obj) === "[object Array]") {
        return obj;
      } else {
        var _ar = [];
        for (var _i in obj) {
          if (obj.hasOwnProperty(_i)) {
            _ar.push(obj[_i]);
          }
        }
        return _ar;
      }
    };
    var _compare = function _compare2(current, next) {
      var i2 = 0;
      var n2 = 0;
      var tmp = 0;
      var nl = 0;
      var cl = 0;
      if (current === next) {
        return 0;
      } else if ((typeof current === "undefined" ? "undefined" : _typeof2(current)) === "object") {
        if ((typeof next === "undefined" ? "undefined" : _typeof2(next)) === "object") {
          current = _obj2Array(current);
          next = _obj2Array(next);
          cl = current.length;
          nl = next.length;
          if (nl > cl) {
            return 1;
          } else if (nl < cl) {
            return -1;
          }
          for (i2 = 0, n2 = cl; i2 < n2; ++i2) {
            tmp = _compare2(current[i2], next[i2]);
            if (tmp === 1) {
              return 1;
            } else if (tmp === -1) {
              return -1;
            }
          }
          return 0;
        }
        return -1;
      } else if ((typeof next === "undefined" ? "undefined" : _typeof2(next)) === "object") {
        return 1;
      } else if (isNaN(next) && !isNaN(current)) {
        if (current === 0) {
          return 0;
        }
        return current < 0 ? 1 : -1;
      } else if (isNaN(current) && !isNaN(next)) {
        if (next === 0) {
          return 0;
        }
        return next > 0 ? 1 : -1;
      }
      if (next === current) {
        return 0;
      }
      return next > current ? 1 : -1;
    };
    if (argc === 0) {
      throw new Error("At least one value should be passed to max()");
    } else if (argc === 1) {
      if (_typeof2(argv[0]) === "object") {
        ar = _obj2Array(argv[0]);
      } else {
        throw new Error("Wrong parameter count for max()");
      }
      if (ar.length === 0) {
        throw new Error("Array must contain at least one element for max()");
      }
    } else {
      ar = argv;
    }
    retVal = ar[0];
    for (i = 1, n = ar.length; i < n; ++i) {
      if (_compare(retVal, ar[i]) === 1) {
        retVal = ar[i];
      }
    }
    return retVal;
  };
  return max;
}
var min;
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin)
    return min;
  hasRequiredMin = 1;
  var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  min = function min2() {
    var ar = void 0;
    var retVal = void 0;
    var i = 0;
    var n = 0;
    var argv = arguments;
    var argc = argv.length;
    var _obj2Array = function _obj2Array2(obj) {
      if (Object.prototype.toString.call(obj) === "[object Array]") {
        return obj;
      }
      var ar2 = [];
      for (var _i in obj) {
        if (obj.hasOwnProperty(_i)) {
          ar2.push(obj[_i]);
        }
      }
      return ar2;
    };
    var _compare = function _compare2(current, next) {
      var i2 = 0;
      var n2 = 0;
      var tmp = 0;
      var nl = 0;
      var cl = 0;
      if (current === next) {
        return 0;
      } else if ((typeof current === "undefined" ? "undefined" : _typeof2(current)) === "object") {
        if ((typeof next === "undefined" ? "undefined" : _typeof2(next)) === "object") {
          current = _obj2Array(current);
          next = _obj2Array(next);
          cl = current.length;
          nl = next.length;
          if (nl > cl) {
            return 1;
          } else if (nl < cl) {
            return -1;
          }
          for (i2 = 0, n2 = cl; i2 < n2; ++i2) {
            tmp = _compare2(current[i2], next[i2]);
            if (tmp === 1) {
              return 1;
            } else if (tmp === -1) {
              return -1;
            }
          }
          return 0;
        }
        return -1;
      } else if ((typeof next === "undefined" ? "undefined" : _typeof2(next)) === "object") {
        return 1;
      } else if (isNaN(next) && !isNaN(current)) {
        if (current === 0) {
          return 0;
        }
        return current < 0 ? 1 : -1;
      } else if (isNaN(current) && !isNaN(next)) {
        if (next === 0) {
          return 0;
        }
        return next > 0 ? 1 : -1;
      }
      if (next === current) {
        return 0;
      }
      return next > current ? 1 : -1;
    };
    if (argc === 0) {
      throw new Error("At least one value should be passed to min()");
    } else if (argc === 1) {
      if (_typeof2(argv[0]) === "object") {
        ar = _obj2Array(argv[0]);
      } else {
        throw new Error("Wrong parameter count for min()");
      }
      if (ar.length === 0) {
        throw new Error("Array must contain at least one element for min()");
      }
    } else {
      ar = argv;
    }
    retVal = ar[0];
    for (i = 1, n = ar.length; i < n; ++i) {
      if (_compare(retVal, ar[i]) === -1) {
        retVal = ar[i];
      }
    }
    return retVal;
  };
  return min;
}
var _phpCastString;
var hasRequired_phpCastString;
function require_phpCastString() {
  if (hasRequired_phpCastString)
    return _phpCastString;
  hasRequired_phpCastString = 1;
  var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  _phpCastString = function _phpCastString2(value) {
    var type2 = typeof value === "undefined" ? "undefined" : _typeof2(value);
    switch (type2) {
      case "boolean":
        return value ? "1" : "";
      case "string":
        return value;
      case "number":
        if (isNaN(value)) {
          return "NAN";
        }
        if (!isFinite(value)) {
          return (value < 0 ? "-" : "") + "INF";
        }
        return value + "";
      case "undefined":
        return "";
      case "object":
        if (Array.isArray(value)) {
          return "Array";
        }
        if (value !== null) {
          return "Object";
        }
        return "";
      case "function":
      default:
        throw new Error("Unsupported value type");
    }
  };
  return _phpCastString;
}
var strip_tags;
var hasRequiredStrip_tags;
function requireStrip_tags() {
  if (hasRequiredStrip_tags)
    return strip_tags;
  hasRequiredStrip_tags = 1;
  strip_tags = function strip_tags2(input, allowed) {
    var _phpCastString2 = require_phpCastString();
    allowed = (((allowed || "") + "").toLowerCase().match(/<[a-z][a-z0-9]*>/g) || []).join("");
    var tags = /<\/?([a-z0-9]*)\b[^>]*>?/gi;
    var commentsAndPhpTags = /<!--[\s\S]*?-->|<\?(?:php)?[\s\S]*?\?>/gi;
    var after = _phpCastString2(input);
    after = after.substring(after.length - 1) === "<" ? after.substring(0, after.length - 1) : after;
    while (true) {
      var before = after;
      after = before.replace(commentsAndPhpTags, "").replace(tags, function($0, $1) {
        return allowed.indexOf("<" + $1.toLowerCase() + ">") > -1 ? $0 : "";
      });
      if (before === after) {
        return after;
      }
    }
  };
  return strip_tags;
}
var strtotime;
var hasRequiredStrtotime;
function requireStrtotime() {
  if (hasRequiredStrtotime)
    return strtotime;
  hasRequiredStrtotime = 1;
  var reSpace = "[ \\t]+";
  var reSpaceOpt = "[ \\t]*";
  var reMeridian = "(?:([ap])\\.?m\\.?([\\t ]|$))";
  var reHour24 = "(2[0-4]|[01]?[0-9])";
  var reHour24lz = "([01][0-9]|2[0-4])";
  var reHour12 = "(0?[1-9]|1[0-2])";
  var reMinute = "([0-5]?[0-9])";
  var reMinutelz = "([0-5][0-9])";
  var reSecond = "(60|[0-5]?[0-9])";
  var reSecondlz = "(60|[0-5][0-9])";
  var reFrac = "(?:\\.([0-9]+))";
  var reDayfull = "sunday|monday|tuesday|wednesday|thursday|friday|saturday";
  var reDayabbr = "sun|mon|tue|wed|thu|fri|sat";
  var reDaytext = reDayfull + "|" + reDayabbr + "|weekdays?";
  var reReltextnumber = "first|second|third|fourth|fifth|sixth|seventh|eighth?|ninth|tenth|eleventh|twelfth";
  var reReltexttext = "next|last|previous|this";
  var reReltextunit = "(?:second|sec|minute|min|hour|day|fortnight|forthnight|month|year)s?|weeks|" + reDaytext;
  var reYear = "([0-9]{1,4})";
  var reYear2 = "([0-9]{2})";
  var reYear4 = "([0-9]{4})";
  var reYear4withSign = "([+-]?[0-9]{4})";
  var reMonth = "(1[0-2]|0?[0-9])";
  var reMonthlz = "(0[0-9]|1[0-2])";
  var reDay = "(?:(3[01]|[0-2]?[0-9])(?:st|nd|rd|th)?)";
  var reDaylz = "(0[0-9]|[1-2][0-9]|3[01])";
  var reMonthFull = "january|february|march|april|may|june|july|august|september|october|november|december";
  var reMonthAbbr = "jan|feb|mar|apr|may|jun|jul|aug|sept?|oct|nov|dec";
  var reMonthroman = "i[vx]|vi{0,3}|xi{0,2}|i{1,3}";
  var reMonthText = "(" + reMonthFull + "|" + reMonthAbbr + "|" + reMonthroman + ")";
  var reTzCorrection = "((?:GMT)?([+-])" + reHour24 + ":?" + reMinute + "?)";
  var reTzAbbr = "\\(?([a-zA-Z]{1,6})\\)?";
  var reDayOfYear = "(00[1-9]|0[1-9][0-9]|[12][0-9][0-9]|3[0-5][0-9]|36[0-6])";
  var reWeekOfYear = "(0[1-9]|[1-4][0-9]|5[0-3])";
  var reDateNoYear = reMonthText + "[ .\\t-]*" + reDay + "[,.stndrh\\t ]*";
  function processMeridian(hour, meridian) {
    meridian = meridian && meridian.toLowerCase();
    switch (meridian) {
      case "a":
        hour += hour === 12 ? -12 : 0;
        break;
      case "p":
        hour += hour !== 12 ? 12 : 0;
        break;
    }
    return hour;
  }
  function processYear(yearStr) {
    var year = +yearStr;
    if (yearStr.length < 4 && year < 100) {
      year += year < 70 ? 2e3 : 1900;
    }
    return year;
  }
  function lookupMonth(monthStr) {
    return {
      jan: 0,
      january: 0,
      i: 0,
      feb: 1,
      february: 1,
      ii: 1,
      mar: 2,
      march: 2,
      iii: 2,
      apr: 3,
      april: 3,
      iv: 3,
      may: 4,
      v: 4,
      jun: 5,
      june: 5,
      vi: 5,
      jul: 6,
      july: 6,
      vii: 6,
      aug: 7,
      august: 7,
      viii: 7,
      sep: 8,
      sept: 8,
      september: 8,
      ix: 8,
      oct: 9,
      october: 9,
      x: 9,
      nov: 10,
      november: 10,
      xi: 10,
      dec: 11,
      december: 11,
      xii: 11
    }[monthStr.toLowerCase()];
  }
  function lookupWeekday(dayStr) {
    var desiredSundayNumber = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var dayNumbers = {
      mon: 1,
      monday: 1,
      tue: 2,
      tuesday: 2,
      wed: 3,
      wednesday: 3,
      thu: 4,
      thursday: 4,
      fri: 5,
      friday: 5,
      sat: 6,
      saturday: 6,
      sun: 0,
      sunday: 0
    };
    return dayNumbers[dayStr.toLowerCase()] || desiredSundayNumber;
  }
  function lookupRelative(relText) {
    var relativeNumbers = {
      last: -1,
      previous: -1,
      this: 0,
      first: 1,
      next: 1,
      second: 2,
      third: 3,
      fourth: 4,
      fifth: 5,
      sixth: 6,
      seventh: 7,
      eight: 8,
      eighth: 8,
      ninth: 9,
      tenth: 10,
      eleventh: 11,
      twelfth: 12
    };
    var relativeBehavior = {
      this: 1
    };
    var relTextLower = relText.toLowerCase();
    return {
      amount: relativeNumbers[relTextLower],
      behavior: relativeBehavior[relTextLower] || 0
    };
  }
  function processTzCorrection(tzOffset, oldValue) {
    var reTzCorrectionLoose = /(?:GMT)?([+-])(\d+)(:?)(\d{0,2})/i;
    tzOffset = tzOffset && tzOffset.match(reTzCorrectionLoose);
    if (!tzOffset) {
      return oldValue;
    }
    var sign2 = tzOffset[1] === "-" ? -1 : 1;
    var hours = +tzOffset[2];
    var minutes = +tzOffset[4];
    if (!tzOffset[4] && !tzOffset[3]) {
      minutes = Math.floor(hours % 100);
      hours = Math.floor(hours / 100);
    }
    return sign2 * (hours * 60 + minutes) * 60;
  }
  var tzAbbrOffsets = {
    acdt: 37800,
    acst: 34200,
    addt: -7200,
    adt: -10800,
    aedt: 39600,
    aest: 36e3,
    ahdt: -32400,
    ahst: -36e3,
    akdt: -28800,
    akst: -32400,
    amt: -13840,
    apt: -10800,
    ast: -14400,
    awdt: 32400,
    awst: 28800,
    awt: -10800,
    bdst: 7200,
    bdt: -36e3,
    bmt: -14309,
    bst: 3600,
    cast: 34200,
    cat: 7200,
    cddt: -14400,
    cdt: -18e3,
    cemt: 10800,
    cest: 7200,
    cet: 3600,
    cmt: -15408,
    cpt: -18e3,
    cst: -21600,
    cwt: -18e3,
    chst: 36e3,
    dmt: -1521,
    eat: 10800,
    eddt: -10800,
    edt: -14400,
    eest: 10800,
    eet: 7200,
    emt: -26248,
    ept: -14400,
    est: -18e3,
    ewt: -14400,
    ffmt: -14660,
    fmt: -4056,
    gdt: 39600,
    gmt: 0,
    gst: 36e3,
    hdt: -34200,
    hkst: 32400,
    hkt: 28800,
    hmt: -19776,
    hpt: -34200,
    hst: -36e3,
    hwt: -34200,
    iddt: 14400,
    idt: 10800,
    imt: 25025,
    ist: 7200,
    jdt: 36e3,
    jmt: 8440,
    jst: 32400,
    kdt: 36e3,
    kmt: 5736,
    kst: 30600,
    lst: 9394,
    mddt: -18e3,
    mdst: 16279,
    mdt: -21600,
    mest: 7200,
    met: 3600,
    mmt: 9017,
    mpt: -21600,
    msd: 14400,
    msk: 10800,
    mst: -25200,
    mwt: -21600,
    nddt: -5400,
    ndt: -9052,
    npt: -9e3,
    nst: -12600,
    nwt: -9e3,
    nzdt: 46800,
    nzmt: 41400,
    nzst: 43200,
    pddt: -21600,
    pdt: -25200,
    pkst: 21600,
    pkt: 18e3,
    plmt: 25590,
    pmt: -13236,
    ppmt: -17340,
    ppt: -25200,
    pst: -28800,
    pwt: -25200,
    qmt: -18840,
    rmt: 5794,
    sast: 7200,
    sdmt: -16800,
    sjmt: -20173,
    smt: -13884,
    sst: -39600,
    tbmt: 10751,
    tmt: 12344,
    uct: 0,
    utc: 0,
    wast: 7200,
    wat: 3600,
    wemt: 7200,
    west: 3600,
    wet: 0,
    wib: 25200,
    wita: 28800,
    wit: 32400,
    wmt: 5040,
    yddt: -25200,
    ydt: -28800,
    ypt: -28800,
    yst: -32400,
    ywt: -28800,
    a: 3600,
    b: 7200,
    c: 10800,
    d: 14400,
    e: 18e3,
    f: 21600,
    g: 25200,
    h: 28800,
    i: 32400,
    k: 36e3,
    l: 39600,
    m: 43200,
    n: -3600,
    o: -7200,
    p: -10800,
    q: -14400,
    r: -18e3,
    s: -21600,
    t: -25200,
    u: -28800,
    v: -32400,
    w: -36e3,
    x: -39600,
    y: -43200,
    z: 0
  };
  var formats = {
    yesterday: {
      regex: /^yesterday/i,
      name: "yesterday",
      callback: function callback() {
        this.rd -= 1;
        return this.resetTime();
      }
    },
    now: {
      regex: /^now/i,
      name: "now"
      // do nothing
    },
    noon: {
      regex: /^noon/i,
      name: "noon",
      callback: function callback() {
        return this.resetTime() && this.time(12, 0, 0, 0);
      }
    },
    midnightOrToday: {
      regex: /^(midnight|today)/i,
      name: "midnight | today",
      callback: function callback() {
        return this.resetTime();
      }
    },
    tomorrow: {
      regex: /^tomorrow/i,
      name: "tomorrow",
      callback: function callback() {
        this.rd += 1;
        return this.resetTime();
      }
    },
    timestamp: {
      regex: /^@(-?\d+)/i,
      name: "timestamp",
      callback: function callback(match, timestamp) {
        this.rs += +timestamp;
        this.y = 1970;
        this.m = 0;
        this.d = 1;
        this.dates = 0;
        return this.resetTime() && this.zone(0);
      }
    },
    firstOrLastDay: {
      regex: /^(first|last) day of/i,
      name: "firstdayof | lastdayof",
      callback: function callback(match, day) {
        if (day.toLowerCase() === "first") {
          this.firstOrLastDayOfMonth = 1;
        } else {
          this.firstOrLastDayOfMonth = -1;
        }
      }
    },
    backOrFrontOf: {
      regex: RegExp("^(back|front) of " + reHour24 + reSpaceOpt + reMeridian + "?", "i"),
      name: "backof | frontof",
      callback: function callback(match, side, hours, meridian) {
        var back = side.toLowerCase() === "back";
        var hour = +hours;
        var minute = 15;
        if (!back) {
          hour -= 1;
          minute = 45;
        }
        hour = processMeridian(hour, meridian);
        return this.resetTime() && this.time(hour, minute, 0, 0);
      }
    },
    weekdayOf: {
      regex: RegExp("^(" + reReltextnumber + "|" + reReltexttext + ")" + reSpace + "(" + reDayfull + "|" + reDayabbr + ")" + reSpace + "of", "i"),
      name: "weekdayof"
      // todo
    },
    mssqltime: {
      regex: RegExp("^" + reHour12 + ":" + reMinutelz + ":" + reSecondlz + "[:.]([0-9]+)" + reMeridian, "i"),
      name: "mssqltime",
      callback: function callback(match, hour, minute, second, frac, meridian) {
        return this.time(processMeridian(+hour, meridian), +minute, +second, +frac.substr(0, 3));
      }
    },
    oracledate: {
      regex: /^(\d{2})-([A-Z]{3})-(\d{2})$/i,
      name: "d-M-y",
      callback: function callback(match, day, monthText, year) {
        var month = {
          JAN: 0,
          FEB: 1,
          MAR: 2,
          APR: 3,
          MAY: 4,
          JUN: 5,
          JUL: 6,
          AUG: 7,
          SEP: 8,
          OCT: 9,
          NOV: 10,
          DEC: 11
        }[monthText.toUpperCase()];
        return this.ymd(2e3 + parseInt(year, 10), month, parseInt(day, 10));
      }
    },
    timeLong12: {
      regex: RegExp("^" + reHour12 + "[:.]" + reMinute + "[:.]" + reSecondlz + reSpaceOpt + reMeridian, "i"),
      name: "timelong12",
      callback: function callback(match, hour, minute, second, meridian) {
        return this.time(processMeridian(+hour, meridian), +minute, +second, 0);
      }
    },
    timeShort12: {
      regex: RegExp("^" + reHour12 + "[:.]" + reMinutelz + reSpaceOpt + reMeridian, "i"),
      name: "timeshort12",
      callback: function callback(match, hour, minute, meridian) {
        return this.time(processMeridian(+hour, meridian), +minute, 0, 0);
      }
    },
    timeTiny12: {
      regex: RegExp("^" + reHour12 + reSpaceOpt + reMeridian, "i"),
      name: "timetiny12",
      callback: function callback(match, hour, meridian) {
        return this.time(processMeridian(+hour, meridian), 0, 0, 0);
      }
    },
    soap: {
      regex: RegExp("^" + reYear4 + "-" + reMonthlz + "-" + reDaylz + "T" + reHour24lz + ":" + reMinutelz + ":" + reSecondlz + reFrac + reTzCorrection + "?", "i"),
      name: "soap",
      callback: function callback(match, year, month, day, hour, minute, second, frac, tzCorrection) {
        return this.ymd(+year, month - 1, +day) && this.time(+hour, +minute, +second, +frac.substr(0, 3)) && this.zone(processTzCorrection(tzCorrection));
      }
    },
    wddx: {
      regex: RegExp("^" + reYear4 + "-" + reMonth + "-" + reDay + "T" + reHour24 + ":" + reMinute + ":" + reSecond),
      name: "wddx",
      callback: function callback(match, year, month, day, hour, minute, second) {
        return this.ymd(+year, month - 1, +day) && this.time(+hour, +minute, +second, 0);
      }
    },
    exif: {
      regex: RegExp("^" + reYear4 + ":" + reMonthlz + ":" + reDaylz + " " + reHour24lz + ":" + reMinutelz + ":" + reSecondlz, "i"),
      name: "exif",
      callback: function callback(match, year, month, day, hour, minute, second) {
        return this.ymd(+year, month - 1, +day) && this.time(+hour, +minute, +second, 0);
      }
    },
    xmlRpc: {
      regex: RegExp("^" + reYear4 + reMonthlz + reDaylz + "T" + reHour24 + ":" + reMinutelz + ":" + reSecondlz),
      name: "xmlrpc",
      callback: function callback(match, year, month, day, hour, minute, second) {
        return this.ymd(+year, month - 1, +day) && this.time(+hour, +minute, +second, 0);
      }
    },
    xmlRpcNoColon: {
      regex: RegExp("^" + reYear4 + reMonthlz + reDaylz + "[Tt]" + reHour24 + reMinutelz + reSecondlz),
      name: "xmlrpcnocolon",
      callback: function callback(match, year, month, day, hour, minute, second) {
        return this.ymd(+year, month - 1, +day) && this.time(+hour, +minute, +second, 0);
      }
    },
    clf: {
      regex: RegExp("^" + reDay + "/(" + reMonthAbbr + ")/" + reYear4 + ":" + reHour24lz + ":" + reMinutelz + ":" + reSecondlz + reSpace + reTzCorrection, "i"),
      name: "clf",
      callback: function callback(match, day, month, year, hour, minute, second, tzCorrection) {
        return this.ymd(+year, lookupMonth(month), +day) && this.time(+hour, +minute, +second, 0) && this.zone(processTzCorrection(tzCorrection));
      }
    },
    iso8601long: {
      regex: RegExp("^t?" + reHour24 + "[:.]" + reMinute + "[:.]" + reSecond + reFrac, "i"),
      name: "iso8601long",
      callback: function callback(match, hour, minute, second, frac) {
        return this.time(+hour, +minute, +second, +frac.substr(0, 3));
      }
    },
    dateTextual: {
      regex: RegExp("^" + reMonthText + "[ .\\t-]*" + reDay + "[,.stndrh\\t ]+" + reYear, "i"),
      name: "datetextual",
      callback: function callback(match, month, day, year) {
        return this.ymd(processYear(year), lookupMonth(month), +day);
      }
    },
    pointedDate4: {
      regex: RegExp("^" + reDay + "[.\\t-]" + reMonth + "[.-]" + reYear4),
      name: "pointeddate4",
      callback: function callback(match, day, month, year) {
        return this.ymd(+year, month - 1, +day);
      }
    },
    pointedDate2: {
      regex: RegExp("^" + reDay + "[.\\t]" + reMonth + "\\." + reYear2),
      name: "pointeddate2",
      callback: function callback(match, day, month, year) {
        return this.ymd(processYear(year), month - 1, +day);
      }
    },
    timeLong24: {
      regex: RegExp("^t?" + reHour24 + "[:.]" + reMinute + "[:.]" + reSecond),
      name: "timelong24",
      callback: function callback(match, hour, minute, second) {
        return this.time(+hour, +minute, +second, 0);
      }
    },
    dateNoColon: {
      regex: RegExp("^" + reYear4 + reMonthlz + reDaylz),
      name: "datenocolon",
      callback: function callback(match, year, month, day) {
        return this.ymd(+year, month - 1, +day);
      }
    },
    pgydotd: {
      regex: RegExp("^" + reYear4 + "\\.?" + reDayOfYear),
      name: "pgydotd",
      callback: function callback(match, year, day) {
        return this.ymd(+year, 0, +day);
      }
    },
    timeShort24: {
      regex: RegExp("^t?" + reHour24 + "[:.]" + reMinute, "i"),
      name: "timeshort24",
      callback: function callback(match, hour, minute) {
        return this.time(+hour, +minute, 0, 0);
      }
    },
    iso8601noColon: {
      regex: RegExp("^t?" + reHour24lz + reMinutelz + reSecondlz, "i"),
      name: "iso8601nocolon",
      callback: function callback(match, hour, minute, second) {
        return this.time(+hour, +minute, +second, 0);
      }
    },
    iso8601dateSlash: {
      // eventhough the trailing slash is optional in PHP
      // here it's mandatory and inputs without the slash
      // are handled by dateslash
      regex: RegExp("^" + reYear4 + "/" + reMonthlz + "/" + reDaylz + "/"),
      name: "iso8601dateslash",
      callback: function callback(match, year, month, day) {
        return this.ymd(+year, month - 1, +day);
      }
    },
    dateSlash: {
      regex: RegExp("^" + reYear4 + "/" + reMonth + "/" + reDay),
      name: "dateslash",
      callback: function callback(match, year, month, day) {
        return this.ymd(+year, month - 1, +day);
      }
    },
    american: {
      regex: RegExp("^" + reMonth + "/" + reDay + "/" + reYear),
      name: "american",
      callback: function callback(match, month, day, year) {
        return this.ymd(processYear(year), month - 1, +day);
      }
    },
    americanShort: {
      regex: RegExp("^" + reMonth + "/" + reDay),
      name: "americanshort",
      callback: function callback(match, month, day) {
        return this.ymd(this.y, month - 1, +day);
      }
    },
    gnuDateShortOrIso8601date2: {
      // iso8601date2 is complete subset of gnudateshort
      regex: RegExp("^" + reYear + "-" + reMonth + "-" + reDay),
      name: "gnudateshort | iso8601date2",
      callback: function callback(match, year, month, day) {
        return this.ymd(processYear(year), month - 1, +day);
      }
    },
    iso8601date4: {
      regex: RegExp("^" + reYear4withSign + "-" + reMonthlz + "-" + reDaylz),
      name: "iso8601date4",
      callback: function callback(match, year, month, day) {
        return this.ymd(+year, month - 1, +day);
      }
    },
    gnuNoColon: {
      regex: RegExp("^t?" + reHour24lz + reMinutelz, "i"),
      name: "gnunocolon",
      callback: function callback(match, hour, minute) {
        switch (this.times) {
          case 0:
            return this.time(+hour, +minute, 0, this.f);
          case 1:
            this.y = hour * 100 + +minute;
            this.times++;
            return true;
          default:
            return false;
        }
      }
    },
    gnuDateShorter: {
      regex: RegExp("^" + reYear4 + "-" + reMonth),
      name: "gnudateshorter",
      callback: function callback(match, year, month) {
        return this.ymd(+year, month - 1, 1);
      }
    },
    pgTextReverse: {
      // note: allowed years are from 32-9999
      // years below 32 should be treated as days in datefull
      regex: RegExp("^(\\d{3,4}|[4-9]\\d|3[2-9])-(" + reMonthAbbr + ")-" + reDaylz, "i"),
      name: "pgtextreverse",
      callback: function callback(match, year, month, day) {
        return this.ymd(processYear(year), lookupMonth(month), +day);
      }
    },
    dateFull: {
      regex: RegExp("^" + reDay + "[ \\t.-]*" + reMonthText + "[ \\t.-]*" + reYear, "i"),
      name: "datefull",
      callback: function callback(match, day, month, year) {
        return this.ymd(processYear(year), lookupMonth(month), +day);
      }
    },
    dateNoDay: {
      regex: RegExp("^" + reMonthText + "[ .\\t-]*" + reYear4, "i"),
      name: "datenoday",
      callback: function callback(match, month, year) {
        return this.ymd(+year, lookupMonth(month), 1);
      }
    },
    dateNoDayRev: {
      regex: RegExp("^" + reYear4 + "[ .\\t-]*" + reMonthText, "i"),
      name: "datenodayrev",
      callback: function callback(match, year, month) {
        return this.ymd(+year, lookupMonth(month), 1);
      }
    },
    pgTextShort: {
      regex: RegExp("^(" + reMonthAbbr + ")-" + reDaylz + "-" + reYear, "i"),
      name: "pgtextshort",
      callback: function callback(match, month, day, year) {
        return this.ymd(processYear(year), lookupMonth(month), +day);
      }
    },
    dateNoYear: {
      regex: RegExp("^" + reDateNoYear, "i"),
      name: "datenoyear",
      callback: function callback(match, month, day) {
        return this.ymd(this.y, lookupMonth(month), +day);
      }
    },
    dateNoYearRev: {
      regex: RegExp("^" + reDay + "[ .\\t-]*" + reMonthText, "i"),
      name: "datenoyearrev",
      callback: function callback(match, day, month) {
        return this.ymd(this.y, lookupMonth(month), +day);
      }
    },
    isoWeekDay: {
      regex: RegExp("^" + reYear4 + "-?W" + reWeekOfYear + "(?:-?([0-7]))?"),
      name: "isoweekday | isoweek",
      callback: function callback(match, year, week, day) {
        day = day ? +day : 1;
        if (!this.ymd(+year, 0, 1)) {
          return false;
        }
        var dayOfWeek = new Date(this.y, this.m, this.d).getDay();
        dayOfWeek = 0 - (dayOfWeek > 4 ? dayOfWeek - 7 : dayOfWeek);
        this.rd += dayOfWeek + (week - 1) * 7 + day;
      }
    },
    relativeText: {
      regex: RegExp("^(" + reReltextnumber + "|" + reReltexttext + ")" + reSpace + "(" + reReltextunit + ")", "i"),
      name: "relativetext",
      callback: function callback(match, relValue, relUnit) {
        var _lookupRelative = lookupRelative(relValue), amount = _lookupRelative.amount;
        switch (relUnit.toLowerCase()) {
          case "sec":
          case "secs":
          case "second":
          case "seconds":
            this.rs += amount;
            break;
          case "min":
          case "mins":
          case "minute":
          case "minutes":
            this.ri += amount;
            break;
          case "hour":
          case "hours":
            this.rh += amount;
            break;
          case "day":
          case "days":
            this.rd += amount;
            break;
          case "fortnight":
          case "fortnights":
          case "forthnight":
          case "forthnights":
            this.rd += amount * 14;
            break;
          case "week":
          case "weeks":
            this.rd += amount * 7;
            break;
          case "month":
          case "months":
            this.rm += amount;
            break;
          case "year":
          case "years":
            this.ry += amount;
            break;
          case "mon":
          case "monday":
          case "tue":
          case "tuesday":
          case "wed":
          case "wednesday":
          case "thu":
          case "thursday":
          case "fri":
          case "friday":
          case "sat":
          case "saturday":
          case "sun":
          case "sunday":
            this.resetTime();
            this.weekday = lookupWeekday(relUnit, 7);
            this.weekdayBehavior = 1;
            this.rd += (amount > 0 ? amount - 1 : amount) * 7;
            break;
        }
      }
    },
    relative: {
      regex: RegExp("^([+-]*)[ \\t]*(\\d+)" + reSpaceOpt + "(" + reReltextunit + "|week)", "i"),
      name: "relative",
      callback: function callback(match, signs, relValue, relUnit) {
        var minuses = signs.replace(/[^-]/g, "").length;
        var amount = +relValue * Math.pow(-1, minuses);
        switch (relUnit.toLowerCase()) {
          case "sec":
          case "secs":
          case "second":
          case "seconds":
            this.rs += amount;
            break;
          case "min":
          case "mins":
          case "minute":
          case "minutes":
            this.ri += amount;
            break;
          case "hour":
          case "hours":
            this.rh += amount;
            break;
          case "day":
          case "days":
            this.rd += amount;
            break;
          case "fortnight":
          case "fortnights":
          case "forthnight":
          case "forthnights":
            this.rd += amount * 14;
            break;
          case "week":
          case "weeks":
            this.rd += amount * 7;
            break;
          case "month":
          case "months":
            this.rm += amount;
            break;
          case "year":
          case "years":
            this.ry += amount;
            break;
          case "mon":
          case "monday":
          case "tue":
          case "tuesday":
          case "wed":
          case "wednesday":
          case "thu":
          case "thursday":
          case "fri":
          case "friday":
          case "sat":
          case "saturday":
          case "sun":
          case "sunday":
            this.resetTime();
            this.weekday = lookupWeekday(relUnit, 7);
            this.weekdayBehavior = 1;
            this.rd += (amount > 0 ? amount - 1 : amount) * 7;
            break;
        }
      }
    },
    dayText: {
      regex: RegExp("^(" + reDaytext + ")", "i"),
      name: "daytext",
      callback: function callback(match, dayText) {
        this.resetTime();
        this.weekday = lookupWeekday(dayText, 0);
        if (this.weekdayBehavior !== 2) {
          this.weekdayBehavior = 1;
        }
      }
    },
    relativeTextWeek: {
      regex: RegExp("^(" + reReltexttext + ")" + reSpace + "week", "i"),
      name: "relativetextweek",
      callback: function callback(match, relText) {
        this.weekdayBehavior = 2;
        switch (relText.toLowerCase()) {
          case "this":
            this.rd += 0;
            break;
          case "next":
            this.rd += 7;
            break;
          case "last":
          case "previous":
            this.rd -= 7;
            break;
        }
        if (isNaN(this.weekday)) {
          this.weekday = 1;
        }
      }
    },
    monthFullOrMonthAbbr: {
      regex: RegExp("^(" + reMonthFull + "|" + reMonthAbbr + ")", "i"),
      name: "monthfull | monthabbr",
      callback: function callback(match, month) {
        return this.ymd(this.y, lookupMonth(month), this.d);
      }
    },
    tzCorrection: {
      regex: RegExp("^" + reTzCorrection, "i"),
      name: "tzcorrection",
      callback: function callback(tzCorrection) {
        return this.zone(processTzCorrection(tzCorrection));
      }
    },
    tzAbbr: {
      regex: RegExp("^" + reTzAbbr),
      name: "tzabbr",
      callback: function callback(match, abbr) {
        var offset2 = tzAbbrOffsets[abbr.toLowerCase()];
        if (isNaN(offset2)) {
          return false;
        }
        return this.zone(offset2);
      }
    },
    ago: {
      regex: /^ago/i,
      name: "ago",
      callback: function callback() {
        this.ry = -this.ry;
        this.rm = -this.rm;
        this.rd = -this.rd;
        this.rh = -this.rh;
        this.ri = -this.ri;
        this.rs = -this.rs;
        this.rf = -this.rf;
      }
    },
    year4: {
      regex: RegExp("^" + reYear4),
      name: "year4",
      callback: function callback(match, year) {
        this.y = +year;
        return true;
      }
    },
    whitespace: {
      regex: /^[ .,\t]+/,
      name: "whitespace"
      // do nothing
    },
    dateShortWithTimeLong: {
      regex: RegExp("^" + reDateNoYear + "t?" + reHour24 + "[:.]" + reMinute + "[:.]" + reSecond, "i"),
      name: "dateshortwithtimelong",
      callback: function callback(match, month, day, hour, minute, second) {
        return this.ymd(this.y, lookupMonth(month), +day) && this.time(+hour, +minute, +second, 0);
      }
    },
    dateShortWithTimeLong12: {
      regex: RegExp("^" + reDateNoYear + reHour12 + "[:.]" + reMinute + "[:.]" + reSecondlz + reSpaceOpt + reMeridian, "i"),
      name: "dateshortwithtimelong12",
      callback: function callback(match, month, day, hour, minute, second, meridian) {
        return this.ymd(this.y, lookupMonth(month), +day) && this.time(processMeridian(+hour, meridian), +minute, +second, 0);
      }
    },
    dateShortWithTimeShort: {
      regex: RegExp("^" + reDateNoYear + "t?" + reHour24 + "[:.]" + reMinute, "i"),
      name: "dateshortwithtimeshort",
      callback: function callback(match, month, day, hour, minute) {
        return this.ymd(this.y, lookupMonth(month), +day) && this.time(+hour, +minute, 0, 0);
      }
    },
    dateShortWithTimeShort12: {
      regex: RegExp("^" + reDateNoYear + reHour12 + "[:.]" + reMinutelz + reSpaceOpt + reMeridian, "i"),
      name: "dateshortwithtimeshort12",
      callback: function callback(match, month, day, hour, minute, meridian) {
        return this.ymd(this.y, lookupMonth(month), +day) && this.time(processMeridian(+hour, meridian), +minute, 0, 0);
      }
    }
  };
  var resultProto = {
    // date
    y: NaN,
    m: NaN,
    d: NaN,
    // time
    h: NaN,
    i: NaN,
    s: NaN,
    f: NaN,
    // relative shifts
    ry: 0,
    rm: 0,
    rd: 0,
    rh: 0,
    ri: 0,
    rs: 0,
    rf: 0,
    // weekday related shifts
    weekday: NaN,
    weekdayBehavior: 0,
    // first or last day of month
    // 0 none, 1 first, -1 last
    firstOrLastDayOfMonth: 0,
    // timezone correction in minutes
    z: NaN,
    // counters
    dates: 0,
    times: 0,
    zones: 0,
    // helper functions
    ymd: function ymd(y, m, d) {
      if (this.dates > 0) {
        return false;
      }
      this.dates++;
      this.y = y;
      this.m = m;
      this.d = d;
      return true;
    },
    time: function time(h2, i, s, f) {
      if (this.times > 0) {
        return false;
      }
      this.times++;
      this.h = h2;
      this.i = i;
      this.s = s;
      this.f = f;
      return true;
    },
    resetTime: function resetTime() {
      this.h = 0;
      this.i = 0;
      this.s = 0;
      this.f = 0;
      this.times = 0;
      return true;
    },
    zone: function zone(minutes) {
      if (this.zones <= 1) {
        this.zones++;
        this.z = minutes;
        return true;
      }
      return false;
    },
    toDate: function toDate(relativeTo) {
      if (this.dates && !this.times) {
        this.h = this.i = this.s = this.f = 0;
      }
      if (isNaN(this.y)) {
        this.y = relativeTo.getFullYear();
      }
      if (isNaN(this.m)) {
        this.m = relativeTo.getMonth();
      }
      if (isNaN(this.d)) {
        this.d = relativeTo.getDate();
      }
      if (isNaN(this.h)) {
        this.h = relativeTo.getHours();
      }
      if (isNaN(this.i)) {
        this.i = relativeTo.getMinutes();
      }
      if (isNaN(this.s)) {
        this.s = relativeTo.getSeconds();
      }
      if (isNaN(this.f)) {
        this.f = relativeTo.getMilliseconds();
      }
      switch (this.firstOrLastDayOfMonth) {
        case 1:
          this.d = 1;
          break;
        case -1:
          this.d = 0;
          this.m += 1;
          break;
      }
      if (!isNaN(this.weekday)) {
        var date2 = new Date(relativeTo.getTime());
        date2.setFullYear(this.y, this.m, this.d);
        date2.setHours(this.h, this.i, this.s, this.f);
        var dow = date2.getDay();
        if (this.weekdayBehavior === 2) {
          if (dow === 0 && this.weekday !== 0) {
            this.weekday = -6;
          }
          if (this.weekday === 0 && dow !== 0) {
            this.weekday = 7;
          }
          this.d -= dow;
          this.d += this.weekday;
        } else {
          var diff2 = this.weekday - dow;
          if (this.rd < 0 && diff2 < 0 || this.rd >= 0 && diff2 <= -this.weekdayBehavior) {
            diff2 += 7;
          }
          if (this.weekday >= 0) {
            this.d += diff2;
          } else {
            this.d -= 7 - (Math.abs(this.weekday) - dow);
          }
          this.weekday = NaN;
        }
      }
      this.y += this.ry;
      this.m += this.rm;
      this.d += this.rd;
      this.h += this.rh;
      this.i += this.ri;
      this.s += this.rs;
      this.f += this.rf;
      this.ry = this.rm = this.rd = 0;
      this.rh = this.ri = this.rs = this.rf = 0;
      var result = new Date(relativeTo.getTime());
      result.setFullYear(this.y, this.m, this.d);
      result.setHours(this.h, this.i, this.s, this.f);
      switch (this.firstOrLastDayOfMonth) {
        case 1:
          result.setDate(1);
          break;
        case -1:
          result.setMonth(result.getMonth() + 1, 0);
          break;
      }
      if (!isNaN(this.z) && result.getTimezoneOffset() !== this.z) {
        result.setUTCFullYear(result.getFullYear(), result.getMonth(), result.getDate());
        result.setUTCHours(result.getHours(), result.getMinutes(), result.getSeconds() - this.z, result.getMilliseconds());
      }
      return result;
    }
  };
  strtotime = function strtotime2(str, now) {
    if (now == null) {
      now = Math.floor(Date.now() / 1e3);
    }
    var rules = [
      formats.yesterday,
      formats.now,
      formats.noon,
      formats.midnightOrToday,
      formats.tomorrow,
      formats.timestamp,
      formats.firstOrLastDay,
      formats.backOrFrontOf,
      // formats.weekdayOf, // not yet implemented
      formats.timeTiny12,
      formats.timeShort12,
      formats.timeLong12,
      formats.mssqltime,
      formats.oracledate,
      formats.timeShort24,
      formats.timeLong24,
      formats.iso8601long,
      formats.gnuNoColon,
      formats.iso8601noColon,
      formats.americanShort,
      formats.american,
      formats.iso8601date4,
      formats.iso8601dateSlash,
      formats.dateSlash,
      formats.gnuDateShortOrIso8601date2,
      formats.gnuDateShorter,
      formats.dateFull,
      formats.pointedDate4,
      formats.pointedDate2,
      formats.dateNoDay,
      formats.dateNoDayRev,
      formats.dateTextual,
      formats.dateNoYear,
      formats.dateNoYearRev,
      formats.dateNoColon,
      formats.xmlRpc,
      formats.xmlRpcNoColon,
      formats.soap,
      formats.wddx,
      formats.exif,
      formats.pgydotd,
      formats.isoWeekDay,
      formats.pgTextShort,
      formats.pgTextReverse,
      formats.clf,
      formats.year4,
      formats.ago,
      formats.dayText,
      formats.relativeTextWeek,
      formats.relativeText,
      formats.monthFullOrMonthAbbr,
      formats.tzCorrection,
      formats.tzAbbr,
      formats.dateShortWithTimeShort12,
      formats.dateShortWithTimeLong12,
      formats.dateShortWithTimeShort,
      formats.dateShortWithTimeLong,
      formats.relative,
      formats.whitespace
    ];
    var result = Object.create(resultProto);
    while (str.length) {
      var longestMatch = null;
      var finalRule = null;
      for (var i = 0, l = rules.length; i < l; i++) {
        var format2 = rules[i];
        var match = str.match(format2.regex);
        if (match) {
          if (!longestMatch || match[0].length > longestMatch[0].length) {
            longestMatch = match;
            finalRule = format2;
          }
        }
      }
      if (!finalRule || finalRule.callback && finalRule.callback.apply(result, longestMatch) === false) {
        return false;
      }
      str = str.substr(longestMatch[0].length);
      finalRule = null;
      longestMatch = null;
    }
    return Math.floor(result.toDate(new Date(now * 1e3)) / 1e3);
  };
  return strtotime;
}
var date;
var hasRequiredDate;
function requireDate() {
  if (hasRequiredDate)
    return date;
  hasRequiredDate = 1;
  date = function date2(format2, timestamp) {
    var jsdate = void 0, f = void 0;
    var txtWords = ["Sun", "Mon", "Tues", "Wednes", "Thurs", "Fri", "Satur", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    var formatChr = /\\?(.?)/gi;
    var formatChrCb = function formatChrCb2(t, s) {
      return f[t] ? f[t]() : s;
    };
    var _pad = function _pad2(n, c) {
      n = String(n);
      while (n.length < c) {
        n = "0" + n;
      }
      return n;
    };
    f = {
      // Day
      d: function d() {
        return _pad(f.j(), 2);
      },
      D: function D() {
        return f.l().slice(0, 3);
      },
      j: function j() {
        return jsdate.getDate();
      },
      l: function l() {
        return txtWords[f.w()] + "day";
      },
      N: function N() {
        return f.w() || 7;
      },
      S: function S2() {
        var j = f.j();
        var i = j % 10;
        if (i <= 3 && parseInt(j % 100 / 10, 10) === 1) {
          i = 0;
        }
        return ["st", "nd", "rd"][i - 1] || "th";
      },
      w: function w() {
        return jsdate.getDay();
      },
      z: function z() {
        var a = new Date(f.Y(), f.n() - 1, f.j());
        var b = new Date(f.Y(), 0, 1);
        return Math.round((a - b) / 864e5);
      },
      // Week
      W: function W() {
        var a = new Date(f.Y(), f.n() - 1, f.j() - f.N() + 3);
        var b = new Date(a.getFullYear(), 0, 4);
        return _pad(1 + Math.round((a - b) / 864e5 / 7), 2);
      },
      // Month
      F: function F() {
        return txtWords[6 + f.n()];
      },
      m: function m() {
        return _pad(f.n(), 2);
      },
      M: function M() {
        return f.F().slice(0, 3);
      },
      n: function n() {
        return jsdate.getMonth() + 1;
      },
      t: function t() {
        return new Date(f.Y(), f.n(), 0).getDate();
      },
      // Year
      L: function L2() {
        var j = f.Y();
        return j % 4 === 0 & j % 100 !== 0 | j % 400 === 0;
      },
      o: function o() {
        var n = f.n();
        var W = f.W();
        var Y2 = f.Y();
        return Y2 + (n === 12 && W < 9 ? 1 : n === 1 && W > 9 ? -1 : 0);
      },
      Y: function Y2() {
        return jsdate.getFullYear();
      },
      y: function y() {
        return f.Y().toString().slice(-2);
      },
      // Time
      a: function a() {
        return jsdate.getHours() > 11 ? "pm" : "am";
      },
      A: function A() {
        return f.a().toUpperCase();
      },
      B: function B() {
        var H = jsdate.getUTCHours() * 3600;
        var i = jsdate.getUTCMinutes() * 60;
        var s = jsdate.getUTCSeconds();
        return _pad(Math.floor((H + i + s + 3600) / 86.4) % 1e3, 3);
      },
      g: function g() {
        return f.G() % 12 || 12;
      },
      G: function G() {
        return jsdate.getHours();
      },
      h: function h2() {
        return _pad(f.g(), 2);
      },
      H: function H() {
        return _pad(f.G(), 2);
      },
      i: function i() {
        return _pad(jsdate.getMinutes(), 2);
      },
      s: function s() {
        return _pad(jsdate.getSeconds(), 2);
      },
      u: function u() {
        return _pad(jsdate.getMilliseconds() * 1e3, 6);
      },
      // Timezone
      e: function e2() {
        var msg = "Not supported (see source code of date() for timezone on how to add support)";
        throw new Error(msg);
      },
      I: function I2() {
        var a = new Date(f.Y(), 0);
        var c = Date.UTC(f.Y(), 0);
        var b = new Date(f.Y(), 6);
        var d = Date.UTC(f.Y(), 6);
        return a - c !== b - d ? 1 : 0;
      },
      O: function O() {
        var tzo = jsdate.getTimezoneOffset();
        var a = Math.abs(tzo);
        return (tzo > 0 ? "-" : "+") + _pad(Math.floor(a / 60) * 100 + a % 60, 4);
      },
      P: function P() {
        var O = f.O();
        return O.substr(0, 3) + ":" + O.substr(3, 2);
      },
      T: function T2() {
        return "UTC";
      },
      Z: function Z() {
        return -jsdate.getTimezoneOffset() * 60;
      },
      // Full Date/Time
      c: function c() {
        return "Y-m-d\\TH:i:sP".replace(formatChr, formatChrCb);
      },
      r: function r() {
        return "D, d M Y H:i:s O".replace(formatChr, formatChrCb);
      },
      U: function U() {
        return jsdate / 1e3 | 0;
      }
    };
    var _date = function _date2(format3, timestamp2) {
      jsdate = timestamp2 === void 0 ? /* @__PURE__ */ new Date() : timestamp2 instanceof Date ? new Date(timestamp2) : new Date(timestamp2 * 1e3);
      return format3.replace(formatChr, formatChrCb);
    };
    return _date(format2, timestamp);
  };
  return date;
}
var boolval;
var hasRequiredBoolval;
function requireBoolval() {
  if (hasRequiredBoolval)
    return boolval;
  hasRequiredBoolval = 1;
  boolval = function boolval2(mixedVar) {
    if (mixedVar === false) {
      return false;
    }
    if (mixedVar === 0 || mixedVar === 0) {
      return false;
    }
    if (mixedVar === "" || mixedVar === "0") {
      return false;
    }
    if (Array.isArray(mixedVar) && mixedVar.length === 0) {
      return false;
    }
    if (mixedVar === null || mixedVar === void 0) {
      return false;
    }
    return true;
  };
  return boolval;
}
var twig_lib;
var hasRequiredTwig_lib;
function requireTwig_lib() {
  if (hasRequiredTwig_lib)
    return twig_lib;
  hasRequiredTwig_lib = 1;
  twig_lib = function(Twig2) {
    Twig2.lib = {};
    Twig2.lib.sprintf = requireSprintf();
    Twig2.lib.vsprintf = requireVsprintf();
    Twig2.lib.round = requireRound();
    Twig2.lib.max = requireMax();
    Twig2.lib.min = requireMin();
    Twig2.lib.stripTags = requireStrip_tags();
    Twig2.lib.strtotime = requireStrtotime();
    Twig2.lib.date = requireDate();
    Twig2.lib.boolval = requireBoolval();
    Twig2.lib.is = function(type2, obj) {
      if (typeof obj === "undefined" || obj === null) {
        return false;
      }
      switch (type2) {
        case "Array":
          return Array.isArray(obj);
        case "Date":
          return obj instanceof Date;
        case "String":
          return typeof obj === "string" || obj instanceof String;
        case "Number":
          return typeof obj === "number" || obj instanceof Number;
        case "Function":
          return typeof obj === "function";
        case "Object":
          return obj instanceof Object;
        default:
          return false;
      }
    };
    Twig2.lib.replaceAll = function(string, search, replace) {
      const stringToChange = typeof string === "string" ? string : string.toString();
      const searchEscaped = search.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      return stringToChange.replace(new RegExp(searchEscaped, "g"), replace);
    };
    Twig2.lib.chunkArray = function(arr, size2) {
      const returnVal = [];
      let x = 0;
      const len = arr.length;
      if (size2 < 1 || !Array.isArray(arr)) {
        return [];
      }
      while (x < len) {
        returnVal.push(arr.slice(x, x += size2));
      }
      return returnVal;
    };
    return Twig2;
  };
  return twig_lib;
}
var twig_loader_ajax;
var hasRequiredTwig_loader_ajax;
function requireTwig_loader_ajax() {
  if (hasRequiredTwig_loader_ajax)
    return twig_loader_ajax;
  hasRequiredTwig_loader_ajax = 1;
  twig_loader_ajax = function(Twig2) {
    Twig2.Templates.registerLoader("ajax", function(location2, params, callback, errorCallback) {
      let template;
      const { precompiled } = params;
      const parser2 = this.parsers[params.parser] || this.parser.twig;
      if (typeof XMLHttpRequest === "undefined") {
        throw new Twig2.Error('Unsupported platform: Unable to do ajax requests because there is no "XMLHTTPRequest" implementation');
      }
      const xmlhttp = new XMLHttpRequest();
      xmlhttp.onreadystatechange = function() {
        let data = null;
        if (xmlhttp.readyState === 4) {
          if (xmlhttp.status === 200 || window.cordova && xmlhttp.status === 0) {
            Twig2.log.debug("Got template ", xmlhttp.responseText);
            if (precompiled === true) {
              data = JSON.parse(xmlhttp.responseText);
            } else {
              data = xmlhttp.responseText;
            }
            params.url = location2;
            params.data = data;
            template = parser2.call(this, params);
            if (typeof callback === "function") {
              callback(template);
            }
          } else if (typeof errorCallback === "function") {
            errorCallback(xmlhttp);
          }
        }
      };
      xmlhttp.open("GET", location2, Boolean(params.async));
      xmlhttp.overrideMimeType("text/plain");
      xmlhttp.send();
      if (params.async) {
        return true;
      }
      return template;
    });
  };
  return twig_loader_ajax;
}
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var twig_loader_fs;
var hasRequiredTwig_loader_fs;
function requireTwig_loader_fs() {
  if (hasRequiredTwig_loader_fs)
    return twig_loader_fs;
  hasRequiredTwig_loader_fs = 1;
  twig_loader_fs = function(Twig2) {
    let fs;
    let path;
    try {
      fs = require$$0;
      path = require$$0;
    } catch (error) {
      console.warn("Missing fs and path modules. " + error);
    }
    Twig2.Templates.registerLoader("fs", function(location2, params, callback, errorCallback) {
      let template;
      let data = null;
      const { precompiled } = params;
      const parser2 = this.parsers[params.parser] || this.parser.twig;
      if (!fs || !path) {
        throw new Twig2.Error('Unsupported platform: Unable to load from file because there is no "fs" or "path" implementation');
      }
      const loadTemplateFn = function(err, data2) {
        if (err) {
          if (typeof errorCallback === "function") {
            errorCallback(err);
          }
          return;
        }
        if (precompiled === true) {
          data2 = JSON.parse(data2);
        }
        params.data = data2;
        params.path = params.path || location2;
        template = parser2.call(this, params);
        if (typeof callback === "function") {
          callback(template);
        }
      };
      params.path = params.path || location2;
      if (params.async) {
        fs.stat(params.path, (err, stats) => {
          if (err || !stats.isFile()) {
            if (typeof errorCallback === "function") {
              errorCallback(new Twig2.Error("Unable to find template file " + params.path));
            }
            return;
          }
          fs.readFile(params.path, "utf8", loadTemplateFn);
        });
        return true;
      }
      try {
        if (!fs.statSync(params.path).isFile()) {
          throw new Twig2.Error("Unable to find template file " + params.path);
        }
      } catch (error) {
        throw new Twig2.Error("Unable to find template file " + params.path + ". " + error);
      }
      data = fs.readFileSync(params.path, "utf8");
      loadTemplateFn(void 0, data);
      return template;
    });
  };
  return twig_loader_fs;
}
var twig_logic;
var hasRequiredTwig_logic;
function requireTwig_logic() {
  if (hasRequiredTwig_logic)
    return twig_logic;
  hasRequiredTwig_logic = 1;
  twig_logic = function(Twig2) {
    Twig2.logic = {};
    Twig2.logic.type = {
      if_: "Twig.logic.type.if",
      endif: "Twig.logic.type.endif",
      for_: "Twig.logic.type.for",
      endfor: "Twig.logic.type.endfor",
      else_: "Twig.logic.type.else",
      elseif: "Twig.logic.type.elseif",
      set: "Twig.logic.type.set",
      setcapture: "Twig.logic.type.setcapture",
      endset: "Twig.logic.type.endset",
      filter: "Twig.logic.type.filter",
      endfilter: "Twig.logic.type.endfilter",
      apply: "Twig.logic.type.apply",
      endapply: "Twig.logic.type.endapply",
      do: "Twig.logic.type.do",
      shortblock: "Twig.logic.type.shortblock",
      block: "Twig.logic.type.block",
      endblock: "Twig.logic.type.endblock",
      extends_: "Twig.logic.type.extends",
      use: "Twig.logic.type.use",
      include: "Twig.logic.type.include",
      spaceless: "Twig.logic.type.spaceless",
      endspaceless: "Twig.logic.type.endspaceless",
      macro: "Twig.logic.type.macro",
      endmacro: "Twig.logic.type.endmacro",
      import_: "Twig.logic.type.import",
      from: "Twig.logic.type.from",
      embed: "Twig.logic.type.embed",
      endembed: "Twig.logic.type.endembed",
      with: "Twig.logic.type.with",
      endwith: "Twig.logic.type.endwith",
      deprecated: "Twig.logic.type.deprecated"
    };
    Twig2.logic.definitions = [
      {
        /**
         * If type logic tokens.
         *
         *  Format: {% if expression %}
         */
        type: Twig2.logic.type.if_,
        regex: /^if\s?([\s\S]+)$/,
        next: [
          Twig2.logic.type.else_,
          Twig2.logic.type.elseif,
          Twig2.logic.type.endif
        ],
        open: true,
        compile(token) {
          const expression = token.match[1];
          token.stack = Twig2.expression.compile.call(this, {
            type: Twig2.expression.type.expression,
            value: expression
          }).stack;
          delete token.match;
          return token;
        },
        parse(token, context, chain) {
          const state2 = this;
          return Twig2.expression.parseAsync.call(state2, token.stack, context).then((result) => {
            chain = true;
            if (Twig2.lib.boolval(result)) {
              chain = false;
              return state2.parseAsync(token.output, context);
            }
            return "";
          }).then((output) => {
            return {
              chain,
              output
            };
          });
        }
      },
      {
        /**
         * Else if type logic tokens.
         *
         *  Format: {% elseif expression %}
         */
        type: Twig2.logic.type.elseif,
        regex: /^elseif\s*([^\s].*)$/,
        next: [
          Twig2.logic.type.else_,
          Twig2.logic.type.elseif,
          Twig2.logic.type.endif
        ],
        open: false,
        compile(token) {
          const expression = token.match[1];
          token.stack = Twig2.expression.compile.call(this, {
            type: Twig2.expression.type.expression,
            value: expression
          }).stack;
          delete token.match;
          return token;
        },
        parse(token, context, chain) {
          const state2 = this;
          return Twig2.expression.parseAsync.call(state2, token.stack, context).then((result) => {
            if (chain && Twig2.lib.boolval(result)) {
              chain = false;
              return state2.parseAsync(token.output, context);
            }
            return "";
          }).then((output) => {
            return {
              chain,
              output
            };
          });
        }
      },
      {
        /**
         * Else type logic tokens.
         *
         *  Format: {% else %}
         */
        type: Twig2.logic.type.else_,
        regex: /^else$/,
        next: [
          Twig2.logic.type.endif,
          Twig2.logic.type.endfor
        ],
        open: false,
        parse(token, context, chain) {
          let promise = Twig2.Promise.resolve("");
          const state2 = this;
          if (chain) {
            promise = state2.parseAsync(token.output, context);
          }
          return promise.then((output) => {
            return {
              chain,
              output
            };
          });
        }
      },
      {
        /**
         * End if type logic tokens.
         *
         *  Format: {% endif %}
         */
        type: Twig2.logic.type.endif,
        regex: /^endif$/,
        next: [],
        open: false
      },
      {
        /**
         * For type logic tokens.
         *
         *  Format: {% for expression %}
         */
        type: Twig2.logic.type.for_,
        regex: /^for\s+([a-zA-Z0-9_,\s]+)\s+in\s+([\S\s]+?)(?:\s+if\s+([^\s].*))?$/,
        next: [
          Twig2.logic.type.else_,
          Twig2.logic.type.endfor
        ],
        open: true,
        compile(token) {
          const keyValue = token.match[1];
          const expression = token.match[2];
          const conditional = token.match[3];
          let kvSplit = null;
          token.keyVar = null;
          token.valueVar = null;
          if (keyValue.includes(",")) {
            kvSplit = keyValue.split(",");
            if (kvSplit.length === 2) {
              token.keyVar = kvSplit[0].trim();
              token.valueVar = kvSplit[1].trim();
            } else {
              throw new Twig2.Error("Invalid expression in for loop: " + keyValue);
            }
          } else {
            token.valueVar = keyValue.trim();
          }
          token.expression = Twig2.expression.compile.call(this, {
            type: Twig2.expression.type.expression,
            value: expression
          }).stack;
          if (conditional) {
            token.conditional = Twig2.expression.compile.call(this, {
              type: Twig2.expression.type.expression,
              value: conditional
            }).stack;
          }
          delete token.match;
          return token;
        },
        parse(token, context, continueChain) {
          const output = [];
          let len;
          let index2 = 0;
          let keyset;
          const state2 = this;
          const { conditional } = token;
          const buildLoop = function(index3, len2) {
            const isConditional = conditional !== void 0;
            return {
              index: index3 + 1,
              index0: index3,
              revindex: isConditional ? void 0 : len2 - index3,
              revindex0: isConditional ? void 0 : len2 - index3 - 1,
              first: index3 === 0,
              last: isConditional ? void 0 : index3 === len2 - 1,
              length: isConditional ? void 0 : len2,
              parent: context
            };
          };
          const loop = function(key, value) {
            const innerContext = { ...context };
            innerContext[token.valueVar] = value;
            if (token.keyVar) {
              innerContext[token.keyVar] = key;
            }
            innerContext.loop = buildLoop(index2, len);
            const promise = conditional === void 0 ? Twig2.Promise.resolve(true) : Twig2.expression.parseAsync.call(state2, conditional, innerContext);
            return promise.then((condition2) => {
              if (!condition2) {
                return;
              }
              return state2.parseAsync(token.output, innerContext).then((tokenOutput) => {
                output.push(tokenOutput);
                index2 += 1;
              });
            }).then(() => {
              delete innerContext.loop;
              delete innerContext[token.valueVar];
              delete innerContext[token.keyVar];
              Twig2.merge(context, innerContext, true);
            });
          };
          return Twig2.expression.parseAsync.call(state2, token.expression, context).then((result) => {
            if (Array.isArray(result)) {
              len = result.length;
              return Twig2.async.forEach(result, (value) => {
                const key = index2;
                return loop(key, value);
              });
            }
            if (Twig2.lib.is("Object", result)) {
              if (result._keys === void 0) {
                keyset = Object.keys(result);
              } else {
                keyset = result._keys;
              }
              len = keyset.length;
              return Twig2.async.forEach(keyset, (key) => {
                if (key === "_keys") {
                  return;
                }
                return loop(key, result[key]);
              });
            }
          }).then(() => {
            continueChain = output.length === 0;
            return {
              chain: continueChain,
              context,
              output: Twig2.output.call(state2.template, output)
            };
          });
        }
      },
      {
        /**
         * End for type logic tokens.
         *
         *  Format: {% endfor %}
         */
        type: Twig2.logic.type.endfor,
        regex: /^endfor$/,
        next: [],
        open: false
      },
      {
        /**
         * Set type logic tokens.
         *
         *  Format: {% set key = expression %}
         */
        type: Twig2.logic.type.set,
        regex: /^set\s+([a-zA-Z0-9_,\s]+)\s*=\s*([\s\S]+)$/,
        next: [],
        open: true,
        compile(token) {
          const key = token.match[1].trim();
          const expression = token.match[2];
          const expressionStack = Twig2.expression.compile.call(this, {
            type: Twig2.expression.type.expression,
            value: expression
          }).stack;
          token.key = key;
          token.expression = expressionStack;
          delete token.match;
          return token;
        },
        parse(token, context, continueChain) {
          const { key } = token;
          const state2 = this;
          return Twig2.expression.parseAsync.call(state2, token.expression, context).then((value) => {
            if (value === context) {
              value = { ...value };
            }
            context[key] = value;
            return {
              chain: continueChain,
              context
            };
          });
        }
      },
      {
        /**
         * Set capture type logic tokens.
         *
         *  Format: {% set key %}
         */
        type: Twig2.logic.type.setcapture,
        regex: /^set\s+([a-zA-Z0-9_,\s]+)$/,
        next: [
          Twig2.logic.type.endset
        ],
        open: true,
        compile(token) {
          const key = token.match[1].trim();
          token.key = key;
          delete token.match;
          return token;
        },
        parse(token, context, continueChain) {
          const state2 = this;
          const { key } = token;
          return state2.parseAsync(token.output, context).then((output) => {
            state2.context[key] = output;
            context[key] = output;
            return {
              chain: continueChain,
              context
            };
          });
        }
      },
      {
        /**
         * End set type block logic tokens.
         *
         *  Format: {% endset %}
         */
        type: Twig2.logic.type.endset,
        regex: /^endset$/,
        next: [],
        open: false
      },
      {
        /**
         * Filter logic tokens.
         *
         *  Format: {% filter upper %} or {% filter lower|escape %}
         */
        type: Twig2.logic.type.filter,
        regex: /^filter\s+(.+)$/,
        next: [
          Twig2.logic.type.endfilter
        ],
        open: true,
        compile(token) {
          const expression = "|" + token.match[1].trim();
          token.stack = Twig2.expression.compile.call(this, {
            type: Twig2.expression.type.expression,
            value: expression
          }).stack;
          delete token.match;
          return token;
        },
        parse(token, context, chain) {
          const state2 = this;
          return state2.parseAsync(token.output, context).then((output) => {
            const stack2 = [{
              type: Twig2.expression.type.string,
              value: output
            }].concat(token.stack);
            return Twig2.expression.parseAsync.call(state2, stack2, context);
          }).then((output) => {
            return {
              chain,
              output
            };
          });
        }
      },
      {
        /**
         * End filter logic tokens.
         *
         *  Format: {% endfilter %}
         */
        type: Twig2.logic.type.endfilter,
        regex: /^endfilter$/,
        next: [],
        open: false
      },
      {
        /**
         * Apply logic tokens.
         *
         *  Format: {% apply upper %} or {% apply lower|escape %}
         */
        type: Twig2.logic.type.apply,
        regex: /^apply\s+(.+)$/,
        next: [
          Twig2.logic.type.endapply
        ],
        open: true,
        compile(token) {
          const expression = "|" + token.match[1].trim();
          token.stack = Twig2.expression.compile.call(this, {
            type: Twig2.expression.type.expression,
            value: expression
          }).stack;
          delete token.match;
          return token;
        },
        parse(token, context, chain) {
          const state2 = this;
          return state2.parseAsync(token.output, context).then((output) => {
            const stack2 = [{
              type: Twig2.expression.type.string,
              value: output
            }].concat(token.stack);
            return Twig2.expression.parseAsync.call(state2, stack2, context);
          }).then((output) => {
            return {
              chain,
              output
            };
          });
        }
      },
      {
        /**
         * End apply logic tokens.
         *
         *  Format: {% endapply %}
         */
        type: Twig2.logic.type.endapply,
        regex: /^endapply$/,
        next: [],
        open: false
      },
      {
        /**
         * Set type logic tokens.
         *
         *  Format: {% do expression %}
         */
        type: Twig2.logic.type.do,
        regex: /^do\s+([\S\s]+)$/,
        next: [],
        open: true,
        compile(token) {
          const expression = token.match[1];
          const expressionStack = Twig2.expression.compile.call(this, {
            type: Twig2.expression.type.expression,
            value: expression
          }).stack;
          token.expression = expressionStack;
          delete token.match;
          return token;
        },
        parse(token, context, continueChain) {
          const state2 = this;
          return Twig2.expression.parseAsync.call(state2, token.expression, context).then(() => {
            return {
              chain: continueChain,
              context
            };
          });
        }
      },
      {
        /**
         * Block logic tokens.
         *
         *  Format: {% block title %}
         */
        type: Twig2.logic.type.block,
        regex: /^block\s+(\w+)$/,
        next: [
          Twig2.logic.type.endblock
        ],
        open: true,
        compile(token) {
          token.blockName = token.match[1].trim();
          delete token.match;
          return token;
        },
        parse(token, context, chain) {
          const state2 = this;
          let promise = Twig2.Promise.resolve();
          state2.template.blocks.defined[token.blockName] = new Twig2.Block(state2.template, token);
          if (state2.template.parentTemplate === null || state2.template.parentTemplate instanceof Twig2.Template) {
            promise = state2.getBlock(token.blockName).render(state2, context);
          }
          return promise.then((output) => {
            return {
              chain,
              output
            };
          });
        }
      },
      {
        /**
         * Block shorthand logic tokens.
         *
         *  Format: {% block title expression %}
         */
        type: Twig2.logic.type.shortblock,
        regex: /^block\s+(\w+)\s+(.+)$/,
        next: [],
        open: true,
        compile(token) {
          const template = this;
          token.expression = token.match[2].trim();
          token.output = Twig2.expression.compile({
            type: Twig2.expression.type.expression,
            value: token.expression
          }).stack;
          return Twig2.logic.handler[Twig2.logic.type.block].compile.apply(template, [token]);
        },
        parse(...args) {
          const state2 = this;
          return Twig2.logic.handler[Twig2.logic.type.block].parse.apply(state2, args);
        }
      },
      {
        /**
         * End block logic tokens.
         *
         *  Format: {% endblock %}
         */
        type: Twig2.logic.type.endblock,
        regex: /^endblock(?:\s+(\w+))?$/,
        next: [],
        open: false
      },
      {
        /**
         * Block logic tokens.
         *
         *  Format: {% extends "template.twig" %}
         */
        type: Twig2.logic.type.extends_,
        regex: /^extends\s+(.+)$/,
        next: [],
        open: true,
        compile(token) {
          const expression = token.match[1].trim();
          delete token.match;
          token.stack = Twig2.expression.compile.call(this, {
            type: Twig2.expression.type.expression,
            value: expression
          }).stack;
          return token;
        },
        parse(token, context, chain) {
          const state2 = this;
          return Twig2.expression.parseAsync.call(state2, token.stack, context).then((fileName) => {
            if (Array.isArray(fileName)) {
              const result = fileName.reverse().reduce((acc, file) => {
                try {
                  return {
                    render: state2.template.importFile(file),
                    fileName: file
                  };
                } catch (error) {
                  return acc;
                }
              }, {
                render: null,
                fileName: null
              });
              if (result.fileName !== null) {
                state2.template.parentTemplate = result.fileName;
              }
            } else {
              state2.template.parentTemplate = fileName;
            }
            return {
              chain,
              output: ""
            };
          });
        }
      },
      {
        /**
         * Block logic tokens.
         *
         *  Format: {% use "template.twig" %}
         */
        type: Twig2.logic.type.use,
        regex: /^use\s+(.+)$/,
        next: [],
        open: true,
        compile(token) {
          const expression = token.match[1].trim();
          delete token.match;
          token.stack = Twig2.expression.compile.call(this, {
            type: Twig2.expression.type.expression,
            value: expression
          }).stack;
          return token;
        },
        parse(token, context, chain) {
          const state2 = this;
          return Twig2.expression.parseAsync.call(state2, token.stack, context).then((filePath) => {
            const useTemplate = state2.template.importFile(filePath);
            const useState = new Twig2.ParseState(useTemplate);
            return useState.parseAsync(useTemplate.tokens).then(() => {
              state2.template.blocks.imported = {
                ...state2.template.blocks.imported,
                ...useState.getBlocks()
              };
            });
          }).then(() => {
            return {
              chain,
              output: ""
            };
          });
        }
      },
      {
        /**
         * Block logic tokens.
         *
         *  Format: {% includes "template.twig" [with {some: 'values'} only] %}
         */
        type: Twig2.logic.type.include,
        regex: /^include\s+(.+?)(?:\s|$)(ignore missing(?:\s|$))?(?:with\s+([\S\s]+?))?(?:\s|$)(only)?$/,
        next: [],
        open: true,
        compile(token) {
          const { match } = token;
          const expression = match[1].trim();
          const ignoreMissing = match[2] !== void 0;
          const withContext = match[3];
          const only = match[4] !== void 0 && match[4].length;
          delete token.match;
          token.only = only;
          token.ignoreMissing = ignoreMissing;
          token.stack = Twig2.expression.compile.call(this, {
            type: Twig2.expression.type.expression,
            value: expression
          }).stack;
          if (withContext !== void 0) {
            token.withStack = Twig2.expression.compile.call(this, {
              type: Twig2.expression.type.expression,
              value: withContext.trim()
            }).stack;
          }
          return token;
        },
        parse(token, context, chain) {
          let innerContext = token.only ? {} : { ...context };
          const { ignoreMissing } = token;
          const state2 = this;
          let promise = null;
          const result = { chain, output: "" };
          if (typeof token.withStack === "undefined") {
            promise = Twig2.Promise.resolve();
          } else {
            promise = Twig2.expression.parseAsync.call(state2, token.withStack, context).then((withContext) => {
              innerContext = {
                ...innerContext,
                ...withContext
              };
            });
          }
          return promise.then(() => {
            return Twig2.expression.parseAsync.call(state2, token.stack, context);
          }).then((file) => {
            let files;
            if (Array.isArray(file)) {
              files = file;
            } else {
              files = [file];
            }
            const result2 = files.reduce((acc, file2) => {
              if (acc.render === null) {
                if (file2 instanceof Twig2.Template) {
                  return {
                    render: file2.renderAsync(
                      innerContext,
                      {
                        isInclude: true
                      }
                    ),
                    lastError: null
                  };
                }
                try {
                  return {
                    render: state2.template.importFile(file2).renderAsync(
                      innerContext,
                      {
                        isInclude: true
                      }
                    ),
                    lastError: null
                  };
                } catch (error) {
                  return {
                    render: null,
                    lastError: error
                  };
                }
              }
              return acc;
            }, { render: null, lastError: null });
            if (result2.render !== null) {
              return result2.render;
            }
            if (result2.render === null && ignoreMissing) {
              return "";
            }
            throw result2.lastError;
          }).then((output) => {
            if (output !== "") {
              result.output = output;
            }
            return result;
          });
        }
      },
      {
        type: Twig2.logic.type.spaceless,
        regex: /^spaceless$/,
        next: [
          Twig2.logic.type.endspaceless
        ],
        open: true,
        // Parse the html and return it without any spaces between tags
        parse(token, context, chain) {
          const state2 = this;
          return state2.parseAsync(token.output, context).then((tokenOutput) => {
            const rBetweenTagSpaces = />\s+</g;
            let output = tokenOutput.replace(rBetweenTagSpaces, "><").trim();
            output = new Twig2.Markup(output);
            return {
              chain,
              output
            };
          });
        }
      },
      // Add the {% endspaceless %} token
      {
        type: Twig2.logic.type.endspaceless,
        regex: /^endspaceless$/,
        next: [],
        open: false
      },
      {
        /**
         * Macro logic tokens.
         *
         * Format: {% macro input(name = default, value, type, size) %}
         *
         */
        type: Twig2.logic.type.macro,
        regex: /^macro\s+(\w+)\s*\(\s*((?:\w+(?:\s*=\s*([\s\S]+))?(?:,\s*)?)*)\s*\)$/,
        next: [
          Twig2.logic.type.endmacro
        ],
        open: true,
        compile(token) {
          const macroName = token.match[1];
          const rawParameters = token.match[2].split(/\s*,\s*/);
          const parameters = rawParameters.map((rawParameter) => {
            return rawParameter.split(/\s*=\s*/)[0];
          });
          const parametersCount = parameters.length;
          if (parametersCount > 1) {
            const uniq = {};
            for (let i = 0; i < parametersCount; i++) {
              const parameter = parameters[i];
              if (uniq[parameter]) {
                throw new Twig2.Error("Duplicate arguments for parameter: " + parameter);
              } else {
                uniq[parameter] = 1;
              }
            }
          }
          token.macroName = macroName;
          token.parameters = parameters;
          token.defaults = rawParameters.reduce(function(defaults, rawParameter) {
            const pair = rawParameter.split(/\s*=\s*/);
            const key = pair[0];
            const expression = pair[1];
            if (expression) {
              defaults[key] = Twig2.expression.compile.call(this, {
                type: Twig2.expression.type.expression,
                value: expression
              }).stack;
            } else {
              defaults[key] = void 0;
            }
            return defaults;
          }, {});
          delete token.match;
          return token;
        },
        parse(token, context, chain) {
          const state2 = this;
          state2.macros[token.macroName] = function(...args) {
            const macroContext = {
              // Use current state context because state context includes current loop variables as well
              ...state2.context,
              _self: state2.macros
            };
            return Twig2.async.forEach(token.parameters, function(prop, i) {
              if (typeof args[i] !== "undefined") {
                macroContext[prop] = args[i];
                return true;
              }
              if (typeof token.defaults[prop] !== "undefined") {
                return Twig2.expression.parseAsync.call(this, token.defaults[prop], context).then((value) => {
                  macroContext[prop] = value;
                  return Twig2.Promise.resolve();
                });
              }
              macroContext[prop] = void 0;
              return true;
            }).then(() => {
              return state2.parseAsync(token.output, macroContext);
            });
          };
          return {
            chain,
            output: ""
          };
        }
      },
      {
        /**
         * End macro logic tokens.
         *
         * Format: {% endmacro %}
         */
        type: Twig2.logic.type.endmacro,
        regex: /^endmacro$/,
        next: [],
        open: false
      },
      {
        /*
        * Import logic tokens.
        *
        * Format: {% import "template.twig" as form %}
        */
        type: Twig2.logic.type.import_,
        regex: /^import\s+(.+)\s+as\s+(\w+)$/,
        next: [],
        open: true,
        compile(token) {
          const expression = token.match[1].trim();
          const contextName = token.match[2].trim();
          delete token.match;
          token.expression = expression;
          token.contextName = contextName;
          token.stack = Twig2.expression.compile.call(this, {
            type: Twig2.expression.type.expression,
            value: expression
          }).stack;
          return token;
        },
        parse(token, context, chain) {
          const state2 = this;
          const output = {
            chain,
            output: ""
          };
          if (token.expression === "_self") {
            context[token.contextName] = state2.macros;
            return output;
          }
          return Twig2.expression.parseAsync.call(state2, token.stack, context).then((filePath) => {
            return state2.template.importFile(filePath || token.expression);
          }).then((importTemplate) => {
            const importState = new Twig2.ParseState(importTemplate);
            return importState.parseAsync(importTemplate.tokens).then(() => {
              context[token.contextName] = importState.macros;
              return output;
            });
          });
        }
      },
      {
        /*
        * From logic tokens.
        *
        * Format: {% from "template.twig" import func as form %}
        */
        type: Twig2.logic.type.from,
        regex: /^from\s+(.+)\s+import\s+([a-zA-Z0-9_, ]+)$/,
        next: [],
        open: true,
        compile(token) {
          const expression = token.match[1].trim();
          const macroExpressions = token.match[2].trim().split(/\s*,\s*/);
          const macroNames = {};
          for (const res of macroExpressions) {
            const macroMatch = res.match(/^(\w+)\s+as\s+(\w+)$/);
            if (macroMatch) {
              macroNames[macroMatch[1].trim()] = macroMatch[2].trim();
            } else if (res.match(/^(\w+)$/)) {
              macroNames[res] = res;
            } else
              ;
          }
          delete token.match;
          token.expression = expression;
          token.macroNames = macroNames;
          token.stack = Twig2.expression.compile.call(this, {
            type: Twig2.expression.type.expression,
            value: expression
          }).stack;
          return token;
        },
        parse(token, context, chain) {
          const state2 = this;
          let promise;
          if (token.expression === "_self") {
            promise = Twig2.Promise.resolve(state2.macros);
          } else {
            promise = Twig2.expression.parseAsync.call(state2, token.stack, context).then((filePath) => {
              return state2.template.importFile(filePath || token.expression);
            }).then((importTemplate) => {
              const importState = new Twig2.ParseState(importTemplate);
              return importState.parseAsync(importTemplate.tokens).then(() => {
                return importState.macros;
              });
            });
          }
          return promise.then((macros) => {
            for (const macroName in token.macroNames) {
              if (macros[macroName] !== void 0) {
                context[token.macroNames[macroName]] = macros[macroName];
              }
            }
            return {
              chain,
              output: ""
            };
          });
        }
      },
      {
        /**
         * The embed tag combines the behaviour of include and extends.
         * It allows you to include another template's contents, just like include does.
         *
         *  Format: {% embed "template.twig" [with {some: 'values'} only] %}
         */
        type: Twig2.logic.type.embed,
        regex: /^embed\s+(.+?)(?:\s+(ignore missing))?(?:\s+with\s+([\S\s]+?))?(?:\s+(only))?$/,
        next: [
          Twig2.logic.type.endembed
        ],
        open: true,
        compile(token) {
          const { match } = token;
          const expression = match[1].trim();
          const ignoreMissing = match[2] !== void 0;
          const withContext = match[3];
          const only = match[4] !== void 0 && match[4].length;
          delete token.match;
          token.only = only;
          token.ignoreMissing = ignoreMissing;
          token.stack = Twig2.expression.compile.call(this, {
            type: Twig2.expression.type.expression,
            value: expression
          }).stack;
          if (withContext !== void 0) {
            token.withStack = Twig2.expression.compile.call(this, {
              type: Twig2.expression.type.expression,
              value: withContext.trim()
            }).stack;
          }
          return token;
        },
        parse(token, context, chain) {
          let embedContext = {};
          let promise = Twig2.Promise.resolve();
          let state2 = this;
          if (!token.only) {
            embedContext = { ...context };
          }
          if (token.withStack !== void 0) {
            promise = Twig2.expression.parseAsync.call(state2, token.withStack, context).then((withContext) => {
              embedContext = { ...embedContext, ...withContext };
            });
          }
          return promise.then(() => {
            return Twig2.expression.parseAsync.call(state2, token.stack, embedContext);
          }).then((fileName) => {
            const embedOverrideTemplate = new Twig2.Template({
              data: token.output,
              base: state2.template.base,
              path: state2.template.path,
              url: state2.template.url,
              name: state2.template.name,
              method: state2.template.method,
              options: state2.template.options
            });
            try {
              embedOverrideTemplate.importFile(fileName);
            } catch (error) {
              if (token.ignoreMissing) {
                return "";
              }
              state2 = null;
              throw error;
            }
            embedOverrideTemplate.parentTemplate = fileName;
            return embedOverrideTemplate.renderAsync(
              embedContext,
              {
                isInclude: true
              }
            );
          }).then((output) => {
            return {
              chain,
              output
            };
          });
        }
      },
      /* Add the {% endembed %} token
       *
       */
      {
        type: Twig2.logic.type.endembed,
        regex: /^endembed$/,
        next: [],
        open: false
      },
      {
        /**
         * Block logic tokens.
         *
         *  Format: {% with {some: 'values'} [only] %}
         */
        type: Twig2.logic.type.with,
        regex: /^(?:with(?:\s+([\S\s]+?))?)(?:\s|$)(only)?$/,
        next: [
          Twig2.logic.type.endwith
        ],
        open: true,
        compile(token) {
          const { match } = token;
          const withContext = match[1];
          const only = match[2] !== void 0 && match[2].length;
          delete token.match;
          token.only = only;
          if (withContext !== void 0) {
            token.withStack = Twig2.expression.compile.call(this, {
              type: Twig2.expression.type.expression,
              value: withContext.trim()
            }).stack;
          }
          return token;
        },
        parse(token, context, chain) {
          let innerContext = {};
          let i;
          const state2 = this;
          let promise = Twig2.Promise.resolve();
          if (!token.only) {
            innerContext = { ...context };
          }
          if (token.withStack !== void 0) {
            promise = Twig2.expression.parseAsync.call(state2, token.withStack, context).then((withContext) => {
              for (i in withContext) {
                if (Object.hasOwnProperty.call(withContext, i)) {
                  innerContext[i] = withContext[i];
                }
              }
            });
          }
          const isolatedState = new Twig2.ParseState(state2.template, void 0, innerContext);
          return promise.then(() => {
            return isolatedState.parseAsync(token.output);
          }).then((output) => {
            return {
              chain,
              output
            };
          });
        }
      },
      {
        type: Twig2.logic.type.endwith,
        regex: /^endwith$/,
        next: [],
        open: false
      },
      {
        /**
         * Deprecated type logic tokens.
         *
         *  Format: {% deprecated 'Description' %}
         */
        type: Twig2.logic.type.deprecated,
        regex: /^deprecated\s+(.+)$/,
        next: [],
        open: true,
        compile(token) {
          console.warn("Deprecation notice: " + token.match[1]);
          return token;
        },
        parse() {
          return {};
        }
      }
    ];
    Twig2.logic.handler = {};
    Twig2.logic.extendType = function(type2, value) {
      value = value || "Twig.logic.type" + type2;
      Twig2.logic.type[type2] = value;
    };
    Twig2.logic.extend = function(definition) {
      if (definition.type) {
        Twig2.logic.extendType(definition.type);
      } else {
        throw new Twig2.Error("Unable to extend logic definition. No type provided for " + definition);
      }
      Twig2.logic.handler[definition.type] = definition;
    };
    while (Twig2.logic.definitions.length > 0) {
      Twig2.logic.extend(Twig2.logic.definitions.shift());
    }
    Twig2.logic.compile = function(rawToken) {
      const expression = rawToken.value.trim();
      let token = Twig2.logic.tokenize.call(this, expression);
      const tokenTemplate = Twig2.logic.handler[token.type];
      if (tokenTemplate.compile) {
        token = tokenTemplate.compile.call(this, token);
        Twig2.log.trace("Twig.logic.compile: ", "Compiled logic token to ", token);
      }
      return token;
    };
    Twig2.logic.tokenize = function(expression) {
      let tokenTemplateType = null;
      let tokenType = null;
      let tokenRegex = null;
      let regexArray = null;
      let regexLen = null;
      let regexI = null;
      let match = null;
      expression = expression.trim();
      for (tokenTemplateType in Twig2.logic.handler) {
        if (Object.hasOwnProperty.call(Twig2.logic.handler, tokenTemplateType)) {
          tokenType = Twig2.logic.handler[tokenTemplateType].type;
          tokenRegex = Twig2.logic.handler[tokenTemplateType].regex;
          regexArray = tokenRegex;
          if (!Array.isArray(tokenRegex)) {
            regexArray = [tokenRegex];
          }
          regexLen = regexArray.length;
          for (regexI = 0; regexI < regexLen; regexI++) {
            match = regexArray[regexI].exec(expression);
            if (match !== null) {
              Twig2.log.trace("Twig.logic.tokenize: ", "Matched a ", tokenType, " regular expression of ", match);
              return {
                type: tokenType,
                match
              };
            }
          }
        }
      }
      throw new Twig2.Error("Unable to parse '" + expression.trim() + "'");
    };
    Twig2.logic.parse = function(token, context, chain, allowAsync) {
      return Twig2.async.potentiallyAsync(this, allowAsync, function() {
        Twig2.log.debug("Twig.logic.parse: ", "Parsing logic token ", token);
        const tokenTemplate = Twig2.logic.handler[token.type];
        let result;
        const state2 = this;
        if (!tokenTemplate.parse) {
          return "";
        }
        state2.nestingStack.unshift(token);
        result = tokenTemplate.parse.call(state2, token, context || {}, chain);
        if (Twig2.isPromise(result)) {
          result = result.then((result2) => {
            state2.nestingStack.shift();
            return result2;
          });
        } else {
          state2.nestingStack.shift();
        }
        return result;
      });
    };
    return Twig2;
  };
  return twig_logic;
}
var twig_parser_source;
var hasRequiredTwig_parser_source;
function requireTwig_parser_source() {
  if (hasRequiredTwig_parser_source)
    return twig_parser_source;
  hasRequiredTwig_parser_source = 1;
  twig_parser_source = function(Twig2) {
    Twig2.Templates.registerParser("source", (params) => {
      return params.data || "";
    });
  };
  return twig_parser_source;
}
var twig_parser_twig;
var hasRequiredTwig_parser_twig;
function requireTwig_parser_twig() {
  if (hasRequiredTwig_parser_twig)
    return twig_parser_twig;
  hasRequiredTwig_parser_twig = 1;
  twig_parser_twig = function(Twig2) {
    Twig2.Templates.registerParser("twig", (params) => {
      return new Twig2.Template(params);
    });
  };
  return twig_parser_twig;
}
var twig_path;
var hasRequiredTwig_path;
function requireTwig_path() {
  if (hasRequiredTwig_path)
    return twig_path;
  hasRequiredTwig_path = 1;
  twig_path = function(Twig2) {
    Twig2.path = {};
    Twig2.path.expandNamespace = function(namespaces, path) {
      const namespaceIdentifiers = Object.keys(namespaces);
      const pattern = new RegExp(`^(?:@(${namespaceIdentifiers.join("|")})/|(${namespaceIdentifiers.join("|")})::)`);
      return path.replace(pattern, (wholeMatch, atNamespace, colonNamespace) => {
        const namespaceIdentifier = atNamespace === void 0 ? colonNamespace : atNamespace;
        return `${namespaces[namespaceIdentifier]}/`;
      });
    };
    Twig2.path.parsePath = function(template, _file) {
      const { namespaces } = template.options;
      const file = _file || "";
      const hasNamespaces = namespaces && typeof namespaces === "object";
      let path = hasNamespaces ? Twig2.path.expandNamespace(namespaces, file) : file;
      if (path === file) {
        path = Twig2.path.relativePath(template, file);
      }
      return path;
    };
    Twig2.path.relativePath = function(template, _file) {
      let base;
      let basePath;
      let sepChr = "/";
      const newPath = [];
      let file = _file || "";
      let val;
      if (template.url) {
        if (typeof template.base === "undefined") {
          base = template.url;
        } else {
          base = template.base.replace(/([^/])$/, "$1/");
        }
      } else if (template.path) {
        const path = require$$0;
        const sep = path.sep || sepChr;
        const relative = new RegExp("^\\.{1,2}" + sep.replace("\\", "\\\\"));
        file = file.replace(/\//g, sep);
        if (template.base !== void 0 && file.match(relative) === null) {
          file = file.replace(template.base, "");
          base = template.base + sep;
        } else {
          base = path.normalize(template.path);
        }
        base = base.replace(sep + sep, sep);
        sepChr = sep;
      } else if ((template.name || template.id) && template.method && template.method !== "fs" && template.method !== "ajax") {
        base = template.base || template.name || template.id;
      } else {
        throw new Twig2.Error("Cannot extend an inline template.");
      }
      basePath = base.split(sepChr);
      basePath.pop();
      basePath = basePath.concat(file.split(sepChr));
      while (basePath.length > 0) {
        val = basePath.shift();
        if (val === ".")
          ;
        else if (val === ".." && newPath.length > 0 && newPath[newPath.length - 1] !== "..") {
          newPath.pop();
        } else {
          newPath.push(val);
        }
      }
      return newPath.join(sepChr);
    };
    return Twig2;
  };
  return twig_path;
}
var twig_tests;
var hasRequiredTwig_tests;
function requireTwig_tests() {
  if (hasRequiredTwig_tests)
    return twig_tests;
  hasRequiredTwig_tests = 1;
  twig_tests = function(Twig2) {
    Twig2.tests = {
      empty(value) {
        if (value === true) {
          return false;
        }
        if (value === null || value === void 0) {
          return true;
        }
        if (typeof value === "number") {
          return false;
        }
        if (value.length > 0) {
          return false;
        }
        for (const key in value) {
          if (Object.hasOwnProperty.call(value, key)) {
            return false;
          }
        }
        return true;
      },
      odd(value) {
        return value % 2 === 1;
      },
      even(value) {
        return value % 2 === 0;
      },
      "divisible by"(value, params) {
        return value % params[0] === 0;
      },
      divisibleby(value, params) {
        console.warn("`divisibleby` is deprecated use `divisible by`");
        return Twig2.tests["divisible by"](value, params);
      },
      defined(value) {
        return value !== void 0;
      },
      none(value) {
        return value === null;
      },
      null(value) {
        return this.none(value);
      },
      "same as"(value, params) {
        return value === params[0];
      },
      sameas(value, params) {
        console.warn("`sameas` is deprecated use `same as`");
        return Twig2.tests["same as"](value, params);
      },
      iterable(value) {
        return value && (Twig2.lib.is("Array", value) || Twig2.lib.is("Object", value));
      }
      /*
      Constant ?
       */
    };
    Twig2.test = function(test2, value, params) {
      if (!Twig2.tests[test2]) {
        throw Twig2.Error("Test " + test2 + " is not defined.");
      }
      return Twig2.tests[test2](value, params);
    };
    Twig2.test.extend = function(test2, definition) {
      Twig2.tests[test2] = definition;
    };
    return Twig2;
  };
  return twig_tests;
}
var twig_async;
var hasRequiredTwig_async;
function requireTwig_async() {
  if (hasRequiredTwig_async)
    return twig_async;
  hasRequiredTwig_async = 1;
  twig_async = function(Twig2) {
    const STATE_UNKNOWN = 0;
    const STATE_RESOLVED = 1;
    const STATE_REJECTED = 2;
    Twig2.ParseState.prototype.parseAsync = function(tokens2, context) {
      return this.parse(tokens2, context, true);
    };
    Twig2.expression.parseAsync = function(tokens2, context, tokensAreParameters) {
      const state2 = this;
      return Twig2.expression.parse.call(state2, tokens2, context, tokensAreParameters, true);
    };
    Twig2.logic.parseAsync = function(token, context, chain) {
      const state2 = this;
      return Twig2.logic.parse.call(state2, token, context, chain, true);
    };
    Twig2.Template.prototype.renderAsync = function(context, params) {
      return this.render(context, params, true);
    };
    Twig2.async = {};
    Twig2.isPromise = function(obj) {
      return obj && obj.then && typeof obj.then === "function";
    };
    function potentiallyAsyncSlow(that, allowAsync, action) {
      let result = action.call(that);
      let err = null;
      let isAsync = true;
      if (!Twig2.isPromise(result)) {
        return result;
      }
      result.then((res) => {
        result = res;
        isAsync = false;
      }).catch((error) => {
        err = error;
      });
      if (err !== null) {
        throw err;
      }
      if (isAsync) {
        throw new Twig2.Error("You are using Twig.js in sync mode in combination with async extensions.");
      }
      return result;
    }
    Twig2.async.potentiallyAsync = function(that, allowAsync, action) {
      if (allowAsync) {
        return Twig2.Promise.resolve(action.call(that));
      }
      return potentiallyAsyncSlow(that, allowAsync, action);
    };
    function run(fn, resolve2, reject) {
      try {
        fn(resolve2, reject);
      } catch (error) {
        reject(error);
      }
    }
    function pending(handlers2, onResolved, onRejected) {
      const h2 = [onResolved, onRejected, -2];
      if (!handlers2) {
        handlers2 = h2;
      } else if (handlers2[2] === -2) {
        handlers2 = [handlers2, h2];
      } else {
        handlers2.push(h2);
      }
      return handlers2;
    }
    Twig2.Thenable = function(then, value, state2) {
      this.then = then;
      this._value = state2 ? value : null;
      this._state = state2 || STATE_UNKNOWN;
    };
    Twig2.Thenable.prototype.catch = function(onRejected) {
      if (this._state === STATE_RESOLVED) {
        return this;
      }
      return this.then(null, onRejected);
    };
    Twig2.Thenable.resolvedThen = function(onResolved) {
      try {
        return Twig2.Promise.resolve(onResolved(this._value));
      } catch (error) {
        return Twig2.Promise.reject(error);
      }
    };
    Twig2.Thenable.rejectedThen = function(onResolved, onRejected) {
      if (!onRejected || typeof onRejected !== "function") {
        return this;
      }
      const value = this._value;
      let result;
      try {
        result = onRejected(value);
      } catch (error) {
        result = Twig2.Promise.reject(error);
      }
      return Twig2.Promise.resolve(result);
    };
    Twig2.Promise = function(executor) {
      let state2 = STATE_UNKNOWN;
      let value = null;
      let changeState = function(nextState, nextValue) {
        state2 = nextState;
        value = nextValue;
      };
      function onReady(v) {
        changeState(STATE_RESOLVED, v);
      }
      function onReject(e2) {
        changeState(STATE_REJECTED, e2);
      }
      run(executor, onReady, onReject);
      if (state2 === STATE_RESOLVED) {
        return Twig2.Promise.resolve(value);
      }
      if (state2 === STATE_REJECTED) {
        return Twig2.Promise.reject(value);
      }
      changeState = new Twig2.FullPromise();
      return changeState.promise;
    };
    Twig2.FullPromise = function() {
      let handlers2 = null;
      function resolved(onResolved) {
        onResolved(p2._value);
      }
      function rejected(onResolved, onRejected) {
        onRejected(p2._value);
      }
      let append = function(onResolved, onRejected) {
        handlers2 = pending(handlers2, onResolved, onRejected);
      };
      function changeState(newState, v) {
        if (p2._state) {
          return;
        }
        p2._value = v;
        p2._state = newState;
        append = newState === STATE_RESOLVED ? resolved : rejected;
        if (!handlers2) {
          return;
        }
        if (handlers2[2] === -2) {
          append(handlers2[0], handlers2[1]);
          handlers2 = null;
          return;
        }
        handlers2.forEach((h2) => {
          append(h2[0], h2[1]);
        });
        handlers2 = null;
      }
      const p2 = new Twig2.Thenable((onResolved, onRejected) => {
        const hasResolved = typeof onResolved === "function";
        if (p2._state === STATE_RESOLVED && !hasResolved) {
          return Twig2.Promise.resolve(p2._value);
        }
        if (p2._state === STATE_RESOLVED) {
          try {
            return Twig2.Promise.resolve(onResolved(p2._value));
          } catch (error) {
            return Twig2.Promise.reject(error);
          }
        }
        const hasRejected = typeof onRejected === "function";
        return new Twig2.Promise((resolve2, reject) => {
          append(
            hasResolved ? (result) => {
              try {
                resolve2(onResolved(result));
              } catch (error) {
                reject(error);
              }
            } : resolve2,
            hasRejected ? (err) => {
              try {
                resolve2(onRejected(err));
              } catch (error) {
                reject(error);
              }
            } : reject
          );
        });
      });
      changeState.promise = p2;
      return changeState;
    };
    Twig2.Promise.defaultResolved = new Twig2.Thenable(Twig2.Thenable.resolvedThen, void 0, STATE_RESOLVED);
    Twig2.Promise.emptyStringResolved = new Twig2.Thenable(Twig2.Thenable.resolvedThen, "", STATE_RESOLVED);
    Twig2.Promise.resolve = function(value) {
      if (arguments.length === 0 || typeof value === "undefined") {
        return Twig2.Promise.defaultResolved;
      }
      if (Twig2.isPromise(value)) {
        return value;
      }
      if (value === "") {
        return Twig2.Promise.emptyStringResolved;
      }
      return new Twig2.Thenable(Twig2.Thenable.resolvedThen, value, STATE_RESOLVED);
    };
    Twig2.Promise.reject = function(e2) {
      return new Twig2.Thenable(Twig2.Thenable.rejectedThen, e2, STATE_REJECTED);
    };
    Twig2.Promise.all = function(promises) {
      const results = new Array(promises.length);
      return Twig2.async.forEach(promises, (p2, index2) => {
        if (!Twig2.isPromise(p2)) {
          results[index2] = p2;
          return;
        }
        if (p2._state === STATE_RESOLVED) {
          results[index2] = p2._value;
          return;
        }
        return p2.then((v) => {
          results[index2] = v;
        });
      }).then(() => {
        return results;
      });
    };
    Twig2.async.forEach = function(arr, callback) {
      const len = arr ? arr.length : 0;
      let index2 = 0;
      function next() {
        let resp = null;
        do {
          if (index2 === len) {
            return Twig2.Promise.resolve();
          }
          resp = callback(arr[index2], index2);
          index2++;
        } while (!resp || !Twig2.isPromise(resp) || resp._state === STATE_RESOLVED);
        return resp.then(next);
      }
      return next();
    };
    return Twig2;
  };
  return twig_async;
}
var twig_exports;
var hasRequiredTwig_exports;
function requireTwig_exports() {
  if (hasRequiredTwig_exports)
    return twig_exports;
  hasRequiredTwig_exports = 1;
  twig_exports = function(Twig2) {
    Twig2.exports = {
      VERSION: Twig2.VERSION
    };
    Twig2.exports.twig = function(params) {
      const { id } = params;
      const options = {
        strictVariables: params.strict_variables || false,
        // TODO: turn autoscape on in the next major version
        autoescape: params.autoescape !== null && params.autoescape || false,
        allowInlineIncludes: params.allowInlineIncludes || false,
        rethrow: params.rethrow || false,
        namespaces: params.namespaces
      };
      if (Twig2.cache && id) {
        Twig2.validateId(id);
      }
      if (params.debug !== void 0) {
        Twig2.debug = params.debug;
      }
      if (params.trace !== void 0) {
        Twig2.trace = params.trace;
      }
      if (params.data !== void 0) {
        return Twig2.Templates.parsers.twig({
          data: params.data,
          path: Object.hasOwnProperty.call(params, "path") ? params.path : void 0,
          module: params.module,
          id,
          options
        });
      }
      if (params.ref !== void 0) {
        if (params.id !== void 0) {
          throw new Twig2.Error("Both ref and id cannot be set on a twig.js template.");
        }
        return Twig2.Templates.load(params.ref);
      }
      if (params.method !== void 0) {
        if (!Twig2.Templates.isRegisteredLoader(params.method)) {
          throw new Twig2.Error('Loader for "' + params.method + '" is not defined.');
        }
        return Twig2.Templates.loadRemote(params.name || params.href || params.path || id || void 0, {
          id,
          method: params.method,
          parser: params.parser || "twig",
          base: params.base,
          module: params.module,
          precompiled: params.precompiled,
          async: params.async,
          options
        }, params.load, params.error);
      }
      if (params.href !== void 0) {
        return Twig2.Templates.loadRemote(params.href, {
          id,
          method: "ajax",
          parser: params.parser || "twig",
          base: params.base,
          module: params.module,
          precompiled: params.precompiled,
          async: params.async,
          options
        }, params.load, params.error);
      }
      if (params.path !== void 0) {
        return Twig2.Templates.loadRemote(params.path, {
          id,
          method: "fs",
          parser: params.parser || "twig",
          base: params.base,
          module: params.module,
          precompiled: params.precompiled,
          async: params.async,
          options
        }, params.load, params.error);
      }
    };
    Twig2.exports.extendFilter = function(filter, definition) {
      Twig2.filter.extend(filter, definition);
    };
    Twig2.exports.extendFunction = function(fn, definition) {
      Twig2._function.extend(fn, definition);
    };
    Twig2.exports.extendTest = function(test2, definition) {
      Twig2.test.extend(test2, definition);
    };
    Twig2.exports.extendTag = function(definition) {
      Twig2.logic.extend(definition);
    };
    Twig2.exports.extend = function(fn) {
      fn(Twig2);
    };
    Twig2.exports.compile = function(markup, options) {
      const id = options.filename;
      const path = options.filename;
      const template = new Twig2.Template({
        data: markup,
        path,
        id,
        options: options.settings["twig options"]
      });
      return function(context) {
        return template.render(context);
      };
    };
    Twig2.exports.renderFile = function(path, options, fn) {
      if (typeof options === "function") {
        fn = options;
        options = {};
      }
      options = options || {};
      const settings = options.settings || {};
      const viewOptions = settings["twig options"];
      const params = {
        path,
        base: settings.views,
        load(template) {
          if (!viewOptions || !viewOptions.allowAsync) {
            fn(null, String(template.render(options)));
            return;
          }
          template.renderAsync(options).then((out) => fn(null, out), fn);
        },
        error(err) {
          fn(err);
        }
      };
      if (viewOptions) {
        for (const option in viewOptions) {
          if (Object.hasOwnProperty.call(viewOptions, option)) {
            params[option] = viewOptions[option];
          }
        }
      }
      Twig2.exports.twig(params);
    };
    Twig2.exports.__express = Twig2.exports.renderFile;
    Twig2.exports.cache = function(cache2) {
      Twig2.cache = cache2;
    };
    Twig2.exports.path = Twig2.path;
    Twig2.exports.filters = Twig2.filters;
    Twig2.exports.tests = Twig2.tests;
    Twig2.exports.functions = Twig2.functions;
    Twig2.exports.Promise = Twig2.Promise;
    return Twig2;
  };
  return twig_exports;
}
var twig_factory = function factory() {
  const Twig2 = {
    VERSION: "1.17.1"
  };
  requireTwig_core()(Twig2);
  requireTwig_compiler()(Twig2);
  requireTwig_expression()(Twig2);
  requireTwig_filters()(Twig2);
  requireTwig_functions()(Twig2);
  requireTwig_lib()(Twig2);
  requireTwig_loader_ajax()(Twig2);
  requireTwig_loader_fs()(Twig2);
  requireTwig_logic()(Twig2);
  requireTwig_parser_source()(Twig2);
  requireTwig_parser_twig()(Twig2);
  requireTwig_path()(Twig2);
  requireTwig_tests()(Twig2);
  requireTwig_async()(Twig2);
  requireTwig_exports()(Twig2);
  Twig2.exports.factory = factory;
  return Twig2.exports;
};
/**
 * Twig.js
 *
 * @copyright 2011-2020 John Roepke and the Twig.js Contributors
 * @license   Available under the BSD 2-Clause License
 * @link      https://github.com/twigjs/twig.js
 */
var twig = twig_factory();
const Twig = /* @__PURE__ */ getDefaultExportFromCjs(twig);
function extendParser(parser2) {
  parser2.functions.array = (len) => new Array(len).fill(0);
  parser2.functions.rand = (x) => Math.floor(Math.random() * parseInt(x));
  parser2.functions.slice = (x, a, b) => x.slice(parseInt(a), parseInt(b));
  parser2.functions.subset = (array, key, value) => array[key] = value;
  return parser2;
}
function getUnknownVariables(text, expression) {
  const retval = expression.variables({ withMembers: false });
  return retval.filter((v) => {
    return !new RegExp(`^${v} *=`, "m").test(text) && !new RegExp(`^${v}(.*?) *=`, "m").test(text) && !new RegExp(`${v}[,)].*?=`, "mi").test(text);
  });
}
function runFormula(story2, formulaText, tags) {
  try {
    const parser2 = new Parser({
      operators: {
        assignment: true
      }
    });
    extendParser(parser2);
    let formula = parser2.parse(formulaText);
    const variables = formula.variables();
    const unknownVariables = getUnknownVariables(formulaText, formula);
    const args = {};
    for (const v of variables) {
      if (/^\$RAND(\d+)/.test(v)) {
        const match = /^\$RAND(\d+)/.exec(v);
        args[v] = Math.floor(Math.random() * (parseInt(match[1]) + 1));
      } else if (!/^\$/.test(v)) {
        const variable = story2.tags.find((t) => t.name == v);
        if (variable) {
          if (variable.type === "ref") {
            let result = tags[variable.id];
            if (typeof result === "string") {
              result = StoryTag.traverse(tags, result.split("."));
            }
            args[v] = result;
          } else if (variable.type === "text") {
            args[v] = tags[variable.id] || "";
          } else {
            args[v] = tags[variable.id] || 0;
          }
        } else if (unknownVariables.includes(v)) {
          args[v] = 0;
        }
      } else {
        args[v] = tags[v];
      }
    }
    const resultValue = formula.evaluate(args);
    return resultValue;
  } catch (ex) {
    console.error("formula error", ex);
    const toaster = useToasterStore();
    toaster.add({
      title: "Formula Error",
      message: `Error: ${ex}`,
      level: "warning"
    });
    return null;
  }
}
class StoryTag {
  constructor(story2, tags, basis, tag, trait) {
    this.story = story2, this.tags = tags;
    this.basis = basis;
    this._tag = tag;
    this.trait = trait;
    this.setup();
  }
  setup() {
  }
  get tag() {
    return this._tag;
  }
  get isTag() {
    return !this.tag.type || this.tag.type === "tag";
  }
  get isText() {
    return this.isTag && this.tag.format === "text";
  }
  get isNumber() {
    return this.tag.type === "number" || this.isTag && this.tag.format !== "text";
  }
  get display() {
    return `${this.name}.${this.trait}`;
  }
  get value() {
    let val = this.basis[this.trait];
    if (this._tag && this._tag.type === "tag" && this._tag.format !== "text") {
      return val || 0;
    }
    return val || "";
  }
  set value(v) {
    this.basis[this.trait] = v;
  }
  erase() {
    delete this.basis[this.trait];
  }
  static traverse(tags, bits) {
    let object = tags;
    for (const bit of bits) {
      if (object instanceof Array) {
        let nextb = null;
        if (typeof bit === "number") {
          nextb = object[bit];
        } else {
          nextb = object.find((element) => element.id === bit);
        }
        if (!nextb) {
          console.log(
            "key not found",
            bit,
            object.map((e2) => e2.id)
          );
          throw Error("key not found");
        }
        object = nextb;
      } else {
        object = object[bit];
      }
    }
    return object;
  }
  static generate(story2, tags, reference) {
    const bits = reference.split(".");
    bits.forEach((bit, i) => {
      const groups = /^(.+)\[(\d+)\]$/.exec(bit);
      if (groups) {
        bits[i] = groups[1];
        bits.splice(i + 1, 0, parseInt(groups[2]));
      }
    });
    const basis = this.traverse(tags, bits.slice(0, bits.length - 1));
    const name = bits[bits.length - 1];
    const trait = /\./.test(reference) ? name : null;
    let tag = (story2.allTags || []).find((t) => t.id === bits[0]);
    let klass = StoryTag;
    if (!tag) {
      console.warn(
        "missing tag",
        bits[0],
        (story2.allTags || []).map((t) => t.id)
      );
      tag = {
        name: "unknown-type",
        type: typeof basis[trait] === "string" ? "string" : "number"
      };
    } else if (tag.type === "action") {
      klass = StoryActionTag;
    } else if (["ref", "array"].includes(tag.type) && bits.length > 1) {
      const { meta, attr } = StoryTag.dereference(story2, {
        typeId: tag.referencing,
        trait
      });
      tag = {
        id: tag.id,
        element: bits[1],
        type: attr ? attr.type : tag.type,
        attr,
        meta
      };
    }
    return new klass(story2, tags, basis, tag, name);
  }
  static dereference(story2, { typeId, blueprintId, trait = null }) {
    let bp = null;
    let id = typeId;
    if (blueprintId) {
      bp = story2.blueprints.find((b) => b.id === blueprintId);
      id = bp.meta;
    }
    const meta = (story2.allTypes || []).find((type2) => type2.id === id);
    if (!meta) {
      console.warn("failed to find type", typeId, blueprintId, trait);
    }
    return {
      meta,
      blueprint: bp,
      attr: trait ? meta && meta.attrs.find((attr) => attr.name === trait) : null
    };
  }
  static formula(story2, tags, text) {
    return runFormula(story2, text, tags);
  }
}
class StoryActionTag extends StoryTag {
  get value() {
    return runFormula(this.story, this.tag.formula, this.tags);
  }
  set value(v) {
    console.error("Cannot set the value of an action");
  }
}
function defaultOne(value, precision = 0) {
  if (value === null || value === void 0) {
    return 1;
  }
  const places = 10 ** precision;
  const val = parseInt(value * places) / places;
  if (val === 0) {
    return 0;
  }
  return val || 1;
}
class TagEffect {
  eval(story2, tags, effect, funcName, ...args) {
    this.story = story2;
    this.tags = tags;
    this.tag = this.find(effect.tag);
    this.tag.value = this[funcName](effect, ...args);
  }
  test(story2, tags, effect, funcName, ...args) {
    this.story = story2;
    this.tags = tags;
    this.tag = this.find(effect.tag);
    return this[funcName](effect, ...args);
  }
  find(name) {
    return StoryTag.generate(this.story, this.tags, name);
  }
  default(v) {
    if (this.tag.isNumber) {
      return defaultOne(v, this.tag.tag.precision || 0);
    }
    return v;
  }
  // text functions
  concatList(a, b) {
    return [a, b].filter((a2) => a2).join(", ");
  }
  concat(effect, ref2 = false) {
    const value = ref2 ? this.find(effect.value).value : this.default(effect.value);
    return this.tag.value + value;
  }
  spliceList(a, b) {
    const temp = a.split(",").map((v) => v.trim()).filter((v) => v);
    if (b) {
      const idx = temp.findIndex((t) => t.toLowerCase() === b.toLowerCase());
      if (idx > -1) {
        temp.splice(idx, 1);
      }
    }
    return temp.join(", ");
  }
  set(effect, ref2 = false) {
    return ref2 ? this.find(effect.value).value : this.default(effect.value);
  }
  // math
  add(effect, ref2 = false, sub2 = false) {
    const value = ref2 ? this.find(effect.value).value : this.default(effect.value);
    if (this.tag.isText) {
      if (sub2) {
        return this.spliceList(this.tag.value, value);
      }
      return this.concatList(this.tag.value, value);
    }
    return (this.tag.value || 0) + (sub2 ? -1 : 1) * this.default(value);
  }
  formula(effect) {
    return runFormula(this.story, effect.value, this.tags);
  }
  array_shift(effect) {
    const other = this.find(effect.other);
    other.value = this.tag.value.shift();
    return this.tag.value;
  }
  array_push(effect) {
    const other = this.find(effect.other);
    this.tag.value.push(other.value);
    other.value = null;
    return this.tag.value;
  }
  array_transfer(effect) {
    const other = this.find(effect.other);
    other.value.forEach((e2) => {
      this.tag.value.push(e2);
    });
    other.value.length = 0;
    return this.tag.value;
  }
  erase(effect) {
    this.tag.erase();
  }
  // effects
  "+"(s, ts, e2) {
    return this.eval(s, ts, e2, "add");
  }
  "-"(s, ts, e2) {
    return this.eval(s, ts, e2, "add", false, true);
  }
  ":"(s, ts, e2) {
    return this.eval(s, ts, e2, "set");
  }
  "."(s, ts, e2) {
    return this.eval(s, ts, e2, "concat");
  }
  x(s, ts, e2) {
    return this.eval(s, ts, e2, "erase");
  }
  "<+>"(s, ts, e2) {
    return this.eval(s, ts, e2, "add", true);
  }
  "<->"(s, ts, e2) {
    return this.eval(s, ts, e2, "add", true, true);
  }
  "<:>"(s, ts, e2) {
    return this.eval(s, ts, e2, "set", true);
  }
  "<.>"(s, ts, e2) {
    return this.eval(s, ts, e2, "concat", true);
  }
  "<f>"(s, ts, e2) {
    return this.eval(s, ts, e2, "formula");
  }
  "#>"(s, ts, e2) {
    return this.eval(s, ts, e2, "array_shift");
  }
  "#<"(s, ts, e2) {
    return this.eval(s, ts, e2, "array_push");
  }
  "#:"(s, ts, e2) {
    return this.eval(s, ts, e2, "array_transfer");
  }
  get list() {
    return ["x", ":", "+", "-", ".", "<:>", "<+>", "<->", "<.>", "<f>", "#>", "#<", "#:", "<c>"];
  }
}
var effects$1 = new TagEffect();
function generateEffectsWithSubstitutions(effects2, player = null, array = null) {
  effects2.forEach((effect) => {
    if (player) {
      const replacement = "$players." + player;
      if (effect.tag) {
        effect.tag = effect.tag.replace(/\$player\b/, replacement);
      }
      if (typeof effect.value === "string") {
        effect.value = effect.value.replace(/\$player\b/, replacement);
      }
      if (typeof effect.other === "string") {
        effect.other = effect.other.replace(/\$player\b/, replacement);
      }
    }
    if (array) {
      if (effect.tag) {
        effect.tag = effect.tag.replace("$item", array);
      }
      if (typeof effect.value === "string") {
        effect.value = effect.value.replace("$item", array);
      }
      if (typeof effect.other === "string") {
        effect.other = effect.other.replace("$item", array);
      }
    }
  });
  return effects2;
}
function shuffle$1(array) {
  const list = array.map((i) => ({ item: i, sort: Math.random() }));
  list.sort(sortby("sort"));
  return list.map((l) => l.item);
}
Twig.extend(function(Twig2) {
  Twig2.exports.extendTag({
    // unique name for tag type
    type: "player",
    // regex match for tag (flag white-space anything)
    regex: /^ ?player +(.+) ?$/,
    // this is a standalone tag and doesn't require a following tag
    next: [],
    open: true,
    // runs on matched tokens when the template is loaded. (once per template)
    compile: function(token) {
      var prop = token.match[1];
      token.stack = {
        name: "prop",
        value: Twig2.expression.compile.apply(this, [
          {
            type: Twig2.expression.type.expression,
            value: prop
          }
        ]).stack
      };
      delete token.match;
      return token;
    },
    // Runs when the template is rendered
    parse: function(token, context, chain) {
      const name = token.stack.name;
      const value = Twig2.expression.parse.apply(this, [
        token.stack.value,
        context
      ]);
      context[name] = value;
      return {
        chain: false,
        output: "${player." + value + "}"
      };
    }
  });
  Twig2.exports.extendTag({
    // unique name for tag type
    type: "settag",
    // regex match for tag (flag white-space anything)
    regex: /^settag\s+"([^"]+)"\s+(.+)$/,
    // this is a standalone tag and doesn't require a following tag
    next: [],
    open: true,
    // runs on matched tokens when the template is loaded. (once per template)
    compile: function(token) {
      var name = token.match[1];
      var value = token.match[2];
      token.stack = {
        name,
        value: Twig2.expression.compile.apply(this, [
          {
            type: Twig2.expression.type.expression,
            value
          }
        ]).stack
      };
      delete token.match;
      return token;
    },
    // Runs when the template is rendered
    parse: function(token, context, chain) {
      const name = token.stack.name;
      const value = Twig2.expression.parse.apply(this, [
        token.stack.value,
        context
      ]);
      document.dispatchEvent(
        new CustomEvent("tag", { detail: { name, value } })
      );
      context[name] = value;
      return {
        chain: false,
        output: ""
      };
    }
  });
});
const fontAdjust = {
  griffinregular: 1.2,
  konstytucyjamedium: 1.7,
  architects_daughterregular: 0.9,
  calligraffitiregular: 1.2
};
function textStyle(style, extras) {
  const retval = {
    color: "black",
    background: "white",
    fontFamily: "literata_bookregular",
    fontSize: "1em",
    textShadow: "0 0 5px white",
    boxShadow: "",
    border: "",
    align: "left"
  };
  if (extras) {
    Object.keys(extras).forEach((key) => {
      if (extras[key]) {
        retval[key] = extras[key];
      }
    });
  }
  if (style) {
    if (style.foreground) {
      retval.color = style.foreground;
    }
    if (style.gradient) {
      switch (style.gradient) {
        case "left":
          retval.background = `linear-gradient(to left, ${style.background}, ${style.background2})`;
          break;
        case "right":
          retval.background = `linear-gradient(to right, ${style.background}, ${style.background2})`;
          break;
        case "top":
          retval.background = `linear-gradient(to top, ${style.background}, ${style.background2})`;
          break;
        case "bottom":
          retval.background = `linear-gradient(to bottom, ${style.background}, ${style.background2})`;
          break;
        default:
        case "bloom":
          retval.background = `radial-gradient(ellipse at 65% 65%, ${style.background}, ${style.background2})`;
          break;
      }
    } else if (style.background) {
      retval.background = style.background;
    }
    if (retval.background) {
      retval["--style-bg"] = retval.background;
      retval["background"] = "var(--style-bg)";
    }
    if (style.size) {
      const adjust = fontAdjust[style.font] || 1;
      retval.fontSize = `calc(${style.size} * ${adjust})`;
    }
    if (style.shadow) {
      retval.textShadow = `0 0 ${style.shadowLength || "5px"} ${style.shadow || "white"}`;
    }
    if (style.font) {
      retval.fontFamily = style.font;
    }
    if (style.border) {
      retval["--border-width"] = style.border;
      retval["--border-color"] = style.borderColor;
      retval.border = `var(--border-width, 0) solid var(--border-color, transparent)`;
    }
    if (style.borderShadow) {
      retval.boxShadow = `0 0 ${style.borderShadow} 1px ${style.borderShadowColor}`;
    }
    if (style.align) {
      retval["text-align"] = style.align;
    }
  }
  return retval;
}
function copy(o) {
  if (o) {
    return JSON.parse(JSON.stringify(o));
  }
  return o;
}
function insertTags(textPrimordial, story2, tags, startContext = null) {
  const context = startContext || {};
  let textModified = textPrimordial || "";
  for (const tag in tags) {
    const conf = story2.tags.find((t) => t.id === tag);
    if (/^\$/.test(tag)) {
      const safeName = tag.replace("$", "__");
      const regContent = tag.slice(1);
      textModified = textModified.replace(
        new RegExp(`\\$${regContent}\\b`),
        safeName
      );
      context[safeName] = tags[tag];
    } else if (conf) {
      let safeName = conf.name.trim().replace(/[^a-z^0-9^_]/gi, "_");
      if (/^[0-9]/.test(safeName)) {
        safeName = "_" + safeName;
      }
      try {
        textModified = textModified.replace(
          new RegExp(`\\b${conf.name}\\b`),
          safeName
        );
      } catch (ex) {
        console.warn("failed to regex this", conf.name);
      }
      try {
        const regex = new RegExp(`@${conf.name}@`, "g");
        textModified = textModified.replace(regex, `@${conf.id}@`);
      } catch (ex) {
        console.warn("failed to regex this", conf.name);
      }
      if (conf.type === "ref") {
        let result = tags[tag];
        if (typeof result === "string") {
          result = StoryTag.traverse(tags, result.split("."));
        }
        context[safeName] = result;
      } else {
        context[safeName] = tags[tag];
      }
    }
  }
  try {
    const t = Twig.twig({
      data: textModified,
      strict_variables: false,
      rethrow: true
    });
    const result = t.render(context);
    return result;
  } catch (ex) {
    let message = ex.message;
    const parts = message.split("near");
    if (parts.length > 1) {
      const near = ex.message.split("near")[1];
      message = `Failed to render text: near ${near}`;
    }
    window.app.addAlert({
      title: "Text Parse Error",
      level: "error",
      message
    });
    return `$#$${message}$#$`;
  }
}
function runSimpleFormula(formulaText, tags = {}) {
  try {
    const parser2 = new index.Parser({
      operators: {
        assignment: true
      }
    });
    parser2.functions.array = (len) => new Array(len).fill(0);
    let formula = parser2.parse(formulaText);
    const args = copy(tags);
    for (const v of formula.variables()) {
      if (/^\$RAND(\d+)/.test(v)) {
        const match = /^\$RAND(\d+)/.exec(v);
        args[v] = Math.floor(Math.random() * (parseInt(match[1]) + 1));
      }
    }
    const resultValue = formula.evaluate(args);
    return resultValue;
  } catch (ex) {
    console.error("formula error", ex);
    return null;
  }
}
function applyEffect(story2, effect, tags) {
  if (effects$1[effect.op]) {
    const tag = StoryTag.generate(story2, tags, effect.tag);
    if (!tag) {
      console.log("tag not found", effect.tag, effect);
      return;
    }
    effects$1[effect.op](story2, tags, effect);
  }
}
function shouldShowDirection(story2, direction, tags) {
  if (direction.type === "notes") {
    return false;
  }
  if (direction.type === "empty" && direction.array) {
    return true;
  }
  const effectList = (direction.effects || []).filter(
    (r) => (r.op === "<t>" || r.op && r.tag) && effects$1.list.indexOf(r.op) === -1
  );
  for (const effect of effectList) {
    const { value } = effect;
    const nvalue = parseInt(
      effect.value === null || effect.value === void 0 ? 1 : effect.value,
      10
    );
    const storytag = effect.tag ? StoryTag.generate(story2, tags, effect.tag) : null;
    const tag = storytag ? storytag.value : 1;
    const ntag = parseInt(tag, 10) || 0;
    let other = null;
    switch (effect.op) {
      case "#":
        if (!tag) {
          return false;
        }
        break;
      case "!":
        if (tag) {
          return false;
        }
        break;
      case ">":
        if (ntag < nvalue) {
          return false;
        }
        break;
      case "<":
        if (ntag > nvalue) {
          return false;
        }
        break;
      case "=":
        if (ntag != nvalue) {
          return false;
        }
        break;
      case "!=":
        if (`${tag}`.toLowerCase() === `${value}`.toLowerCase()) {
          return false;
        }
        break;
      case "==":
        if (`${tag}`.toLowerCase() != `${value}`.toLowerCase()) {
          return false;
        }
        break;
      case "[v]":
        if (safe(value) && !new RegExp(value, "gi").test(tag || "")) {
          return false;
        }
        break;
      case "[^]":
        if (safe(value) && new RegExp(value, "gi").test(tag || "")) {
          return false;
        }
        break;
      case "<=>":
        other = StoryTag.generate(story2, tags, effect.value);
        if (tag != other.value) {
          return false;
        }
        break;
      case "<!>":
        other = StoryTag.generate(story2, tags, effect.value);
        if (tag == other.value) {
          return false;
        }
        break;
      case "<>>":
        other = StoryTag.generate(story2, tags, effect.value);
        if (tag < other.value) {
          return false;
        }
        break;
      case "<<>":
        other = StoryTag.generate(story2, tags, effect.value);
        if (tag > other.value) {
          return false;
        }
        break;
      case "<t>":
        const result = runFormula(story2, value, tags);
        if (result === false || result <= 0) {
          return false;
        }
        break;
      case "[ ]":
        if (tag && tag.length > 0) {
          return false;
        }
        break;
      case "[>]":
        if (tag && tag.length <= nvalue) {
          return false;
        }
        break;
      case "[*]":
        if (tag && tag.length === 0) {
          return false;
        }
        break;
    }
  }
  return true;
}
function directionWillModify(direction) {
  const deffects = direction.effects || [];
  for (const effect of deffects.filter((r) => r.op && r.tag)) {
    if (effects$1.list.indexOf(effect.op) > -1) {
      return true;
    }
  }
  return false;
}
/*! Capacitor: https://capacitorjs.com/ - MIT License */
const createCapacitorPlatforms = (win) => {
  const defaultPlatformMap = /* @__PURE__ */ new Map();
  defaultPlatformMap.set("web", { name: "web" });
  const capPlatforms = win.CapacitorPlatforms || {
    currentPlatform: { name: "web" },
    platforms: defaultPlatformMap
  };
  const addPlatform = (name, platform) => {
    capPlatforms.platforms.set(name, platform);
  };
  const setPlatform = (name) => {
    if (capPlatforms.platforms.has(name)) {
      capPlatforms.currentPlatform = capPlatforms.platforms.get(name);
    }
  };
  capPlatforms.addPlatform = addPlatform;
  capPlatforms.setPlatform = setPlatform;
  return capPlatforms;
};
const initPlatforms = (win) => win.CapacitorPlatforms = createCapacitorPlatforms(win);
const CapacitorPlatforms = /* @__PURE__ */ initPlatforms(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
CapacitorPlatforms.addPlatform;
CapacitorPlatforms.setPlatform;
var ExceptionCode;
(function(ExceptionCode2) {
  ExceptionCode2["Unimplemented"] = "UNIMPLEMENTED";
  ExceptionCode2["Unavailable"] = "UNAVAILABLE";
})(ExceptionCode || (ExceptionCode = {}));
class CapacitorException2 extends Error {
  constructor(message, code2, data) {
    super(message);
    this.message = message;
    this.code = code2;
    this.data = data;
  }
}
const getPlatformId = (win) => {
  var _a, _b;
  if (win === null || win === void 0 ? void 0 : win.androidBridge) {
    return "android";
  } else if ((_b = (_a = win === null || win === void 0 ? void 0 : win.webkit) === null || _a === void 0 ? void 0 : _a.messageHandlers) === null || _b === void 0 ? void 0 : _b.bridge) {
    return "ios";
  } else {
    return "web";
  }
};
const createCapacitor = (win) => {
  var _a, _b, _c, _d, _e;
  const capCustomPlatform = win.CapacitorCustomPlatform || null;
  const cap = win.Capacitor || {};
  const Plugins = cap.Plugins = cap.Plugins || {};
  const capPlatforms = win.CapacitorPlatforms;
  const defaultGetPlatform = () => {
    return capCustomPlatform !== null ? capCustomPlatform.name : getPlatformId(win);
  };
  const getPlatform = ((_a = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _a === void 0 ? void 0 : _a.getPlatform) || defaultGetPlatform;
  const defaultIsNativePlatform = () => getPlatform() !== "web";
  const isNativePlatform = ((_b = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _b === void 0 ? void 0 : _b.isNativePlatform) || defaultIsNativePlatform;
  const defaultIsPluginAvailable = (pluginName) => {
    const plugin = registeredPlugins.get(pluginName);
    if (plugin === null || plugin === void 0 ? void 0 : plugin.platforms.has(getPlatform())) {
      return true;
    }
    if (getPluginHeader(pluginName)) {
      return true;
    }
    return false;
  };
  const isPluginAvailable = ((_c = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _c === void 0 ? void 0 : _c.isPluginAvailable) || defaultIsPluginAvailable;
  const defaultGetPluginHeader = (pluginName) => {
    var _a2;
    return (_a2 = cap.PluginHeaders) === null || _a2 === void 0 ? void 0 : _a2.find((h2) => h2.name === pluginName);
  };
  const getPluginHeader = ((_d = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _d === void 0 ? void 0 : _d.getPluginHeader) || defaultGetPluginHeader;
  const handleError2 = (err) => win.console.error(err);
  const pluginMethodNoop = (_target2, prop, pluginName) => {
    return Promise.reject(`${pluginName} does not have an implementation of "${prop}".`);
  };
  const registeredPlugins = /* @__PURE__ */ new Map();
  const defaultRegisterPlugin = (pluginName, jsImplementations = {}) => {
    const registeredPlugin = registeredPlugins.get(pluginName);
    if (registeredPlugin) {
      console.warn(`Capacitor plugin "${pluginName}" already registered. Cannot register plugins twice.`);
      return registeredPlugin.proxy;
    }
    const platform = getPlatform();
    const pluginHeader = getPluginHeader(pluginName);
    let jsImplementation;
    const loadPluginImplementation = async () => {
      if (!jsImplementation && platform in jsImplementations) {
        jsImplementation = typeof jsImplementations[platform] === "function" ? jsImplementation = await jsImplementations[platform]() : jsImplementation = jsImplementations[platform];
      } else if (capCustomPlatform !== null && !jsImplementation && "web" in jsImplementations) {
        jsImplementation = typeof jsImplementations["web"] === "function" ? jsImplementation = await jsImplementations["web"]() : jsImplementation = jsImplementations["web"];
      }
      return jsImplementation;
    };
    const createPluginMethod = (impl, prop) => {
      var _a2, _b2;
      if (pluginHeader) {
        const methodHeader = pluginHeader === null || pluginHeader === void 0 ? void 0 : pluginHeader.methods.find((m) => prop === m.name);
        if (methodHeader) {
          if (methodHeader.rtype === "promise") {
            return (options) => cap.nativePromise(pluginName, prop.toString(), options);
          } else {
            return (options, callback) => cap.nativeCallback(pluginName, prop.toString(), options, callback);
          }
        } else if (impl) {
          return (_a2 = impl[prop]) === null || _a2 === void 0 ? void 0 : _a2.bind(impl);
        }
      } else if (impl) {
        return (_b2 = impl[prop]) === null || _b2 === void 0 ? void 0 : _b2.bind(impl);
      } else {
        throw new CapacitorException2(`"${pluginName}" plugin is not implemented on ${platform}`, ExceptionCode.Unimplemented);
      }
    };
    const createPluginMethodWrapper = (prop) => {
      let remove2;
      const wrapper = (...args) => {
        const p2 = loadPluginImplementation().then((impl) => {
          const fn = createPluginMethod(impl, prop);
          if (fn) {
            const p3 = fn(...args);
            remove2 = p3 === null || p3 === void 0 ? void 0 : p3.remove;
            return p3;
          } else {
            throw new CapacitorException2(`"${pluginName}.${prop}()" is not implemented on ${platform}`, ExceptionCode.Unimplemented);
          }
        });
        if (prop === "addListener") {
          p2.remove = async () => remove2();
        }
        return p2;
      };
      wrapper.toString = () => `${prop.toString()}() { [capacitor code] }`;
      Object.defineProperty(wrapper, "name", {
        value: prop,
        writable: false,
        configurable: false
      });
      return wrapper;
    };
    const addListener = createPluginMethodWrapper("addListener");
    const removeListener = createPluginMethodWrapper("removeListener");
    const addListenerNative = (eventName, callback) => {
      const call = addListener({ eventName }, callback);
      const remove2 = async () => {
        const callbackId = await call;
        removeListener({
          eventName,
          callbackId
        }, callback);
      };
      const p2 = new Promise((resolve2) => call.then(() => resolve2({ remove: remove2 })));
      p2.remove = async () => {
        console.warn(`Using addListener() without 'await' is deprecated.`);
        await remove2();
      };
      return p2;
    };
    const proxy = new Proxy({}, {
      get(_, prop) {
        switch (prop) {
          case "$$typeof":
            return void 0;
          case "toJSON":
            return () => ({});
          case "addListener":
            return pluginHeader ? addListenerNative : addListener;
          case "removeListener":
            return removeListener;
          default:
            return createPluginMethodWrapper(prop);
        }
      }
    });
    Plugins[pluginName] = proxy;
    registeredPlugins.set(pluginName, {
      name: pluginName,
      proxy,
      platforms: /* @__PURE__ */ new Set([
        ...Object.keys(jsImplementations),
        ...pluginHeader ? [platform] : []
      ])
    });
    return proxy;
  };
  const registerPlugin2 = ((_e = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _e === void 0 ? void 0 : _e.registerPlugin) || defaultRegisterPlugin;
  if (!cap.convertFileSrc) {
    cap.convertFileSrc = (filePath) => filePath;
  }
  cap.getPlatform = getPlatform;
  cap.handleError = handleError2;
  cap.isNativePlatform = isNativePlatform;
  cap.isPluginAvailable = isPluginAvailable;
  cap.pluginMethodNoop = pluginMethodNoop;
  cap.registerPlugin = registerPlugin2;
  cap.Exception = CapacitorException2;
  cap.DEBUG = !!cap.DEBUG;
  cap.isLoggingEnabled = !!cap.isLoggingEnabled;
  cap.platform = cap.getPlatform();
  cap.isNative = cap.isNativePlatform();
  return cap;
};
const initCapacitorGlobal = (win) => win.Capacitor = createCapacitor(win);
const Capacitor = /* @__PURE__ */ initCapacitorGlobal(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
const registerPlugin = Capacitor.registerPlugin;
Capacitor.Plugins;
class WebPlugin2 {
  constructor(config) {
    this.listeners = {};
    this.retainedEventArguments = {};
    this.windowListeners = {};
    if (config) {
      console.warn(`Capacitor WebPlugin "${config.name}" config object was deprecated in v3 and will be removed in v4.`);
      this.config = config;
    }
  }
  addListener(eventName, listenerFunc) {
    let firstListener = false;
    const listeners = this.listeners[eventName];
    if (!listeners) {
      this.listeners[eventName] = [];
      firstListener = true;
    }
    this.listeners[eventName].push(listenerFunc);
    const windowListener = this.windowListeners[eventName];
    if (windowListener && !windowListener.registered) {
      this.addWindowListener(windowListener);
    }
    if (firstListener) {
      this.sendRetainedArgumentsForEvent(eventName);
    }
    const remove2 = async () => this.removeListener(eventName, listenerFunc);
    const p2 = Promise.resolve({ remove: remove2 });
    return p2;
  }
  async removeAllListeners() {
    this.listeners = {};
    for (const listener in this.windowListeners) {
      this.removeWindowListener(this.windowListeners[listener]);
    }
    this.windowListeners = {};
  }
  notifyListeners(eventName, data, retainUntilConsumed) {
    const listeners = this.listeners[eventName];
    if (!listeners) {
      if (retainUntilConsumed) {
        let args = this.retainedEventArguments[eventName];
        if (!args) {
          args = [];
        }
        args.push(data);
        this.retainedEventArguments[eventName] = args;
      }
      return;
    }
    listeners.forEach((listener) => listener(data));
  }
  hasListeners(eventName) {
    return !!this.listeners[eventName].length;
  }
  registerWindowListener(windowEventName, pluginEventName) {
    this.windowListeners[pluginEventName] = {
      registered: false,
      windowEventName,
      pluginEventName,
      handler: (event) => {
        this.notifyListeners(pluginEventName, event);
      }
    };
  }
  unimplemented(msg = "not implemented") {
    return new Capacitor.Exception(msg, ExceptionCode.Unimplemented);
  }
  unavailable(msg = "not available") {
    return new Capacitor.Exception(msg, ExceptionCode.Unavailable);
  }
  async removeListener(eventName, listenerFunc) {
    const listeners = this.listeners[eventName];
    if (!listeners) {
      return;
    }
    const index2 = listeners.indexOf(listenerFunc);
    this.listeners[eventName].splice(index2, 1);
    if (!this.listeners[eventName].length) {
      this.removeWindowListener(this.windowListeners[eventName]);
    }
  }
  addWindowListener(handle) {
    window.addEventListener(handle.windowEventName, handle.handler);
    handle.registered = true;
  }
  removeWindowListener(handle) {
    if (!handle) {
      return;
    }
    window.removeEventListener(handle.windowEventName, handle.handler);
    handle.registered = false;
  }
  sendRetainedArgumentsForEvent(eventName) {
    const args = this.retainedEventArguments[eventName];
    if (!args) {
      return;
    }
    delete this.retainedEventArguments[eventName];
    args.forEach((arg) => {
      this.notifyListeners(eventName, arg);
    });
  }
}
const encode = (str) => encodeURIComponent(str).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
const decode = (str) => str.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
class CapacitorCookiesPluginWeb2 extends WebPlugin2 {
  async getCookies() {
    const cookies = document.cookie;
    const cookieMap = {};
    cookies.split(";").forEach((cookie) => {
      if (cookie.length <= 0)
        return;
      let [key, value] = cookie.replace(/=/, "CAP_COOKIE").split("CAP_COOKIE");
      key = decode(key).trim();
      value = decode(value).trim();
      cookieMap[key] = value;
    });
    return cookieMap;
  }
  async setCookie(options) {
    try {
      const encodedKey = encode(options.key);
      const encodedValue = encode(options.value);
      const expires = `; expires=${(options.expires || "").replace("expires=", "")}`;
      const path = (options.path || "/").replace("path=", "");
      const domain = options.url != null && options.url.length > 0 ? `domain=${options.url}` : "";
      document.cookie = `${encodedKey}=${encodedValue || ""}${expires}; path=${path}; ${domain};`;
    } catch (error) {
      return Promise.reject(error);
    }
  }
  async deleteCookie(options) {
    try {
      document.cookie = `${options.key}=; Max-Age=0`;
    } catch (error) {
      return Promise.reject(error);
    }
  }
  async clearCookies() {
    try {
      const cookies = document.cookie.split(";") || [];
      for (const cookie of cookies) {
        document.cookie = cookie.replace(/^ +/, "").replace(/=.*/, `=;expires=${(/* @__PURE__ */ new Date()).toUTCString()};path=/`);
      }
    } catch (error) {
      return Promise.reject(error);
    }
  }
  async clearAllCookies() {
    try {
      await this.clearCookies();
    } catch (error) {
      return Promise.reject(error);
    }
  }
}
registerPlugin("CapacitorCookies", {
  web: () => new CapacitorCookiesPluginWeb2()
});
const readBlobAsBase64 = async (blob) => new Promise((resolve2, reject) => {
  const reader = new FileReader();
  reader.onload = () => {
    const base64String = reader.result;
    resolve2(base64String.indexOf(",") >= 0 ? base64String.split(",")[1] : base64String);
  };
  reader.onerror = (error) => reject(error);
  reader.readAsDataURL(blob);
});
const normalizeHttpHeaders = (headers = {}) => {
  const originalKeys = Object.keys(headers);
  const loweredKeys = Object.keys(headers).map((k) => k.toLocaleLowerCase());
  const normalized = loweredKeys.reduce((acc, key, index2) => {
    acc[key] = headers[originalKeys[index2]];
    return acc;
  }, {});
  return normalized;
};
const buildUrlParams = (params, shouldEncode = true) => {
  if (!params)
    return null;
  const output = Object.entries(params).reduce((accumulator, entry) => {
    const [key, value] = entry;
    let encodedValue;
    let item;
    if (Array.isArray(value)) {
      item = "";
      value.forEach((str) => {
        encodedValue = shouldEncode ? encodeURIComponent(str) : str;
        item += `${key}=${encodedValue}&`;
      });
      item.slice(0, -1);
    } else {
      encodedValue = shouldEncode ? encodeURIComponent(value) : value;
      item = `${key}=${encodedValue}`;
    }
    return `${accumulator}&${item}`;
  }, "");
  return output.substr(1);
};
const buildRequestInit = (options, extra = {}) => {
  const output = Object.assign({ method: options.method || "GET", headers: options.headers }, extra);
  const headers = normalizeHttpHeaders(options.headers);
  const type2 = headers["content-type"] || "";
  if (typeof options.data === "string") {
    output.body = options.data;
  } else if (type2.includes("application/x-www-form-urlencoded")) {
    const params = new URLSearchParams();
    for (const [key, value] of Object.entries(options.data || {})) {
      params.set(key, value);
    }
    output.body = params.toString();
  } else if (type2.includes("multipart/form-data") || options.data instanceof FormData) {
    const form = new FormData();
    if (options.data instanceof FormData) {
      options.data.forEach((value, key) => {
        form.append(key, value);
      });
    } else {
      for (const key of Object.keys(options.data)) {
        form.append(key, options.data[key]);
      }
    }
    output.body = form;
    const headers2 = new Headers(output.headers);
    headers2.delete("content-type");
    output.headers = headers2;
  } else if (type2.includes("application/json") || typeof options.data === "object") {
    output.body = JSON.stringify(options.data);
  }
  return output;
};
class CapacitorHttpPluginWeb2 extends WebPlugin2 {
  /**
   * Perform an Http request given a set of options
   * @param options Options to build the HTTP request
   */
  async request(options) {
    const requestInit = buildRequestInit(options, options.webFetchExtra);
    const urlParams = buildUrlParams(options.params, options.shouldEncodeUrlParams);
    const url = urlParams ? `${options.url}?${urlParams}` : options.url;
    const response = await fetch(url, requestInit);
    const contentType = response.headers.get("content-type") || "";
    let { responseType = "text" } = response.ok ? options : {};
    if (contentType.includes("application/json")) {
      responseType = "json";
    }
    let data;
    let blob;
    switch (responseType) {
      case "arraybuffer":
      case "blob":
        blob = await response.blob();
        data = await readBlobAsBase64(blob);
        break;
      case "json":
        data = await response.json();
        break;
      case "document":
      case "text":
      default:
        data = await response.text();
    }
    const headers = {};
    response.headers.forEach((value, key) => {
      headers[key] = value;
    });
    return {
      data,
      headers,
      status: response.status,
      url: response.url
    };
  }
  /**
   * Perform an Http GET request given a set of options
   * @param options Options to build the HTTP request
   */
  async get(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "GET" }));
  }
  /**
   * Perform an Http POST request given a set of options
   * @param options Options to build the HTTP request
   */
  async post(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "POST" }));
  }
  /**
   * Perform an Http PUT request given a set of options
   * @param options Options to build the HTTP request
   */
  async put(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "PUT" }));
  }
  /**
   * Perform an Http PATCH request given a set of options
   * @param options Options to build the HTTP request
   */
  async patch(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "PATCH" }));
  }
  /**
   * Perform an Http DELETE request given a set of options
   * @param options Options to build the HTTP request
   */
  async delete(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "DELETE" }));
  }
}
registerPlugin("CapacitorHttp", {
  web: () => new CapacitorHttpPluginWeb2()
});
const App$1 = registerPlugin("App", {
  web: () => __vitePreload(() => import("./web-WPQPppko.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url).then((m) => new m.AppWeb())
});
var browser = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h2 = m * 60;
  var d = h2 * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse4(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse4(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h2) {
      return plural(ms2, msAbs, h2, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms;
}
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = requireMs();
  createDebug.destroy = destroy;
  Object.keys(env).forEach((key) => {
    createDebug[key] = env[key];
  });
  createDebug.names = [];
  createDebug.skips = [];
  createDebug.formatters = {};
  function selectColor(namespace) {
    let hash = 0;
    for (let i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0;
    }
    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;
  function createDebug(namespace) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug2(...args) {
      if (!debug2.enabled) {
        return;
      }
      const self2 = debug2;
      const curr = Number(/* @__PURE__ */ new Date());
      const ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      let index2 = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
        if (match === "%%") {
          return "%";
        }
        index2++;
        const formatter = createDebug.formatters[format2];
        if (typeof formatter === "function") {
          const val = args[index2];
          match = formatter.call(self2, val);
          args.splice(index2, 1);
          index2--;
        }
        return match;
      });
      createDebug.formatArgs.call(self2, args);
      const logFn = self2.log || createDebug.log;
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace;
    debug2.useColors = createDebug.useColors();
    debug2.color = createDebug.selectColor(namespace);
    debug2.extend = extend2;
    debug2.destroy = createDebug.destroy;
    Object.defineProperty(debug2, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: (v) => {
        enableOverride = v;
      }
    });
    if (typeof createDebug.init === "function") {
      createDebug.init(debug2);
    }
    return debug2;
  }
  function extend2(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    let i;
    const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    const len = split.length;
    for (i = 0; i < len; i++) {
      if (!split[i]) {
        continue;
      }
      namespaces = split[i].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
      } else {
        createDebug.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    const namespaces = [
      ...createDebug.names.map(toNamespace),
      ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
    ].join(",");
    createDebug.enable("");
    return namespaces;
  }
  function enabled(name) {
    if (name[name.length - 1] === "*") {
      return true;
    }
    let i;
    let len;
    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }
  function destroy() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  createDebug.enable(createDebug.load());
  return createDebug;
}
var common$m = setup;
(function(module, exports) {
  var define_process_env_default = { PRODUCTION: "production", cyoa: true };
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = /* @__PURE__ */ (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index2 = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index2++;
      if (match === "%c") {
        lastC = index2;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = define_process_env_default.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module.exports = common$m(exports);
  const { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
})(browser, browser.exports);
var browserExports = browser.exports;
const debug = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
const log$4 = debug("animation");
var framePromise = null;
function nextFrame$1(inside) {
  if (!framePromise) {
    framePromise = new Deferred();
    requestAnimationFrame(() => {
      log$4("frame");
      if (inside) {
        inside();
      }
      const promise = framePromise;
      framePromise = null;
      promise.resolve(true);
    });
  }
  return framePromise.promise;
}
class Effect {
  constructor(config, prev) {
    this.config = config;
    this.prev = prev;
  }
  get props() {
    return [];
  }
  async apply(el, display) {
    try {
      if (el) {
        if (this.prev && this.prev.duration < 30) {
          await nextFrame$1();
          await nextFrame$1();
        }
        if (this.prev) {
          this.prev.finish(el);
        }
        this.applyTransition(el);
        this.start(el);
        if (display) {
          await nextFrame$1();
          el.display = null;
        }
      } else {
        log$4("missing", el);
      }
    } catch (ex) {
      console.error(ex);
    }
  }
  applyTransition(el) {
    if (this.prev) {
      for (const prop of this.prev.props) {
        const easing = this.config.easing || "ease-in-out";
        const transition = `${prop} ${this.duration}ms ${easing} ${el.dataset.delay || 0}ms`;
        if (!el.style.transition) {
          el.style.transition = transition;
        } else {
          el.style.transition += `,${transition}`;
        }
      }
    }
    for (const prop of this.props) {
      const transition = `${prop} ${this.duration}ms`;
      if (!el.style.transition) {
        el.style.transition = transition;
      } else {
        el.style.transition += `,${transition}`;
      }
    }
  }
  start(el) {
    for (const prop of this.props) {
      el.style[prop] = this.config[prop];
      log$4(this.config.track, `applied ${prop}`, this.config[prop]);
    }
  }
  finish(el) {
    for (const prop of this.props) {
      el.style[prop] = null;
      log$4(this.config.track, `removed ${prop}`);
    }
  }
}
class Empty extends Effect {
}
class Blur extends Effect {
  get props() {
    return ["filter"];
  }
  start(el) {
    el.style.filter = `blur(${this.config.blur * 5}px)`;
    log$4(this.config.track, `applied filter blur`, this.config.blur);
  }
}
class Color2 extends Effect {
  get props() {
    return ["color"];
  }
}
class Opacity extends Effect {
  get props() {
    return ["opacity"];
  }
  start(el) {
    el.style.opacity = this.config.opacity;
    log$4(this.config.track, `applied opacity`, el.className, this.config.opacity);
  }
}
class Background extends Effect {
  get props() {
    return ["background"];
  }
}
function nrand$2(v) {
  return Math.random() * (v * 2) - v;
}
class Transform extends Effect {
  get props() {
    return ["transform"];
  }
  start(el) {
    let x = 0;
    let y = 0;
    if (this.config.direction) {
      x = this.config.direction.x;
      y = this.config.direction.y;
    }
    if (this.config.randomize) {
      x += nrand$2(this.config.randomize);
      y += nrand$2(this.config.randomize);
    }
    const a = this.config.rotation || 0 + nrand$2(this.config.rotationRandomize);
    const s = this.config.scale || this.config.scale === 0 ? this.config.scale : 1;
    el.style.transform = `translate(${x * 100}px, ${y * 50}px) scale(${s}) rotate(${a}rad) `;
  }
}
class Shadow extends Effect {
  get props() {
    return ["text-shadow"];
  }
  start(el) {
    let x = 0;
    let y = 0;
    if (this.config.direction) {
      x = this.config.direction.x;
      y = this.config.direction.y;
    }
    const len = (this.config.length || 0) * 5;
    const shadow = `${x * 3}px ${y * 3}px ${len * 2}px ${this.config.color}`;
    el.style["text-shadow"] = shadow;
    log$4(this.config.track, `applied shadow`, shadow);
  }
}
const effects = {
  background: Background,
  blur: Blur,
  color: Color2,
  empty: Empty,
  opacity: Opacity,
  shadow: Shadow,
  transform: Transform
};
class AnimationHandler {
  constructor(pipeline, duration = 1e3, reverse = false) {
    let mypipeline = pipeline.slice();
    this.pipeline = [];
    this.deferred = [];
    this.duration = parseFloat(duration);
    this.reverse = reverse;
    const times = {};
    const totals = {};
    const prev = {};
    const durations = {};
    if (reverse) {
      mypipeline = mypipeline.reverse();
    }
    for (const pipe of mypipeline) {
      totals[pipe.track] = (totals[pipe.track] || 0) + parseFloat(pipe.duration);
    }
    for (const track2 in totals) {
      times[track2] = 0;
      totals[track2] = Math.max(1, totals[track2]);
    }
    for (const pipe of mypipeline) {
      const effect = new effects[pipe.type || "empty"](pipe, prev[pipe.track]);
      const time = times[pipe.track];
      effect.starts = Math.floor(time);
      if (this.reverse) {
        effect.duration = durations[pipe.track] || 0;
        durations[pipe.track] = parseFloat(pipe.duration) / totals[pipe.track] * duration;
      } else {
        effect.duration = parseFloat(pipe.duration) / totals[pipe.track] * duration;
      }
      times[pipe.track] = time + effect.duration;
      this.pipeline.push(effect);
      prev[pipe.track] = effect;
    }
  }
  async start(el, loop = false) {
    if (this.duration < 16) {
      this.finished();
      return;
    }
    const def2 = new Deferred();
    this.deferred.push(def2);
    const prevStyle = el.style.cssText;
    const times = /* @__PURE__ */ new Set();
    for (const pipe of this.pipeline) {
      times.add(pipe.starts);
    }
    const st = Date.now();
    for (const start of times) {
      const timeout = start - (Date.now() - st);
      if (timeout > 0) {
        await Promise.race([def2.promise, new Promise((r) => setTimeout(r, timeout))]);
      }
      if (def2.resolved) {
        break;
      }
      let display = false;
      if (!this.reverse) {
        display = true;
      }
      for (const pipe of this.pipeline.filter((p2) => p2.starts === start)) {
        pipe.apply(el, display);
        display = false;
      }
    }
    if (!def2.resolved) {
      const d = this.duration - (Date.now() - st);
      await Promise.race([def2.promise, new Promise((r) => setTimeout(r, d))]);
    }
    if (el) {
      await nextFrame$1();
      el.style = prevStyle;
      if (this.reverse) {
        el.style.opacity = 0;
      }
      if (loop && !def2.resolved) {
        log$4("looping");
        await this.start(el, loop);
      }
    } else {
      console.error("missing el", el);
    }
    def2.resolve(!def2.resolved);
    return def2.promise;
  }
  async stop() {
    for (const def2 of this.deferred) {
      def2.resolve(false);
    }
    await this.finished();
    this.deferred = [];
  }
  isFinished() {
    return this.deferred.every((d) => d.resolved);
  }
  async finished() {
    await Promise.all(this.deferred.map((d) => d.promise));
  }
}
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$l = {
  name: "animation",
  props: {
    id: String,
    playReverse: { type: Boolean, default: true },
    animations: Array
  },
  data() {
    let resolve2 = null;
    const promise = new Promise((r) => resolve2 = r);
    return {
      promise,
      resolve: resolve2
    };
  },
  watch: {
    id() {
      this.setup();
    },
    animations() {
      this.setup();
    }
  },
  mounted() {
    this.setup();
    this.resolve();
  },
  methods: {
    in() {
      if (this.forward) {
        return !this.forward.isFinished();
      }
      return false;
    },
    stop() {
      if (this.forward) {
        this.forward.stop();
      }
      if (this.reverse) {
        this.reverse.stop();
      }
    },
    setup() {
      if (this.animations) {
        this.config = this.animations.find((a) => a.id === this.id);
        if (this.config) {
          this.forward = new AnimationHandler(this.config.pipeline, this.config.duration);
          if (this.playReverse) {
            this.reverse = new AnimationHandler(this.config.pipeline, this.config.duration, true);
          }
        }
      }
    },
    // ENTERING
    beforeEnter(el) {
      el.style.display = null;
    },
    // the done callback is optional when
    // used in combination with CSS
    async enter(el, done) {
      await this.promise;
      if (this.forward) {
        await this.forward.stop();
        this.promise = this.forward.start(el);
      }
      await this.promise;
      done();
    },
    afterEnter(el) {
      this.$emit("after-enter", el);
    },
    // LEAVING
    beforeLeave(el) {
    },
    // the done callback is optional when
    // used in combination with CSS
    async leave(el, done) {
      if (this.reverse) {
        await this.reverse.stop();
        this.promise = this.reverse.start(el);
        await this.promise;
      }
      done();
    },
    afterLeave(el) {
      el.style.transition = null;
      el.style.opacity = 0;
      this.$emit("after-leave", el);
    }
  }
};
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, {
    appear: "",
    mode: "out-in",
    css: false,
    onBeforeEnter: $options.beforeEnter,
    onEnter: $options.enter,
    onAfterEnter: $options.afterEnter,
    onBeforeLeave: $options.beforeLeave,
    onLeave: $options.leave,
    onAfterLeave: $options.afterLeave,
    onClickCapture: $options.stop
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["onBeforeEnter", "onEnter", "onAfterEnter", "onBeforeLeave", "onLeave", "onAfterLeave", "onClickCapture"]);
}
const Animation = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$h]]);
const _sfc_main$k = {
  name: "VectorImage",
  props: {
    name: { type: String, required: true }
  },
  computed: {
    path() {
      return {
        "credit-card": "M20,8H4V6H20M20,18H4V12H20M20,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6C22,4.89 21.1,4 20,4Z",
        admin: "M20,6A2,2 0 0,1 22,8V18A2,2 0 0,1 20,20H4C2.89,20 2,19.1 2,18V6C2,4.89 2.89,4 4,4H10L12,6H20M19,17V13H18V12A3,3 0 0,0 15,9A3,3 0 0,0 12,12V13H11V17H19M15,11A1,1 0 0,1 16,12V13H14V12A1,1 0 0,1 15,11Z",
        alignleft: "M4 22H2V2H4V22M22 7H6V10H22V7M16 14H6V17H16V14Z",
        array: "M3,5A2,2 0 0,1 5,3H19A2,2 0 0,1 21,5V19A2,2 0 0,1 19,21H5C3.89,21 3,20.1 3,19V5M6,6V18H10V16H8V8H10V6H6M16,16H14V18H18V6H14V8H16V16Z",
        arrowleft: "M20,10V14H11L14.5,17.5L12.08,19.92L4.16,12L12.08,4.08L14.5,6.5L11,10H20Z",
        background: "M8.5,13.5L11,16.5L14.5,12L19,18H5M21,19V5C21,3.89 20.1,3 19,3H5A2,2 0 0,0 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19Z",
        battle: "M6.2,2.44L18.1,14.34L20.22,12.22L21.63,13.63L19.16,16.1L22.34,19.28C22.73,19.67 22.73,20.3 22.34,20.69L21.63,21.4C21.24,21.79 20.61,21.79 20.22,21.4L17,18.23L14.56,20.7L13.15,19.29L15.27,17.17L3.37,5.27V2.44H6.2M15.89,10L20.63,5.26V2.44H17.8L13.06,7.18L15.89,10M10.94,15L8.11,12.13L5.9,14.34L3.78,12.22L2.37,13.63L4.84,16.1L1.66,19.29C1.27,19.68 1.27,20.31 1.66,20.7L2.37,21.41C2.76,21.8 3.39,21.8 3.78,21.41L7,18.23L9.44,20.7L10.85,19.29L8.73,17.17L10.94,15Z",
        blur: "M14,8.5A1.5,1.5 0 0,0 12.5,10A1.5,1.5 0 0,0 14,11.5A1.5,1.5 0 0,0 15.5,10A1.5,1.5 0 0,0 14,8.5M14,12.5A1.5,1.5 0 0,0 12.5,14A1.5,1.5 0 0,0 14,15.5A1.5,1.5 0 0,0 15.5,14A1.5,1.5 0 0,0 14,12.5M10,17A1,1 0 0,0 9,18A1,1 0 0,0 10,19A1,1 0 0,0 11,18A1,1 0 0,0 10,17M10,8.5A1.5,1.5 0 0,0 8.5,10A1.5,1.5 0 0,0 10,11.5A1.5,1.5 0 0,0 11.5,10A1.5,1.5 0 0,0 10,8.5M14,20.5A0.5,0.5 0 0,0 13.5,21A0.5,0.5 0 0,0 14,21.5A0.5,0.5 0 0,0 14.5,21A0.5,0.5 0 0,0 14,20.5M14,17A1,1 0 0,0 13,18A1,1 0 0,0 14,19A1,1 0 0,0 15,18A1,1 0 0,0 14,17M21,13.5A0.5,0.5 0 0,0 20.5,14A0.5,0.5 0 0,0 21,14.5A0.5,0.5 0 0,0 21.5,14A0.5,0.5 0 0,0 21,13.5M18,5A1,1 0 0,0 17,6A1,1 0 0,0 18,7A1,1 0 0,0 19,6A1,1 0 0,0 18,5M18,9A1,1 0 0,0 17,10A1,1 0 0,0 18,11A1,1 0 0,0 19,10A1,1 0 0,0 18,9M18,17A1,1 0 0,0 17,18A1,1 0 0,0 18,19A1,1 0 0,0 19,18A1,1 0 0,0 18,17M18,13A1,1 0 0,0 17,14A1,1 0 0,0 18,15A1,1 0 0,0 19,14A1,1 0 0,0 18,13M10,12.5A1.5,1.5 0 0,0 8.5,14A1.5,1.5 0 0,0 10,15.5A1.5,1.5 0 0,0 11.5,14A1.5,1.5 0 0,0 10,12.5M10,7A1,1 0 0,0 11,6A1,1 0 0,0 10,5A1,1 0 0,0 9,6A1,1 0 0,0 10,7M10,3.5A0.5,0.5 0 0,0 10.5,3A0.5,0.5 0 0,0 10,2.5A0.5,0.5 0 0,0 9.5,3A0.5,0.5 0 0,0 10,3.5M10,20.5A0.5,0.5 0 0,0 9.5,21A0.5,0.5 0 0,0 10,21.5A0.5,0.5 0 0,0 10.5,21A0.5,0.5 0 0,0 10,20.5M3,13.5A0.5,0.5 0 0,0 2.5,14A0.5,0.5 0 0,0 3,14.5A0.5,0.5 0 0,0 3.5,14A0.5,0.5 0 0,0 3,13.5M14,3.5A0.5,0.5 0 0,0 14.5,3A0.5,0.5 0 0,0 14,2.5A0.5,0.5 0 0,0 13.5,3A0.5,0.5 0 0,0 14,3.5M14,7A1,1 0 0,0 15,6A1,1 0 0,0 14,5A1,1 0 0,0 13,6A1,1 0 0,0 14,7M21,10.5A0.5,0.5 0 0,0 21.5,10A0.5,0.5 0 0,0 21,9.5A0.5,0.5 0 0,0 20.5,10A0.5,0.5 0 0,0 21,10.5M6,5A1,1 0 0,0 5,6A1,1 0 0,0 6,7A1,1 0 0,0 7,6A1,1 0 0,0 6,5M3,9.5A0.5,0.5 0 0,0 2.5,10A0.5,0.5 0 0,0 3,10.5A0.5,0.5 0 0,0 3.5,10A0.5,0.5 0 0,0 3,9.5M6,9A1,1 0 0,0 5,10A1,1 0 0,0 6,11A1,1 0 0,0 7,10A1,1 0 0,0 6,9M6,17A1,1 0 0,0 5,18A1,1 0 0,0 6,19A1,1 0 0,0 7,18A1,1 0 0,0 6,17M6,13A1,1 0 0,0 5,14A1,1 0 0,0 6,15A1,1 0 0,0 7,14A1,1 0 0,0 6,13Z",
        bottom: "M16,13H13V3H11V13H8L12,17L16,13M4,19V21H20V19H4Z",
        box: "M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3M19,5V19H5V5H19Z",
        boxshadow: "M3,3H18V18H3V3M19,19H21V21H19V19M19,16H21V18H19V16M19,13H21V15H19V13M19,10H21V12H19V10M19,7H21V9H19V7M16,19H18V21H16V19M13,19H15V21H13V19M10,19H12V21H10V19M7,19H9V21H7V19Z",
        brain: "M21.33,12.91C21.42,14.46 20.71,15.95 19.44,16.86L20.21,18.35C20.44,18.8 20.47,19.33 20.27,19.8C20.08,20.27 19.69,20.64 19.21,20.8L18.42,21.05C18.25,21.11 18.06,21.14 17.88,21.14C17.37,21.14 16.89,20.91 16.56,20.5L14.44,18C13.55,17.85 12.71,17.47 12,16.9C11.5,17.05 11,17.13 10.5,17.13C9.62,17.13 8.74,16.86 8,16.34C7.47,16.5 6.93,16.57 6.38,16.56C5.59,16.57 4.81,16.41 4.08,16.11C2.65,15.47 1.7,14.07 1.65,12.5C1.57,11.78 1.69,11.05 2,10.39C1.71,9.64 1.68,8.82 1.93,8.06C2.3,7.11 3,6.32 3.87,5.82C4.45,4.13 6.08,3 7.87,3.12C9.47,1.62 11.92,1.46 13.7,2.75C14.12,2.64 14.56,2.58 15,2.58C16.36,2.55 17.65,3.15 18.5,4.22C20.54,4.75 22,6.57 22.08,8.69C22.13,9.8 21.83,10.89 21.22,11.82C21.29,12.18 21.33,12.54 21.33,12.91M16.33,11.5C16.9,11.57 17.35,12 17.35,12.57A1,1 0 0,1 16.35,13.57H15.72C15.4,14.47 14.84,15.26 14.1,15.86C14.35,15.95 14.61,16 14.87,16.07C20,16 19.4,12.87 19.4,12.82C19.34,11.39 18.14,10.27 16.71,10.33A1,1 0 0,1 15.71,9.33A1,1 0 0,1 16.71,8.33C17.94,8.36 19.12,8.82 20.04,9.63C20.09,9.34 20.12,9.04 20.12,8.74C20.06,7.5 19.5,6.42 17.25,6.21C16,3.25 12.85,4.89 12.85,5.81V5.81C12.82,6.04 13.06,6.53 13.1,6.56A1,1 0 0,1 14.1,7.56C14.1,8.11 13.65,8.56 13.1,8.56V8.56C12.57,8.54 12.07,8.34 11.67,8C11.19,8.31 10.64,8.5 10.07,8.56V8.56C9.5,8.61 9.03,8.21 9,7.66C8.92,7.1 9.33,6.61 9.88,6.56C10.04,6.54 10.82,6.42 10.82,5.79V5.79C10.82,5.13 11.07,4.5 11.5,4C10.58,3.75 9.59,4.08 8.59,5.29C6.75,5 6,5.25 5.45,7.2C4.5,7.67 4,8 3.78,9C4.86,8.78 5.97,8.87 7,9.25C7.5,9.44 7.78,10 7.59,10.54C7.4,11.06 6.82,11.32 6.3,11.13C5.57,10.81 4.75,10.79 4,11.07C3.68,11.34 3.68,11.9 3.68,12.34C3.68,13.08 4.05,13.77 4.68,14.17C5.21,14.44 5.8,14.58 6.39,14.57C6.24,14.31 6.11,14.04 6,13.76C5.81,13.22 6.1,12.63 6.64,12.44C7.18,12.25 7.77,12.54 7.96,13.08C8.36,14.22 9.38,15 10.58,15.13C11.95,15.06 13.17,14.25 13.77,13C14,11.62 15.11,11.5 16.33,11.5M18.33,18.97L17.71,17.67L17,17.83L18,19.08L18.33,18.97M13.68,10.36C13.7,9.83 13.3,9.38 12.77,9.33C12.06,9.29 11.37,9.53 10.84,10C10.27,10.58 9.97,11.38 10,12.19A1,1 0 0,0 11,13.19C11.57,13.19 12,12.74 12,12.19C12,11.92 12.07,11.65 12.23,11.43C12.35,11.33 12.5,11.28 12.66,11.28C13.21,11.31 13.68,10.9 13.68,10.36Z",
        brush: "M20.71,4.63L19.37,3.29C19,2.9 18.35,2.9 17.96,3.29L9,12.25L11.75,15L20.71,6.04C21.1,5.65 21.1,5 20.71,4.63M7,14A3,3 0 0,0 4,17C4,18.31 2.84,19 2,19C2.92,20.22 4.5,21 6,21A4,4 0 0,0 10,17A3,3 0 0,0 7,14Z",
        center: "M19,16V13H23V11H19V8L15,12L19,16M5,8V11H1V13H5V16L9,12L5,8M11,20H13V4H11V20Z",
        centerfocus: "M12,9A3,3 0 0,0 9,12A3,3 0 0,0 12,15A3,3 0 0,0 15,12A3,3 0 0,0 12,9M19,19H15V21H19A2,2 0 0,0 21,19V15H19M19,3H15V5H19V9H21V5A2,2 0 0,0 19,3M5,5H9V3H5A2,2 0 0,0 3,5V9H5M5,15H3V19A2,2 0 0,0 5,21H9V19H5V15Z",
        checkbox: "M10,17L5,12L6.41,10.58L10,14.17L17.59,6.58L19,8M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3Z",
        chevrondown: "M7.41,8.58L12,13.17L16.59,8.58L18,10L12,16L6,10L7.41,8.58Z",
        chevronleft: "M22,12A10,10 0 0,1 12,22A10,10 0 0,1 2,12A10,10 0 0,1 12,2A10,10 0 0,1 22,12M15.4,16.6L10.8,12L15.4,7.4L14,6L8,12L14,18L15.4,16.6Z",
        chevronright: "M22,12A10,10 0 0,1 12,22A10,10 0 0,1 2,12A10,10 0 0,1 12,2A10,10 0 0,1 22,12M10,18L16,12L10,6L8.6,7.4L13.2,12L8.6,16.6L10,18Z",
        chip: "M6,4H18V5H21V7H18V9H21V11H18V13H21V15H18V17H21V19H18V20H6V19H3V17H6V15H3V13H6V11H3V9H6V7H3V5H6V4M11,15V18H12V15H11M13,15V18H14V15H13M15,15V18H16V15H15Z",
        circle: "M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z",
        close: "M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z",
        diamond: "M6,2L2,8L12,22L22,8L18,2H6Z",
        discord: "M22,24L16.75,19L17.38,21H4.5A2.5,2.5 0 0,1 2,18.5V3.5A2.5,2.5 0 0,1 4.5,1H19.5A2.5,2.5 0 0,1 22,3.5V24M12,6.8C9.32,6.8 7.44,7.95 7.44,7.95C8.47,7.03 10.27,6.5 10.27,6.5L10.1,6.33C8.41,6.36 6.88,7.53 6.88,7.53C5.16,11.12 5.27,14.22 5.27,14.22C6.67,16.03 8.75,15.9 8.75,15.9L9.46,15C8.21,14.73 7.42,13.62 7.42,13.62C7.42,13.62 9.3,14.9 12,14.9C14.7,14.9 16.58,13.62 16.58,13.62C16.58,13.62 15.79,14.73 14.54,15L15.25,15.9C15.25,15.9 17.33,16.03 18.73,14.22C18.73,14.22 18.84,11.12 17.12,7.53C17.12,7.53 15.59,6.36 13.9,6.33L13.73,6.5C13.73,6.5 15.53,7.03 16.56,7.95C16.56,7.95 14.68,6.8 12,6.8M9.93,10.59C10.58,10.59 11.11,11.16 11.1,11.86C11.1,12.55 10.58,13.13 9.93,13.13C9.29,13.13 8.77,12.55 8.77,11.86C8.77,11.16 9.28,10.59 9.93,10.59M14.1,10.59C14.75,10.59 15.27,11.16 15.27,11.86C15.27,12.55 14.75,13.13 14.1,13.13C13.46,13.13 12.94,12.55 12.94,11.86C12.94,11.16 13.45,10.59 14.1,10.59Z",
        download: "M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z",
        dropper: "M19.35,11.72L17.22,13.85L15.81,12.43L8.1,20.14L3.5,22L2,20.5L3.86,15.9L11.57,8.19L10.15,6.78L12.28,4.65L19.35,11.72M16.76,3C17.93,1.83 19.83,1.83 21,3C22.17,4.17 22.17,6.07 21,7.24L19.08,9.16L14.84,4.92L16.76,3M5.56,17.03L4.5,19.5L6.97,18.44L14.4,11L13,9.6L5.56,17.03Z",
        flag: "M6,3A1,1 0 0,1 7,4V4.88C8.06,4.44 9.5,4 11,4C14,4 14,6 16,6C19,6 20,4 20,4V12C20,12 19,14 16,14C13,14 13,12 11,12C8,12 7,14 7,14V21H5V4A1,1 0 0,1 6,3Z",
        formula: "M11.76,16.83L14.59,14L11.76,11.17L13.17,9.76L16,12.59L18.83,9.76L20.24,11.17L17.41,14L20.24,16.83L18.83,18.24L16,15.41L13.17,18.24L11.76,16.83M2,11H5V11H5L7.29,16.4L10,6H22V8H11.55L8.68,19H6.22L3.68,13H2V11Z",
        gameall: "M5,8A4,4 0 0,1 9,12A4,4 0 0,1 5,16A4,4 0 0,1 1,12A4,4 0 0,1 5,8M12,1A4,4 0 0,1 16,5A4,4 0 0,1 12,9A4,4 0 0,1 8,5A4,4 0 0,1 12,1M12,15A4,4 0 0,1 16,19A4,4 0 0,1 12,23A4,4 0 0,1 8,19A4,4 0 0,1 12,15M19,8A4,4 0 0,1 23,12A4,4 0 0,1 19,16A4,4 0 0,1 15,12A4,4 0 0,1 19,8Z",
        gamedown: "M5,8A4,4 0 0,1 9,12A4,4 0 0,1 5,16A4,4 0 0,1 1,12A4,4 0 0,1 5,8M12,1A4,4 0 0,1 16,5A4,4 0 0,1 12,9A4,4 0 0,1 8,5A4,4 0 0,1 12,1M12,15A4,4 0 0,1 16,19A4,4 0 0,1 12,23A4,4 0 0,1 8,19A4,4 0 0,1 12,15M19,8A4,4 0 0,1 23,12A4,4 0 0,1 19,16A4,4 0 0,1 15,12A4,4 0 0,1 19,8M12,3A2,2 0 0,0 10,5A2,2 0 0,0 12,7A2,2 0 0,0 14,5A2,2 0 0,0 12,3M5,10A2,2 0 0,0 3,12A2,2 0 0,0 5,14A2,2 0 0,0 7,12A2,2 0 0,0 5,10M19,10A2,2 0 0,0 17,12A2,2 0 0,0 19,14A2,2 0 0,0 21,12A2,2 0 0,0 19,10Z",
        gameleft: "M5,8A4,4 0 0,1 9,12A4,4 0 0,1 5,16A4,4 0 0,1 1,12A4,4 0 0,1 5,8M12,1A4,4 0 0,1 16,5A4,4 0 0,1 12,9A4,4 0 0,1 8,5A4,4 0 0,1 12,1M12,15A4,4 0 0,1 16,19A4,4 0 0,1 12,23A4,4 0 0,1 8,19A4,4 0 0,1 12,15M19,8A4,4 0 0,1 23,12A4,4 0 0,1 19,16A4,4 0 0,1 15,12A4,4 0 0,1 19,8M19,10A2,2 0 0,0 17,12A2,2 0 0,0 19,14A2,2 0 0,0 21,12A2,2 0 0,0 19,10M12,17A2,2 0 0,0 10,19A2,2 0 0,0 12,21A2,2 0 0,0 14,19A2,2 0 0,0 12,17M12,3A2,2 0 0,0 10,5A2,2 0 0,0 12,7A2,2 0 0,0 14,5A2,2 0 0,0 12,3Z",
        gamenone: "M5,8A4,4 0 0,1 9,12A4,4 0 0,1 5,16A4,4 0 0,1 1,12A4,4 0 0,1 5,8M5,10A2,2 0 0,0 3,12A2,2 0 0,0 5,14A2,2 0 0,0 7,12A2,2 0 0,0 5,10M12,1A4,4 0 0,1 16,5A4,4 0 0,1 12,9A4,4 0 0,1 8,5A4,4 0 0,1 12,1M12,3A2,2 0 0,0 10,5A2,2 0 0,0 12,7A2,2 0 0,0 14,5A2,2 0 0,0 12,3M12,15A4,4 0 0,1 16,19A4,4 0 0,1 12,23A4,4 0 0,1 8,19A4,4 0 0,1 12,15M12,17A2,2 0 0,0 10,19A2,2 0 0,0 12,21A2,2 0 0,0 14,19A2,2 0 0,0 12,17M19,8A4,4 0 0,1 23,12A4,4 0 0,1 19,16A4,4 0 0,1 15,12A4,4 0 0,1 19,8M19,10A2,2 0 0,0 17,12A2,2 0 0,0 19,14A2,2 0 0,0 21,12A2,2 0 0,0 19,10Z",
        gameright: "M5,8A4,4 0 0,1 9,12A4,4 0 0,1 5,16A4,4 0 0,1 1,12A4,4 0 0,1 5,8M12,1A4,4 0 0,1 16,5A4,4 0 0,1 12,9A4,4 0 0,1 8,5A4,4 0 0,1 12,1M12,15A4,4 0 0,1 16,19A4,4 0 0,1 12,23A4,4 0 0,1 8,19A4,4 0 0,1 12,15M19,8A4,4 0 0,1 23,12A4,4 0 0,1 19,16A4,4 0 0,1 15,12A4,4 0 0,1 19,8M12,3A2,2 0 0,0 10,5A2,2 0 0,0 12,7A2,2 0 0,0 14,5A2,2 0 0,0 12,3M5,10A2,2 0 0,0 3,12A2,2 0 0,0 5,14A2,2 0 0,0 7,12A2,2 0 0,0 5,10M12,17A2,2 0 0,0 10,19A2,2 0 0,0 12,21A2,2 0 0,0 14,19A2,2 0 0,0 12,17Z",
        gameup: "M5,8A4,4 0 0,1 9,12A4,4 0 0,1 5,16A4,4 0 0,1 1,12A4,4 0 0,1 5,8M12,1A4,4 0 0,1 16,5A4,4 0 0,1 12,9A4,4 0 0,1 8,5A4,4 0 0,1 12,1M12,15A4,4 0 0,1 16,19A4,4 0 0,1 12,23A4,4 0 0,1 8,19A4,4 0 0,1 12,15M19,8A4,4 0 0,1 23,12A4,4 0 0,1 19,16A4,4 0 0,1 15,12A4,4 0 0,1 19,8M5,10A2,2 0 0,0 3,12A2,2 0 0,0 5,14A2,2 0 0,0 7,12A2,2 0 0,0 5,10M19,10A2,2 0 0,0 17,12A2,2 0 0,0 19,14A2,2 0 0,0 21,12A2,2 0 0,0 19,10M12,17A2,2 0 0,0 10,19A2,2 0 0,0 12,21A2,2 0 0,0 14,19A2,2 0 0,0 12,17Z",
        globe: "M17.9,17.39C17.64,16.59 16.89,16 16,16H15V13A1,1 0 0,0 14,12H8V10H10A1,1 0 0,0 11,9V7H13A2,2 0 0,0 15,5V4.59C17.93,5.77 20,8.64 20,12C20,14.08 19.2,15.97 17.9,17.39M11,19.93C7.05,19.44 4,16.08 4,12C4,11.38 4.08,10.78 4.21,10.21L9,15V16A2,2 0 0,0 11,18M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z",
        infinity: "M18.6,6.62C21.58,6.62 24,9 24,12C24,14.96 21.58,17.37 18.6,17.37C17.15,17.37 15.8,16.81 14.78,15.8L12,13.34L9.17,15.85C8.2,16.82 6.84,17.38 5.4,17.38C2.42,17.38 0,14.96 0,12C0,9.04 2.42,6.62 5.4,6.62C6.84,6.62 8.2,7.18 9.22,8.2L12,10.66L14.83,8.15C15.8,7.18 17.16,6.62 18.6,6.62M7.8,14.39L10.5,12L7.84,9.65C7.16,8.97 6.31,8.62 5.4,8.62C3.53,8.62 2,10.13 2,12C2,13.87 3.53,15.38 5.4,15.38C6.31,15.38 7.16,15.03 7.8,14.39M16.2,9.61L13.5,12L16.16,14.35C16.84,15.03 17.7,15.38 18.6,15.38C20.47,15.38 22,13.87 22,12C22,10.13 20.47,8.62 18.6,8.62C17.69,8.62 16.84,8.97 16.2,9.61Z",
        layers: "M12,16L19.36,10.27L21,9L12,2L3,9L4.63,10.27M12,18.54L4.62,12.81L3,14.07L12,21.07L21,14.07L19.37,12.8L12,18.54Z",
        layersOff: "M3.27,1L2,2.27L6.22,6.5L3,9L4.63,10.27L12,16L14.1,14.37L15.53,15.8L12,18.54L4.63,12.81L3,14.07L12,21.07L16.95,17.22L20.73,21L22,19.73L3.27,1M19.36,10.27L21,9L12,2L9.09,4.27L16.96,12.15L19.36,10.27M19.81,15L21,14.07L19.57,12.64L18.38,13.56L19.81,15Z",
        left: "M11,16V13H21V11H11V8L7,12L11,16M3,20H5V4H3V20Z",
        magnify: "M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z",
        merge: "M17,20.41L18.41,19L15,15.59L13.59,17M7.5,8H11V13.59L5.59,19L7,20.41L13,14.41V8H16.5L12,3.5",
        microphone: "M12,2A3,3 0 0,1 15,5V11A3,3 0 0,1 12,14A3,3 0 0,1 9,11V5A3,3 0 0,1 12,2M19,11C19,14.53 16.39,17.44 13,17.93V21H11V17.93C7.61,17.44 5,14.53 5,11H7A5,5 0 0,0 12,16A5,5 0 0,0 17,11H19Z",
        middle: "M8,19H11V23H13V19H16L12,15L8,19M16,5H13V1H11V5H8L12,9L16,5M4,11V13H20V11H4Z",
        move: "M13,6V11H18V7.75L22.25,12L18,16.25V13H13V18H16.25L12,22.25L7.75,18H11V13H6V16.25L1.75,12L6,7.75V11H11V6H7.75L12,1.75L16.25,6H13Z",
        music: "M21,3V15.5A3.5,3.5 0 0,1 17.5,19A3.5,3.5 0 0,1 14,15.5A3.5,3.5 0 0,1 17.5,12C18.04,12 18.55,12.12 19,12.34V6.47L9,8.6V17.5A3.5,3.5 0 0,1 5.5,21A3.5,3.5 0 0,1 2,17.5A3.5,3.5 0 0,1 5.5,14C6.04,14 6.55,14.12 7,14.34V6L21,3Z",
        note: "M14,10H19.5L14,4.5V10M5,3H15L21,9V19A2,2 0 0,1 19,21H5C3.89,21 3,20.1 3,19V5C3,3.89 3.89,3 5,3M5,5V19H19V12H12V5H5Z",
        opacity: "M17.66,8L12,2.35L6.34,8C4.78,9.56 4,11.64 4,13.64C4,15.64 4.78,17.75 6.34,19.31C7.9,20.87 9.95,21.66 12,21.66C14.05,21.66 16.1,20.87 17.66,19.31C19.22,17.75 20,15.64 20,13.64C20,11.64 19.22,9.56 17.66,8M6,14C6,12 6.62,10.73 7.76,9.6L12,5.27L16.24,9.65C17.38,10.77 18,12 18,14H6Z",
        package: "M21,16.5C21,16.88 20.79,17.21 20.47,17.38L12.57,21.82C12.41,21.94 12.21,22 12,22C11.79,22 11.59,21.94 11.43,21.82L3.53,17.38C3.21,17.21 3,16.88 3,16.5V7.5C3,7.12 3.21,6.79 3.53,6.62L11.43,2.18C11.59,2.06 11.79,2 12,2C12.21,2 12.41,2.06 12.57,2.18L20.47,6.62C20.79,6.79 21,7.12 21,7.5V16.5M12,4.15L10.11,5.22L16,8.61L17.96,7.5L12,4.15M6.04,7.5L12,10.85L13.96,9.75L8.08,6.35L6.04,7.5M5,15.91L11,19.29V12.58L5,9.21V15.91M19,15.91V9.21L13,12.58V19.29L19,15.91Z",
        paint: "M8 3C5.79 3 4 4.79 4 7V14C4 15.1 4.9 16 6 16H9V20C9 21.1 9.9 22 11 22H13C14.1 22 15 21.1 15 20V16H18C19.1 16 20 15.1 20 14V3H8M8 5H12V7H14V5H15V9H17V5H18V10H6V7C6 5.9 6.9 5 8 5M6 14V12H18V14H6Z",
        palette: "M17.5,12A1.5,1.5 0 0,1 16,10.5A1.5,1.5 0 0,1 17.5,9A1.5,1.5 0 0,1 19,10.5A1.5,1.5 0 0,1 17.5,12M14.5,8A1.5,1.5 0 0,1 13,6.5A1.5,1.5 0 0,1 14.5,5A1.5,1.5 0 0,1 16,6.5A1.5,1.5 0 0,1 14.5,8M9.5,8A1.5,1.5 0 0,1 8,6.5A1.5,1.5 0 0,1 9.5,5A1.5,1.5 0 0,1 11,6.5A1.5,1.5 0 0,1 9.5,8M6.5,12A1.5,1.5 0 0,1 5,10.5A1.5,1.5 0 0,1 6.5,9A1.5,1.5 0 0,1 8,10.5A1.5,1.5 0 0,1 6.5,12M12,3A9,9 0 0,0 3,12A9,9 0 0,0 12,21A1.5,1.5 0 0,0 13.5,19.5C13.5,19.11 13.35,18.76 13.11,18.5C12.88,18.23 12.73,17.88 12.73,17.5A1.5,1.5 0 0,1 14.23,16H16A5,5 0 0,0 21,11C21,6.58 16.97,3 12,3Z",
        pause: "M14,19H18V5H14M6,19H10V5H6V19Z",
        pencil: "M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z",
        play: "M8,5.14V19.14L19,12.14L8,5.14Z",
        plus: "M20 14H14V20H10V14H4V10H10V4H14V10H20V14Z",
        plusbox: "M17,13H13V17H11V13H7V11H11V7H13V11H17M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3Z",
        pointer: "M13.75,10.19L14.38,10.32L18.55,12.4C19.25,12.63 19.71,13.32 19.65,14.06V14.19L19.65,14.32L18.75,20.44C18.69,20.87 18.5,21.27 18.15,21.55C17.84,21.85 17.43,22 17,22H10.12C9.63,22 9.18,21.82 8.85,21.47L2.86,15.5L3.76,14.5C4,14.25 4.38,14.11 4.74,14.13H5.03L9,15V4.5A2,2 0 0,1 11,2.5A2,2 0 0,1 13,4.5V10.19H13.75Z",
        record: "M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4M12,9A3,3 0 0,0 9,12A3,3 0 0,0 12,15A3,3 0 0,0 15,12A3,3 0 0,0 12,9Z",
        recordoutline: "M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4M12,9A3,3 0 0,0 9,12A3,3 0 0,0 12,15A3,3 0 0,0 15,12A3,3 0 0,0 12,9Z",
        redo: "M10.5 18H18V20H10.5C6.91 20 4 17.09 4 13.5S6.91 7 10.5 7H16.17L13.08 3.91L14.5 2.5L20 8L14.5 13.5L13.09 12.09L16.17 9H10.5C8 9 6 11 6 13.5S8 18 10.5 18Z",
        restore: "M13,3A9,9 0 0,0 4,12H1L4.89,15.89L4.96,16.03L9,12H6A7,7 0 0,1 13,5A7,7 0 0,1 20,12A7,7 0 0,1 13,19C11.07,19 9.32,18.21 8.06,16.94L6.64,18.36C8.27,20 10.5,21 13,21A9,9 0 0,0 22,12A9,9 0 0,0 13,3Z",
        right: "M13,8V11H3V13H13V16L17,12L13,8M19,20H21V4H19V20Z",
        seal: "M20.39,19.37L16.38,18L15,22L11.92,16L9,22L7.62,18L3.61,19.37L6.53,13.37C5.57,12.17 5,10.65 5,9A7,7 0 0,1 12,2A7,7 0 0,1 19,9C19,10.65 18.43,12.17 17.47,13.37L20.39,19.37M7,9L9.69,10.34L9.5,13.34L12,11.68L14.5,13.33L14.33,10.34L17,9L14.32,7.65L14.5,4.67L12,6.31L9.5,4.65L9.67,7.66L7,9Z",
        selectdrag: "M14,17H17V14H19V17H22V19H19V22H17V19H14V17M12,17V19H9V17H12M7,17V19H3V15H5V17H7M3,13V10H5V13H3M3,8V4H7V6H5V8H3M9,4H12V6H9V4M15,4H19V8H17V6H15V4M19,10V12H17V10H19Z",
        selectsearch: "M19.27 18.9C19.7 18.21 19.95 17.38 19.95 16.5C19.95 14 17.95 12 15.46 12S10.96 14 10.96 16.5 12.96 21 15.46 21C16.33 21 17.15 20.75 17.84 20.32L20.96 23.39L22.35 22L19.27 18.9M15.46 19C14.07 19 12.96 17.88 12.96 16.5S14.07 14 15.46 14 17.95 15.12 17.95 16.5 16.84 19 15.46 19M22 14H21.45C21.12 13.19 20.62 12.47 20 11.86V10H22V14M20 4H17V2H20C21.11 2 22 2.9 22 4V7H20V4M14 4H10V2H14V4M4 2H7V4H4V7H2V4C2 2.89 2.9 2 4 2M12 22H10V20C10.5 20.82 11.2 21.5 12 22M4 20H7V22H4C2.9 22 2 21.11 2 20V17H4V20M4 14H2V10H4V14Z",
        shadow: "M3,3H16V6H11V18H8V6H3V3M12,7H14V9H12V7M15,7H17V9H15V7M18,7H20V9H18V7M12,10H14V12H12V10M12,13H14V15H12V13M12,16H14V18H12V16M12,19H14V21H12V19Z",
        skip: "M16,18H18V6H16M6,18L14.5,12L6,6V18Z",
        skipprev: "M6,18V6H8V18H6M9.5,12L18,6V18L9.5,12Z",
        split: "M14,4L16.29,6.29L13.41,9.17L14.83,10.59L17.71,7.71L20,10V4M10,4H4V10L6.29,7.71L11,12.41V20H13V11.59L7.71,6.29",
        stop: "M18,18H6V6H18V18Z",
        stopwatch: "M12,20A7,7 0 0,1 5,13A7,7 0 0,1 12,6A7,7 0 0,1 19,13A7,7 0 0,1 12,20M19.03,7.39L20.45,5.97C20,5.46 19.55,5 19.04,4.56L17.62,6C16.07,4.74 14.12,4 12,4A9,9 0 0,0 3,13A9,9 0 0,0 12,22C17,22 21,17.97 21,13C21,10.88 20.26,8.93 19.03,7.39M11,14H13V8H11M15,1H9V3H15V1Z",
        sword: "M6.92,5H5L14,14L15,13.06M19.96,19.12L19.12,19.96C18.73,20.35 18.1,20.35 17.71,19.96L14.59,16.84L11.91,19.5L10.5,18.09L11.92,16.67L3,7.75V3H7.75L16.67,11.92L18.09,10.5L19.5,11.91L16.83,14.58L19.95,17.7C20.35,18.1 20.35,18.73 19.96,19.12Z",
        tag: "M5.5,7A1.5,1.5 0 0,1 4,5.5A1.5,1.5 0 0,1 5.5,4A1.5,1.5 0 0,1 7,5.5A1.5,1.5 0 0,1 5.5,7M21.41,11.58L12.41,2.58C12.05,2.22 11.55,2 11,2H4C2.89,2 2,2.89 2,4V11C2,11.55 2.22,12.05 2.59,12.41L11.58,21.41C11.95,21.77 12.45,22 13,22C13.55,22 14.05,21.77 14.41,21.41L21.41,14.41C21.78,14.05 22,13.55 22,13C22,12.44 21.77,11.94 21.41,11.58Z",
        top: "M8,11H11V21H13V11H16L12,7L8,11M4,3V5H20V3H4Z",
        trash: "M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z",
        undo: "M20 13.5C20 17.09 17.09 20 13.5 20H6V18H13.5C16 18 18 16 18 13.5S16 9 13.5 9H7.83L10.91 12.09L9.5 13.5L4 8L9.5 2.5L10.92 3.91L7.83 7H13.5C17.09 7 20 9.91 20 13.5Z",
        unpackage: "M2,10.96C1.5,10.68 1.35,10.07 1.63,9.59L3.13,7C3.24,6.8 3.41,6.66 3.6,6.58L11.43,2.18C11.59,2.06 11.79,2 12,2C12.21,2 12.41,2.06 12.57,2.18L20.47,6.62C20.66,6.72 20.82,6.88 20.91,7.08L22.36,9.6C22.64,10.08 22.47,10.69 22,10.96L21,11.54V16.5C21,16.88 20.79,17.21 20.47,17.38L12.57,21.82C12.41,21.94 12.21,22 12,22C11.79,22 11.59,21.94 11.43,21.82L3.53,17.38C3.21,17.21 3,16.88 3,16.5V10.96C2.7,11.13 2.32,11.14 2,10.96M12,4.15V4.15L12,10.85V10.85L17.96,7.5L12,4.15M5,15.91L11,19.29V12.58L5,9.21V15.91M19,15.91V12.69L14,15.59C13.67,15.77 13.3,15.76 13,15.6V19.29L19,15.91M13.85,13.36L20.13,9.73L19.55,8.72L13.27,12.35L13.85,13.36Z",
        upload: "M9,16V10H5L12,3L19,10H15V16H9M5,20V18H19V20H5Z",
        user: "M12,4A4,4 0 0,1 16,8A4,4 0 0,1 12,12A4,4 0 0,1 8,8A4,4 0 0,1 12,4M12,14C16.42,14 20,15.79 20,18V20H4V18C4,15.79 7.58,14 12,14Z",
        users: "M12,5.5A3.5,3.5 0 0,1 15.5,9A3.5,3.5 0 0,1 12,12.5A3.5,3.5 0 0,1 8.5,9A3.5,3.5 0 0,1 12,5.5M5,8C5.56,8 6.08,8.15 6.53,8.42C6.38,9.85 6.8,11.27 7.66,12.38C7.16,13.34 6.16,14 5,14A3,3 0 0,1 2,11A3,3 0 0,1 5,8M19,8A3,3 0 0,1 22,11A3,3 0 0,1 19,14C17.84,14 16.84,13.34 16.34,12.38C17.2,11.27 17.62,9.85 17.47,8.42C17.92,8.15 18.44,8 19,8M5.5,18.25C5.5,16.18 8.41,14.5 12,14.5C15.59,14.5 18.5,16.18 18.5,18.25V20H5.5V18.25M0,20V18.5C0,17.11 1.89,15.94 4.45,15.6C3.86,16.28 3.5,17.22 3.5,18.25V20H0M24,20H20.5V18.25C20.5,17.22 20.14,16.28 19.55,15.6C22.11,15.94 24,17.11 24,18.5V20Z",
        volumehigh: "M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.84 14,18.7V20.77C18,19.86 21,16.28 21,12C21,7.72 18,4.14 14,3.23M16.5,12C16.5,10.23 15.5,8.71 14,7.97V16C15.5,15.29 16.5,13.76 16.5,12M3,9V15H7L12,20V4L7,9H3Z",
        volumeoff: "M12,4L9.91,6.09L12,8.18M4.27,3L3,4.27L7.73,9H3V15H7L12,20V13.27L16.25,17.53C15.58,18.04 14.83,18.46 14,18.7V20.77C15.38,20.45 16.63,19.82 17.68,18.96L19.73,21L21,19.73L12,10.73M19,12C19,12.94 18.8,13.82 18.46,14.64L19.97,16.15C20.62,14.91 21,13.5 21,12C21,7.72 18,4.14 14,3.23V5.29C16.89,6.15 19,8.83 19,12M16.5,12C16.5,10.23 15.5,8.71 14,7.97V10.18L16.45,12.63C16.5,12.43 16.5,12.21 16.5,12Z"
      }[this.name];
    }
  }
};
const _hoisted_1$h = ["d"];
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 24 24",
    class: "vector-image",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }, [
    createBaseVNode("path", {
      fill: "currentColor",
      d: $options.path
    }, null, 8, _hoisted_1$h)
  ]);
}
const VectorImage = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$g], ["__scopeId", "data-v-7763b992"]]);
const _sfc_main$j = {
  name: "BlobAudio",
  components: {
    vi: VectorImage
  },
  props: {
    blob: String,
    loop: Boolean,
    controls: Boolean,
    autobuffer: Boolean,
    autoplay: Boolean,
    oncanplaythrough: Function,
    tabindex: String,
    lazy: { type: Boolean, default: false },
    volume: { type: Number, default: 1 },
    currentTime: { type: Number, default: 0 }
  },
  data() {
    return {
      source: null,
      instance: null,
      loaded: !this.lazy
    };
  },
  watch: {
    async blob() {
      await this.getURL();
    },
    async currentTime() {
      this.$el.currentTime = this.currentTime;
    },
    volume() {
      this.$el.volume = this.volume;
    }
  },
  async mounted() {
    await this.getURL();
  },
  beforeUnmount() {
    if (this.$el.pause) {
      this.$el.currentTime = 0;
      this.$el.src = "";
      this.$el.pause();
    }
  },
  methods: {
    async getURL() {
      if (!this.lazy || this.loaded) {
        if (this.blob) {
          this.instance = await Media.load(this.blob);
          if (this.instance) {
            this.source = await this.instance.getUrl();
          }
        } else {
          this.instance = null;
          this.source = "";
        }
      }
    },
    pause() {
      this.$el.pause();
      this.$el.currentTime = 0;
    },
    play() {
      this.$el.play();
    },
    async handleError() {
      this.source = await this.getURL();
    }
  }
};
const _hoisted_1$g = {
  key: 0,
  class: "audio icon button"
};
const _hoisted_2$e = ["autoplay", "controls", "autobuffer", "loop", "oncanplaythrough", "src", "tabindex"];
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_vi = resolveComponent("vi");
  return $props.lazy && !$data.loaded ? (openBlock(), createElementBlock("div", _hoisted_1$g, [
    createVNode(_component_vi, {
      name: "unpackage",
      onClick: _cache[0] || (_cache[0] = ($event) => {
        $data.loaded = true;
        $options.getURL();
      })
    })
  ])) : withDirectives((openBlock(), createElementBlock("audio", {
    key: 1,
    autoplay: $props.autoplay,
    controls: $props.controls,
    autobuffer: $props.autobuffer,
    loop: $props.loop,
    oncanplaythrough: $props.oncanplaythrough,
    src: $data.source,
    tabindex: $props.tabindex,
    onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("click", $event)),
    onLoad: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("load", $event)),
    onCanplaythrough: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("canplaythrough", $event)),
    onError: _cache[4] || (_cache[4] = (...args) => $options.handleError && $options.handleError(...args))
  }, null, 40, _hoisted_2$e)), [
    [vShow, $props.blob && $data.source]
  ]);
}
const BlobAudio = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$f], ["__scopeId", "data-v-f404d004"]]);
function bitdown(text, story2, variables = {}) {
  const markers = [
    { startTag: "\\*\\*", tag: "b" },
    { startTag: "\\*", tag: "i" },
    { startTag: "~~", tag: "s" },
    { startTag: "@", tag: "r" },
    {
      startTag: "\\$#\\$",
      endTag: "\\$#\\$",
      tag: 'span style="display:block;padding:5px;text-shadow:none;color:red;background:black"'
    }
  ];
  if (story2) {
    markers.push({
      startTag: "\\!\\[",
      endTag: "\\]",
      render: (tag, inside) => {
        let [source, size2] = inside.split(/,| /);
        const tags = story2.tags || [];
        let variable = tags.find(
          (tag2) => tag2.name === source && tag2.type === "story-object-ref" && tag2.referencing === "images"
        );
        if (variable) {
          source = variables[variable.id] || variable.default;
        }
        variable = tags.find(
          (tag2) => tag2.name === size2 && tag2.type === "tag" && (!tag2.format || tag2.format === "numeric")
        );
        if (variable) {
          size2 = variables[variable.id] || variable.default;
        }
        const image = story2.images.find((i) => i.id === source || i.name === source);
        if (image) {
          size2 = size2 ? ` width="${parseInt(size2)}"` : "";
          return `<img src="${image.blob_id}"${size2}>`;
        }
        return "";
      }
    });
    for (const style of (story2 == null ? void 0 : story2.styles) || []) {
      if (style.name) {
        let textStyle2 = "";
        for (const [key, value] of [
          ["foreground", "color"],
          ["font", "font-family"],
          ["size", "font-size"]
        ]) {
          if (style[key]) {
            const styleValue = `${style[key] || ""}`.replace(/ /g, "");
            textStyle2 += `${value}:${styleValue};`;
          }
        }
        markers.push({ startTag: `#${style.name}#`, tag: `span style="${textStyle2}"` });
      }
    }
  }
  for (const marker of markers) {
    text = matchMarker(
      marker.startTag,
      marker.endTag || marker.startTag,
      marker.tag,
      text,
      marker.render
    );
  }
  return text;
}
function matchMarker(startTag, endTag, tag, text, renderFunc = null) {
  const char2 = startTag.replace(/\\/g, "").charAt(0);
  const regex = new RegExp(`${startTag}(\\S[^${char2}
]*?(?<=\\S))${endTag}`, "g");
  let htmlEnd = tag;
  if (/ /.test(htmlEnd)) {
    htmlEnd = htmlEnd.split(/ /)[0];
  }
  text = text.replace(regex, (full, inside) => {
    if (renderFunc) {
      return renderFunc(tag, inside);
    } else {
      return `<${tag}>${inside}</${htmlEnd}>`;
    }
  });
  return text;
}
const _sfc_main$i = {
  name: "blob-image",
  props: {
    blob: String,
    width: { type: [String, Number], default: null },
    thumb: { type: Boolean, default: false }
  },
  data() {
    return {
      image: null,
      isLoaded: false
    };
  },
  computed: {
    ...mapStores(useImageStore)
  },
  watch: {
    async blob() {
      this.isLoaded = false;
      await this.getImage();
    }
  },
  async mounted() {
    try {
      await this.getImage();
    } catch (e2) {
      console.error("error loading images", e2);
    }
  },
  methods: {
    async getImage() {
      this.image = await this.imagesStore.loadImage(this.blob, this.thumb);
    },
    async loaded() {
      this.isLoaded = true;
      this.$emit("load");
    },
    handleError(error) {
      this.$emit("error", error);
      this.imagesStore.clearOne(this.blob, this.thumb);
      this.getImage();
    }
  }
};
const _hoisted_1$f = ["src", "width"];
const _hoisted_2$d = { key: 1 };
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return $props.blob && $data.image ? (openBlock(), createElementBlock("img", {
    key: 0,
    src: $data.image,
    width: $props.width,
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event)),
    onError: _cache[1] || (_cache[1] = (...args) => $options.handleError && $options.handleError(...args)),
    onLoad: _cache[2] || (_cache[2] = (...args) => $options.loaded && $options.loaded(...args))
  }, null, 40, _hoisted_1$f)) : (openBlock(), createElementBlock("img", _hoisted_2$d));
}
const BlobImage = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$e]]);
function nextFrame() {
  return new Promise((r) => {
    requestAnimationFrame(r);
  });
}
function timer$2(t) {
  return new Promise((r) => {
    setTimeout(() => {
      r();
    }, t);
  });
}
function nrand$1(x = 1) {
  return (Math.random() - 0.5) * 2 * x;
}
const _sfc_main$h = {
  name: "FallingNumbers",
  props: {
    start: { type: Number, required: true },
    delta: { type: Number, required: true }
  },
  data() {
    return {
      number: Math.floor(this.start),
      remaining: this.delta,
      particles: [],
      life: 600,
      hurried: false
    };
  },
  watch: {
    start() {
      this.resetFall();
    },
    delta() {
      this.resetFall();
    }
  },
  async mounted() {
    this.resetFall();
  },
  unmounted() {
    this.hurried = true;
    this.particles.length = 0;
    window.cancelAnimationFrame(this.nextFrame);
    clearTimeout(this.timeout);
  },
  methods: {
    async hurry() {
      this.hurried = true;
    },
    async resetFall() {
      if (!this.timeout) {
        this.timeout = 1;
        this.hurried = true;
        await this.previous;
        this.hurried = false;
        this.previous = this.fall();
      }
    },
    async fall() {
      this.number = Math.floor(this.start);
      this.remaining = this.delta;
      this.timeout = timer$2(600);
      await this.timeout;
      const steps = Math.ceil(Math.min(15, Math.abs(this.delta)));
      let last = Date.now();
      let lastNumber = this.number;
      for (let step = 1; step <= steps; step += 1) {
        const p2 = this.ease(step / steps);
        this.number = Math.floor(this.start + this.delta * p2);
        this.remaining = Math.abs(Math.floor(this.delta * (1 - p2)));
        if ((p2 >= 1 || Date.now() - last > 60) && Math.abs(this.number - lastNumber) > 0) {
          let number2 = this.number - lastNumber;
          if (number2 > 0) {
            number2 = "+" + number2;
          }
          last = Date.now();
          const angle = 0 + Math.cos((Date.now() + nrand$1(0.4) * 2) / 50) * 0.3;
          const speed = nrand$1(1) + 5;
          this.particles.push({
            id: last,
            text: number2,
            // text: `${this.number}`,
            expires: Date.now() + this.life,
            x: 0,
            y: 0,
            a: angle,
            dx: 0 + Math.cos(angle) * speed,
            // + nrand(1.5),
            dy: 0 + Math.sin(angle) * speed,
            // + nrand(2),
            da: nrand$1(0),
            opacity: 1
          });
          lastNumber = this.number;
        }
        this.timeout = timer$2(10 + Math.random() * 20);
        await this.timeout;
        await nextFrame();
        this.startAnimation();
        if (this.hurried) {
          this.number = this.start + this.delta;
          this.remaining = 0;
          break;
        }
      }
      this.timeout = null;
    },
    ease(x) {
      return 1 - Math.pow(1 - x, 2);
    },
    startAnimation() {
      if (!this.nextFrame) {
        this.animate();
      }
    },
    async animate() {
      for (let p2 of this.particles) {
        const life = p2.expires - Date.now();
        if (life < 100) {
          p2.opacity = life / 100;
        }
        if (p2.opacity <= 0) {
          this.particles.splice(this.particles.indexOf(p2), 1);
        } else {
          p2.x += p2.dx;
          p2.y += p2.dy;
          p2.a += p2.da;
          p2.dy = p2.dy * 0.9;
          p2.dx = p2.dx * 0.9;
          p2.da = p2.da * 0.9;
        }
      }
      if (this.particles.length > 0) {
        this.nextFrame = window.requestAnimationFrame(this.animate.bind(this));
      } else {
        this.nextFrame = null;
      }
    }
  }
};
const _hoisted_1$e = { class: "number" };
const _hoisted_2$c = { class: "number-text" };
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "falling-numbers",
    onClick: _cache[0] || (_cache[0] = (...args) => $options.hurry && $options.hurry(...args))
  }, [
    createBaseVNode("span", _hoisted_1$e, [
      createBaseVNode("span", _hoisted_2$c, toDisplayString$1($data.number), 1),
      (openBlock(true), createElementBlock(Fragment, null, renderList($data.particles, (particle) => {
        return openBlock(), createElementBlock("div", {
          key: particle.id,
          style: normalizeStyle({
            transform: `translate(${particle.x / 22}em, ${particle.y / 22}em) rotate(${particle.a}rad)`,
            opacity: particle.opacity
          }),
          class: normalizeClass(["particle", { positive: $props.delta > 0, negative: $props.delta < 0 }])
        }, toDisplayString$1(particle.text), 7);
      }), 128))
    ]),
    createVNode(Transition, { name: "quickfade" }, {
      default: withCtx(() => [
        $data.remaining ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: normalizeClass({ positive: $props.delta > 0, negative: $props.delta < 0 })
        }, toDisplayString$1($props.delta > 0 ? "+" : "-") + toDisplayString$1(Math.floor(Math.abs($data.remaining))), 3)) : createCommentVNode("", true)
      ]),
      _: 1
    })
  ]);
}
const FallingNumbers = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$d], ["__scopeId", "data-v-99a4d0fb"]]);
const _sfc_main$g = {
  name: "typer-leaf",
  components: {
    FallingNumber: FallingNumbers,
    BlobImage
  },
  props: {
    allowImages: { default: false },
    position: { type: Number },
    finished: { type: Number },
    words: { type: Array },
    tagName: { type: String, default: "span" },
    htmlattrs: { type: Object },
    variables: { type: Object }
  },
  data() {
    let value = null;
    return {
      value,
      startValue: value || 0,
      endValue: value || 0,
      frame: 0,
      maxFrames: 80
    };
  },
  computed: {
    readyWords() {
      const nb = this.nextBreak;
      return this.words.filter((word) => {
        return word.startsAt <= nb;
      });
    },
    nextBreak() {
      const words = this.words.filter((w) => w.startsAt > this.position && w.newLine);
      if (words.length > 1) {
        return words[0].startsAt;
      }
      if (this.words.length > 0) {
        return this.words[this.words.length - 1].endsAt;
      }
      return 0;
    },
    word() {
      return this.getWord();
    },
    var() {
      if (!this.variables || !this.word) {
        return null;
      }
      return this.variables[this.word];
    },
    isNumber() {
      return typeof this.var === "number";
    }
  },
  watch: {
    var() {
      this.start();
    }
  },
  mounted() {
    this.start();
  },
  unmounted() {
    cancelAnimationFrame(this._moveValue);
  },
  methods: {
    start() {
      if (this.tagName === "r") {
        this.frame = 1;
        if (this.var || this.var === 0) {
          if (this.isNumber) {
            this.startValue = this.value || 0;
            this.endValue = this.var;
            this.value = this.var;
            this.maxFrames = Math.max(1, Math.floor(Math.abs(this.startValue - this.endValue) * 2));
          } else {
            this.value = this.var;
            this.maxFrames = this.var.length;
          }
          this.moveValue();
        } else {
          this.value = null;
        }
      } else {
        const word = this.getWord();
        if (this.variables && this.variables[word]) {
          this.value = this.variables[word];
        }
      }
    },
    getWord() {
      if (this.words.length > 0) {
        return this.words[0].content.join("");
      }
      return null;
    },
    arrayify(value) {
      return Array.from(`${value}`);
    },
    moveValue() {
      this.frame += 1;
      if (this.frame <= this.maxFrames) {
        this._moveValue = requestAnimationFrame(() => this.moveValue());
      }
    },
    ease(x) {
      return 1 - Math.pow(1 - x, 2);
    }
  }
};
const _hoisted_1$d = { key: 1 };
const _hoisted_2$b = {
  key: 3,
  class: "chars"
};
const _hoisted_3$b = ["id"];
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_falling_number = resolveComponent("falling-number");
  const _component_typer_leaf = resolveComponent("typer-leaf");
  const _component_BlobImage = resolveComponent("BlobImage");
  return $props.tagName === "r" && $options.isNumber ? (openBlock(), createBlock(_component_falling_number, {
    key: 0,
    start: $data.startValue || 0,
    delta: ($data.endValue || 0) - ($data.startValue || 0)
  }, null, 8, ["start", "delta"])) : $props.tagName === "r" ? (openBlock(), createBlock(_component_typer_leaf, {
    key: 1,
    words: [{ startsAt: 0, endsAt: ($data.value || "").length, content: $options.arrayify($data.value) }],
    position: $data.frame,
    finished: $data.frame,
    allowImages: $props.allowImages
  }, null, 8, ["words", "position", "finished", "allowImages"])) : (openBlock(), createBlock(resolveDynamicComponent($props.tagName), mergeProps({
    key: 2,
    class: "word"
  }, $props.htmlattrs), {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.readyWords, (word) => {
        return openBlock(), createElementBlock("span", {
          key: `word-${word.id}`,
          class: normalizeClass(["word", {
            long: word.long,
            current: word.startsAt <= $props.position && word.endsAt > $props.position,
            nextword: word.startsAt > $props.position,
            whitespace: word.type === "whitespace",
            notNewLine: !word.newLine,
            newLine: word.newLine
          }])
        }, [
          word.tag === "img" && $props.allowImages ? (openBlock(), createBlock(_component_BlobImage, {
            key: 0,
            blob: word.attrs.src,
            width: word.attrs.width,
            class: normalizeClass({
              cursor: $props.position === word.startsAt,
              hidden: $props.position < word.endsAt
            })
          }, null, 8, ["blob", "width", "class"])) : createCommentVNode("", true),
          word.tag === "img" ? (openBlock(), createElementBlock("span", _hoisted_1$d)) : word.children ? (openBlock(), createBlock(_component_typer_leaf, {
            key: 2,
            position: $props.position,
            finished: $props.finished,
            words: word.children,
            tagName: word.tag,
            variables: $props.variables,
            htmlattrs: word.attrs,
            allowImages: $props.allowImages
          }, null, 8, ["position", "finished", "words", "tagName", "variables", "htmlattrs", "allowImages"])) : word.endsAt <= $props.finished ? (openBlock(), createElementBlock("span", _hoisted_2$b, toDisplayString$1(word.content.join("")), 1)) : (openBlock(true), createElementBlock(Fragment, { key: 4 }, renderList(word.content, (c, cid) => {
            return openBlock(), createElementBlock("span", {
              id: `char_${word.startsAt + cid}`,
              key: `char_${word.startsAt + cid}`,
              class: normalizeClass(["char", {
                cursor: $props.position === word.startsAt + cid,
                hidden: $props.position < word.startsAt + cid
              }])
            }, toDisplayString$1(c), 11, _hoisted_3$b);
          }), 128))
        ], 2);
      }), 128))
    ]),
    _: 1
  }, 16));
}
const TyperLeaf = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$c], ["__scopeId", "data-v-fa945d7d"]]);
function typerSplitLine(line) {
  let words = [];
  line = line;
  line = line.replace(/\t/g, "");
  line = line.replace(/<br ?\/?>/g, "");
  line = line.replace(/<p>/g, "");
  line = line.replace(/<\/p>/g, "\n").trim();
  line = line.replace(/&quot;/g, '"');
  let word = { content: [], type: null };
  for (let char2 of line) {
    let type2 = null;
    if (/\>/.test(char2) && word.type === "tag") {
      const content = word.content.join("") + char2;
      let tagName = content.slice(1).split(/>/)[0];
      let attrs = {};
      if (/ /.test(tagName)) {
        const bits = tagName.split(/ /);
        tagName = bits[0];
        attrs = bits.slice(1);
        if (attrs) {
          attrs = attrs.map((attr) => attr.trim().split("=")).reduce((a, b) => {
            a[b[0]] = b[1].slice(1, -1);
            return a;
          }, {});
        }
      }
      if (["img"].includes(tagName)) {
        word.tag = tagName;
        word.attrs = attrs;
        word.content = [1];
        word.ended = true;
        word.type = "tag";
        type2 = "tag";
        char2 = "image";
      } else {
        const testEndTag = new RegExp(`</${tagName}>`);
        if (testEndTag.test(content)) {
          const inner1 = content.split(">").slice(1).join(">");
          const inner2 = inner1.split("<");
          const inner = inner2.slice(0, inner2.length - 1).join("<");
          if (["b", "i", "s", "r", "em", "strong"].includes(tagName)) {
            word.tag = tagName;
          } else {
            word.tag = "span";
          }
          word.attrs = attrs;
          word.children = typerSplitLine(inner);
          word.ended = true;
        } else if (/\/\>|\<br\>|\<hr\>$/.test(content)) {
          word.remove = true;
          word.ended = true;
        }
        type2 = "tag";
      }
    } else if (/\</.test(char2) || word.type === "tag" && !word.ended) {
      type2 = "tag";
    } else if (/\s/.test(char2)) {
      type2 = "whitespace";
    } else {
      type2 = "text";
    }
    if (!word.type) {
      word.type = type2;
    }
    if (word.ended) {
      word.content.push(char2);
      words.push(word);
      word = { content: [] };
    } else if (type2 !== word.type) {
      if (word.content.length > 0) {
        words.push(word);
      }
      word = { content: [], type: type2 };
      word.content.push(char2);
    } else {
      word.content.push(char2);
    }
  }
  if (word.content.length > 0) {
    words.push(word);
  }
  words = words.filter((w) => !w.remove);
  return words;
}
const log$3 = debug("typer");
function nrand(x) {
  return (Math.random() - 0.5) * 2 * x;
}
function h2r(hex) {
  let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : null;
}
function r2h(rgb) {
  return "#" + ((1 << 24) + (rgb[0] << 16) + (rgb[1] << 8) + rgb[2]).toString(16).slice(1);
}
function interpolateColor(color1, color2, factor) {
  let result = color1.slice();
  for (let i = 0; i < 3; i++) {
    result[i] = Math.round(result[i] + factor * (color2[i] - color1[i]));
  }
  return result;
}
function merge(a, b) {
  for (let prop in b) {
    if (b[prop] || b[prop] === 0) {
      a[prop] = b[prop];
    }
  }
  return a;
}
const _sfc_main$f = {
  components: {
    TyperLeaf
  },
  props: {
    text: String,
    allowImages: { type: Boolean, default: false },
    allowWrap: { type: Boolean, default: true },
    speed: { type: Number, default: 32 },
    allowFastforward: { default: true },
    animationConfig: { type: Object, required: false },
    animationDurationMultiplier: { type: Number, default: 1 },
    animations: { type: Array, required: false },
    story: { type: Object, required: false },
    delay: { type: Number, default: 0 },
    particleConfig: { type: Object },
    variables: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  data() {
    return {
      version: 0,
      cidx: -1,
      typed: -1,
      words: [],
      multipliers: {
        "\n": 5,
        ".": 8,
        "?": 8,
        ",": 6,
        "-": 0,
        image: 8
      },
      finished: false,
      particles: [],
      now: 0,
      hasNextFrame: false,
      lastIndex: 0,
      output: null,
      myWidth: 0,
      mWidth: -1
    };
  },
  watch: {
    async text() {
      this.reset();
    },
    particleConfig: {
      handler() {
        this.reset();
      },
      deep: true
    },
    animationConfig: {
      handler(o, n) {
        if (o.enter !== n.enter || o.exit !== n.exit) {
          this.createAnimators();
        }
      },
      deep: true
    },
    animations: {
      handler() {
        this.createAnimators();
      },
      deep: true
    }
  },
  mounted() {
    this.myWidth = this.$refs.inner.getBoundingClientRect().width;
    this.createAnimators();
    this.splitWords();
    this.animation = this.enterAnimation;
    setTimeout(this.handleType.bind(this), this.delay);
    if (this.speed <= 1) {
      this.speedup();
    }
  },
  unmounted() {
    this.resetStyles();
  },
  methods: {
    splitWords() {
      this.words = [];
      const output = bitdown(this.text, this.story, this.variables);
      const words = typerSplitLine(output);
      let lineWidth = 0;
      words.forEach((w) => {
        w.width = this.measureWidth(w.content);
        lineWidth += w.width;
        if (w.content.includes("\n")) {
          lineWidth = 0;
          w.newLine = true;
        } else if (lineWidth > this.myWidth) {
          lineWidth = w.width;
          w.newLine = true;
        }
        w.long = w.width > window.innerWidth * 0.8;
      });
      this.lastIndex = this.measureWords(words);
      this.words = words;
    },
    measureWords(line, index2 = 0, id = 1) {
      for (const word of line) {
        word.id = id;
        id += 1;
        word.startsAt = index2;
        if (word.children) {
          index2 = this.measureWords(word.children, index2, id);
        } else {
          index2 += word.content.length;
        }
        word.endsAt = index2;
      }
      return index2;
    },
    measureWidth(text) {
      if (this.mWidth === -1) {
        this.$refs.measure.textContent = "m";
        this.mWidth = this.$refs.measure.getBoundingClientRect().width;
      }
      this.$refs.measure.textContent = "m" + text.join("");
      return this.$refs.measure.getBoundingClientRect().width - this.mWidth;
    },
    resetStyles() {
      if (this.animation) {
        this.animation.stop();
      }
      for (let w = 0; w < this.words.length; w += 1) {
        for (let c = 0; c < this.words[w].content.length; c += 1) {
          const el = this.$refs[`char_${w}_${c}`];
          if (el && el[0]) {
            el[0].style = null;
          }
        }
      }
    },
    createAnimators() {
      this.resetStyles();
      this.exitAnimation = null;
      this.enterAnimation = null;
      this.idleAnimation = null;
      if (this.animationConfig) {
        const enter = this.animations.find((a) => a.id === this.animationConfig.enter);
        const idle = this.animations.find((a) => a.id === this.animationConfig.idle);
        const exit = this.animations.find((a) => a.id === this.animationConfig.exit);
        if (enter) {
          this.enterAnimation = new AnimationHandler(
            enter.pipeline,
            enter.duration * this.animationDurationMultiplier
          );
        }
        if (idle) {
          this.idleAnimation = new AnimationHandler(
            idle.pipeline,
            idle.duration * this.animationDurationMultiplier
          );
        }
        if (exit) {
          this.exitAnimation = new AnimationHandler(
            exit.pipeline,
            exit.duration * this.animationDurationMultiplier,
            true
          );
        }
      }
    },
    async clear() {
      if (this.animation) {
        await this.animation.stop();
        log$3("animation stopped");
      }
      this.version += 1;
      this.cidx = -1;
      this.typed = -1;
      this.finished = true;
      log$3("cleared");
    },
    async reset() {
      this.splitWords();
      this.cidx = -1;
      this.typed = -1;
      this.version += 1;
      this.finished = false;
      this.particles.length = 0;
      if (this.animation) {
        await this.animation.finished();
      }
      this.animation = this.enterAnimation;
      this.$nextTick(() => setTimeout(this.handleType.bind(this), this.delay));
    },
    getChar(index2, words) {
      const word = words.find((word2) => word2.startsAt <= index2 && word2.endsAt > index2);
      if (!word) {
        return null;
      }
      let char2 = null;
      if (word.children) {
        char2 = this.getChar(index2, word.children);
      } else {
        char2 = word.content[index2 - word.startsAt];
      }
      return char2;
    },
    async handleType() {
      let cidx = this.cidx + 1;
      this.cidx = cidx;
      if (cidx < this.lastIndex) {
        const char2 = this.getChar(cidx, this.words);
        if (/\W/.test(char2))
          ;
        else {
          this.$emit("type", char2);
          if (this.particleConfig) {
            this.particle(this.particleConfig);
          }
        }
        clearTimeout(this.__type);
        let multiplier = this.multipliers[char2] || 1;
        this.__type = setTimeout(
          this.handleType.bind(this),
          (this.speed || 32) * multiplier * this.animationDurationMultiplier
        );
      } else {
        if (this.animation) {
          await this.animation.finished();
        }
        this.finished = true;
        this.$emit("end");
        log$3("finished");
      }
      if (this.animation) {
        await this.$nextTick();
        const el = this.$el.querySelector(`#char_${cidx}`);
        if (el) {
          const version2 = this.version;
          this.animation.start(el).then(() => {
            if (this.version === version2) {
              this.typed = cidx;
            }
          });
        } else {
          this.typed = cidx;
        }
      } else {
        this.typed = cidx;
      }
    },
    async speedup(e2) {
      const animationFinished = this.animation ? this.animation.isFinished() : true;
      this.resetStyles();
      if (this.cleared && !animationFinished) {
        this.animation.stop();
        this.cleared.resolve();
        return true;
      } else if (!this.finished || !animationFinished) {
        clearTimeout(this.__type);
        if (this.animation) {
          this.animation.stop();
        }
        if (!this.finished) {
          this.typed = this.lastIndex;
          this.cidx = this.lastIndex;
          this.finished = true;
          this.$emit("end");
        }
        return true;
      } else {
        if (animationFinished) {
          this.$emit("click", e2);
          return false;
        }
        return true;
      }
    },
    async particle(spec) {
      await this.$nextTick();
      if (!spec.x) {
        spec = this.copy(spec);
        await this.$nextTick();
        let parent = this.$el.getBoundingClientRect();
        let box = this.$el.querySelector(".char.cursor").getBoundingClientRect();
        spec.x = box.x - parent.x + box.width * 0.5;
        spec.y = box.y - parent.y + box.height * 0.5;
      }
      if (spec.type == "emitter") {
        spec.probability *= 0.2;
        this.particles.push(spec);
      } else {
        spec = merge(
          {
            type: "particle",
            probability: 1,
            color1: "#ff8000",
            color2: "#c0c0c0",
            count: 1,
            a: 0,
            da: 0.2,
            da2: 0.1,
            dx: 0.5,
            dy: 0.5,
            dy2: 0.8,
            gravity: 4.4,
            size: 20,
            dsize: 0.7,
            duration: 0.9
          },
          spec
        );
        for (let x = 0; x < spec.count; x += 1) {
          if (Math.random() <= spec.probability) {
            let p2 = this.particles.find((p3) => p3.expires && p3.expires <= Date.now());
            if (p2 || this.particles.length < 1500) {
              let particle = {
                type: "particle",
                a: spec.a + nrand(spec.da),
                x: spec.x,
                y: spec.y,
                da: nrand(spec.da2) / 10,
                dx: nrand(spec.dx),
                dy: nrand(spec.dy) - spec.dy2,
                ddx: 0,
                ddy: parseFloat(spec.gravity) / 100,
                size: spec.size,
                dsize: spec.dsize,
                colors: [h2r(spec.color1), h2r(spec.color2)],
                char: spec.char,
                duration: spec.duration * 1e3,
                expires: spec.duration ? Date.now() + spec.duration * 1e3 : 0,
                decal: spec.decal
              };
              if (p2) {
                for (let prop in particle) {
                  p2[prop] = particle[prop];
                }
              } else {
                this.particles.push(particle);
              }
            }
          }
        }
      }
      if (!this.hasNextFrame) {
        this.nextFrame();
      }
    },
    nextFrame() {
      this.now = Date.now();
      let expired = 0;
      for (let particle of this.particles) {
        if (!particle.expires || particle.expires > this.now) {
          if (particle.type == "emitter") {
            if (Math.random() * 100 < 12) {
              let p2 = this.copy(particle);
              p2.type = "particle";
              this.particle(p2);
            }
          } else {
            let t = Math.max(0, particle.expires - this.now) / particle.duration;
            particle.a += particle.da;
            particle.x += particle.dx;
            particle.y += particle.dy;
            particle.dx += particle.ddx;
            particle.dy += particle.ddy;
            particle.size += particle.dsize;
            particle.opacity = t;
            if (particle.colors) {
              particle.color = r2h(interpolateColor(particle.colors[0], particle.colors[1], 1 - t));
            }
          }
        } else {
          expired += 1;
        }
      }
      this.particles[0];
      if (expired < this.particles.length) {
        this.hasNextFrame = true;
        window.requestAnimationFrame(this.nextFrame.bind(this));
      } else {
        this.hasNextFrame = false;
        log$3("particles finished");
      }
    }
  }
};
const _hoisted_1$c = { class: "particles" };
const _hoisted_2$a = {
  class: "measure",
  ref: "measure"
};
const _hoisted_3$a = {
  class: "typer-inner",
  ref: "inner"
};
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_typer_leaf = resolveComponent("typer-leaf");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["typer", { allowwrap: $props.allowWrap }]),
    onClick: _cache[0] || (_cache[0] = ($event) => $props.allowFastforward ? $options.speedup() : null)
  }, [
    createBaseVNode("div", _hoisted_1$c, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($data.particles.filter((p2) => p2.type == "particle"), (particle, idx) => {
        return withDirectives((openBlock(), createElementBlock("div", {
          class: "particle",
          key: idx,
          style: normalizeStyle({
            transform: `translate(${particle.x - particle.size / 2}px, ${particle.y - particle.size / 2}px) rotate(${particle.a}rad)`,
            width: `${particle.size}px`,
            height: `${particle.size}px`,
            maskImage: particle.decal ? `url(${particle.decal})` : null,
            backgroundColor: `${particle.color}`,
            opacity: particle.opacity
          })
        }, toDisplayString$1(particle.char), 5)), [
          [vShow, particle.expires > $data.now]
        ]);
      }), 128))
    ]),
    createBaseVNode("div", _hoisted_2$a, null, 512),
    createBaseVNode("div", _hoisted_3$a, [
      createVNode(_component_typer_leaf, {
        position: $data.cidx,
        finished: $data.typed,
        words: $data.words,
        variables: $props.variables,
        allowImages: $props.allowImages
      }, null, 8, ["position", "finished", "words", "variables", "allowImages"])
    ], 512)
  ], 2);
}
const Typer = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$b], ["__scopeId", "data-v-a8cdd71b"]]);
const _hoisted_1$b = {
  key: 0,
  class: "start-screen"
};
const _hoisted_2$9 = { class: "start" };
const _hoisted_3$9 = { class: "responsive-cont buttons mellow flex-column wmax" };
const _hoisted_4$6 = { class: "wmax flex-row flex-right align-center" };
const _hoisted_5$5 = ["value"];
const _hoisted_6$5 = { key: 0 };
const _hoisted_7$5 = { key: 1 };
const _hoisted_8$5 = { class: "flex-row flex-right" };
const _hoisted_9$5 = { class: "about" };
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "ApkStartScreen",
  props: {
    story: {},
    choices: { default: [] }
  },
  emits: ["start", "reset", "about"],
  setup(__props, { emit: __emit }) {
    useCssVars((_ctx) => ({
      "3518ceec": fadeMs.value,
      "aeffa7b2": zoomMax.value,
      "0f8fce7c": cycleMs.value
    }));
    const props = __props;
    const emits = __emit;
    const backgroundIdx = ref(0);
    const allBackgrounds = ref([]);
    const playMusic = ref(false);
    const pauseMusic = ref(false);
    const show = ref(true);
    const lastTime = ref(Date.now());
    const resumeChoice = ref();
    let updateBackground = 0;
    const choiceList = computed(() => {
      const retval = [];
      const scenes = Array.from(new Set(props.choices.map((c) => c.scene)));
      for (const choice2 of scenes) {
        const scene = props.story.scenes.find((s) => s.id === choice2);
        if (scene) {
          const label = sceneGetText(scene);
          if (label) {
            retval.unshift({ label, value: choice2 });
          }
        }
      }
      return retval;
    });
    const frameWidth = computed(() => {
      var _a;
      return ((_a = landing.value) == null ? void 0 : _a.backgroundCycleSpeed) ?? 8e3;
    });
    const landing = computed(() => {
      var _a;
      return (_a = props.story) == null ? void 0 : _a.landing;
    });
    const titleStyle = computed(() => {
      return props.story.styles.find((s) => {
        var _a;
        return s.id === ((_a = landing.value) == null ? void 0 : _a.titleStyle);
      });
    });
    const backgrounds = computed(() => {
      var _a;
      const selected = (_a = landing.value) == null ? void 0 : _a.backgrounds;
      let all = allBackgrounds.value.slice();
      if (selected && selected.length > 0) {
        all = all.filter((b) => selected.includes(b.blob_id));
      }
      return all.map((b) => b.url);
    });
    const background = computed(() => {
      const idx = backgroundIdx.value;
      if (backgrounds.value.length === 0) {
        return null;
      }
      return backgrounds.value[idx];
    });
    const cycleMs = computed(() => {
      var _a;
      return (((_a = landing.value) == null ? void 0 : _a.backgroundCycleSpeed) ?? 8e3) + "ms";
    });
    const fadeMs = computed(() => {
      var _a;
      return (((_a = landing.value) == null ? void 0 : _a.backgroundFadeSpeed) ?? 1e3) + "ms";
    });
    const zoomMax = computed(() => {
      var _a;
      return ((_a = landing.value) == null ? void 0 : _a.backgroundZoom) ?? 1.5;
    });
    watch(
      () => landing.value,
      async () => {
        show.value = false;
        stopSlideshow();
        await nextTick();
        show.value = true;
        startSlideshow();
      },
      { deep: true }
    );
    watch([playMusic, pauseMusic], () => {
      put("music-volume", !pauseMusic.value && playMusic.value ? 1 : 0);
    });
    onMounted(async () => {
      const mvol = fetch$1("music-volume", 1);
      playMusic.value = mvol > 0;
      for (const image of props.story.backgrounds.filter((b) => b)) {
        const media = await Media.load(image.blob_id);
        if (media) {
          const url = await media.getUrl();
          if (url) {
            allBackgrounds.value.push({ id: image.id, blob_id: image.blob_id, url });
          } else {
            console.log("missing bg url", image.name, "-", image.blob_id, "-", media);
          }
        } else {
          console.log("missing background", image.name, "-", image.blob_id, "-");
        }
      }
      backgroundIdx.value = Math.floor(Math.random() * backgrounds.value.length);
      startSlideshow();
      App$1.addListener("pause", () => {
        stopSlideshow();
        console.log("paused app");
        pauseMusic.value = true;
      });
      App$1.addListener("resume", () => {
        startSlideshow();
        console.log("resumed app");
        pauseMusic.value = false;
      });
    });
    onUnmounted(() => {
      stopSlideshow();
    });
    function startSlideshow() {
      showNextFrame();
    }
    function showNextFrame() {
      if (Date.now() - lastTime.value >= frameWidth.value) {
        backgroundIdx.value = (backgroundIdx.value + 1) % backgrounds.value.length;
        lastTime.value = Date.now();
      }
      updateBackground = window.requestAnimationFrame(showNextFrame);
    }
    function stopSlideshow() {
      clearInterval(updateBackground);
    }
    function canPlay(e2) {
      console.log("can play", e2);
      e2.target.play();
    }
    return (_ctx, _cache) => {
      var _a, _b, _c, _d, _e;
      return show.value ? (openBlock(), createElementBlock("div", _hoisted_1$b, [
        playMusic.value && !pauseMusic.value && ((_a = landing.value) == null ? void 0 : _a.music) ? (openBlock(), createBlock(BlobAudio, {
          key: 0,
          blob: landing.value.music,
          loop: "",
          onLoad: canPlay,
          onCanplaythrough: canPlay
        }, null, 8, ["blob"])) : createCommentVNode("", true),
        background.value ? (openBlock(), createBlock(Transition, {
          key: 1,
          name: "bgfade"
        }, {
          default: withCtx(() => {
            var _a2, _b2;
            return [
              (openBlock(), createElementBlock("div", {
                key: background.value,
                class: normalizeClass(["title-backdrop", {
                  zoomin: ((_a2 = landing.value) == null ? void 0 : _a2.backgroundCycle) === void 0 ? true : (_b2 = landing.value) == null ? void 0 : _b2.backgroundCycle
                }]),
                style: normalizeStyle({ "background-image": `url(${background.value})` })
              }, null, 6))
            ];
          }),
          _: 1
        })) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_2$9, [
          ((_b = landing.value) == null ? void 0 : _b.titleAnimation) ? (openBlock(), createBlock(Animation, {
            key: 0,
            id: (_c = landing.value) == null ? void 0 : _c.titleAnimation,
            animations: _ctx.story.animation
          }, {
            default: withCtx(() => [
              createBaseVNode("div", {
                class: "title-cont responsive-cont header flex-static p-1",
                style: normalizeStyle(unref(textStyle)(titleStyle.value))
              }, [
                createVNode(Typer, {
                  text: _ctx.story.title
                }, null, 8, ["text"])
              ], 4)
            ]),
            _: 1
          }, 8, ["id", "animations"])) : (openBlock(), createElementBlock("div", {
            key: 1,
            class: "title-cont responsive-cont header flex-static p-1",
            style: normalizeStyle(unref(textStyle)(titleStyle.value))
          }, [
            createVNode(Typer, {
              text: _ctx.story.title
            }, null, 8, ["text"])
          ], 4)),
          _cache[8] || (_cache[8] = createBaseVNode("div", { class: "flex-stretch" }, null, -1)),
          createBaseVNode("div", _hoisted_3$9, [
            createBaseVNode("div", _hoisted_4$6, [
              ((_d = landing.value) == null ? void 0 : _d.allowRewind) && choiceList.value.length > 0 ? withDirectives((openBlock(), createElementBlock("select", {
                key: 0,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => resumeChoice.value = $event),
                class: "flex-stretch wmin"
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(choiceList.value, (scene, idx) => {
                  return openBlock(), createElementBlock("option", {
                    value: idx === 0 ? void 0 : scene.value
                  }, toDisplayString$1(scene.label), 9, _hoisted_5$5);
                }), 256))
              ], 512)), [
                [vModelSelect, resumeChoice.value]
              ]) : createCommentVNode("", true),
              createBaseVNode("button", {
                onClick: _cache[1] || (_cache[1] = ($event) => emits("start", resumeChoice.value))
              }, [
                props.choices.length > 0 ? (openBlock(), createElementBlock("span", _hoisted_6$5, "Resume")) : (openBlock(), createElementBlock("span", _hoisted_7$5, "New Game"))
              ]),
              props.choices.length > 0 ? (openBlock(), createElementBlock("button", {
                key: 1,
                onClick: _cache[2] || (_cache[2] = ($event) => emits("reset"))
              }, "Reset")) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_8$5, [
              createBaseVNode("div", _hoisted_9$5, [
                createBaseVNode("a", {
                  onClick: _cache[3] || (_cache[3] = withModifiers(($event) => emits("about"), ["prevent"])),
                  class: "flex-static"
                }, _cache[5] || (_cache[5] = [
                  createTextVNode(" Made with CYOA Factory "),
                  createBaseVNode("span", null, "  ", -1)
                ])),
                _cache[6] || (_cache[6] = createBaseVNode("span", { class: "tiny" }, "SHELL v1.03", -1))
              ])
            ]),
            ((_e = landing.value) == null ? void 0 : _e.music) ? (openBlock(), createElementBlock("a", {
              key: 0,
              onClick: _cache[4] || (_cache[4] = withModifiers(($event) => playMusic.value = !playMusic.value, ["prevent"])),
              class: "music-toggle"
            }, _cache[7] || (_cache[7] = [
              createBaseVNode("i", { class: "fa fa-music" }, null, -1)
            ]))) : createCommentVNode("", true)
          ])
        ])
      ])) : createCommentVNode("", true);
    };
  }
});
const ApkStartScreen = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__scopeId", "data-v-b0ab13cf"]]);
const _sfc_main$d = {
  name: "comments",
  props: {
    story: String,
    remoteApi: Function
  },
  data() {
    return {
      status: null,
      content: "",
      comments: [],
      page: 1
    };
  },
  computed: {
    filteredComments() {
      return this.comments.filter((c) => {
        return this.$root.blockedUsers.indexOf(c.uid) === -1;
      });
    }
  },
  async mounted() {
    await this.fetchComments();
  },
  methods: {
    async fetchComments(page = 1) {
      if (this.story) {
        const response = await this.remoteApi("public_comments", {
          fid: this.story,
          page
        });
        if (!response.error) {
          this.comments = response.list;
          this.comments.sort(sortby("timestamp"));
        }
      }
    },
    async removeComment(comment) {
      if (confirm(this.$t("comments.remove-this-comment"))) {
        await this.remoteApi("public_comment_remove", {
          fid: this.story,
          id: comment.id
        });
        await this.fetchComments();
        this.status = null;
      }
    },
    async saveComment() {
      if (this.status === "typing") {
        await this.remoteApi("public_comment", {
          fid: this.story,
          content: this.content
        });
        this.content = "";
        await this.fetchComments();
        this.status = null;
      } else {
        this.status = "typing";
      }
    }
  }
};
const _hoisted_1$a = {
  key: 0,
  class: "comments static"
};
const _hoisted_2$8 = {
  key: 0,
  class: "comment-list"
};
const _hoisted_3$8 = { class: "meta row center" };
const _hoisted_4$5 = { class: "meta-date" };
const _hoisted_5$4 = ["onClick"];
const _hoisted_6$4 = { class: "content row" };
const _hoisted_7$4 = { class: "row padded space-around" };
const _hoisted_8$4 = ["placeholder"];
const _hoisted_9$4 = {
  key: 1,
  class: "button"
};
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_user_tag = resolveComponent("user-tag");
  const _component_moderation_flag = resolveComponent("moderation-flag");
  return $props.story ? (openBlock(), createElementBlock("div", _hoisted_1$a, [
    $data.comments.length > 0 ? (openBlock(), createElementBlock("ul", _hoisted_2$8, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.filteredComments.slice(-100, $data.comments.length), (comment) => {
        return openBlock(), createElementBlock("li", {
          key: comment.id,
          class: "comment column"
        }, [
          createBaseVNode("div", _hoisted_3$8, [
            createBaseVNode("div", _hoisted_4$5, toDisplayString$1(new Date(comment.timestamp * 1e3).toLocaleString()), 1),
            createVNode(_component_user_tag, {
              uid: comment.uid
            }, null, 8, ["uid"]),
            comment.uid === _ctx.$root.user.id || _ctx.$root.isEditor ? (openBlock(), createElementBlock("a", {
              key: 0,
              class: "static remove-comment",
              onClick: ($event) => $options.removeComment(comment)
            }, "  ", 8, _hoisted_5$4)) : (openBlock(), createBlock(_component_moderation_flag, {
              key: 1,
              source: `Story/${$props.story}/Comments/${comment.id}@${comment.uid}`,
              content: comment.content,
              user: comment.uid
            }, null, 8, ["source", "content", "user"]))
          ]),
          createBaseVNode("div", _hoisted_6$4, toDisplayString$1(comment.content.trim()), 1)
        ]);
      }), 128))
    ])) : createCommentVNode("", true),
    createBaseVNode("div", _hoisted_7$4, [
      createBaseVNode("button", {
        onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.fetchComments && $options.fetchComments(...args), ["prevent"]))
      }, _cache[5] || (_cache[5] = [
        createBaseVNode("i", { class: "fa fa-refresh" }, null, -1)
      ])),
      $data.status == null ? (openBlock(), createElementBlock("button", {
        key: 0,
        onClick: _cache[1] || (_cache[1] = ($event) => {
          $data.status = "typing";
        }),
        class: "button"
      }, toDisplayString$1(_ctx.$t("comments.share-your-thoughts")), 1)) : createCommentVNode("", true)
    ]),
    createBaseVNode("form", {
      class: "form",
      onSubmit: _cache[4] || (_cache[4] = withModifiers((...args) => $options.saveComment && $options.saveComment(...args), ["prevent"]))
    }, [
      $data.status == "typing" ? withDirectives((openBlock(), createElementBlock("textarea", {
        key: 0,
        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.content = $event),
        placeholder: _ctx.$t("comments.type-your-comment-here"),
        required: ""
      }, null, 8, _hoisted_8$4)), [
        [vModelText, $data.content]
      ]) : createCommentVNode("", true),
      $data.status == "typing" ? (openBlock(), createElementBlock("button", _hoisted_9$4, [
        _cache[6] || (_cache[6] = createBaseVNode("i", { class: "fa fa-upload" }, null, -1)),
        createTextVNode(" " + toDisplayString$1(_ctx.$t("comments.submit-comment")), 1)
      ])) : createCommentVNode("", true),
      $data.status == "typing" ? (openBlock(), createElementBlock("button", {
        key: 2,
        class: "button",
        onClick: _cache[3] || (_cache[3] = withModifiers(($event) => $data.status = null, ["prevent"]))
      }, "  " + toDisplayString$1(_ctx.$t("story_reader.cancel")), 1)) : createCommentVNode("", true)
    ], 32)
  ])) : createCommentVNode("", true);
}
const Comments = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$a], ["__scopeId", "data-v-9a1cd53c"]]);
const alignment = "Alignment";
const en = {
  "App.error": "Error",
  "account.account": "Account",
  "account.account-recovered": "Account recovered!",
  "account.avatar": "Avatar",
  "account.bio": "This will be displayed to your readers at the end of all of your stories just above your donation and social media links",
  "account.email": "Email",
  "account.email-purpose": "Used for account recovery",
  "account.failed-to-recover-sorry": "Failed to recover, sorry",
  "account.link": "Website Link",
  "account.link-description": "Link to your social media, website or about page",
  "account.recover": "Recover",
  "account.save": "Save",
  "account.short-description": "Short Description",
  "account.unable-to-contact-server-at-this-time": "Unable to contact server at this time",
  "account.user-saved": "User saved!",
  "account.username": "Username",
  "account.well-send-a-code-to-this-email-to-recover-your-account": "We'll send a code to this email to recover your account",
  "achievement_content.achievement-will-not-be-revealed-on-story-detail-page": "Achievement information will not be revealed on story detail page",
  "achievement_content.achievements-track-user-progress-and-can-show-shiny-popups": "Achievements track user progress and can show shiny popups",
  "achievement_content.add-title-text": "Add Title Text",
  "achievement_content.adding-a-code-will-save-reader-statistics": "Adding a code will save reader statistics",
  "achievement_content.animation": "Animation",
  "achievement_content.choose": "Choose...",
  "achievement_content.code": "Code",
  "achievement_content.hidden": "Hidden",
  "achievement_content.large": "Large",
  "achievement_content.readers-will-not-see-a-popup": "Readers will not see a popup",
  "achievement_content.silent": "Silent",
  "achievement_content.small": "Small",
  "action_content.type-action-text-here": "Type action text here",
  "admin.admin": "Admin",
  "advanced.generate-choices-from-list": "Generate Choices From List:",
  "advanced.iterate-from-list": "Iterate From List:",
  "advanced.mark-scenes-as-microcosms-instead": "Mark scenes as microcosms instead",
  "advanced.shared-points": "Shared Points:",
  "advanced.twig-templates": "Twig templates",
  "agreement.any-of-your-public-content-found-objectionable-may-be-removed": "Any of your public content found objectionable may be removed.",
  "agreement.i-understand-and-accept-these-terms": "I understand and accept these terms",
  "agreement.media-depicting-explicit-nudity-or-real-world-violence-is-not-allowed": "Media depicting explicit nudity or real-world violence is not allowed.",
  "agreement.no-personal-information-is-required-to-use-the-app-and-no-information-collected-is-sold-to-third-parties": "No personal information is required to use the app, and no information collected is sold to third parties.",
  "agreement.online-content-policy": "Online Content Policy",
  "agreement.this-app-has-user-generated-content-heres-our-policy-on-that": "This app has user generated content, here's our policy on that:",
  "agreement.you-may-share-your-email-with-morphosis-games-for-account-recovery": "You may share your email with Morphosis Games for account recovery.",
  "agreement.your-username-bio-media-links-and-published-content-will-be-publically-available": "Your username, bio, media links and published content will be publically available.",
  "animation.animating": "Animating...",
  "animation.duration": "Duration",
  "app.beta": "BETA",
  "app.delete-this-object-name": "Delete: {name}?",
  "app.loading": "Loading",
  "app_status.loading": "Loading",
  "area.remaining-points": "Remaining Points:",
  "audio_clips.audio-clips-are-short-clips-that-play-in-the-foreground": "Audio clips are short clips that play in the foreground.",
  "audio_clips.story-title-audio-clips": "{story_title}: Audio Clips",
  "audio_clips.you-currently-dont-have-any-audio-clips-for-this-story": "You currently don't have any audio clips for this story",
  "audio_content.audio-clip": "Audio Clip",
  "audio_content.audio-help": "Audio clips are short clips that play in the foreground. The story will wait for the clip to finish before proceeding.",
  "audio_content.no-clip-chosen": "- No Clip Chosen -",
  "audio_content.upload-audio-clip": "Upload audio clip:",
  "audio_modal.select-audio-clip": "Select Audio Clip",
  "audio_modal.select-music": "Select Music",
  "audio_modal.url-permalink": "URL / Permalink",
  "author_plug.written-by": "Written by:",
  "autogrow_text.help-for-advanced-editing-you-can-use-basic-templating": "For advanced editing, you can use basic templating",
  "autogrow_text.insert-tag": "Insert Tag:",
  "autogrow_text.insert-tag-0": "Insert Tag...",
  "autogrow_text.overwrite": "Overwrite?",
  "autogrow_text.style": "Style:",
  "autogrow_text.style-choice--story-default": "Story Default",
  "background_content.allow-the-user-to-explore-the-background": "Allow the user to explore the background",
  "background_content.background-color": "Background Color:",
  "background_content.choose-background": "Choose Background",
  "background_content.cover-the-device-surface-some-of-the-image-will-be-cut-off": "Cover the device surface (some of the image will be cut off)",
  "background_content.create-new-background": "Create new background",
  "background_content.default-is-cover": "(default is cover)",
  "background_content.remove-background": "Remove Background",
  "background_content.show-the-whole-background-short-sides-will-be-filled-with-the-background-color": "Show the whole background (short sides will be filled with the background color)",
  "backgrounds.backgrounds-description": "Backgrounds are just large images shown in the background of the story.",
  "backgrounds.backgrounds-description2": "Images should generally be portrait instead of landscape, they will be automatically fit to screen",
  "backgrounds.backgrounds-empty": "You currently don't have any background images for this story",
  "backgrounds.bad-permalink": "Sorry, this url is not valid",
  "backgrounds.form-field-name": "Name",
  "backgrounds.form-field-permalink": "Permalink",
  "backgrounds.form-field-upload": "Upload",
  "battle.change-action": "Change Action",
  "battle.dead": "Dead",
  "battle.do-nothing": "Do Nothing",
  "battle.proceed": "Proceed",
  "battle.there-was-supposed-to-be-a-battle-here-but-it-looks-like-no-contestants-showed-up": "There was supposed to be a battle here, but it looks like no contestants showed up.",
  "battle.there-was-supposed-to-be-a-battle-here-but-only-one-side-showed-up": "There was supposed to be a battle here, but only one side showed up.",
  "battle_content.antagonists": "Antagonists",
  "battle_content.battles-enter-a-different-reading-mode-where-the-player-can-battle-against-other-characters-place-battle-participants-above-in-contestant-directions": 'Battles enter a different reading mode where the player can battle against other characters. Place battle participants above in "contestant" directions.',
  "battle_content.protagonists": "Protagonists",
  "battle_content.rounds": "Rounds",
  "battle_content.save-result-to": "Save result to:",
  "battle_content.stop-battle-after": "Stop battle after",
  "battle_effects.character-sheet-name-is-dead": "{character_name} is dead",
  "battle_effects.character-uses-action": "{character_name} uses {action_name}...",
  "battle_effects.failure": "Failure!",
  "battle_effects.next": "Next",
  "battle_effects.success": "Success!",
  "blob_image.missing-image": "Missing image",
  "bug_report.contact-email-address": "Contact Email Address",
  "bug_report.please-describe-the-problem": "Please describe the problem",
  "change_start.change-start-scene": "Change Starting Scene",
  "change_start.change-the-starting-scene": "Change the starting scene",
  "character.character-images": "Character Images",
  "character.character-states": "Character States",
  "character.form-field-aura": "Aura",
  "character.form-field-image-default-position": "Default Position",
  "character.form-field-image-label": "Label",
  "character.form-field-image-name": "Name",
  "character.form-field-image-permalink": "Permalink",
  "character.form-field-name": "Name",
  "character.form-field-padding": "Padding",
  "character.form-field-width": "Width (pixels)",
  "character.hide-advanced-image-options": "Hide Advanced Image Options",
  "character.image-position-center": "Center",
  "character.image-position-default": "Default",
  "character.image-position-left": "Left",
  "character.image-position-right": "Right",
  "character.notes": "Notes",
  "character.set-a-tag-if-you-need-to-change-character-traits-in-the-story": "Set a tag if you need to change character traits in the story",
  "character.show-advanced-image-options": "Show Advanced Image Options",
  "character.upload-images-for-each-character-state-with-examples": 'Upload images for each character state. Happy, Angry, Flirty, or a single "default" image',
  "character_modal.change-character": "Change Character",
  "character_modal.character-list": "Character List",
  "character_modal.select-character": "Select Character",
  "characters.breadcrumb-characters": "Characters",
  "characters.no-characters-yet": "No characters yet",
  "characters.unnamed-character": "Unnamed",
  "choice_content.change-group": "Change Group:",
  "choice_content.microcosm": "Microcosm",
  "choice_content.multiplayer": "Multiplayer",
  "choice_content.return-here-when-finished": "Return here when finished",
  "choice_content.split-explanation": "If set, players who choose this will be put into the named group",
  "choice_line.linked-scene-will-return-here-it-is-a-microcosm": "Linked scene will return here (it is a microcosm)",
  "choice_line.not-linked": "Not Linked",
  "choices.scan-a-qr-code": "Scan a QR code",
  "client.begin": "Begin",
  "client.browse-the-online-library": "browse the online library",
  "client.exit": "Exit",
  "client.host-game": "Host Game",
  "client.join-game": "Join Game",
  "client.loading-story": "Loading story...",
  "client.my-status": "My Status:",
  "client.share-code": "share code:",
  "client.share-or-publish": "Share or publish your stories or {0}",
  "client.you-can-use-any-shared-or-published-story": "You can use any shared or published story",
  "client.you-dont-have-any-stories-to-read": "You don't have any stories to read.",
  "cloud_list.delete-file-key": "Delete? {filename} THERE IS NO UNDO\n{warnings}",
  "cloud_safe.child-sexual-abuse": "Child sexual abuse",
  "cloud_safe.cloud-images-should-be-safe-for-most-audiences-to-view": "Cloud images should be safe for most audiences to view",
  "cloud_safe.copyrighted-material-unless-you-are-the-copyright-holder": "Copyrighted material unless you are the copyright holder",
  "cloud_safe.explicity-the-following-types-of-images-are-not-allowed": "Explicity the following types of images are not allowed:",
  "cloud_safe.extreme-gore-abuse-or-violence": "Extreme gore, abuse or violence",
  "cloud_safe.nudity-or-sexually-explicit-content": "Nudity or sexually explicit content",
  "cloud_safe.personal-information-or-doxing": "Personal information or doxing",
  "cloud_safe.spam-or-blank-images-use-a-background-color-instead": "Spam or blank images (use a background color instead)",
  "cloud_safe.violating-images-will-be-removed-and-future-uploading-may-be-suspended": "Violating images will be removed and future uploading may be suspended",
  "cloud_safe.you-can-use-whatever-images-you-wish-for-stories-on-your-local-device": "You can use whatever images you wish for stories on your local device",
  "color_dialog.opacity": "Opacity:",
  "color_dialog.transparent": "Transparent",
  "command_search_popup.check-tag": "Check tag",
  "command_search_popup.create-direction": "Create '{direction_type}' Direction",
  "command_search_popup.create-formula-effect": "Create Formula Effect",
  "command_search_popup.create-formula-test": "Create Formula Test",
  "command_search_popup.creating": "creating...",
  "command_search_popup.debug-fill-this-scene-with-directions": "[DEBUG] fill this scene with directions",
  "command_search_popup.delete-direction": "Delete Direction",
  "command_search_popup.dice": "dice",
  "command_search_popup.duplicate": "Duplicate",
  "command_search_popup.duplicate-except-text": "Duplicate (except text)",
  "command_search_popup.duplicate-scene": "Duplicate scene",
  "command_search_popup.executing-command": "Executing command",
  "command_search_popup.export-story-json": "Export Story JSON",
  "command_search_popup.go-to-previous-scene": "Go to Previous Scene",
  "command_search_popup.keyword-tag": "tag",
  "command_search_popup.keywords-delete-remove-erase": "delete remove erase",
  "command_search_popup.move-direction-down": "Move Direction Down",
  "command_search_popup.move-direction-up": "Move Direction Up",
  "command_search_popup.roll-a-dice-dice": "Roll a Dice ({dice})",
  "command_search_popup.search-commands": "Search commands",
  "command_search_popup.set-tag": "Set tag",
  "command_search_popup.split-this-and-below-into-a-new-scene": "Split scene here  ",
  "comments.remove-this-comment": "Remove this comment?",
  "comments.share-your-thoughts": "Share your thoughts",
  "comments.submit-comment": "Submit Comment",
  "comments.type-your-comment-here": "Type your comment here",
  "confirm_button.confirm": "Confirm?",
  "contestant_content.antagonist": "Antagonist",
  "contestant_content.create-new": "Create New",
  "contestant_content.enters-a-character-into-battles-put-a-battle-direction-under-all-contestants": 'Enters a character into battles. Put a "battle" direction under all contestants.',
  "contestant_content.go": "Go",
  "contestant_content.orientation": "Orientation:",
  "contestant_content.protagonist": "Protagonist",
  "contestant_content.reset-character-stats": "Reset Character Stats?",
  "contestant_content.youll-need-to-create-a-character": "You'll need to create a character",
  "daily_tip.showTutorials": "Show tutorials",
  "daily_tip.tutorialOfTheDay": "Tutorial of the day",
  "dashboard.audio-clip": "Audio Clips",
  "dashboard.background": "Background | Backgrounds",
  "dashboard.background-music": "Background Music",
  "dashboard.backup-your-work": "Backup your work",
  "dashboard.blueprint-or-blueprints": "Blueprint | Blueprints",
  "dashboard.change-start-scene": "",
  "dashboard.character": "Character | Characters",
  "dashboard.character-sheet": "",
  "dashboard.cloud-sync": "Cloud Sync",
  "dashboard.comment-notifications": "Comment notifications",
  "dashboard.connection_off": "Off",
  "dashboard.connection_on": "On",
  "dashboard.continue-reading": "Continue reading",
  "dashboard.continue-writing": "Continue writing",
  "dashboard.export-backup": "Export Backup",
  "dashboard.find-a-scene-by-title-or-content": "Find a scene by title or content",
  "dashboard.images": "Images",
  "dashboard.more-options": "More Options",
  "dashboard.publish-on-websites-and-appstores": "Publish on Websites and Appstores",
  "dashboard.read-your-multiplayer-story": "Read your multiplayer story",
  "dashboard.read-your-story": "Read your story",
  "dashboard.reader-page": "Reader Page",
  "dashboard.remove-published-story": "Remove published story",
  "dashboard.reveal-your-masterpiece": "Reveal your masterpiece!",
  "dashboard.save-cloud-description": "Save cloud backup and synchronize stories between devices",
  "dashboard.scene": "Scene | Scenes",
  "dashboard.scene-list": "Scene List",
  "dashboard.scene-overview": "Overview",
  "dashboard.search-scenes": "Search Scenes",
  "dashboard.share-code": "Share code",
  "dashboard.show-scenes-linked-in-a-graph": "Show scenes linked in a graph",
  "dashboard.start-writing": "Start writing",
  "dashboard.story-stats-and-comments": "Story stats and comments",
  "dashboard.tag": "Tag | Tags",
  "dashboard.text-style": "Text Style | Text Styles",
  "dashboard.unshare": "Unshare",
  "dashboard.unshare-story": "Unshare story",
  "dashboard.update-published-story": "Update published story ({storyId})",
  "dashboard.update-shared-story": "Update shared story",
  "dashboard.you-ll-need-at-least-x-scenes-to-publish": "You'll need at least {number} scenes to publish",
  "detail.decimal-places": "decimal places",
  "detail.edit": "Edit",
  "detail.edit-character": "Edit Character",
  "detail.number-precision": "Number Precision",
  "detail.pick-a-category": "Pick a category",
  "detail.references": "References",
  "detail.story-meta-data": "Story Meta Data",
  "detail.tag-names-rules": "Tag names must start with a letter and names can only include letters, numbers or underscore",
  "direction.achievement": "achievement",
  "direction.all-choices-will-be-removed": "All choices will be removed",
  "direction.choice-timer": "choice timer",
  "direction.choice-timer-help": "Place a choice timer under a list of choices. If the user doesn't pick a choice within the given number of seconds, the story will continue to the `fallback` scene",
  "direction.create-backgrounds": "Create Backgrounds",
  "direction.delete-this-direction": "Delete this direction?",
  "direction.empty-help": "A direction that does nothing, you can use it to alter tags for future directions",
  "direction.fallback": "Fallback:",
  "direction.if-requirements-arent-met-this-direction-will-be-hidden": "If requirements aren't met, this direction will be hidden",
  "direction.input-suggestion-help": "Suggestions are for users who don't want to type their own input",
  "direction.option": "option",
  "direction.party": "Party",
  "direction.redirect-help": "Automatically routes to a different scene without a user interaction",
  "direction.return": "Return",
  "direction.return-help": "Automatically routes to the previous scene and resumes where it left",
  "direction.seconds": "Seconds",
  "direction.set-tags": "Set Tags",
  "direction.setting-tags-can-help-hide-or-show-future-directions": "Setting tags can help hide or show future directions",
  "direction.tag-requirements": "Tag Requirements",
  "direction.tags-help": "Tags are used to control which choices can be seen by the player.",
  "direction.thoughts-help": "Thoughts appear when a choice is selected and let the player reconsider",
  "direction.type-choice-text-here": "Type choice text here",
  "direction.unknown-direction": "Unknown Direction",
  "directionGroup.advanced": "Advanced",
  "directionGroup.battle": "Battle",
  "directionGroup.media": "Media",
  "directionGroup.multiplayer": "Multiplayer",
  "directionGroup.standard": "Standard",
  "directionType.achievement": "achievement",
  "directionType.action": "action",
  "directionType.audio": "audio",
  "directionType.background": "background",
  "directionType.battle": "battle",
  "directionType.choice": "choice",
  "directionType.choice-timer": "timer",
  "directionType.clear": "Clear",
  "directionType.contestant": "contestant",
  "directionType.empty": "empty",
  "directionType.event": "event",
  "directionType.group": "randomize",
  "directionType.image": "image",
  "directionType.input": "input",
  "directionType.layout": "layout",
  "directionType.lighting": "lighting",
  "directionType.music": "music",
  "directionType.notes": "notes",
  "directionType.option": "option",
  "directionType.party": "party",
  "directionType.pause": "pause",
  "directionType.redirect": "redirect",
  "directionType.return": "return",
  "directionType.text": "text",
  "directionType.timer": "timer",
  "directionType.video": "video",
  "direction_effect.action-result": "- Action result -",
  "direction_effect.add-the-value-of": "Add the value of...",
  "direction_effect.add-to-list": "Add to list",
  "direction_effect.append": "Append",
  "direction_effect.append-the-value-of": "Append the value of...",
  "direction_effect.contains": "Contains",
  "direction_effect.doesnt-contain": "Doesn't Contain",
  "direction_effect.effects": "Effects",
  "direction_effect.erase": "Erase",
  "direction_effect.evaluate-formula": "Evaluate formula...",
  "direction_effect.gives": "Gives",
  "direction_effect.has-any-value-except-0": "Has any value (except 0)",
  "direction_effect.is": "Is",
  "direction_effect.is-empty": "Is Empty",
  "direction_effect.is-equal-or-lesser-than": "Is equal or lesser than",
  "direction_effect.is-equal-or-lesser-than-0": "Is equal or lesser than...",
  "direction_effect.is-equal-to": "Is equal to",
  "direction_effect.is-greater-or-equal-to": "Is greater or equal to",
  "direction_effect.is-greater-or-equal-to-0": "Is greater or equal to...",
  "direction_effect.is-longer-than": "Is longer than",
  "direction_effect.is-same-as": "Is same as...",
  "direction_effect.isnt": "Isn't",
  "direction_effect.isnt-empty": "Isn't Empty",
  "direction_effect.isnt-the-same-as": "Isn't the same as...",
  "direction_effect.operation": "Operation",
  "direction_effect.push-to-end": "Push to end",
  "direction_effect.reference-instance": "Reference instance",
  "direction_effect.remove-from-list": "Remove from list",
  "direction_effect.remove-reference": "Remove reference",
  "direction_effect.requirement-or-effect": "- Requirement or Effect -",
  "direction_effect.requirements": "Requirements",
  "direction_effect.set-to": "Set to",
  "direction_effect.set-to-formula-result": "Set to formula result...",
  "direction_effect.set-to-the-value-of": "Set to the value of...",
  "direction_effect.shift-off-start": "Shift off start",
  "direction_effect.sub-the-value-of": "Sub the value of...",
  "direction_effect.takes": "Takes",
  "direction_effect.transfer-list": "transfer list",
  "empty_content.process-from-a-list": "Process From A List",
  "event_content.event-details": "Event Details",
  "event_content.event-name": "Event Name",
  "event_content.events-are-for-stories-intended-to-be-used-in-external-applications-they-send-a-message-and-wait-for-the-program-to-be-resumed": "Events are for stories intended to be used in external applications. They send a message and wait for the program to be resumed.",
  "export_apk.export-standalone": "Export Standalone",
  "export_backup.all": "all",
  "export_backup.compress-to-zip-file": "Compress to .zip file?",
  "export_backup.export": "Export",
  "export_backup.export-selected": "Export Selected",
  "export_backup.export-story-data-info": "Export story data and all media files. You can use it in a game, in an application or save it as a backup",
  "export_backup.export-story-title": "Export `{story_title}`?",
  "export_backup.exporting": "Exporting",
  "export_backup.none": "none",
  "export_backup.story-data": "Story Data",
  "export_backup.you-can-also-make-a-standalone-export": "You can also make a standalone export",
  "feedback.contact-email-optional": "Contact Email (optional)",
  "feedback.discord-pitch": "If you need help or creative advice you can talk to devs and other writers on discord.",
  "feedback.donate-plea": "Also, if you are inclined, please support us with a small donation",
  "feedback.i-found-a-bug": "I found a bug",
  "feedback.i-have-a-feature-suggestion": "I have a feature suggestion",
  "feedback.nope-im-already-awesome": "Nope, I'm already awesome",
  "feedback.please-type-something-before-sending": "Please type something before sending",
  "feedback.rate-this-app": "Rate this app",
  "feedback.review-plea": "If you are enjoying the app, please give us a review.",
  "feedback.submit": "Submit",
  "feedback.support-us": "Support Us",
  "feedback.thanks-for-your-feedback": "Thanks for your feedback!",
  "formula_input.ex-str-5-or-dex-1-3": "Ex: STR + 5 -or- DEX * 1.3",
  "formula_popup.something-is-wrong-with-your-formula-ex": "Something is wrong with your formula ({error})",
  "formula_popup.tags-are-not-allowed-to-start-with": "Tags must not start with $",
  "formula_popup.type-your-formula": "Type your formula:",
  "genres.adventure": "Adventure",
  "genres.dating": "Dating",
  "genres.escape": "Escape",
  "genres.experimental": "Experimental",
  "genres.fantasy": "Fantasy",
  "genres.horror": "Horror",
  "genres.modern": "Modern",
  "genres.mystery": "Mystery",
  "genres.other": "Other",
  "genres.psychological-horror": "Psychological Horror",
  "genres.sci-fi": "Sci-Fi",
  "genres.simulation": "Simulation",
  "genres.survival": "Survival",
  "genres.visual-novella": "Visual Novella",
  "genres.zombie": "Zombie",
  "group_content.directions-with-a-zero-value-probability": "Directions with a zero value probability",
  "group_content.tap-on-the-cube": "Tap on the cube to make a direction more likely to be picked.",
  "group_content.this-will-bundle-the-following-directions-of-the-same-type-and-randomly-show-one-of-them": "This will bundle the following directions of the same type and randomly show one of them.",
  "group_content.will-only-be-used-if-no-other-direction-matches": "will only be used if no other direction matches",
  "help.filter-tutorials": "Filter tutorials",
  "home.browse-all-stories": "Browse All Stories",
  "home.create-story": "Create Story",
  "home.create-story-prompt": "Ready to create a new story?",
  "home.delete-this-story-warning": "Delete this story: '{title}'? There is no UNDO",
  "home.download": "Download",
  "home.get-started": "Get Started",
  "home.help-translate": "Help translate",
  "home.import-backup-story": "Import from backup file",
  "home.import-stories-from-previous-version": "Import Stories from Previous Version",
  "home.mini-tutorials": "Mini Tutorials",
  "home.my-library": "Library",
  "home.my-stories": "My Stories",
  "home.news": "News",
  "home.notifications": "Notifications",
  "home.offline": "Offline",
  "home.online": "Online",
  "home.read": "Read",
  "home.tap-here-for-app-news-and-updates": "Tap here for app news and updates",
  "home.tap-here-to-browse-published-stories": "Tap here to browse published stories",
  "home.tap-here-to-customize-your-app-theme": "Tap here to customize your app theme",
  "home.tap-here-to-write-stories": "Tap here to write stories",
  "home.translation-warning": "Our translations are community translated and might not be perfect.",
  "home.tutorials-and-writing-help": "Tutorials and Writing Help",
  "home.unpublish-this-story-as-well": "Unpublish this story as well?",
  "home.update-author-profile": "Update Author Profile",
  "home.write": "Write",
  "home.your-library-is-empty": "Your library is empty",
  "image_content.add-image": "Add Image",
  "image_content.change-image": "Change Image",
  "image_content.choose-an-image": "Choose an image:",
  "image_content.delete-this-image": "Delete this image?",
  "image_content.images-are-shown-in-the-foreground-the-story-will-wait-for-the-user-to-click-the-image": "Images are shown in the foreground. The story will wait for the user to click the image.",
  "image_content.optional-permalink": "Optional: Permalink",
  "image_content.upload-image": "Upload image",
  "import_backup.cancel": "Cancel",
  "import_backup.downloading": "Downloading...",
  "import_backup.import": "Import",
  "import_backup.import-backup": "Import Backup",
  "import_backup.import-file": "Import File",
  "import_backup.imports-a-story-from-a-json-file": "Imports a story from a JSON file.",
  "import_backup.it-will-overwrite-if-it-finds-the-same-story-on-this-device": "It will overwrite if it finds the same story on this device",
  "import_backup.sorry-failed-to-read-file": "Sorry, failed to read file",
  "import_backup.sorry-this-isnt-a-story-file": "Sorry, this isn't a story file",
  "index.create-animation": "Create animation",
  "input_content.choose": "- Choose -",
  "input_content.input-prompt": "Input Prompt",
  "input_content.item-attribute": "Item Attribute",
  "input_content.max-points": "Max Points",
  "input_content.store-value-in": "- Store value in... -",
  "input_content.tag-input-notice": "User input must be: `{format}`, change the tag format to change the data format",
  "input_content.unlimited": "Unlimited",
  "languages.english": "English",
  "languages.french": "French",
  "languages.german": "German",
  "languages.hungarian": "Hungarian",
  "languages.indonesian": "Indonesian",
  "languages.italian": "Italian",
  "languages.korean": "Korean",
  "languages.other": "Other",
  "languages.portuguese": "Portuguese",
  "languages.russian": "Russian",
  "languages.serbian": "Serbian",
  "languages.spanish": "Spanish",
  "layout.back": "Back",
  "layout.read-again": "Read Again?",
  "layout.this-will-erase-all-player-data-for-this-story": "This will erase all player data for this story",
  "layout_content.speaker": "Speaker",
  "list.add-button-label": "Add",
  "list.create-new-tag": "Create new tag",
  "list.create-tag-filter": "Create tag `{tag}",
  "list.type-to-filter-tags": "Type to filter tags",
  "list_detail.empty": "Empty :(",
  "media_uploader.cancel": "Cancel",
  "media_uploader.cloud-safe": "Cloud Safe",
  "media_uploader.confirm": "Confirm",
  "media_uploader.failed-to-upload-file": "Failed to upload file",
  "media_uploader.gallery": "Gallery",
  "media_uploader.remove": "Remove",
  "media_uploader.remove-media": "Remove media?",
  "media_uploader.repair": "Repair",
  "media_uploader.send-to-cloud": "Send to Cloud",
  "media_uploader.switch": "Switch",
  "media_uploader.url": "URL",
  "media_uploader.url-permalink": "URL / Permalink",
  "moderation_report.block-this-user": "Block this user",
  "moderation_report.block-user": "Block User?",
  "moderation_report.blocked": "Blocked!",
  "moderation_report.blocking-explained": "Blocking a user will hide all comments and stories from this user. You can unblock a user in the settings",
  "moderation_report.cyoa-moderation-report": "CYOA Moderation Report",
  "moderation_report.describe-the-problem-here": "Describe the problem here",
  "moderation_report.email-address": "Email Address",
  "moderation_report.report-content": "Report Content",
  "moderation_report.thank-you-we-will-review-your-submission": "Thank you, we will review your submission",
  "moderation_report.this-user-is-now-blocked-you-can-change-this-in-the-settings": "This user is now blocked, you can change this in the settings",
  "moderation_report.what-is-objectionable-about-this-content": "What is objectionable about this content?",
  "moderation_report.your-email-address": "Your Email Address",
  "morphosis-games-discord": "Morphosis Games Chat",
  "multiplayer.if-a-group-is-set-a-limited-number-of-players-will-be-split-away-from-the-current-party": "If a group is set, a limited number of players will be split away from the current party",
  "multiplayer.if-set-these-groups-must-be-present-at-this-exact-direction-before-the-story-can-continue": "If set, these groups must be present at this exact direction before the story can continue",
  "multiplayer.player-count": "Player Count:",
  "multiplayer.type-a-group-to-wait-for": "Type a group to wait for",
  "multiplayer.wait-for": "Wait for:",
  "music_content.music-help": "Music will play in the background and will not pause the story",
  "music_content.music-will-stop-playing": "Music will stop playing",
  "music_content.play-clip": "Play {media} once",
  "music_content.play-music": "Play {media} continuously",
  "music_content.silence": "- Silence -",
  "music_content.silence-0": "Silence",
  "music_content.silence-all-sound-effects": "Silence all sound effects",
  "music_content.upload-music-clip": "Upload Music clip:",
  "newsfeed.no-news-is-good-news": "No news is good news?",
  "notes_content.add-task": "Add task...",
  "notes_content.notes-help": "Notes are not rendered as part of the story, they are intended to help you organize your thoughts",
  "notes_content.record-notes-here": "Record notes here",
  "notifications.failed-to-fetch-notification-list-error": "Failed to fetch notification list: {error}",
  "notifications.hit-the-bell": "Hit the bell icon on stories and news to listen for updates",
  "notifications.no-notifications": "No notifications",
  "notifications.object-title-on-object-file-title": "{title} on {file}:",
  "notifications.sorry-this-notifications-subject-has-been-deleted": "Sorry, this notification's subject has been deleted",
  "operation_array.add-tags": "Add Tags",
  "option_content.max-value-max": "Max: {max}",
  "option_content.min-value-min": "Min: {min}",
  "option_content.option-directions-require-overlayout": '`Option` directions only work with "Over Layout" turned on in the {0}',
  "option_content.settings": "settings",
  "option_content.step-value-step": "Step: {step}",
  "permalink.advice": "Publishing story space is limited. If you intend to publish your story, consider permalinks for your assets instead of uploading files.",
  "permalink.create": "You can get a URL from your files in Dropbox, GitHub and other services to use as the permalink.",
  "permalink.rights-warning": "Do not add a permalink for files you don't have rights to",
  "reader.comments": "Comments",
  "reader.edit-this-scene": "Edit this Scene",
  "reader.reset-story": "Reset Story",
  "reader.restart-story": "Restart Story",
  "reader.story-home": "Story Home",
  "scene.add-direction": "Add Direction",
  "scene.clipboard-is-not-empty-clipped": "Clipboard is not empty, clipped data will be lost. Proceed?",
  "scene.cut-all-selected-directions": "Cut all selected? (There is no UNDO)",
  "scene.delete-all-selected-directions": "Delete all selected? (There is no UNDO)",
  "scene.delete-this-scene": "Delete this scene",
  "scene.delete-this-scene-warning": "Delete this scene? You'll have to reattach choices manually.",
  "scene.previous": "Prev",
  "scene.saved": "Saved",
  "scene.scene-microcosm-tutorial": "A microcosm scene will return the reader to the next direction in the scene they came from",
  "scene.scene-title": "Scene Title",
  "scene.show-mini-tutorials": "Show mini tutorials",
  "scene.syncing": "Syncing...",
  "scene.wordcount-words": "0 words | 1 word | {count} words",
  "scene_color_popup.no-color": "No Color",
  "scene_color_popup.scene-color": "Scene Color:",
  "scene_read.assign-start-scene": "Assign Start Scene",
  "scene_read.bookmark-saved": "Bookmark Saved",
  "scene_read.looks-like-this-part-of-the-story-is-missing": "Looks like this part of the story is missing",
  "scene_read.overwrite-previous-bookmark": "Overwrite Previous Bookmark?",
  "scene_read.restart-story": "Restart Story?",
  "scene_read.rewind-to-bookmark": "Rewind to bookmark?",
  "scene_read.so-well-have-to-stop-the-story-here": "So we'll have to stop the story here:",
  "scene_read.sorry-the-writer-broke-it": "Sorry, the author hasn't configured this block correctly",
  "scene_read.sorry-this-scene-is-incomplete": "Sorry, this scene is incomplete",
  "scene_search_popup.create-new-scene": "Create New Scene",
  "scene_search_popup.create-new-scene-with-title": "Create '{title}'",
  "scene_search_popup.creating-new-scene": "Creating New Scene...",
  "scene_search_popup.load-more-scenes": "Load more...",
  "scene_search_popup.type-to-search-scenes": "Type to search scenes",
  "scene_search_popup.unlink-currentscenedtitle": "Unlink `{title}`",
  "searching_modal.this-place-is-empty": "This place is empty",
  "settings.about-us": "About Us",
  "settings.about_tab": "About",
  "settings.accent-color": "Accent Color",
  "settings.accented-colors": "Accented",
  "settings.allow-story-syncing": "Allow Story syncing",
  "settings.beta-label": "[BETA]",
  "settings.clear-filesystem": "Clear Filesystem",
  "settings.color-theme-sample": "Color Theme Sample",
  "settings.contributions": "Contributions",
  "settings.contributions-thanks": "Thanks to all those who helped by submitting bugfixes or feature requests!",
  "settings.dark-mode": "Dark Mode",
  "settings.disable-scene-drag-and-drop": "Disable scene drag and drop",
  "settings.donate": "Donate",
  "settings.donate-request": "If you enjoy using this app, please considering making a small purchase to help us pay for development and server costs.",
  "settings.done": "Done",
  "settings.enable-debug-mode": "Enable Debug Mode",
  "settings.fetch-published-stories": "Fetch published stories",
  "settings.fetching-stories": "Fetching stories",
  "settings.help-improve-this-app-with-anonymous-statistics": "Help improve this app with anonymous statistics",
  "settings.hyper-colors": "Hyper",
  "settings.language": "Language",
  "settings.mellow-colors": "Mellow",
  "settings.merge-from-backup-filesystem": "Merge From Backup Filesystem",
  "settings.monthly": "Monthly",
  "settings.morphosis-games-is-a-small-indie-company": "Morphosis Games is a small indie company that loves making games.",
  "settings.open-source-licenses": "Open Source Licenses",
  "settings.reset-system-messages": "Reset System Messages",
  "settings.reset-tutorial-messages": "Reset Tutorial Messages",
  "settings.run-benchmarks": "Run Benchmarks",
  "settings.settings_tab": "Settings",
  "settings.show-filesystem": "Show filesystem",
  "settings.show-mini-tutorials-on-start-up": "Show mini-tutorials on start up",
  "settings.show-notification-tab": "Show notification tab",
  "settings.show-word-count-while-writing": "Show word count while writing",
  "settings.spark": "Spark",
  "settings.spark-color": "Spark Color",
  "settings.special-thanks-to-community-translators": "Special thanks to community translators!",
  "settings.subscribe": "Subscribe",
  "settings.theme": "Theme",
  "settings.this-might-take-a-few-minutes": "This might take a few minutes",
  "settings.this-will-load-backups-into-the-main-filesystem": "This will load backups into the main filesystem",
  "settings.this-will-remove-all-stories-and-images-everything-are-you-sure": "This will remove all stories and images. EVERYTHING! Are you sure?",
  "settings.utilities": "Utilities",
  "settings.your-account": "Your Account",
  "story.animations": "Animations",
  "story.audio-clips": "Audio Clips",
  "story.backgrounds": "Backgrounds",
  "story.character-sheets": "",
  "story.copied": "Copied",
  "story.copy-button-label": "Copy",
  "story.musics": "Music",
  "story.publish": "Publish",
  "story.scenes": "Scenes",
  "story.settings": "Settings",
  "story.share": "Share",
  "story.share-code": "Share Code",
  "story.tags": "Tags",
  "story_browser.all-generas": "All Genres",
  "story_browser.all-languages": "All Languages",
  "story_browser.close": "Close",
  "story_browser.downloading-story": "Downloading story",
  "story_browser.engagement": "Engagement",
  "story_browser.filters": "Filters",
  "story_browser.i-am-over-13-years-old": "I am over 13 years old",
  "story_browser.loading-stories": "Loading stories",
  "story_browser.maybe-come-back-later": "Maybe come back later?",
  "story_browser.most-content-first": "Most Content First",
  "story_browser.most-conversation-first": "Most Conversation First",
  "story_browser.most-downloaded-first": "Most Downloaded First",
  "story_browser.most-loved-first": "Most Loved First",
  "story_browser.nevermind": "Nevermind",
  "story_browser.newest-first": "Newest First",
  "story_browser.no-stories-found": "No stories found",
  "story_browser.public-stories": "Public Stories",
  "story_browser.published-stories": "Published Stories",
  "story_browser.search": "Search...",
  "story_browser.shucks-looks-like-there-is-nothing-new": "Shucks, looks like there is nothing new.",
  "story_browser.sorry-looks-like-the-server-is-down": "Sorry, looks like the server is down :(",
  "story_browser.sorted-by-title": "Sorted by Title",
  "story_browser.story-content-warning": "We can't promise that they will be good quality or safe for all readers. We wish we had the resources to properly tag and filter every story that we get, but at this time, it is not possible. We are working on it though...",
  "story_browser.story-reading-age-recommendation": "So with that said, we recommend that only those at least 13 years or older continue.",
  "story_browser.the-stories-are-user-contributed": "The stories listed online are submitted from users like you.",
  "story_create.do-you-wish-to-abandon-this-novel": "Do you wish to abandon this novel?",
  "story_detail.a-hidden-achievement": "Hidden Achievement",
  "story_detail.achievements": "Achievements",
  "story_detail.comments-below-may-contain-spoilers": "Comments below may contain spoilers",
  "story_detail.download": "Download",
  "story_detail.last-published": "Last Published",
  "story_detail.last-updated": "Last Updated",
  "story_detail.read": "Read",
  "story_detail.remove": "Remove",
  "story_detail.unpublish": "Unpublish",
  "story_detail.update": "Update",
  "story_form.choose-genre": "-Choose Genre-",
  "story_form.choose-language": "-Choose Language-",
  "story_form.cover": "Cover",
  "story_form.create-story": "Create Story",
  "story_form.description": "Description",
  "story_form.genre": "Genre",
  "story_form.language": "Language",
  "story_form.original-artwork-for-promoting-your-story": "Original artwork for promoting your story",
  "story_form.players": "Players",
  "story_form.saving": "Saving...",
  "story_form.short-description": "Short Description",
  "story_form.title": "Title",
  "story_form.update-story": "Update Story",
  "story_item.backup-saved-x-ago": "backup saved {datetime_diff} ago",
  "story_item.negative-word-diff": "no change | -1 word | {count} words",
  "story_item.no-backup-saved": "No backup saved",
  "story_item.positive-word-diff": "no change | +1 word | +{count} words",
  "story_reader.bug-report": "Bug Report",
  "story_reader.bug-submitted": "Bug submitted!",
  "story_reader.cancel": "Cancel",
  "story_reader.discuss-this-story": "Discuss this Story",
  "story_reader.if-you-liked-the-story-give-it-a-heart": "If you liked the story, give it a heart!",
  "story_reader.no-tags-have-been-set": "No tags have been set",
  "story_reader.optional-developers-can-contact-me-here": "Developers can contact me here:",
  "story_reader.player-tag": "Player Tag",
  "story_reader.report-bug": "Report Bug",
  "story_reader.reset-player": "Reset Player",
  "story_reader.the-bug-report-will-include-a-copy-of-this-story": "The bug report will include a copy of this story",
  "story_settings.allow-user-bookmark": "Allow User Bookmark:",
  "story_settings.background-color": "Background Color:",
  "story_settings.character-label-style": "Character Label Style:",
  "story_settings.default-animation": "Default Animation:",
  "story_settings.default-aura-color": "Default Aura Color:",
  "story_settings.default-typing-speed": "Default Typing Speed:",
  "story_settings.settings-for-story-title": "Settings for `{title}",
  "story_settings.stack-dialog": "Stack Dialog:",
  "story_settings.text-color": "Text Color:",
  "story_settings.thought-style": "Thought Style:",
  "story_settings.title-style": "Title Style:",
  "story_unpublish.all-statistics-removed": "All statistics will be removed and no one will be able to download your story from the server.",
  "story_unpublish.no-revoking": "Users who have already downloaded your story will not have their copies revoked.",
  "story_unpublish.waiting-for-server": "Waiting for server...",
  "story_unpublish.your-story-has-been-removed-from-the-public-server": "Your story has been removed from the public server",
  "style.choice-default-checkbox-option": "Choice Default",
  "style.default-font-label": "Default",
  "style.entrance-animation": "Entrance Animation",
  "style.exit-animation": "Exit Animation",
  "style.font": "Font",
  "style.font-size": "Font Size",
  "style.foreground-shadow-form-label": "Foreground/Shadow",
  "style.form-field-background": "Background",
  "style.form-field-colors": "Colors",
  "style.form-field-name": "Name",
  "style.gradient-option-bloom": "Bloom",
  "style.gradient-option-downward": "Downward",
  "style.gradient-option-left": "Left",
  "style.gradient-option-no-gradient": "No Gradient",
  "style.gradient-option-right": "Right",
  "style.gradient-option-upward": "Upward",
  "style.none": "- none -",
  "style.shadow-option-no-shadow": "No Shadow",
  "style.shadow-option-normal": "Normal",
  "style.shadow-option-outline": "Outline",
  "style.shadow-option-smeared": "Smeared",
  "style.text-default-checkbox-option": "Text Default",
  "style.typing-particles": "Particles",
  "styles.style-breadcrumb": "Styles",
  "styles.style-description": "Styles change the way that text is displayed in the story.",
  "styles.styles-empty": "You don't have any styles defined for this story",
  "styles.unnamed-style": "Unnamed",
  "styles.usage-examples": "For instance, you can create a style to show written text, or for specific characters.",
  "tag_detail.icon": "Icon",
  "tag_picker.no-tag-selected": "No tag selected",
  "tag_popup.clear-typing": 'Clear "{name}"',
  "tag_popup.create-typing": 'Create "{name}"',
  "tag_popup.edit-typing": 'Edit "{name}"',
  "tag_popup.manage-tags": "Manage Tags",
  "tag_popup.no-tags-have-been-created-yet": "No tags have been created yet",
  "tag_popup.no-tags-match": "No tags match",
  "tag_popup.please-choose-a-character-trait": "Please choose a character trait",
  "tag_popup.your-story-doesnt-have-any-tags-yet": "Your story doesn't have any tags yet",
  "tags.add-tag": "Add",
  "tags.breadcrumb-story": "Story",
  "tags.breadcrumbs-all-tags": "All Tags",
  "tags.choose-a-tag-on-the-left-or-create-a-new-tag": "Choose a tag on the left or create a new tag",
  "tags.create-a-tag": "Create a tag",
  "tags.duplicate-tag-warning": "There is already a tag named '{name}'",
  "tags.form-field-category": "Category",
  "tags.form-field-format": "Format",
  "tags.form-field-formula": "Formula",
  "tags.form-field-name": "Name",
  "tags.form-field-permanent": "Permanent",
  "tags.form-field-type": "Type",
  "tags.format-types-numeric": "Numeric",
  "tags.format-types-text": "Text",
  "tags.new-tag-default-label": "New Tag",
  "tags.non-permanent-description": "This tag will be reset when the story is started",
  "tags.permanent-field-description": "This tag will persist between story sessions",
  "tags.tag-types-action": "Action",
  "tags.tag-types-tag": "Tag",
  "tags.tags-names-should-consist-of-only-letters-numbers-or-underscore": "Tags names should consist of only letters, numbers or underscore",
  "tags.tags-no-start-with-dollar": "Tags are not allowed to start with `$",
  "text_content.add-text-here": "Add text here",
  "thought_array.type-here-to-add-a-thought": "Type here to add a thought",
  "token_promote_popover.and-give-it-a-random-chance-to-appear-at-the-top-of-the-market": "- and give it a random chance to appear at the top of the market",
  "token_promote_popover.enhance-the-visual-appeal-of-this-story": "- enhance the visual appeal of this story",
  "token_promote_popover.promote": "Promote",
  "token_promote_popover.promote-this-story": "Promote this story?",
  "token_promote_popover.spend-a-story-token-to": "Spend a story token to:",
  "token_promote_popover.this-story-has-x-tokens": "This story has no tokens | This story has 1 token | This story has {tokens} tokens",
  "token_promote_popover.using-token": "Using token...",
  "token_promote_popover.you-have-x-tokens": "You have no tokens | You have 1 token | You have {tokens} tokens ",
  "tracks.background": "Background",
  "tracks.blur": "Blur",
  "tracks.color": "Color",
  "tracks.delete-this-node": "Delete this node?",
  "tracks.direction": "Direction",
  "tracks.ease-in-out": "Ease-in-out",
  "tracks.easing": "Easing",
  "tracks.empty": "Empty",
  "tracks.length": "Length",
  "tracks.linear": "Linear",
  "tracks.node": "node",
  "tracks.opacity": "Opacity",
  "tracks.randomize": "Randomize",
  "tracks.randomize-rotation": "Randomize Rotation",
  "tracks.rotation": "Rotation",
  "tracks.scale": "Scale",
  "tracks.shadow": "Shadow",
  "tracks.transform": "Transform",
  "translate.advert": 'If you are interested in helping to translate this app to your language, please join our community chat and say "hello".',
  "translate.help-translate": "Help Translate",
  "tutorial_overview.close": "Close",
  "tutorial_popup.search-tutorials": "Search tutorials...",
  "tutorials.april-update": "April Update",
  "tutorials.aprilfools-adding-up-the-totals": "Adding up the totals...\nDooby dooby doo...\nThat's what I do...\ndooby dooby doo",
  "tutorials.aprilfools-corporate-has-decided": "Corporate has decided to backwards apply some charges. I'll just put a counter on your screen so you have an easy way to know how much you owe\n\nGo ahead and click on it to see how much you owe",
  "tutorials.aprilfools-corporate-is-really-unhappy-with-my-sales-figures-n-sigh": "Corporate is really unhappy with my sales figures.\n*sigh*",
  "tutorials.aprilfools-hey-there-were-making-some-changes": "Hey there! We're making some changes in the way this app will be monetized.\n\nNothing too big, I'll tell you more about it later",
  "tutorials.aprilfools-hi-have-you-noticed-your-bill": "Hi! Have you noticed your bill up at the top?\nI've made a detailed breakdown for you if you click on it",
  "tutorials.aprilfools-i-m-going-to-clean": "I'm going to clean this up, please try not to break anything else",
  "tutorials.aprilfools-just-a-little-reminder": "Just a little reminder to check your invoice for using the app. It's at the top of the screen\nYou can click it to see a breakdown",
  "tutorials.aprilfools-so-you-owe-us-quite-a-bit": "So you can see here that you owe us quite a bit now. \n\nGo ahead and look it over, you can add your payment information when you are ready",
  "tutorials.aprilfools-you-broke-it": "You broke it!\n\nHow did you do that? I'm going to have to add that to your bill, you know",
  "tutorials.hello-sorry-to-interrupt": "Hello, sorry to interrupt. Just wanted to remind you that you can buy more crystals and support the app\n\nThanks!",
  "video_content.youtube-code": "YouTube Code",
  "video_content.youtube-video-player": "YouTube video player",
  alignment,
  "aura-shine": "Aura Shine",
  "aura-shine-rotation-speed": "Rotation",
  "aura-shine-spokes": "Spoke Count",
  "aura-shine-spoke-size": "Spoke Size"
};
/*!
  * shared v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const inBrowser = typeof window !== "undefined";
const makeSymbol = (name, shareable = false) => !shareable ? Symbol(name) : Symbol.for(name);
const generateFormatCacheKey = (locale, key, source) => friendlyJSONstringify({ l: locale, k: key, s: source });
const friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
const isNumber = (val) => typeof val === "number" && isFinite(val);
const isDate = (val) => toTypeString(val) === "[object Date]";
const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
const isEmptyObject = (val) => isPlainObject(val) && Object.keys(val).length === 0;
const assign$1 = Object.assign;
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function escapeHtml(rawText) {
  return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
const hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
const isArray = Array.isArray;
const isFunction = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isBoolean = (val) => typeof val === "boolean";
const isObject$1 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$1(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const isPlainObject = (val) => {
  if (!isObject$1(val))
    return false;
  const proto = Object.getPrototypeOf(val);
  return proto === null || proto.constructor === Object;
};
const toDisplayString = (val) => {
  return val == null ? "" : isArray(val) || isPlainObject(val) && val.toString === objectToString ? JSON.stringify(val, null, 2) : String(val);
};
function join$1(items, separator = "") {
  return items.reduce((str, item, index2) => index2 === 0 ? str + item : str + separator + item, "");
}
function incrementer(code2) {
  let current = code2;
  return () => ++current;
}
function warn(msg, err) {
  if (typeof console !== "undefined") {
    console.warn(`[intlify] ` + msg);
    if (err) {
      console.warn(err.stack);
    }
  }
}
const isNotObjectOrIsArray = (val) => !isObject$1(val) || isArray(val);
function deepCopy(src, des) {
  if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
    throw new Error("Invalid value");
  }
  const stack2 = [{ src, des }];
  while (stack2.length) {
    const { src: src2, des: des2 } = stack2.pop();
    Object.keys(src2).forEach((key) => {
      if (isNotObjectOrIsArray(src2[key]) || isNotObjectOrIsArray(des2[key])) {
        des2[key] = src2[key];
      } else {
        stack2.push({ src: src2[key], des: des2[key] });
      }
    });
  }
}
/*!
  * message-compiler v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function createPosition(line, column, offset2) {
  return { line, column, offset: offset2 };
}
function createLocation(start, end, source) {
  const loc2 = { start, end };
  if (source != null) {
    loc2.source = source;
  }
  return loc2;
}
const RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
function format$2(message, ...args) {
  if (args.length === 1 && isObject(args[0])) {
    args = args[0];
  }
  if (!args || !args.hasOwnProperty) {
    args = {};
  }
  return message.replace(RE_ARGS, (match, identifier) => {
    return args.hasOwnProperty(identifier) ? args[identifier] : "";
  });
}
const assign = Object.assign;
const isString = (val) => typeof val === "string";
const isObject = (val) => val !== null && typeof val === "object";
function join(items, separator = "") {
  return items.reduce((str, item, index2) => index2 === 0 ? str + item : str + separator + item, "");
}
const CompileWarnCodes = {
  USE_MODULO_SYNTAX: 1,
  __EXTEND_POINT__: 2
};
const warnMessages = {
  [CompileWarnCodes.USE_MODULO_SYNTAX]: `Use modulo before '{{0}}'.`
};
function createCompileWarn(code2, loc2, ...args) {
  const msg = format$2(warnMessages[code2] || "", ...args || []);
  const message = { message: String(msg), code: code2 };
  if (loc2) {
    message.location = loc2;
  }
  return message;
}
const CompileErrorCodes = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // generator error codes
  UNHANDLED_CODEGEN_NODE_TYPE: 15,
  // minifier error codes
  UNHANDLED_MINIFIER_NODE_TYPE: 16,
  // Special value for higher-order compilers to pick up the last code
  // to avoid collision of error codes. This should always be kept as the last
  // item.
  __EXTEND_POINT__: 17
};
const errorMessages = {
  // tokenizer error messages
  [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,
  [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,
  [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,
  [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\{0}`,
  [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,
  [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,
  [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,
  [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,
  [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,
  [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,
  // parser error messages
  [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,
  [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,
  // generator error messages
  [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,
  // minimizer error messages
  [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`
};
function createCompileError(code2, loc2, options = {}) {
  const { domain, messages, args } = options;
  const msg = format$2((messages || errorMessages)[code2] || "", ...args || []);
  const error = new SyntaxError(String(msg));
  error.code = code2;
  if (loc2) {
    error.location = loc2;
  }
  error.domain = domain;
  return error;
}
function defaultOnError(error) {
  throw error;
}
const CHAR_SP = " ";
const CHAR_CR = "\r";
const CHAR_LF = "\n";
const CHAR_LS = String.fromCharCode(8232);
const CHAR_PS = String.fromCharCode(8233);
function createScanner(str) {
  const _buf = str;
  let _index = 0;
  let _line = 1;
  let _column = 1;
  let _peekOffset = 0;
  const isCRLF = (index3) => _buf[index3] === CHAR_CR && _buf[index3 + 1] === CHAR_LF;
  const isLF = (index3) => _buf[index3] === CHAR_LF;
  const isPS = (index3) => _buf[index3] === CHAR_PS;
  const isLS = (index3) => _buf[index3] === CHAR_LS;
  const isLineEnd = (index3) => isCRLF(index3) || isLF(index3) || isPS(index3) || isLS(index3);
  const index2 = () => _index;
  const line = () => _line;
  const column = () => _column;
  const peekOffset = () => _peekOffset;
  const charAt = (offset2) => isCRLF(offset2) || isPS(offset2) || isLS(offset2) ? CHAR_LF : _buf[offset2];
  const currentChar = () => charAt(_index);
  const currentPeek = () => charAt(_index + _peekOffset);
  function next() {
    _peekOffset = 0;
    if (isLineEnd(_index)) {
      _line++;
      _column = 0;
    }
    if (isCRLF(_index)) {
      _index++;
    }
    _index++;
    _column++;
    return _buf[_index];
  }
  function peek() {
    if (isCRLF(_index + _peekOffset)) {
      _peekOffset++;
    }
    _peekOffset++;
    return _buf[_index + _peekOffset];
  }
  function reset2() {
    _index = 0;
    _line = 1;
    _column = 1;
    _peekOffset = 0;
  }
  function resetPeek(offset2 = 0) {
    _peekOffset = offset2;
  }
  function skipToPeek() {
    const target = _index + _peekOffset;
    while (target !== _index) {
      next();
    }
    _peekOffset = 0;
  }
  return {
    index: index2,
    line,
    column,
    peekOffset,
    charAt,
    currentChar,
    currentPeek,
    next,
    peek,
    reset: reset2,
    resetPeek,
    skipToPeek
  };
}
const EOF = void 0;
const DOT = ".";
const LITERAL_DELIMITER = "'";
const ERROR_DOMAIN$3 = "tokenizer";
function createTokenizer(source, options = {}) {
  const location2 = options.location !== false;
  const _scnr = createScanner(source);
  const currentOffset = () => _scnr.index();
  const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());
  const _initLoc = currentPosition();
  const _initOffset = currentOffset();
  const _context = {
    currentType: 14,
    offset: _initOffset,
    startLoc: _initLoc,
    endLoc: _initLoc,
    lastType: 14,
    lastOffset: _initOffset,
    lastStartLoc: _initLoc,
    lastEndLoc: _initLoc,
    braceNest: 0,
    inLinked: false,
    text: ""
  };
  const context = () => _context;
  const { onError } = options;
  function emitError(code2, pos, offset2, ...args) {
    const ctx = context();
    pos.column += offset2;
    pos.offset += offset2;
    if (onError) {
      const loc2 = location2 ? createLocation(ctx.startLoc, pos) : null;
      const err = createCompileError(code2, loc2, {
        domain: ERROR_DOMAIN$3,
        args
      });
      onError(err);
    }
  }
  function getToken(context2, type2, value) {
    context2.endLoc = currentPosition();
    context2.currentType = type2;
    const token = { type: type2 };
    if (location2) {
      token.loc = createLocation(context2.startLoc, context2.endLoc);
    }
    if (value != null) {
      token.value = value;
    }
    return token;
  }
  const getEndToken = (context2) => getToken(
    context2,
    14
    /* TokenTypes.EOF */
  );
  function eat(scnr, ch) {
    if (scnr.currentChar() === ch) {
      scnr.next();
      return ch;
    } else {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
      return "";
    }
  }
  function peekSpaces(scnr) {
    let buf = "";
    while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
      buf += scnr.currentPeek();
      scnr.peek();
    }
    return buf;
  }
  function skipSpaces(scnr) {
    const buf = peekSpaces(scnr);
    scnr.skipToPeek();
    return buf;
  }
  function isIdentifierStart(ch) {
    if (ch === EOF) {
      return false;
    }
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc === 95;
  }
  function isNumberStart(ch) {
    if (ch === EOF) {
      return false;
    }
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57;
  }
  function isNamedIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isListIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ch = scnr.currentPeek() === "-" ? scnr.peek() : scnr.currentPeek();
    const ret = isNumberStart(ch);
    scnr.resetPeek();
    return ret;
  }
  function isLiteralStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === LITERAL_DELIMITER;
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDotStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 8) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ".";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedModifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 9) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDelimiterStart(scnr, context2) {
    const { currentType } = context2;
    if (!(currentType === 8 || currentType === 12)) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ":";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedReferStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 10) {
      return false;
    }
    const fn = () => {
      const ch = scnr.currentPeek();
      if (ch === "{") {
        return isIdentifierStart(scnr.peek());
      } else if (ch === "@" || ch === "%" || ch === "|" || ch === ":" || ch === "." || ch === CHAR_SP || !ch) {
        return false;
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn();
      } else {
        return isTextStart(scnr, false);
      }
    };
    const ret = fn();
    scnr.resetPeek();
    return ret;
  }
  function isPluralStart(scnr) {
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === "|";
    scnr.resetPeek();
    return ret;
  }
  function detectModuloStart(scnr) {
    const spaces = peekSpaces(scnr);
    const ret = scnr.currentPeek() === "%" && scnr.peek() === "{";
    scnr.resetPeek();
    return {
      isModulo: ret,
      hasSpace: spaces.length > 0
    };
  }
  function isTextStart(scnr, reset2 = true) {
    const fn = (hasSpace = false, prev = "", detectModulo = false) => {
      const ch = scnr.currentPeek();
      if (ch === "{") {
        return prev === "%" ? false : hasSpace;
      } else if (ch === "@" || !ch) {
        return prev === "%" ? true : hasSpace;
      } else if (ch === "%") {
        scnr.peek();
        return fn(hasSpace, "%", true);
      } else if (ch === "|") {
        return prev === "%" || detectModulo ? true : !(prev === CHAR_SP || prev === CHAR_LF);
      } else if (ch === CHAR_SP) {
        scnr.peek();
        return fn(true, CHAR_SP, detectModulo);
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn(true, CHAR_LF, detectModulo);
      } else {
        return true;
      }
    };
    const ret = fn();
    reset2 && scnr.resetPeek();
    return ret;
  }
  function takeChar(scnr, fn) {
    const ch = scnr.currentChar();
    if (ch === EOF) {
      return EOF;
    }
    if (fn(ch)) {
      scnr.next();
      return ch;
    }
    return null;
  }
  function isIdentifier(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc >= 48 && cc <= 57 || // 0-9
    cc === 95 || // _
    cc === 36;
  }
  function takeIdentifierChar(scnr) {
    return takeChar(scnr, isIdentifier);
  }
  function isNamedIdentifier(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc >= 48 && cc <= 57 || // 0-9
    cc === 95 || // _
    cc === 36 || // $
    cc === 45;
  }
  function takeNamedIdentifierChar(scnr) {
    return takeChar(scnr, isNamedIdentifier);
  }
  function isDigit(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57;
  }
  function takeDigit(scnr) {
    return takeChar(scnr, isDigit);
  }
  function isHexDigit(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57 || // 0-9
    cc >= 65 && cc <= 70 || // A-F
    cc >= 97 && cc <= 102;
  }
  function takeHexDigit(scnr) {
    return takeChar(scnr, isHexDigit);
  }
  function getDigits(scnr) {
    let ch = "";
    let num = "";
    while (ch = takeDigit(scnr)) {
      num += ch;
    }
    return num;
  }
  function readModulo(scnr) {
    skipSpaces(scnr);
    const ch = scnr.currentChar();
    if (ch !== "%") {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
    }
    scnr.next();
    return "%";
  }
  function readText(scnr) {
    let buf = "";
    while (true) {
      const ch = scnr.currentChar();
      if (ch === "{" || ch === "}" || ch === "@" || ch === "|" || !ch) {
        break;
      } else if (ch === "%") {
        if (isTextStart(scnr)) {
          buf += ch;
          scnr.next();
        } else {
          break;
        }
      } else if (ch === CHAR_SP || ch === CHAR_LF) {
        if (isTextStart(scnr)) {
          buf += ch;
          scnr.next();
        } else if (isPluralStart(scnr)) {
          break;
        } else {
          buf += ch;
          scnr.next();
        }
      } else {
        buf += ch;
        scnr.next();
      }
    }
    return buf;
  }
  function readNamedIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = "";
    let name = "";
    while (ch = takeNamedIdentifierChar(scnr)) {
      name += ch;
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return name;
  }
  function readListIdentifier(scnr) {
    skipSpaces(scnr);
    let value = "";
    if (scnr.currentChar() === "-") {
      scnr.next();
      value += `-${getDigits(scnr)}`;
    } else {
      value += getDigits(scnr);
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return value;
  }
  function isLiteral2(ch) {
    return ch !== LITERAL_DELIMITER && ch !== CHAR_LF;
  }
  function readLiteral(scnr) {
    skipSpaces(scnr);
    eat(scnr, `'`);
    let ch = "";
    let literal = "";
    while (ch = takeChar(scnr, isLiteral2)) {
      if (ch === "\\") {
        literal += readEscapeSequence(scnr);
      } else {
        literal += ch;
      }
    }
    const current = scnr.currentChar();
    if (current === CHAR_LF || current === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
      if (current === CHAR_LF) {
        scnr.next();
        eat(scnr, `'`);
      }
      return literal;
    }
    eat(scnr, `'`);
    return literal;
  }
  function readEscapeSequence(scnr) {
    const ch = scnr.currentChar();
    switch (ch) {
      case "\\":
      case `'`:
        scnr.next();
        return `\\${ch}`;
      case "u":
        return readUnicodeEscapeSequence(scnr, ch, 4);
      case "U":
        return readUnicodeEscapeSequence(scnr, ch, 6);
      default:
        emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);
        return "";
    }
  }
  function readUnicodeEscapeSequence(scnr, unicode, digits) {
    eat(scnr, unicode);
    let sequence = "";
    for (let i = 0; i < digits; i++) {
      const ch = takeHexDigit(scnr);
      if (!ch) {
        emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
        break;
      }
      sequence += ch;
    }
    return `\\${unicode}${sequence}`;
  }
  function isInvalidIdentifier(ch) {
    return ch !== "{" && ch !== "}" && ch !== CHAR_SP && ch !== CHAR_LF;
  }
  function readInvalidIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = "";
    let identifiers = "";
    while (ch = takeChar(scnr, isInvalidIdentifier)) {
      identifiers += ch;
    }
    return identifiers;
  }
  function readLinkedModifier(scnr) {
    let ch = "";
    let name = "";
    while (ch = takeIdentifierChar(scnr)) {
      name += ch;
    }
    return name;
  }
  function readLinkedRefer(scnr) {
    const fn = (buf) => {
      const ch = scnr.currentChar();
      if (ch === "{" || ch === "%" || ch === "@" || ch === "|" || ch === "(" || ch === ")" || !ch) {
        return buf;
      } else if (ch === CHAR_SP) {
        return buf;
      } else if (ch === CHAR_LF || ch === DOT) {
        buf += ch;
        scnr.next();
        return fn(buf);
      } else {
        buf += ch;
        scnr.next();
        return fn(buf);
      }
    };
    return fn("");
  }
  function readPlural(scnr) {
    skipSpaces(scnr);
    const plural = eat(
      scnr,
      "|"
      /* TokenChars.Pipe */
    );
    skipSpaces(scnr);
    return plural;
  }
  function readTokenInPlaceholder(scnr, context2) {
    let token = null;
    const ch = scnr.currentChar();
    switch (ch) {
      case "{":
        if (context2.braceNest >= 1) {
          emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token = getToken(
          context2,
          2,
          "{"
          /* TokenChars.BraceLeft */
        );
        skipSpaces(scnr);
        context2.braceNest++;
        return token;
      case "}":
        if (context2.braceNest > 0 && context2.currentType === 2) {
          emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token = getToken(
          context2,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
        context2.braceNest--;
        context2.braceNest > 0 && skipSpaces(scnr);
        if (context2.inLinked && context2.braceNest === 0) {
          context2.inLinked = false;
        }
        return token;
      case "@":
        if (context2.braceNest > 0) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        token = readTokenInLinked(scnr, context2) || getEndToken(context2);
        context2.braceNest = 0;
        return token;
      default: {
        let validNamedIdentifier = true;
        let validListIdentifier = true;
        let validLiteral = true;
        if (isPluralStart(scnr)) {
          if (context2.braceNest > 0) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          }
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        if (context2.braceNest > 0 && (context2.currentType === 5 || context2.currentType === 6 || context2.currentType === 7)) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          context2.braceNest = 0;
          return readToken(scnr, context2);
        }
        if (validNamedIdentifier = isNamedIdentifierStart(scnr, context2)) {
          token = getToken(context2, 5, readNamedIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (validListIdentifier = isListIdentifierStart(scnr, context2)) {
          token = getToken(context2, 6, readListIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (validLiteral = isLiteralStart(scnr, context2)) {
          token = getToken(context2, 7, readLiteral(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
          token = getToken(context2, 13, readInvalidIdentifier(scnr));
          emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);
          skipSpaces(scnr);
          return token;
        }
        break;
      }
    }
    return token;
  }
  function readTokenInLinked(scnr, context2) {
    const { currentType } = context2;
    let token = null;
    const ch = scnr.currentChar();
    if ((currentType === 8 || currentType === 9 || currentType === 12 || currentType === 10) && (ch === CHAR_LF || ch === CHAR_SP)) {
      emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
    }
    switch (ch) {
      case "@":
        scnr.next();
        token = getToken(
          context2,
          8,
          "@"
          /* TokenChars.LinkedAlias */
        );
        context2.inLinked = true;
        return token;
      case ".":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context2,
          9,
          "."
          /* TokenChars.LinkedDot */
        );
      case ":":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context2,
          10,
          ":"
          /* TokenChars.LinkedDelimiter */
        );
      default:
        if (isPluralStart(scnr)) {
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        if (isLinkedDotStart(scnr, context2) || isLinkedDelimiterStart(scnr, context2)) {
          skipSpaces(scnr);
          return readTokenInLinked(scnr, context2);
        }
        if (isLinkedModifierStart(scnr, context2)) {
          skipSpaces(scnr);
          return getToken(context2, 12, readLinkedModifier(scnr));
        }
        if (isLinkedReferStart(scnr, context2)) {
          skipSpaces(scnr);
          if (ch === "{") {
            return readTokenInPlaceholder(scnr, context2) || token;
          } else {
            return getToken(context2, 11, readLinkedRefer(scnr));
          }
        }
        if (currentType === 8) {
          emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
        }
        context2.braceNest = 0;
        context2.inLinked = false;
        return readToken(scnr, context2);
    }
  }
  function readToken(scnr, context2) {
    let token = {
      type: 14
      /* TokenTypes.EOF */
    };
    if (context2.braceNest > 0) {
      return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
    }
    if (context2.inLinked) {
      return readTokenInLinked(scnr, context2) || getEndToken(context2);
    }
    const ch = scnr.currentChar();
    switch (ch) {
      case "{":
        return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
      case "}":
        emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
        scnr.next();
        return getToken(
          context2,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
      case "@":
        return readTokenInLinked(scnr, context2) || getEndToken(context2);
      default: {
        if (isPluralStart(scnr)) {
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        const { isModulo, hasSpace } = detectModuloStart(scnr);
        if (isModulo) {
          return hasSpace ? getToken(context2, 0, readText(scnr)) : getToken(context2, 4, readModulo(scnr));
        }
        if (isTextStart(scnr)) {
          return getToken(context2, 0, readText(scnr));
        }
        break;
      }
    }
    return token;
  }
  function nextToken() {
    const { currentType, offset: offset2, startLoc, endLoc } = _context;
    _context.lastType = currentType;
    _context.lastOffset = offset2;
    _context.lastStartLoc = startLoc;
    _context.lastEndLoc = endLoc;
    _context.offset = currentOffset();
    _context.startLoc = currentPosition();
    if (_scnr.currentChar() === EOF) {
      return getToken(
        _context,
        14
        /* TokenTypes.EOF */
      );
    }
    return readToken(_scnr, _context);
  }
  return {
    nextToken,
    currentOffset,
    currentPosition,
    context
  };
}
const ERROR_DOMAIN$2 = "parser";
const KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function fromEscapeSequence(match, codePoint4, codePoint6) {
  switch (match) {
    case `\\\\`:
      return `\\`;
    case `\\'`:
      return `'`;
    default: {
      const codePoint = parseInt(codePoint4 || codePoint6, 16);
      if (codePoint <= 55295 || codePoint >= 57344) {
        return String.fromCodePoint(codePoint);
      }
      return "";
    }
  }
}
function createParser(options = {}) {
  const location2 = options.location !== false;
  const { onError, onWarn } = options;
  function emitError(tokenzer, code2, start, offset2, ...args) {
    const end = tokenzer.currentPosition();
    end.offset += offset2;
    end.column += offset2;
    if (onError) {
      const loc2 = location2 ? createLocation(start, end) : null;
      const err = createCompileError(code2, loc2, {
        domain: ERROR_DOMAIN$2,
        args
      });
      onError(err);
    }
  }
  function emitWarn(tokenzer, code2, start, offset2, ...args) {
    const end = tokenzer.currentPosition();
    end.offset += offset2;
    end.column += offset2;
    if (onWarn) {
      const loc2 = location2 ? createLocation(start, end) : null;
      onWarn(createCompileWarn(code2, loc2, args));
    }
  }
  function startNode(type2, offset2, loc2) {
    const node = { type: type2 };
    if (location2) {
      node.start = offset2;
      node.end = offset2;
      node.loc = { start: loc2, end: loc2 };
    }
    return node;
  }
  function endNode(node, offset2, pos, type2) {
    if (type2) {
      node.type = type2;
    }
    if (location2) {
      node.end = offset2;
      if (node.loc) {
        node.loc.end = pos;
      }
    }
  }
  function parseText(tokenizer2, value) {
    const context = tokenizer2.context();
    const node = startNode(3, context.offset, context.startLoc);
    node.value = value;
    endNode(node, tokenizer2.currentOffset(), tokenizer2.currentPosition());
    return node;
  }
  function parseList(tokenizer2, index2) {
    const context = tokenizer2.context();
    const { lastOffset: offset2, lastStartLoc: loc2 } = context;
    const node = startNode(5, offset2, loc2);
    node.index = parseInt(index2, 10);
    tokenizer2.nextToken();
    endNode(node, tokenizer2.currentOffset(), tokenizer2.currentPosition());
    return node;
  }
  function parseNamed(tokenizer2, key, modulo) {
    const context = tokenizer2.context();
    const { lastOffset: offset2, lastStartLoc: loc2 } = context;
    const node = startNode(4, offset2, loc2);
    node.key = key;
    if (modulo === true) {
      node.modulo = true;
    }
    tokenizer2.nextToken();
    endNode(node, tokenizer2.currentOffset(), tokenizer2.currentPosition());
    return node;
  }
  function parseLiteral(tokenizer2, value) {
    const context = tokenizer2.context();
    const { lastOffset: offset2, lastStartLoc: loc2 } = context;
    const node = startNode(9, offset2, loc2);
    node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);
    tokenizer2.nextToken();
    endNode(node, tokenizer2.currentOffset(), tokenizer2.currentPosition());
    return node;
  }
  function parseLinkedModifier(tokenizer2) {
    const token = tokenizer2.nextToken();
    const context = tokenizer2.context();
    const { lastOffset: offset2, lastStartLoc: loc2 } = context;
    const node = startNode(8, offset2, loc2);
    if (token.type !== 12) {
      emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
      node.value = "";
      endNode(node, offset2, loc2);
      return {
        nextConsumeToken: token,
        node
      };
    }
    if (token.value == null) {
      emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }
    node.value = token.value || "";
    endNode(node, tokenizer2.currentOffset(), tokenizer2.currentPosition());
    return {
      node
    };
  }
  function parseLinkedKey(tokenizer2, value) {
    const context = tokenizer2.context();
    const node = startNode(7, context.offset, context.startLoc);
    node.value = value;
    endNode(node, tokenizer2.currentOffset(), tokenizer2.currentPosition());
    return node;
  }
  function parseLinked(tokenizer2) {
    const context = tokenizer2.context();
    const linkedNode = startNode(6, context.offset, context.startLoc);
    let token = tokenizer2.nextToken();
    if (token.type === 9) {
      const parsed = parseLinkedModifier(tokenizer2);
      linkedNode.modifier = parsed.node;
      token = parsed.nextConsumeToken || tokenizer2.nextToken();
    }
    if (token.type !== 10) {
      emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }
    token = tokenizer2.nextToken();
    if (token.type === 2) {
      token = tokenizer2.nextToken();
    }
    switch (token.type) {
      case 11:
        if (token.value == null) {
          emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseLinkedKey(tokenizer2, token.value || "");
        break;
      case 5:
        if (token.value == null) {
          emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseNamed(tokenizer2, token.value || "");
        break;
      case 6:
        if (token.value == null) {
          emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseList(tokenizer2, token.value || "");
        break;
      case 7:
        if (token.value == null) {
          emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseLiteral(tokenizer2, token.value || "");
        break;
      default: {
        emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
        const nextContext = tokenizer2.context();
        const emptyLinkedKeyNode = startNode(7, nextContext.offset, nextContext.startLoc);
        emptyLinkedKeyNode.value = "";
        endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
        linkedNode.key = emptyLinkedKeyNode;
        endNode(linkedNode, nextContext.offset, nextContext.startLoc);
        return {
          nextConsumeToken: token,
          node: linkedNode
        };
      }
    }
    endNode(linkedNode, tokenizer2.currentOffset(), tokenizer2.currentPosition());
    return {
      node: linkedNode
    };
  }
  function parseMessage(tokenizer2) {
    const context = tokenizer2.context();
    const startOffset = context.currentType === 1 ? tokenizer2.currentOffset() : context.offset;
    const startLoc = context.currentType === 1 ? context.endLoc : context.startLoc;
    const node = startNode(2, startOffset, startLoc);
    node.items = [];
    let nextToken = null;
    let modulo = null;
    do {
      const token = nextToken || tokenizer2.nextToken();
      nextToken = null;
      switch (token.type) {
        case 0:
          if (token.value == null) {
            emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseText(tokenizer2, token.value || ""));
          break;
        case 6:
          if (token.value == null) {
            emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseList(tokenizer2, token.value || ""));
          break;
        case 4:
          modulo = true;
          break;
        case 5:
          if (token.value == null) {
            emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseNamed(tokenizer2, token.value || "", !!modulo));
          if (modulo) {
            emitWarn(tokenizer2, CompileWarnCodes.USE_MODULO_SYNTAX, context.lastStartLoc, 0, getTokenCaption(token));
            modulo = null;
          }
          break;
        case 7:
          if (token.value == null) {
            emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseLiteral(tokenizer2, token.value || ""));
          break;
        case 8: {
          const parsed = parseLinked(tokenizer2);
          node.items.push(parsed.node);
          nextToken = parsed.nextConsumeToken || null;
          break;
        }
      }
    } while (context.currentType !== 14 && context.currentType !== 1);
    const endOffset = context.currentType === 1 ? context.lastOffset : tokenizer2.currentOffset();
    const endLoc = context.currentType === 1 ? context.lastEndLoc : tokenizer2.currentPosition();
    endNode(node, endOffset, endLoc);
    return node;
  }
  function parsePlural(tokenizer2, offset2, loc2, msgNode) {
    const context = tokenizer2.context();
    let hasEmptyMessage = msgNode.items.length === 0;
    const node = startNode(1, offset2, loc2);
    node.cases = [];
    node.cases.push(msgNode);
    do {
      const msg = parseMessage(tokenizer2);
      if (!hasEmptyMessage) {
        hasEmptyMessage = msg.items.length === 0;
      }
      node.cases.push(msg);
    } while (context.currentType !== 14);
    if (hasEmptyMessage) {
      emitError(tokenizer2, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc2, 0);
    }
    endNode(node, tokenizer2.currentOffset(), tokenizer2.currentPosition());
    return node;
  }
  function parseResource(tokenizer2) {
    const context = tokenizer2.context();
    const { offset: offset2, startLoc } = context;
    const msgNode = parseMessage(tokenizer2);
    if (context.currentType === 14) {
      return msgNode;
    } else {
      return parsePlural(tokenizer2, offset2, startLoc, msgNode);
    }
  }
  function parse4(source) {
    const tokenizer2 = createTokenizer(source, assign({}, options));
    const context = tokenizer2.context();
    const node = startNode(0, context.offset, context.startLoc);
    if (location2 && node.loc) {
      node.loc.source = source;
    }
    node.body = parseResource(tokenizer2);
    if (options.onCacheKey) {
      node.cacheKey = options.onCacheKey(source);
    }
    if (context.currentType !== 14) {
      emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || "");
    }
    endNode(node, tokenizer2.currentOffset(), tokenizer2.currentPosition());
    return node;
  }
  return { parse: parse4 };
}
function getTokenCaption(token) {
  if (token.type === 14) {
    return "EOF";
  }
  const name = (token.value || "").replace(/\r?\n/gu, "\\n");
  return name.length > 10 ? name.slice(0, 9) + "" : name;
}
function createTransformer(ast, options = {}) {
  const _context = {
    ast,
    helpers: /* @__PURE__ */ new Set()
  };
  const context = () => _context;
  const helper = (name) => {
    _context.helpers.add(name);
    return name;
  };
  return { context, helper };
}
function traverseNodes(nodes, transformer) {
  for (let i = 0; i < nodes.length; i++) {
    traverseNode(nodes[i], transformer);
  }
}
function traverseNode(node, transformer) {
  switch (node.type) {
    case 1:
      traverseNodes(node.cases, transformer);
      transformer.helper(
        "plural"
        /* HelperNameMap.PLURAL */
      );
      break;
    case 2:
      traverseNodes(node.items, transformer);
      break;
    case 6: {
      const linked = node;
      traverseNode(linked.key, transformer);
      transformer.helper(
        "linked"
        /* HelperNameMap.LINKED */
      );
      transformer.helper(
        "type"
        /* HelperNameMap.TYPE */
      );
      break;
    }
    case 5:
      transformer.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer.helper(
        "list"
        /* HelperNameMap.LIST */
      );
      break;
    case 4:
      transformer.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer.helper(
        "named"
        /* HelperNameMap.NAMED */
      );
      break;
  }
}
function transform$3(ast, options = {}) {
  const transformer = createTransformer(ast);
  transformer.helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  );
  ast.body && traverseNode(ast.body, transformer);
  const context = transformer.context();
  ast.helpers = Array.from(context.helpers);
}
function optimize3(ast) {
  const body = ast.body;
  if (body.type === 2) {
    optimizeMessageNode(body);
  } else {
    body.cases.forEach((c) => optimizeMessageNode(c));
  }
  return ast;
}
function optimizeMessageNode(message) {
  if (message.items.length === 1) {
    const item = message.items[0];
    if (item.type === 3 || item.type === 9) {
      message.static = item.value;
      delete item.value;
    }
  } else {
    const values = [];
    for (let i = 0; i < message.items.length; i++) {
      const item = message.items[i];
      if (!(item.type === 3 || item.type === 9)) {
        break;
      }
      if (item.value == null) {
        break;
      }
      values.push(item.value);
    }
    if (values.length === message.items.length) {
      message.static = join(values);
      for (let i = 0; i < message.items.length; i++) {
        const item = message.items[i];
        if (item.type === 3 || item.type === 9) {
          delete item.value;
        }
      }
    }
  }
}
const ERROR_DOMAIN$1 = "minifier";
function minify(node) {
  node.t = node.type;
  switch (node.type) {
    case 0: {
      const resource = node;
      minify(resource.body);
      resource.b = resource.body;
      delete resource.body;
      break;
    }
    case 1: {
      const plural = node;
      const cases = plural.cases;
      for (let i = 0; i < cases.length; i++) {
        minify(cases[i]);
      }
      plural.c = cases;
      delete plural.cases;
      break;
    }
    case 2: {
      const message = node;
      const items = message.items;
      for (let i = 0; i < items.length; i++) {
        minify(items[i]);
      }
      message.i = items;
      delete message.items;
      if (message.static) {
        message.s = message.static;
        delete message.static;
      }
      break;
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const valueNode = node;
      if (valueNode.value) {
        valueNode.v = valueNode.value;
        delete valueNode.value;
      }
      break;
    }
    case 6: {
      const linked = node;
      minify(linked.key);
      linked.k = linked.key;
      delete linked.key;
      if (linked.modifier) {
        minify(linked.modifier);
        linked.m = linked.modifier;
        delete linked.modifier;
      }
      break;
    }
    case 5: {
      const list = node;
      list.i = list.index;
      delete list.index;
      break;
    }
    case 4: {
      const named = node;
      named.k = named.key;
      delete named.key;
      break;
    }
    default: {
      throw createCompileError(CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, null, {
        domain: ERROR_DOMAIN$1,
        args: [node.type]
      });
    }
  }
  delete node.type;
}
const ERROR_DOMAIN = "parser";
function createCodeGenerator(ast, options) {
  const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options;
  const location2 = options.location !== false;
  const _context = {
    filename,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode,
    needIndent: _needIndent,
    indentLevel: 0
  };
  if (location2 && ast.loc) {
    _context.source = ast.loc.source;
  }
  const context = () => _context;
  function push(code2, node) {
    _context.code += code2;
  }
  function _newline(n, withBreakLine = true) {
    const _breakLineCode = withBreakLine ? breakLineCode : "";
    push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);
  }
  function indent(withNewLine = true) {
    const level = ++_context.indentLevel;
    withNewLine && _newline(level);
  }
  function deindent(withNewLine = true) {
    const level = --_context.indentLevel;
    withNewLine && _newline(level);
  }
  function newline() {
    _newline(_context.indentLevel);
  }
  const helper = (key) => `_${key}`;
  const needIndent = () => _context.needIndent;
  return {
    context,
    push,
    indent,
    deindent,
    newline,
    helper,
    needIndent
  };
}
function generateLinkedNode(generator2, node) {
  const { helper } = generator2;
  generator2.push(`${helper(
    "linked"
    /* HelperNameMap.LINKED */
  )}(`);
  generateNode(generator2, node.key);
  if (node.modifier) {
    generator2.push(`, `);
    generateNode(generator2, node.modifier);
    generator2.push(`, _type`);
  } else {
    generator2.push(`, undefined, _type`);
  }
  generator2.push(`)`);
}
function generateMessageNode(generator2, node) {
  const { helper, needIndent } = generator2;
  generator2.push(`${helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  )}([`);
  generator2.indent(needIndent());
  const length = node.items.length;
  for (let i = 0; i < length; i++) {
    generateNode(generator2, node.items[i]);
    if (i === length - 1) {
      break;
    }
    generator2.push(", ");
  }
  generator2.deindent(needIndent());
  generator2.push("])");
}
function generatePluralNode(generator2, node) {
  const { helper, needIndent } = generator2;
  if (node.cases.length > 1) {
    generator2.push(`${helper(
      "plural"
      /* HelperNameMap.PLURAL */
    )}([`);
    generator2.indent(needIndent());
    const length = node.cases.length;
    for (let i = 0; i < length; i++) {
      generateNode(generator2, node.cases[i]);
      if (i === length - 1) {
        break;
      }
      generator2.push(", ");
    }
    generator2.deindent(needIndent());
    generator2.push(`])`);
  }
}
function generateResource(generator2, node) {
  if (node.body) {
    generateNode(generator2, node.body);
  } else {
    generator2.push("null");
  }
}
function generateNode(generator2, node) {
  const { helper } = generator2;
  switch (node.type) {
    case 0:
      generateResource(generator2, node);
      break;
    case 1:
      generatePluralNode(generator2, node);
      break;
    case 2:
      generateMessageNode(generator2, node);
      break;
    case 6:
      generateLinkedNode(generator2, node);
      break;
    case 8:
      generator2.push(JSON.stringify(node.value), node);
      break;
    case 7:
      generator2.push(JSON.stringify(node.value), node);
      break;
    case 5:
      generator2.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "list"
        /* HelperNameMap.LIST */
      )}(${node.index}))`, node);
      break;
    case 4:
      generator2.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "named"
        /* HelperNameMap.NAMED */
      )}(${JSON.stringify(node.key)}))`, node);
      break;
    case 9:
      generator2.push(JSON.stringify(node.value), node);
      break;
    case 3:
      generator2.push(JSON.stringify(node.value), node);
      break;
    default: {
      throw createCompileError(CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, null, {
        domain: ERROR_DOMAIN,
        args: [node.type]
      });
    }
  }
}
const generate$2 = (ast, options = {}) => {
  const mode = isString(options.mode) ? options.mode : "normal";
  const filename = isString(options.filename) ? options.filename : "message.intl";
  const sourceMap = !!options.sourceMap;
  const breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === "arrow" ? ";" : "\n";
  const needIndent = options.needIndent ? options.needIndent : mode !== "arrow";
  const helpers = ast.helpers || [];
  const generator2 = createCodeGenerator(ast, {
    mode,
    filename,
    sourceMap,
    breakLineCode,
    needIndent
  });
  generator2.push(mode === "normal" ? `function __msg__ (ctx) {` : `(ctx) => {`);
  generator2.indent(needIndent);
  if (helpers.length > 0) {
    generator2.push(`const { ${join(helpers.map((s) => `${s}: _${s}`), ", ")} } = ctx`);
    generator2.newline();
  }
  generator2.push(`return `);
  generateNode(generator2, ast);
  generator2.deindent(needIndent);
  generator2.push(`}`);
  delete ast.helpers;
  const { code: code2, map } = generator2.context();
  return {
    ast,
    code: code2,
    map: map ? map.toJSON() : void 0
    // eslint-disable-line @typescript-eslint/no-explicit-any
  };
};
function baseCompile$1(source, options = {}) {
  const assignedOptions = assign({}, options);
  const jit = !!assignedOptions.jit;
  const enalbeMinify = !!assignedOptions.minify;
  const enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;
  const parser2 = createParser(assignedOptions);
  const ast = parser2.parse(source);
  if (!jit) {
    transform$3(ast, assignedOptions);
    return generate$2(ast, assignedOptions);
  } else {
    enambeOptimize && optimize3(ast);
    enalbeMinify && minify(ast);
    return { ast, code: "" };
  }
}
/*!
  * core-base v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function initFeatureFlags$1() {
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
  if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
    getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
  }
  if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
    getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
  }
}
const pathStateMachine = [];
pathStateMachine[
  0
  /* States.BEFORE_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    0
    /* States.BEFORE_PATH */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  1
  /* States.IN_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1
    /* States.IN_PATH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  2
  /* States.BEFORE_IDENT */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  3
  /* States.IN_IDENT */
] = {
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1,
    1
    /* Actions.PUSH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2,
    1
    /* Actions.PUSH */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    1
    /* Actions.PUSH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7,
    1
    /* Actions.PUSH */
  ]
};
pathStateMachine[
  4
  /* States.IN_SUB_PATH */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ],
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  [
    "]"
    /* PathCharTypes.RIGHT_BRACKET */
  ]: [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ]
};
const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function isLiteral(exp) {
  return literalValueRE.test(exp);
}
function stripQuotes(str) {
  const a = str.charCodeAt(0);
  const b = str.charCodeAt(str.length - 1);
  return a === b && (a === 34 || a === 39) ? str.slice(1, -1) : str;
}
function getPathCharType(ch) {
  if (ch === void 0 || ch === null) {
    return "o";
  }
  const code2 = ch.charCodeAt(0);
  switch (code2) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return ch;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w";
  }
  return "i";
}
function formatSubPath(path) {
  const trimmed = path.trim();
  if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
    return false;
  }
  return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
}
function parse3(path) {
  const keys = [];
  let index2 = -1;
  let mode = 0;
  let subPathDepth = 0;
  let c;
  let key;
  let newChar;
  let type2;
  let transition;
  let action;
  let typeMap;
  const actions = [];
  actions[
    0
    /* Actions.APPEND */
  ] = () => {
    if (key === void 0) {
      key = newChar;
    } else {
      key += newChar;
    }
  };
  actions[
    1
    /* Actions.PUSH */
  ] = () => {
    if (key !== void 0) {
      keys.push(key);
      key = void 0;
    }
  };
  actions[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    actions[
      0
      /* Actions.APPEND */
    ]();
    subPathDepth++;
  };
  actions[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode = 4;
      actions[
        0
        /* Actions.APPEND */
      ]();
    } else {
      subPathDepth = 0;
      if (key === void 0) {
        return false;
      }
      key = formatSubPath(key);
      if (key === false) {
        return false;
      } else {
        actions[
          1
          /* Actions.PUSH */
        ]();
      }
    }
  };
  function maybeUnescapeQuote() {
    const nextChar = path[index2 + 1];
    if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
      index2++;
      newChar = "\\" + nextChar;
      actions[
        0
        /* Actions.APPEND */
      ]();
      return true;
    }
  }
  while (mode !== null) {
    index2++;
    c = path[index2];
    if (c === "\\" && maybeUnescapeQuote()) {
      continue;
    }
    type2 = getPathCharType(c);
    typeMap = pathStateMachine[mode];
    transition = typeMap[type2] || typeMap[
      "l"
      /* PathCharTypes.ELSE */
    ] || 8;
    if (transition === 8) {
      return;
    }
    mode = transition[0];
    if (transition[1] !== void 0) {
      action = actions[transition[1]];
      if (action) {
        newChar = c;
        if (action() === false) {
          return;
        }
      }
    }
    if (mode === 7) {
      return keys;
    }
  }
}
const cache = /* @__PURE__ */ new Map();
function resolveWithKeyValue(obj, path) {
  return isObject$1(obj) ? obj[path] : null;
}
function resolveValue(obj, path) {
  if (!isObject$1(obj)) {
    return null;
  }
  let hit = cache.get(path);
  if (!hit) {
    hit = parse3(path);
    if (hit) {
      cache.set(path, hit);
    }
  }
  if (!hit) {
    return null;
  }
  const len = hit.length;
  let last = obj;
  let i = 0;
  while (i < len) {
    const val = last[hit[i]];
    if (val === void 0) {
      return null;
    }
    if (isFunction(last)) {
      return null;
    }
    last = val;
    i++;
  }
  return last;
}
const DEFAULT_MODIFIER = (str) => str;
const DEFAULT_MESSAGE = (ctx) => "";
const DEFAULT_MESSAGE_DATA_TYPE = "text";
const DEFAULT_NORMALIZE = (values) => values.length === 0 ? "" : join$1(values);
const DEFAULT_INTERPOLATE = toDisplayString;
function pluralDefault(choice2, choicesLength) {
  choice2 = Math.abs(choice2);
  if (choicesLength === 2) {
    return choice2 ? choice2 > 1 ? 1 : 0 : 1;
  }
  return choice2 ? Math.min(choice2, 2) : 0;
}
function getPluralIndex(options) {
  const index2 = isNumber(options.pluralIndex) ? options.pluralIndex : -1;
  return options.named && (isNumber(options.named.count) || isNumber(options.named.n)) ? isNumber(options.named.count) ? options.named.count : isNumber(options.named.n) ? options.named.n : index2 : index2;
}
function normalizeNamed(pluralIndex, props) {
  if (!props.count) {
    props.count = pluralIndex;
  }
  if (!props.n) {
    props.n = pluralIndex;
  }
}
function createMessageContext(options = {}) {
  const locale = options.locale;
  const pluralIndex = getPluralIndex(options);
  const pluralRule = isObject$1(options.pluralRules) && isString$1(locale) && isFunction(options.pluralRules[locale]) ? options.pluralRules[locale] : pluralDefault;
  const orgPluralRule = isObject$1(options.pluralRules) && isString$1(locale) && isFunction(options.pluralRules[locale]) ? pluralDefault : void 0;
  const plural = (messages) => {
    return messages[pluralRule(pluralIndex, messages.length, orgPluralRule)];
  };
  const _list = options.list || [];
  const list = (index2) => _list[index2];
  const _named = options.named || {};
  isNumber(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
  const named = (key) => _named[key];
  function message(key) {
    const msg = isFunction(options.messages) ? options.messages(key) : isObject$1(options.messages) ? options.messages[key] : false;
    return !msg ? options.parent ? options.parent.message(key) : DEFAULT_MESSAGE : msg;
  }
  const _modifier = (name) => options.modifiers ? options.modifiers[name] : DEFAULT_MODIFIER;
  const normalize = isPlainObject(options.processor) && isFunction(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
  const interpolate = isPlainObject(options.processor) && isFunction(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
  const type2 = isPlainObject(options.processor) && isString$1(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
  const linked = (key, ...args) => {
    const [arg1, arg2] = args;
    let type22 = "text";
    let modifier = "";
    if (args.length === 1) {
      if (isObject$1(arg1)) {
        modifier = arg1.modifier || modifier;
        type22 = arg1.type || type22;
      } else if (isString$1(arg1)) {
        modifier = arg1 || modifier;
      }
    } else if (args.length === 2) {
      if (isString$1(arg1)) {
        modifier = arg1 || modifier;
      }
      if (isString$1(arg2)) {
        type22 = arg2 || type22;
      }
    }
    const ret = message(key)(ctx);
    const msg = (
      // The message in vnode resolved with linked are returned as an array by processor.nomalize
      type22 === "vnode" && isArray(ret) && modifier ? ret[0] : ret
    );
    return modifier ? _modifier(modifier)(msg, type22) : msg;
  };
  const ctx = {
    [
      "list"
      /* HelperNameMap.LIST */
    ]: list,
    [
      "named"
      /* HelperNameMap.NAMED */
    ]: named,
    [
      "plural"
      /* HelperNameMap.PLURAL */
    ]: plural,
    [
      "linked"
      /* HelperNameMap.LINKED */
    ]: linked,
    [
      "message"
      /* HelperNameMap.MESSAGE */
    ]: message,
    [
      "type"
      /* HelperNameMap.TYPE */
    ]: type2,
    [
      "interpolate"
      /* HelperNameMap.INTERPOLATE */
    ]: interpolate,
    [
      "normalize"
      /* HelperNameMap.NORMALIZE */
    ]: normalize,
    [
      "values"
      /* HelperNameMap.VALUES */
    ]: assign$1({}, _list, _named)
  };
  return ctx;
}
let devtools = null;
function setDevToolsHook(hook) {
  devtools = hook;
}
function initI18nDevTools(i18n2, version2, meta) {
  devtools && devtools.emit("i18n:init", {
    timestamp: Date.now(),
    i18n: i18n2,
    version: version2,
    meta
  });
}
const translateDevTools = /* @__PURE__ */ createDevToolsHook(
  "function:translate"
  /* IntlifyDevToolsHooks.FunctionTranslate */
);
function createDevToolsHook(hook) {
  return (payloads) => devtools && devtools.emit(hook, payloads);
}
const code$1$1 = CompileWarnCodes.__EXTEND_POINT__;
const inc$1$1 = incrementer(code$1$1);
const CoreWarnCodes = {
  NOT_FOUND_KEY: code$1$1,
  // 2
  FALLBACK_TO_TRANSLATE: inc$1$1(),
  // 3
  CANNOT_FORMAT_NUMBER: inc$1$1(),
  // 4
  FALLBACK_TO_NUMBER_FORMAT: inc$1$1(),
  // 5
  CANNOT_FORMAT_DATE: inc$1$1(),
  // 6
  FALLBACK_TO_DATE_FORMAT: inc$1$1(),
  // 7
  EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: inc$1$1(),
  // 8
  __EXTEND_POINT__: inc$1$1()
  // 9
};
const code$2 = CompileErrorCodes.__EXTEND_POINT__;
const inc$2 = incrementer(code$2);
const CoreErrorCodes = {
  INVALID_ARGUMENT: code$2,
  // 17
  INVALID_DATE_ARGUMENT: inc$2(),
  // 18
  INVALID_ISO_DATE_ARGUMENT: inc$2(),
  // 19
  NOT_SUPPORT_NON_STRING_MESSAGE: inc$2(),
  // 20
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: inc$2(),
  // 21
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: inc$2(),
  // 22
  NOT_SUPPORT_LOCALE_TYPE: inc$2(),
  // 23
  __EXTEND_POINT__: inc$2()
  // 24
};
function createCoreError(code2) {
  return createCompileError(code2, null, void 0);
}
function getLocale(context, options) {
  return options.locale != null ? resolveLocale(options.locale) : resolveLocale(context.locale);
}
let _resolveLocale;
function resolveLocale(locale) {
  if (isString$1(locale)) {
    return locale;
  } else {
    if (isFunction(locale)) {
      if (locale.resolvedOnce && _resolveLocale != null) {
        return _resolveLocale;
      } else if (locale.constructor.name === "Function") {
        const resolve2 = locale();
        if (isPromise(resolve2)) {
          throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
        }
        return _resolveLocale = resolve2;
      } else {
        throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
      }
    } else {
      throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE);
    }
  }
}
function fallbackWithSimple(ctx, fallback, start) {
  return [.../* @__PURE__ */ new Set([
    start,
    ...isArray(fallback) ? fallback : isObject$1(fallback) ? Object.keys(fallback) : isString$1(fallback) ? [fallback] : [start]
  ])];
}
function fallbackWithLocaleChain(ctx, fallback, start) {
  const startLocale = isString$1(start) ? start : DEFAULT_LOCALE;
  const context = ctx;
  if (!context.__localeChainCache) {
    context.__localeChainCache = /* @__PURE__ */ new Map();
  }
  let chain = context.__localeChainCache.get(startLocale);
  if (!chain) {
    chain = [];
    let block = [start];
    while (isArray(block)) {
      block = appendBlockToChain(chain, block, fallback);
    }
    const defaults = isArray(fallback) || !isPlainObject(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
    block = isString$1(defaults) ? [defaults] : defaults;
    if (isArray(block)) {
      appendBlockToChain(chain, block, false);
    }
    context.__localeChainCache.set(startLocale, chain);
  }
  return chain;
}
function appendBlockToChain(chain, block, blocks) {
  let follow = true;
  for (let i = 0; i < block.length && isBoolean(follow); i++) {
    const locale = block[i];
    if (isString$1(locale)) {
      follow = appendLocaleToChain(chain, block[i], blocks);
    }
  }
  return follow;
}
function appendLocaleToChain(chain, locale, blocks) {
  let follow;
  const tokens2 = locale.split("-");
  do {
    const target = tokens2.join("-");
    follow = appendItemToChain(chain, target, blocks);
    tokens2.splice(-1, 1);
  } while (tokens2.length && follow === true);
  return follow;
}
function appendItemToChain(chain, target, blocks) {
  let follow = false;
  if (!chain.includes(target)) {
    follow = true;
    if (target) {
      follow = target[target.length - 1] !== "!";
      const locale = target.replace(/!/g, "");
      chain.push(locale);
      if ((isArray(blocks) || isPlainObject(blocks)) && blocks[locale]) {
        follow = blocks[locale];
      }
    }
  }
  return follow;
}
const VERSION$1 = "9.13.1";
const NOT_REOSLVED = -1;
const DEFAULT_LOCALE = "en-US";
const MISSING_RESOLVE_VALUE = "";
const capitalize = (str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;
function getDefaultLinkedModifiers() {
  return {
    upper: (val, type2) => {
      return type2 === "text" && isString$1(val) ? val.toUpperCase() : type2 === "vnode" && isObject$1(val) && "__v_isVNode" in val ? val.children.toUpperCase() : val;
    },
    lower: (val, type2) => {
      return type2 === "text" && isString$1(val) ? val.toLowerCase() : type2 === "vnode" && isObject$1(val) && "__v_isVNode" in val ? val.children.toLowerCase() : val;
    },
    capitalize: (val, type2) => {
      return type2 === "text" && isString$1(val) ? capitalize(val) : type2 === "vnode" && isObject$1(val) && "__v_isVNode" in val ? capitalize(val.children) : val;
    }
  };
}
let _compiler;
function registerMessageCompiler(compiler) {
  _compiler = compiler;
}
let _resolver;
function registerMessageResolver(resolver) {
  _resolver = resolver;
}
let _fallbacker;
function registerLocaleFallbacker(fallbacker) {
  _fallbacker = fallbacker;
}
let _additionalMeta = null;
const setAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ (meta) => {
  _additionalMeta = meta;
};
const getAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ () => _additionalMeta;
let _fallbackContext = null;
const setFallbackContext = (context) => {
  _fallbackContext = context;
};
const getFallbackContext = () => _fallbackContext;
let _cid = 0;
function createCoreContext(options = {}) {
  const onWarn = isFunction(options.onWarn) ? options.onWarn : warn;
  const version2 = isString$1(options.version) ? options.version : VERSION$1;
  const locale = isString$1(options.locale) || isFunction(options.locale) ? options.locale : DEFAULT_LOCALE;
  const _locale = isFunction(locale) ? DEFAULT_LOCALE : locale;
  const fallbackLocale = isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || isString$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale;
  const messages = isPlainObject(options.messages) ? options.messages : { [_locale]: {} };
  const datetimeFormats = isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale]: {} };
  const numberFormats = isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale]: {} };
  const modifiers = assign$1({}, options.modifiers || {}, getDefaultLinkedModifiers());
  const pluralRules = options.pluralRules || {};
  const missing = isFunction(options.missing) ? options.missing : null;
  const missingWarn = isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  const fallbackWarn = isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  const fallbackFormat = !!options.fallbackFormat;
  const unresolving = !!options.unresolving;
  const postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  const processor = isPlainObject(options.processor) ? options.processor : null;
  const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  const escapeParameter = !!options.escapeParameter;
  const messageCompiler = isFunction(options.messageCompiler) ? options.messageCompiler : _compiler;
  const messageResolver = isFunction(options.messageResolver) ? options.messageResolver : _resolver || resolveWithKeyValue;
  const localeFallbacker = isFunction(options.localeFallbacker) ? options.localeFallbacker : _fallbacker || fallbackWithSimple;
  const fallbackContext = isObject$1(options.fallbackContext) ? options.fallbackContext : void 0;
  const internalOptions = options;
  const __datetimeFormatters = isObject$1(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
  const __numberFormatters = isObject$1(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
  const __meta = isObject$1(internalOptions.__meta) ? internalOptions.__meta : {};
  _cid++;
  const context = {
    version: version2,
    cid: _cid,
    locale,
    fallbackLocale,
    messages,
    modifiers,
    pluralRules,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackFormat,
    unresolving,
    postTranslation,
    processor,
    warnHtmlMessage,
    escapeParameter,
    messageCompiler,
    messageResolver,
    localeFallbacker,
    fallbackContext,
    onWarn,
    __meta
  };
  {
    context.datetimeFormats = datetimeFormats;
    context.numberFormats = numberFormats;
    context.__datetimeFormatters = __datetimeFormatters;
    context.__numberFormatters = __numberFormatters;
  }
  if (__INTLIFY_PROD_DEVTOOLS__) {
    initI18nDevTools(context, version2, __meta);
  }
  return context;
}
function handleMissing(context, key, locale, missingWarn, type2) {
  const { missing, onWarn } = context;
  if (missing !== null) {
    const ret = missing(context, locale, key, type2);
    return isString$1(ret) ? ret : key;
  } else {
    return key;
  }
}
function updateFallbackLocale(ctx, locale, fallback) {
  const context = ctx;
  context.__localeChainCache = /* @__PURE__ */ new Map();
  ctx.localeFallbacker(ctx, fallback, locale);
}
function isAlmostSameLocale(locale, compareLocale) {
  if (locale === compareLocale)
    return false;
  return locale.split("-")[0] === compareLocale.split("-")[0];
}
function isImplicitFallback(targetLocale, locales) {
  const index2 = locales.indexOf(targetLocale);
  if (index2 === -1) {
    return false;
  }
  for (let i = index2 + 1; i < locales.length; i++) {
    if (isAlmostSameLocale(targetLocale, locales[i])) {
      return true;
    }
  }
  return false;
}
function format$1(ast) {
  const msg = (ctx) => formatParts(ctx, ast);
  return msg;
}
function formatParts(ctx, ast) {
  const body = ast.b || ast.body;
  if ((body.t || body.type) === 1) {
    const plural = body;
    const cases = plural.c || plural.cases;
    return ctx.plural(cases.reduce((messages, c) => [
      ...messages,
      formatMessageParts(ctx, c)
    ], []));
  } else {
    return formatMessageParts(ctx, body);
  }
}
function formatMessageParts(ctx, node) {
  const _static = node.s || node.static;
  if (_static) {
    return ctx.type === "text" ? _static : ctx.normalize([_static]);
  } else {
    const messages = (node.i || node.items).reduce((acm, c) => [...acm, formatMessagePart(ctx, c)], []);
    return ctx.normalize(messages);
  }
}
function formatMessagePart(ctx, node) {
  const type2 = node.t || node.type;
  switch (type2) {
    case 3: {
      const text = node;
      return text.v || text.value;
    }
    case 9: {
      const literal = node;
      return literal.v || literal.value;
    }
    case 4: {
      const named = node;
      return ctx.interpolate(ctx.named(named.k || named.key));
    }
    case 5: {
      const list = node;
      return ctx.interpolate(ctx.list(list.i != null ? list.i : list.index));
    }
    case 6: {
      const linked = node;
      const modifier = linked.m || linked.modifier;
      return ctx.linked(formatMessagePart(ctx, linked.k || linked.key), modifier ? formatMessagePart(ctx, modifier) : void 0, ctx.type);
    }
    case 7: {
      const linkedKey = node;
      return linkedKey.v || linkedKey.value;
    }
    case 8: {
      const linkedModifier = node;
      return linkedModifier.v || linkedModifier.value;
    }
    default:
      throw new Error(`unhandled node type on format message part: ${type2}`);
  }
}
const defaultOnCacheKey = (message) => message;
let compileCache = /* @__PURE__ */ Object.create(null);
const isMessageAST = (val) => isObject$1(val) && (val.t === 0 || val.type === 0) && ("b" in val || "body" in val);
function baseCompile(message, options = {}) {
  let detectError = false;
  const onError = options.onError || defaultOnError;
  options.onError = (err) => {
    detectError = true;
    onError(err);
  };
  return { ...baseCompile$1(message, options), detectError };
}
const compileToFunction = /* @__NO_SIDE_EFFECTS__ */ (message, context) => {
  if (!isString$1(message)) {
    throw createCoreError(CoreErrorCodes.NOT_SUPPORT_NON_STRING_MESSAGE);
  }
  {
    isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
    const onCacheKey = context.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { code: code2, detectError } = baseCompile(message, context);
    const msg = new Function(`return ${code2}`)();
    return !detectError ? compileCache[cacheKey] = msg : msg;
  }
};
function compile(message, context) {
  if (__INTLIFY_JIT_COMPILATION__ && !__INTLIFY_DROP_MESSAGE_COMPILER__ && isString$1(message)) {
    isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
    const onCacheKey = context.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { ast, detectError } = baseCompile(message, {
      ...context,
      location: false,
      jit: true
    });
    const msg = format$1(ast);
    return !detectError ? compileCache[cacheKey] = msg : msg;
  } else {
    const cacheKey = message.cacheKey;
    if (cacheKey) {
      const cached = compileCache[cacheKey];
      if (cached) {
        return cached;
      }
      return compileCache[cacheKey] = format$1(message);
    } else {
      return format$1(message);
    }
  }
}
const NOOP_MESSAGE_FUNCTION = () => "";
const isMessageFunction = (val) => isFunction(val);
function translate(context, ...args) {
  const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages } = context;
  const [key, options] = parseTranslateArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const escapeParameter = isBoolean(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
  const resolvedMessage = !!options.resolvedMessage;
  const defaultMsgOrKey = isString$1(options.default) || isBoolean(options.default) ? !isBoolean(options.default) ? options.default : !messageCompiler ? () => key : key : fallbackFormat ? !messageCompiler ? () => key : key : "";
  const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
  const locale = getLocale(context, options);
  escapeParameter && escapeParams(options);
  let [formatScope, targetLocale, message] = !resolvedMessage ? resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) : [
    key,
    locale,
    messages[locale] || {}
  ];
  let format2 = formatScope;
  let cacheBaseKey = key;
  if (!resolvedMessage && !(isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2))) {
    if (enableDefaultMsg) {
      format2 = defaultMsgOrKey;
      cacheBaseKey = format2;
    }
  }
  if (!resolvedMessage && (!(isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2)) || !isString$1(targetLocale))) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let occurred = false;
  const onError = () => {
    occurred = true;
  };
  const msg = !isMessageFunction(format2) ? compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) : format2;
  if (occurred) {
    return format2;
  }
  const ctxOptions = getMessageContextOptions(context, targetLocale, message, options);
  const msgContext = createMessageContext(ctxOptions);
  const messaged = evaluateMessage(context, msg, msgContext);
  const ret = postTranslation ? postTranslation(messaged, key) : messaged;
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const payloads = {
      timestamp: Date.now(),
      key: isString$1(key) ? key : isMessageFunction(format2) ? format2.key : "",
      locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
      format: isString$1(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
      message: ret
    };
    payloads.meta = assign$1({}, context.__meta, /* @__PURE__ */ getAdditionalMeta() || {});
    translateDevTools(payloads);
  }
  return ret;
}
function escapeParams(options) {
  if (isArray(options.list)) {
    options.list = options.list.map((item) => isString$1(item) ? escapeHtml(item) : item);
  } else if (isObject$1(options.named)) {
    Object.keys(options.named).forEach((key) => {
      if (isString$1(options.named[key])) {
        options.named[key] = escapeHtml(options.named[key]);
      }
    });
  }
}
function resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {
  const { messages, onWarn, messageResolver: resolveValue2, localeFallbacker } = context;
  const locales = localeFallbacker(context, fallbackLocale, locale);
  let message = {};
  let targetLocale;
  let format2 = null;
  const type2 = "translate";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    message = messages[targetLocale] || {};
    if ((format2 = resolveValue2(message, key)) === null) {
      format2 = message[key];
    }
    if (isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2)) {
      break;
    }
    if (!isImplicitFallback(targetLocale, locales)) {
      const missingRet = handleMissing(
        context,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        key,
        targetLocale,
        missingWarn,
        type2
      );
      if (missingRet !== key) {
        format2 = missingRet;
      }
    }
  }
  return [format2, targetLocale, message];
}
function compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) {
  const { messageCompiler, warnHtmlMessage } = context;
  if (isMessageFunction(format2)) {
    const msg2 = format2;
    msg2.locale = msg2.locale || targetLocale;
    msg2.key = msg2.key || key;
    return msg2;
  }
  if (messageCompiler == null) {
    const msg2 = () => format2;
    msg2.locale = targetLocale;
    msg2.key = key;
    return msg2;
  }
  const msg = messageCompiler(format2, getCompileContext(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, onError));
  msg.locale = targetLocale;
  msg.key = key;
  msg.source = format2;
  return msg;
}
function evaluateMessage(context, msg, msgCtx) {
  const messaged = msg(msgCtx);
  return messaged;
}
function parseTranslateArgs(...args) {
  const [arg1, arg2, arg3] = args;
  const options = {};
  if (!isString$1(arg1) && !isNumber(arg1) && !isMessageFunction(arg1) && !isMessageAST(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const key = isNumber(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
  if (isNumber(arg2)) {
    options.plural = arg2;
  } else if (isString$1(arg2)) {
    options.default = arg2;
  } else if (isPlainObject(arg2) && !isEmptyObject(arg2)) {
    options.named = arg2;
  } else if (isArray(arg2)) {
    options.list = arg2;
  }
  if (isNumber(arg3)) {
    options.plural = arg3;
  } else if (isString$1(arg3)) {
    options.default = arg3;
  } else if (isPlainObject(arg3)) {
    assign$1(options, arg3);
  }
  return [key, options];
}
function getCompileContext(context, locale, key, source, warnHtmlMessage, onError) {
  return {
    locale,
    key,
    warnHtmlMessage,
    onError: (err) => {
      onError && onError(err);
      {
        throw err;
      }
    },
    onCacheKey: (source2) => generateFormatCacheKey(locale, key, source2)
  };
}
function getMessageContextOptions(context, locale, message, options) {
  const { modifiers, pluralRules, messageResolver: resolveValue2, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
  const resolveMessage = (key) => {
    let val = resolveValue2(message, key);
    if (val == null && fallbackContext) {
      const [, , message2] = resolveMessageFormat(fallbackContext, key, locale, fallbackLocale, fallbackWarn, missingWarn);
      val = resolveValue2(message2, key);
    }
    if (isString$1(val) || isMessageAST(val)) {
      let occurred = false;
      const onError = () => {
        occurred = true;
      };
      const msg = compileMessageFormat(context, key, locale, val, key, onError);
      return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
    } else if (isMessageFunction(val)) {
      return val;
    } else {
      return NOOP_MESSAGE_FUNCTION;
    }
  };
  const ctxOptions = {
    locale,
    modifiers,
    pluralRules,
    messages: resolveMessage
  };
  if (context.processor) {
    ctxOptions.processor = context.processor;
  }
  if (options.list) {
    ctxOptions.list = options.list;
  }
  if (options.named) {
    ctxOptions.named = options.named;
  }
  if (isNumber(options.plural)) {
    ctxOptions.pluralIndex = options.plural;
  }
  return ctxOptions;
}
function datetime(context, ...args) {
  const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __datetimeFormatters } = context;
  const [key, value, options, overrides] = parseDateTimeArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = getLocale(context, options);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale
  );
  if (!isString$1(key) || key === "") {
    return new Intl.DateTimeFormat(locale, overrides).format(value);
  }
  let datetimeFormat = {};
  let targetLocale;
  let format2 = null;
  const type2 = "datetime format";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    datetimeFormat = datetimeFormats[targetLocale] || {};
    format2 = datetimeFormat[key];
    if (isPlainObject(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type2);
  }
  if (!isPlainObject(format2) || !isString$1(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id = `${id}__${JSON.stringify(overrides)}`;
  }
  let formatter = __datetimeFormatters.get(id);
  if (!formatter) {
    formatter = new Intl.DateTimeFormat(targetLocale, assign$1({}, format2, overrides));
    __datetimeFormatters.set(id, formatter);
  }
  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
const DATETIME_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function parseDateTimeArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = {};
  let overrides = {};
  let value;
  if (isString$1(arg1)) {
    const matches = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!matches) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
    const dateTime = matches[3] ? matches[3].trim().startsWith("T") ? `${matches[1].trim()}${matches[3].trim()}` : `${matches[1].trim()}T${matches[3].trim()}` : matches[1].trim();
    value = new Date(dateTime);
    try {
      value.toISOString();
    } catch (e2) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (isDate(arg1)) {
    if (isNaN(arg1.getTime())) {
      throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
    }
    value = arg1;
  } else if (isNumber(arg1)) {
    value = arg1;
  } else {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  if (isString$1(arg2)) {
    options.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }
  if (isString$1(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value, options, overrides];
}
function clearDateTimeFormat(ctx, locale, format2) {
  const context = ctx;
  for (const key in format2) {
    const id = `${locale}__${key}`;
    if (!context.__datetimeFormatters.has(id)) {
      continue;
    }
    context.__datetimeFormatters.delete(id);
  }
}
function number(context, ...args) {
  const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __numberFormatters } = context;
  const [key, value, options, overrides] = parseNumberArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = getLocale(context, options);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale
  );
  if (!isString$1(key) || key === "") {
    return new Intl.NumberFormat(locale, overrides).format(value);
  }
  let numberFormat = {};
  let targetLocale;
  let format2 = null;
  const type2 = "number format";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    numberFormat = numberFormats[targetLocale] || {};
    format2 = numberFormat[key];
    if (isPlainObject(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type2);
  }
  if (!isPlainObject(format2) || !isString$1(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id = `${id}__${JSON.stringify(overrides)}`;
  }
  let formatter = __numberFormatters.get(id);
  if (!formatter) {
    formatter = new Intl.NumberFormat(targetLocale, assign$1({}, format2, overrides));
    __numberFormatters.set(id, formatter);
  }
  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
const NUMBER_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function parseNumberArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = {};
  let overrides = {};
  if (!isNumber(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const value = arg1;
  if (isString$1(arg2)) {
    options.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }
  if (isString$1(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value, options, overrides];
}
function clearNumberFormat(ctx, locale, format2) {
  const context = ctx;
  for (const key in format2) {
    const id = `${locale}__${key}`;
    if (!context.__numberFormatters.has(id)) {
      continue;
    }
    context.__numberFormatters.delete(id);
  }
}
{
  initFeatureFlags$1();
}
/*!
  * vue-i18n v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const VERSION = "9.13.1";
function initFeatureFlags() {
  if (typeof __VUE_I18N_FULL_INSTALL__ !== "boolean") {
    getGlobalThis().__VUE_I18N_FULL_INSTALL__ = true;
  }
  if (typeof __VUE_I18N_LEGACY_API__ !== "boolean") {
    getGlobalThis().__VUE_I18N_LEGACY_API__ = true;
  }
  if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
    getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
  }
  if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
    getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
  }
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}
const code$1 = CoreWarnCodes.__EXTEND_POINT__;
const inc$1 = incrementer(code$1);
({
  FALLBACK_TO_ROOT: code$1,
  // 9
  NOT_SUPPORTED_PRESERVE: inc$1(),
  // 10
  NOT_SUPPORTED_FORMATTER: inc$1(),
  // 11
  NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$1(),
  // 12
  NOT_SUPPORTED_GET_CHOICE_INDEX: inc$1(),
  // 13
  COMPONENT_NAME_LEGACY_COMPATIBLE: inc$1(),
  // 14
  NOT_FOUND_PARENT_SCOPE: inc$1(),
  // 15
  IGNORE_OBJ_FLATTEN: inc$1(),
  // 16
  NOTICE_DROP_ALLOW_COMPOSITION: inc$1(),
  // 17
  NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG: inc$1()
  // 18
});
const code = CoreErrorCodes.__EXTEND_POINT__;
const inc = incrementer(code);
const I18nErrorCodes = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: code,
  // 24
  // legacy module errors
  INVALID_ARGUMENT: inc(),
  // 25
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: inc(),
  // 26
  NOT_INSTALLED: inc(),
  // 27
  NOT_AVAILABLE_IN_LEGACY_MODE: inc(),
  // 28
  // directive module errors
  REQUIRED_VALUE: inc(),
  // 29
  INVALID_VALUE: inc(),
  // 30
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc(),
  // 31
  NOT_INSTALLED_WITH_PROVIDE: inc(),
  // 32
  // unexpected error
  UNEXPECTED_ERROR: inc(),
  // 33
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: inc(),
  // 34
  // bridge support vue 2.x only
  BRIDGE_SUPPORT_VUE_2_ONLY: inc(),
  // 35
  // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
  MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc(),
  // 36
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc(),
  // 37
  // for enhancement
  __EXTEND_POINT__: inc()
  // 38
};
function createI18nError(code2, ...args) {
  return createCompileError(code2, null, void 0);
}
const TranslateVNodeSymbol = /* @__PURE__ */ makeSymbol("__translateVNode");
const DatetimePartsSymbol = /* @__PURE__ */ makeSymbol("__datetimeParts");
const NumberPartsSymbol = /* @__PURE__ */ makeSymbol("__numberParts");
const SetPluralRulesSymbol = makeSymbol("__setPluralRules");
const InejctWithOptionSymbol = /* @__PURE__ */ makeSymbol("__injectWithOption");
const DisposeSymbol = /* @__PURE__ */ makeSymbol("__dispose");
function handleFlatJson(obj) {
  if (!isObject$1(obj)) {
    return obj;
  }
  for (const key in obj) {
    if (!hasOwn(obj, key)) {
      continue;
    }
    if (!key.includes(".")) {
      if (isObject$1(obj[key])) {
        handleFlatJson(obj[key]);
      }
    } else {
      const subKeys = key.split(".");
      const lastIndex = subKeys.length - 1;
      let currentObj = obj;
      let hasStringValue = false;
      for (let i = 0; i < lastIndex; i++) {
        if (!(subKeys[i] in currentObj)) {
          currentObj[subKeys[i]] = {};
        }
        if (!isObject$1(currentObj[subKeys[i]])) {
          hasStringValue = true;
          break;
        }
        currentObj = currentObj[subKeys[i]];
      }
      if (!hasStringValue) {
        currentObj[subKeys[lastIndex]] = obj[key];
        delete obj[key];
      }
      if (isObject$1(currentObj[subKeys[lastIndex]])) {
        handleFlatJson(currentObj[subKeys[lastIndex]]);
      }
    }
  }
  return obj;
}
function getLocaleMessages(locale, options) {
  const { messages, __i18n, messageResolver, flatJson } = options;
  const ret = isPlainObject(messages) ? messages : isArray(__i18n) ? {} : { [locale]: {} };
  if (isArray(__i18n)) {
    __i18n.forEach((custom) => {
      if ("locale" in custom && "resource" in custom) {
        const { locale: locale2, resource } = custom;
        if (locale2) {
          ret[locale2] = ret[locale2] || {};
          deepCopy(resource, ret[locale2]);
        } else {
          deepCopy(resource, ret);
        }
      } else {
        isString$1(custom) && deepCopy(JSON.parse(custom), ret);
      }
    });
  }
  if (messageResolver == null && flatJson) {
    for (const key in ret) {
      if (hasOwn(ret, key)) {
        handleFlatJson(ret[key]);
      }
    }
  }
  return ret;
}
function getComponentOptions(instance2) {
  return instance2.type;
}
function adjustI18nResources(gl, options, componentOptions) {
  let messages = isObject$1(options.messages) ? options.messages : {};
  if ("__i18nGlobal" in componentOptions) {
    messages = getLocaleMessages(gl.locale.value, {
      messages,
      __i18n: componentOptions.__i18nGlobal
    });
  }
  const locales = Object.keys(messages);
  if (locales.length) {
    locales.forEach((locale) => {
      gl.mergeLocaleMessage(locale, messages[locale]);
    });
  }
  {
    if (isObject$1(options.datetimeFormats)) {
      const locales2 = Object.keys(options.datetimeFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          gl.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
        });
      }
    }
    if (isObject$1(options.numberFormats)) {
      const locales2 = Object.keys(options.numberFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          gl.mergeNumberFormat(locale, options.numberFormats[locale]);
        });
      }
    }
  }
}
function createTextNode(key) {
  return createVNode(Text, null, key, 0);
}
const DEVTOOLS_META = "__INTLIFY_META__";
const NOOP_RETURN_ARRAY = () => [];
const NOOP_RETURN_FALSE = () => false;
let composerID = 0;
function defineCoreMissingHandler(missing) {
  return (ctx, locale, key, type2) => {
    return missing(locale, key, getCurrentInstance() || void 0, type2);
  };
}
const getMetaInfo = /* @__NO_SIDE_EFFECTS__ */ () => {
  const instance2 = getCurrentInstance();
  let meta = null;
  return instance2 && (meta = getComponentOptions(instance2)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
};
function createComposer(options = {}, VueI18nLegacy) {
  const { __root, __injectWithOption } = options;
  const _isGlobal = __root === void 0;
  const flatJson = options.flatJson;
  const _ref = inBrowser ? ref : shallowRef;
  const translateExistCompatible = !!options.translateExistCompatible;
  let _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : true;
  const _locale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.locale.value : isString$1(options.locale) ? options.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.fallbackLocale.value : isString$1(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
  );
  const _messages = _ref(getLocaleMessages(_locale.value, options));
  const _datetimeFormats = _ref(isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = _ref(isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
  let _missingWarn = __root ? __root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  let _fallbackFormat = !!options.fallbackFormat;
  let _missing = isFunction(options.missing) ? options.missing : null;
  let _runtimeMissing = isFunction(options.missing) ? defineCoreMissingHandler(options.missing) : null;
  let _postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  let _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  let _escapeParameter = !!options.escapeParameter;
  const _modifiers = __root ? __root.modifiers : isPlainObject(options.modifiers) ? options.modifiers : {};
  let _pluralRules = options.pluralRules || __root && __root.pluralRules;
  let _context;
  const getCoreContext = () => {
    _isGlobal && setFallbackContext(null);
    const ctxOptions = {
      version: VERSION,
      locale: _locale.value,
      fallbackLocale: _fallbackLocale.value,
      messages: _messages.value,
      modifiers: _modifiers,
      pluralRules: _pluralRules,
      missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
      missingWarn: _missingWarn,
      fallbackWarn: _fallbackWarn,
      fallbackFormat: _fallbackFormat,
      unresolving: true,
      postTranslation: _postTranslation === null ? void 0 : _postTranslation,
      warnHtmlMessage: _warnHtmlMessage,
      escapeParameter: _escapeParameter,
      messageResolver: options.messageResolver,
      messageCompiler: options.messageCompiler,
      __meta: { framework: "vue" }
    };
    {
      ctxOptions.datetimeFormats = _datetimeFormats.value;
      ctxOptions.numberFormats = _numberFormats.value;
      ctxOptions.__datetimeFormatters = isPlainObject(_context) ? _context.__datetimeFormatters : void 0;
      ctxOptions.__numberFormatters = isPlainObject(_context) ? _context.__numberFormatters : void 0;
    }
    const ctx = createCoreContext(ctxOptions);
    _isGlobal && setFallbackContext(ctx);
    return ctx;
  };
  _context = getCoreContext();
  updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale = computed({
    get: () => _locale.value,
    set: (val) => {
      _locale.value = val;
      _context.locale = _locale.value;
    }
  });
  const fallbackLocale = computed({
    get: () => _fallbackLocale.value,
    set: (val) => {
      _fallbackLocale.value = val;
      _context.fallbackLocale = _fallbackLocale.value;
      updateFallbackLocale(_context, _locale.value, val);
    }
  });
  const messages = computed(() => _messages.value);
  const datetimeFormats = /* @__PURE__ */ computed(() => _datetimeFormats.value);
  const numberFormats = /* @__PURE__ */ computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return isFunction(_postTranslation) ? _postTranslation : null;
  }
  function setPostTranslationHandler(handler) {
    _postTranslation = handler;
    _context.postTranslation = handler;
  }
  function getMissingHandler() {
    return _missing;
  }
  function setMissingHandler(handler) {
    if (handler !== null) {
      _runtimeMissing = defineCoreMissingHandler(handler);
    }
    _missing = handler;
    _context.missing = _runtimeMissing;
  }
  const wrapWithDeps = (fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
    trackReactivityValues();
    let ret;
    try {
      if (__INTLIFY_PROD_DEVTOOLS__) {
        /* @__PURE__ */ setAdditionalMeta(/* @__PURE__ */ getMetaInfo());
      }
      if (!_isGlobal) {
        _context.fallbackContext = __root ? getFallbackContext() : void 0;
      }
      ret = fn(_context);
    } finally {
      if (__INTLIFY_PROD_DEVTOOLS__)
        ;
      if (!_isGlobal) {
        _context.fallbackContext = void 0;
      }
    }
    if (warnType !== "translate exists" && // for not `te` (e.g `t`)
    isNumber(ret) && ret === NOT_REOSLVED || warnType === "translate exists" && !ret) {
      const [key, arg2] = argumentParser();
      return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
    } else if (successCondition(ret)) {
      return ret;
    } else {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
    }
  };
  function t(...args) {
    return wrapWithDeps((context) => Reflect.apply(translate, null, [context, ...args]), () => parseTranslateArgs(...args), "translate", (root) => Reflect.apply(root.t, root, [...args]), (key) => key, (val) => isString$1(val));
  }
  function rt(...args) {
    const [arg1, arg2, arg3] = args;
    if (arg3 && !isObject$1(arg3)) {
      throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
    }
    return t(...[arg1, arg2, assign$1({ resolvedMessage: true }, arg3 || {})]);
  }
  function d(...args) {
    return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root) => Reflect.apply(root.d, root, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
  }
  function n(...args) {
    return wrapWithDeps((context) => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root) => Reflect.apply(root.n, root, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
  }
  function normalize(values) {
    return values.map((val) => isString$1(val) || isNumber(val) || isBoolean(val) ? createTextNode(String(val)) : val);
  }
  const interpolate = (val) => val;
  const processor = {
    normalize,
    interpolate,
    type: "vnode"
  };
  function translateVNode(...args) {
    return wrapWithDeps(
      (context) => {
        let ret;
        const _context2 = context;
        try {
          _context2.processor = processor;
          ret = Reflect.apply(translate, null, [_context2, ...args]);
        } finally {
          _context2.processor = null;
        }
        return ret;
      },
      () => parseTranslateArgs(...args),
      "translate",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[TranslateVNodeSymbol](...args),
      (key) => [createTextNode(key)],
      (val) => isArray(val)
    );
  }
  function numberParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(number, null, [context, ...args]),
      () => parseNumberArgs(...args),
      "number format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[NumberPartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString$1(val) || isArray(val)
    );
  }
  function datetimeParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(datetime, null, [context, ...args]),
      () => parseDateTimeArgs(...args),
      "datetime format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[DatetimePartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString$1(val) || isArray(val)
    );
  }
  function setPluralRules(rules) {
    _pluralRules = rules;
    _context.pluralRules = _pluralRules;
  }
  function te(key, locale2) {
    return wrapWithDeps(() => {
      if (!key) {
        return false;
      }
      const targetLocale = isString$1(locale2) ? locale2 : _locale.value;
      const message = getLocaleMessage(targetLocale);
      const resolved = _context.messageResolver(message, key);
      return !translateExistCompatible ? isMessageAST(resolved) || isMessageFunction(resolved) || isString$1(resolved) : resolved != null;
    }, () => [key], "translate exists", (root) => {
      return Reflect.apply(root.te, root, [key, locale2]);
    }, NOOP_RETURN_FALSE, (val) => isBoolean(val));
  }
  function resolveMessages(key) {
    let messages2 = null;
    const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
    for (let i = 0; i < locales.length; i++) {
      const targetLocaleMessages = _messages.value[locales[i]] || {};
      const messageValue = _context.messageResolver(targetLocaleMessages, key);
      if (messageValue != null) {
        messages2 = messageValue;
        break;
      }
    }
    return messages2;
  }
  function tm(key) {
    const messages2 = resolveMessages(key);
    return messages2 != null ? messages2 : __root ? __root.tm(key) || {} : {};
  }
  function getLocaleMessage(locale2) {
    return _messages.value[locale2] || {};
  }
  function setLocaleMessage(locale2, message) {
    if (flatJson) {
      const _message = { [locale2]: message };
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
      message = _message[locale2];
    }
    _messages.value[locale2] = message;
    _context.messages = _messages.value;
  }
  function mergeLocaleMessage(locale2, message) {
    _messages.value[locale2] = _messages.value[locale2] || {};
    const _message = { [locale2]: message };
    if (flatJson) {
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
    }
    message = _message[locale2];
    deepCopy(message, _messages.value[locale2]);
    _context.messages = _messages.value;
  }
  function getDateTimeFormat(locale2) {
    return _datetimeFormats.value[locale2] || {};
  }
  function setDateTimeFormat(locale2, format2) {
    _datetimeFormats.value[locale2] = format2;
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format2);
  }
  function mergeDateTimeFormat(locale2, format2) {
    _datetimeFormats.value[locale2] = assign$1(_datetimeFormats.value[locale2] || {}, format2);
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format2);
  }
  function getNumberFormat(locale2) {
    return _numberFormats.value[locale2] || {};
  }
  function setNumberFormat(locale2, format2) {
    _numberFormats.value[locale2] = format2;
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format2);
  }
  function mergeNumberFormat(locale2, format2) {
    _numberFormats.value[locale2] = assign$1(_numberFormats.value[locale2] || {}, format2);
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format2);
  }
  composerID++;
  if (__root && inBrowser) {
    watch(__root.locale, (val) => {
      if (_inheritLocale) {
        _locale.value = val;
        _context.locale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
    watch(__root.fallbackLocale, (val) => {
      if (_inheritLocale) {
        _fallbackLocale.value = val;
        _context.fallbackLocale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
  }
  const composer = {
    id: composerID,
    locale,
    fallbackLocale,
    get inheritLocale() {
      return _inheritLocale;
    },
    set inheritLocale(val) {
      _inheritLocale = val;
      if (val && __root) {
        _locale.value = __root.locale.value;
        _fallbackLocale.value = __root.fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    },
    get availableLocales() {
      return Object.keys(_messages.value).sort();
    },
    messages,
    get modifiers() {
      return _modifiers;
    },
    get pluralRules() {
      return _pluralRules || {};
    },
    get isGlobal() {
      return _isGlobal;
    },
    get missingWarn() {
      return _missingWarn;
    },
    set missingWarn(val) {
      _missingWarn = val;
      _context.missingWarn = _missingWarn;
    },
    get fallbackWarn() {
      return _fallbackWarn;
    },
    set fallbackWarn(val) {
      _fallbackWarn = val;
      _context.fallbackWarn = _fallbackWarn;
    },
    get fallbackRoot() {
      return _fallbackRoot;
    },
    set fallbackRoot(val) {
      _fallbackRoot = val;
    },
    get fallbackFormat() {
      return _fallbackFormat;
    },
    set fallbackFormat(val) {
      _fallbackFormat = val;
      _context.fallbackFormat = _fallbackFormat;
    },
    get warnHtmlMessage() {
      return _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      _warnHtmlMessage = val;
      _context.warnHtmlMessage = val;
    },
    get escapeParameter() {
      return _escapeParameter;
    },
    set escapeParameter(val) {
      _escapeParameter = val;
      _context.escapeParameter = val;
    },
    t,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    [SetPluralRulesSymbol]: setPluralRules
  };
  {
    composer.datetimeFormats = datetimeFormats;
    composer.numberFormats = numberFormats;
    composer.rt = rt;
    composer.te = te;
    composer.tm = tm;
    composer.d = d;
    composer.n = n;
    composer.getDateTimeFormat = getDateTimeFormat;
    composer.setDateTimeFormat = setDateTimeFormat;
    composer.mergeDateTimeFormat = mergeDateTimeFormat;
    composer.getNumberFormat = getNumberFormat;
    composer.setNumberFormat = setNumberFormat;
    composer.mergeNumberFormat = mergeNumberFormat;
    composer[InejctWithOptionSymbol] = __injectWithOption;
    composer[TranslateVNodeSymbol] = translateVNode;
    composer[DatetimePartsSymbol] = datetimeParts;
    composer[NumberPartsSymbol] = numberParts;
  }
  return composer;
}
function convertComposerOptions(options) {
  const locale = isString$1(options.locale) ? options.locale : DEFAULT_LOCALE;
  const fallbackLocale = isString$1(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
  const missing = isFunction(options.missing) ? options.missing : void 0;
  const missingWarn = isBoolean(options.silentTranslationWarn) || isRegExp(options.silentTranslationWarn) ? !options.silentTranslationWarn : true;
  const fallbackWarn = isBoolean(options.silentFallbackWarn) || isRegExp(options.silentFallbackWarn) ? !options.silentFallbackWarn : true;
  const fallbackRoot = isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  const fallbackFormat = !!options.formatFallbackMessages;
  const modifiers = isPlainObject(options.modifiers) ? options.modifiers : {};
  const pluralizationRules = options.pluralizationRules;
  const postTranslation = isFunction(options.postTranslation) ? options.postTranslation : void 0;
  const warnHtmlMessage = isString$1(options.warnHtmlInMessage) ? options.warnHtmlInMessage !== "off" : true;
  const escapeParameter = !!options.escapeParameterHtml;
  const inheritLocale = isBoolean(options.sync) ? options.sync : true;
  let messages = options.messages;
  if (isPlainObject(options.sharedMessages)) {
    const sharedMessages = options.sharedMessages;
    const locales = Object.keys(sharedMessages);
    messages = locales.reduce((messages2, locale2) => {
      const message = messages2[locale2] || (messages2[locale2] = {});
      assign$1(message, sharedMessages[locale2]);
      return messages2;
    }, messages || {});
  }
  const { __i18n, __root, __injectWithOption } = options;
  const datetimeFormats = options.datetimeFormats;
  const numberFormats = options.numberFormats;
  const flatJson = options.flatJson;
  const translateExistCompatible = options.translateExistCompatible;
  return {
    locale,
    fallbackLocale,
    messages,
    flatJson,
    datetimeFormats,
    numberFormats,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackRoot,
    fallbackFormat,
    modifiers,
    pluralRules: pluralizationRules,
    postTranslation,
    warnHtmlMessage,
    escapeParameter,
    messageResolver: options.messageResolver,
    inheritLocale,
    translateExistCompatible,
    __i18n,
    __root,
    __injectWithOption
  };
}
function createVueI18n(options = {}, VueI18nLegacy) {
  {
    const composer = createComposer(convertComposerOptions(options));
    const { __extender } = options;
    const vueI18n = {
      // id
      id: composer.id,
      // locale
      get locale() {
        return composer.locale.value;
      },
      set locale(val) {
        composer.locale.value = val;
      },
      // fallbackLocale
      get fallbackLocale() {
        return composer.fallbackLocale.value;
      },
      set fallbackLocale(val) {
        composer.fallbackLocale.value = val;
      },
      // messages
      get messages() {
        return composer.messages.value;
      },
      // datetimeFormats
      get datetimeFormats() {
        return composer.datetimeFormats.value;
      },
      // numberFormats
      get numberFormats() {
        return composer.numberFormats.value;
      },
      // availableLocales
      get availableLocales() {
        return composer.availableLocales;
      },
      // formatter
      get formatter() {
        return {
          interpolate() {
            return [];
          }
        };
      },
      set formatter(val) {
      },
      // missing
      get missing() {
        return composer.getMissingHandler();
      },
      set missing(handler) {
        composer.setMissingHandler(handler);
      },
      // silentTranslationWarn
      get silentTranslationWarn() {
        return isBoolean(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
      },
      set silentTranslationWarn(val) {
        composer.missingWarn = isBoolean(val) ? !val : val;
      },
      // silentFallbackWarn
      get silentFallbackWarn() {
        return isBoolean(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
      },
      set silentFallbackWarn(val) {
        composer.fallbackWarn = isBoolean(val) ? !val : val;
      },
      // modifiers
      get modifiers() {
        return composer.modifiers;
      },
      // formatFallbackMessages
      get formatFallbackMessages() {
        return composer.fallbackFormat;
      },
      set formatFallbackMessages(val) {
        composer.fallbackFormat = val;
      },
      // postTranslation
      get postTranslation() {
        return composer.getPostTranslationHandler();
      },
      set postTranslation(handler) {
        composer.setPostTranslationHandler(handler);
      },
      // sync
      get sync() {
        return composer.inheritLocale;
      },
      set sync(val) {
        composer.inheritLocale = val;
      },
      // warnInHtmlMessage
      get warnHtmlInMessage() {
        return composer.warnHtmlMessage ? "warn" : "off";
      },
      set warnHtmlInMessage(val) {
        composer.warnHtmlMessage = val !== "off";
      },
      // escapeParameterHtml
      get escapeParameterHtml() {
        return composer.escapeParameter;
      },
      set escapeParameterHtml(val) {
        composer.escapeParameter = val;
      },
      // preserveDirectiveContent
      get preserveDirectiveContent() {
        return true;
      },
      set preserveDirectiveContent(val) {
      },
      // pluralizationRules
      get pluralizationRules() {
        return composer.pluralRules || {};
      },
      // for internal
      __composer: composer,
      // t
      t(...args) {
        const [arg1, arg2, arg3] = args;
        const options2 = {};
        let list = null;
        let named = null;
        if (!isString$1(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString$1(arg2)) {
          options2.locale = arg2;
        } else if (isArray(arg2)) {
          list = arg2;
        } else if (isPlainObject(arg2)) {
          named = arg2;
        }
        if (isArray(arg3)) {
          list = arg3;
        } else if (isPlainObject(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list || named || {},
          options2
        ]);
      },
      rt(...args) {
        return Reflect.apply(composer.rt, composer, [...args]);
      },
      // tc
      tc(...args) {
        const [arg1, arg2, arg3] = args;
        const options2 = { plural: 1 };
        let list = null;
        let named = null;
        if (!isString$1(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString$1(arg2)) {
          options2.locale = arg2;
        } else if (isNumber(arg2)) {
          options2.plural = arg2;
        } else if (isArray(arg2)) {
          list = arg2;
        } else if (isPlainObject(arg2)) {
          named = arg2;
        }
        if (isString$1(arg3)) {
          options2.locale = arg3;
        } else if (isArray(arg3)) {
          list = arg3;
        } else if (isPlainObject(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list || named || {},
          options2
        ]);
      },
      // te
      te(key, locale) {
        return composer.te(key, locale);
      },
      // tm
      tm(key) {
        return composer.tm(key);
      },
      // getLocaleMessage
      getLocaleMessage(locale) {
        return composer.getLocaleMessage(locale);
      },
      // setLocaleMessage
      setLocaleMessage(locale, message) {
        composer.setLocaleMessage(locale, message);
      },
      // mergeLocaleMessage
      mergeLocaleMessage(locale, message) {
        composer.mergeLocaleMessage(locale, message);
      },
      // d
      d(...args) {
        return Reflect.apply(composer.d, composer, [...args]);
      },
      // getDateTimeFormat
      getDateTimeFormat(locale) {
        return composer.getDateTimeFormat(locale);
      },
      // setDateTimeFormat
      setDateTimeFormat(locale, format2) {
        composer.setDateTimeFormat(locale, format2);
      },
      // mergeDateTimeFormat
      mergeDateTimeFormat(locale, format2) {
        composer.mergeDateTimeFormat(locale, format2);
      },
      // n
      n(...args) {
        return Reflect.apply(composer.n, composer, [...args]);
      },
      // getNumberFormat
      getNumberFormat(locale) {
        return composer.getNumberFormat(locale);
      },
      // setNumberFormat
      setNumberFormat(locale, format2) {
        composer.setNumberFormat(locale, format2);
      },
      // mergeNumberFormat
      mergeNumberFormat(locale, format2) {
        composer.mergeNumberFormat(locale, format2);
      },
      // getChoiceIndex
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getChoiceIndex(choice2, choicesLength) {
        return -1;
      }
    };
    vueI18n.__extender = __extender;
    return vueI18n;
  }
}
const baseFormatProps = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (val) => val === "parent" || val === "global",
    default: "parent"
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object
  }
};
function getInterpolateArg({ slots }, keys) {
  if (keys.length === 1 && keys[0] === "default") {
    const ret = slots.default ? slots.default() : [];
    return ret.reduce((slot, current) => {
      return [
        ...slot,
        // prettier-ignore
        ...current.type === Fragment ? current.children : [current]
      ];
    }, []);
  } else {
    return keys.reduce((arg, key) => {
      const slot = slots[key];
      if (slot) {
        arg[key] = slot();
      }
      return arg;
    }, {});
  }
}
function getFragmentableTag(tag) {
  return Fragment;
}
const TranslationImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-t",
  props: assign$1({
    keypath: {
      type: String,
      required: true
    },
    plural: {
      type: [Number, String],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      validator: (val) => isNumber(val) || !isNaN(val)
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const { slots, attrs } = context;
    const i18n2 = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return () => {
      const keys = Object.keys(slots).filter((key) => key !== "_");
      const options = {};
      if (props.locale) {
        options.locale = props.locale;
      }
      if (props.plural !== void 0) {
        options.plural = isString$1(props.plural) ? +props.plural : props.plural;
      }
      const arg = getInterpolateArg(context, keys);
      const children = i18n2[TranslateVNodeSymbol](props.keypath, arg, options);
      const assignedAttrs = assign$1({}, attrs);
      const tag = isString$1(props.tag) || isObject$1(props.tag) ? props.tag : getFragmentableTag();
      return h(tag, assignedAttrs, children);
    };
  }
});
const Translation = TranslationImpl;
function isVNode(target) {
  return isArray(target) && !isString$1(target[0]);
}
function renderFormatter(props, context, slotKeys, partFormatter) {
  const { slots, attrs } = context;
  return () => {
    const options = { part: true };
    let overrides = {};
    if (props.locale) {
      options.locale = props.locale;
    }
    if (isString$1(props.format)) {
      options.key = props.format;
    } else if (isObject$1(props.format)) {
      if (isString$1(props.format.key)) {
        options.key = props.format.key;
      }
      overrides = Object.keys(props.format).reduce((options2, prop) => {
        return slotKeys.includes(prop) ? assign$1({}, options2, { [prop]: props.format[prop] }) : options2;
      }, {});
    }
    const parts = partFormatter(...[props.value, options, overrides]);
    let children = [options.key];
    if (isArray(parts)) {
      children = parts.map((part, index2) => {
        const slot = slots[part.type];
        const node = slot ? slot({ [part.type]: part.value, index: index2, parts }) : [part.value];
        if (isVNode(node)) {
          node[0].key = `${part.type}-${index2}`;
        }
        return node;
      });
    } else if (isString$1(parts)) {
      children = [parts];
    }
    const assignedAttrs = assign$1({}, attrs);
    const tag = isString$1(props.tag) || isObject$1(props.tag) ? props.tag : getFragmentableTag();
    return h(tag, assignedAttrs, children);
  };
}
const NumberFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-n",
  props: assign$1({
    value: {
      type: Number,
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n2 = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n2[NumberPartsSymbol](...args)
    ));
  }
});
const NumberFormat = NumberFormatImpl;
const DatetimeFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-d",
  props: assign$1({
    value: {
      type: [Number, Date],
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n2 = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n2[DatetimePartsSymbol](...args)
    ));
  }
});
const DatetimeFormat = DatetimeFormatImpl;
function getComposer$2(i18n2, instance2) {
  const i18nInternal = i18n2;
  if (i18n2.mode === "composition") {
    return i18nInternal.__getInstance(instance2) || i18n2.global;
  } else {
    const vueI18n = i18nInternal.__getInstance(instance2);
    return vueI18n != null ? vueI18n.__composer : i18n2.global.__composer;
  }
}
function vTDirective(i18n2) {
  const _process = (binding) => {
    const { instance: instance2, modifiers, value } = binding;
    if (!instance2 || !instance2.$) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const composer = getComposer$2(i18n2, instance2.$);
    const parsedValue = parseValue(value);
    return [
      Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]),
      composer
    ];
  };
  const register = (el, binding) => {
    const [textContent, composer] = _process(binding);
    if (inBrowser && i18n2.global === composer) {
      el.__i18nWatcher = watch(composer.locale, () => {
        binding.instance && binding.instance.$forceUpdate();
      });
    }
    el.__composer = composer;
    el.textContent = textContent;
  };
  const unregister = (el) => {
    if (inBrowser && el.__i18nWatcher) {
      el.__i18nWatcher();
      el.__i18nWatcher = void 0;
      delete el.__i18nWatcher;
    }
    if (el.__composer) {
      el.__composer = void 0;
      delete el.__composer;
    }
  };
  const update = (el, { value }) => {
    if (el.__composer) {
      const composer = el.__composer;
      const parsedValue = parseValue(value);
      el.textContent = Reflect.apply(composer.t, composer, [
        ...makeParams(parsedValue)
      ]);
    }
  };
  const getSSRProps = (binding) => {
    const [textContent] = _process(binding);
    return { textContent };
  };
  return {
    created: register,
    unmounted: unregister,
    beforeUpdate: update,
    getSSRProps
  };
}
function parseValue(value) {
  if (isString$1(value)) {
    return { path: value };
  } else if (isPlainObject(value)) {
    if (!("path" in value)) {
      throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
    }
    return value;
  } else {
    throw createI18nError(I18nErrorCodes.INVALID_VALUE);
  }
}
function makeParams(value) {
  const { path, locale, args, choice: choice2, plural } = value;
  const options = {};
  const named = args || {};
  if (isString$1(locale)) {
    options.locale = locale;
  }
  if (isNumber(choice2)) {
    options.plural = choice2;
  }
  if (isNumber(plural)) {
    options.plural = plural;
  }
  return [path, named, options];
}
function apply(app2, i18n2, ...options) {
  const pluginOptions = isPlainObject(options[0]) ? options[0] : {};
  const useI18nComponentName = !!pluginOptions.useI18nComponentName;
  const globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
  if (globalInstall) {
    [!useI18nComponentName ? Translation.name : "i18n", "I18nT"].forEach((name) => app2.component(name, Translation));
    [NumberFormat.name, "I18nN"].forEach((name) => app2.component(name, NumberFormat));
    [DatetimeFormat.name, "I18nD"].forEach((name) => app2.component(name, DatetimeFormat));
  }
  {
    app2.directive("t", vTDirective(i18n2));
  }
}
function defineMixin(vuei18n, composer, i18n2) {
  return {
    beforeCreate() {
      const instance2 = getCurrentInstance();
      if (!instance2) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const options = this.$options;
      if (options.i18n) {
        const optionsI18n = options.i18n;
        if (options.__i18n) {
          optionsI18n.__i18n = options.__i18n;
        }
        optionsI18n.__root = composer;
        if (this === this.$root) {
          this.$i18n = mergeToGlobal(vuei18n, optionsI18n);
        } else {
          optionsI18n.__injectWithOption = true;
          optionsI18n.__extender = i18n2.__vueI18nExtend;
          this.$i18n = createVueI18n(optionsI18n);
          const _vueI18n = this.$i18n;
          if (_vueI18n.__extender) {
            _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
          }
        }
      } else if (options.__i18n) {
        if (this === this.$root) {
          this.$i18n = mergeToGlobal(vuei18n, options);
        } else {
          this.$i18n = createVueI18n({
            __i18n: options.__i18n,
            __injectWithOption: true,
            __extender: i18n2.__vueI18nExtend,
            __root: composer
          });
          const _vueI18n = this.$i18n;
          if (_vueI18n.__extender) {
            _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
          }
        }
      } else {
        this.$i18n = vuei18n;
      }
      if (options.__i18nGlobal) {
        adjustI18nResources(composer, options, options);
      }
      this.$t = (...args) => this.$i18n.t(...args);
      this.$rt = (...args) => this.$i18n.rt(...args);
      this.$tc = (...args) => this.$i18n.tc(...args);
      this.$te = (key, locale) => this.$i18n.te(key, locale);
      this.$d = (...args) => this.$i18n.d(...args);
      this.$n = (...args) => this.$i18n.n(...args);
      this.$tm = (key) => this.$i18n.tm(key);
      i18n2.__setInstance(instance2, this.$i18n);
    },
    mounted() {
    },
    unmounted() {
      const instance2 = getCurrentInstance();
      if (!instance2) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const _vueI18n = this.$i18n;
      delete this.$t;
      delete this.$rt;
      delete this.$tc;
      delete this.$te;
      delete this.$d;
      delete this.$n;
      delete this.$tm;
      if (_vueI18n.__disposer) {
        _vueI18n.__disposer();
        delete _vueI18n.__disposer;
        delete _vueI18n.__extender;
      }
      i18n2.__deleteInstance(instance2);
      delete this.$i18n;
    }
  };
}
function mergeToGlobal(g, options) {
  g.locale = options.locale || g.locale;
  g.fallbackLocale = options.fallbackLocale || g.fallbackLocale;
  g.missing = options.missing || g.missing;
  g.silentTranslationWarn = options.silentTranslationWarn || g.silentFallbackWarn;
  g.silentFallbackWarn = options.silentFallbackWarn || g.silentFallbackWarn;
  g.formatFallbackMessages = options.formatFallbackMessages || g.formatFallbackMessages;
  g.postTranslation = options.postTranslation || g.postTranslation;
  g.warnHtmlInMessage = options.warnHtmlInMessage || g.warnHtmlInMessage;
  g.escapeParameterHtml = options.escapeParameterHtml || g.escapeParameterHtml;
  g.sync = options.sync || g.sync;
  g.__composer[SetPluralRulesSymbol](options.pluralizationRules || g.pluralizationRules);
  const messages = getLocaleMessages(g.locale, {
    messages: options.messages,
    __i18n: options.__i18n
  });
  Object.keys(messages).forEach((locale) => g.mergeLocaleMessage(locale, messages[locale]));
  if (options.datetimeFormats) {
    Object.keys(options.datetimeFormats).forEach((locale) => g.mergeDateTimeFormat(locale, options.datetimeFormats[locale]));
  }
  if (options.numberFormats) {
    Object.keys(options.numberFormats).forEach((locale) => g.mergeNumberFormat(locale, options.numberFormats[locale]));
  }
  return g;
}
const I18nInjectionKey = /* @__PURE__ */ makeSymbol("global-vue-i18n");
function createI18n(options = {}, VueI18nLegacy) {
  const __legacyMode = __VUE_I18N_LEGACY_API__ && isBoolean(options.legacy) ? options.legacy : __VUE_I18N_LEGACY_API__;
  const __globalInjection = isBoolean(options.globalInjection) ? options.globalInjection : true;
  const __allowComposition = __VUE_I18N_LEGACY_API__ && __legacyMode ? !!options.allowComposition : true;
  const __instances = /* @__PURE__ */ new Map();
  const [globalScope, __global] = createGlobal(options, __legacyMode);
  const symbol = /* @__PURE__ */ makeSymbol("");
  function __getInstance(component) {
    return __instances.get(component) || null;
  }
  function __setInstance(component, instance2) {
    __instances.set(component, instance2);
  }
  function __deleteInstance(component) {
    __instances.delete(component);
  }
  {
    const i18n2 = {
      // mode
      get mode() {
        return __VUE_I18N_LEGACY_API__ && __legacyMode ? "legacy" : "composition";
      },
      // allowComposition
      get allowComposition() {
        return __allowComposition;
      },
      // install plugin
      async install(app2, ...options2) {
        app2.__VUE_I18N_SYMBOL__ = symbol;
        app2.provide(app2.__VUE_I18N_SYMBOL__, i18n2);
        if (isPlainObject(options2[0])) {
          const opts = options2[0];
          i18n2.__composerExtend = opts.__composerExtend;
          i18n2.__vueI18nExtend = opts.__vueI18nExtend;
        }
        let globalReleaseHandler = null;
        if (!__legacyMode && __globalInjection) {
          globalReleaseHandler = injectGlobalFields(app2, i18n2.global);
        }
        if (__VUE_I18N_FULL_INSTALL__) {
          apply(app2, i18n2, ...options2);
        }
        if (__VUE_I18N_LEGACY_API__ && __legacyMode) {
          app2.mixin(defineMixin(__global, __global.__composer, i18n2));
        }
        const unmountApp = app2.unmount;
        app2.unmount = () => {
          globalReleaseHandler && globalReleaseHandler();
          i18n2.dispose();
          unmountApp();
        };
      },
      // global accessor
      get global() {
        return __global;
      },
      dispose() {
        globalScope.stop();
      },
      // @internal
      __instances,
      // @internal
      __getInstance,
      // @internal
      __setInstance,
      // @internal
      __deleteInstance
    };
    return i18n2;
  }
}
function useI18n(options = {}) {
  const instance2 = getCurrentInstance();
  if (instance2 == null) {
    throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
  }
  if (!instance2.isCE && instance2.appContext.app != null && !instance2.appContext.app.__VUE_I18N_SYMBOL__) {
    throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
  }
  const i18n2 = getI18nInstance(instance2);
  const gl = getGlobalComposer(i18n2);
  const componentOptions = getComponentOptions(instance2);
  const scope = getScope(options, componentOptions);
  if (__VUE_I18N_LEGACY_API__) {
    if (i18n2.mode === "legacy" && !options.__useComponent) {
      if (!i18n2.allowComposition) {
        throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE);
      }
      return useI18nForLegacy(instance2, scope, gl, options);
    }
  }
  if (scope === "global") {
    adjustI18nResources(gl, options, componentOptions);
    return gl;
  }
  if (scope === "parent") {
    let composer2 = getComposer(i18n2, instance2, options.__useComponent);
    if (composer2 == null) {
      composer2 = gl;
    }
    return composer2;
  }
  const i18nInternal = i18n2;
  let composer = i18nInternal.__getInstance(instance2);
  if (composer == null) {
    const composerOptions = assign$1({}, options);
    if ("__i18n" in componentOptions) {
      composerOptions.__i18n = componentOptions.__i18n;
    }
    if (gl) {
      composerOptions.__root = gl;
    }
    composer = createComposer(composerOptions);
    if (i18nInternal.__composerExtend) {
      composer[DisposeSymbol] = i18nInternal.__composerExtend(composer);
    }
    setupLifeCycle(i18nInternal, instance2, composer);
    i18nInternal.__setInstance(instance2, composer);
  }
  return composer;
}
function createGlobal(options, legacyMode, VueI18nLegacy) {
  const scope = effectScope();
  {
    const obj = __VUE_I18N_LEGACY_API__ && legacyMode ? scope.run(() => createVueI18n(options)) : scope.run(() => createComposer(options));
    if (obj == null) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    return [scope, obj];
  }
}
function getI18nInstance(instance2) {
  {
    const i18n2 = inject(!instance2.isCE ? instance2.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
    if (!i18n2) {
      throw createI18nError(!instance2.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE);
    }
    return i18n2;
  }
}
function getScope(options, componentOptions) {
  return isEmptyObject(options) ? "__i18n" in componentOptions ? "local" : "global" : !options.useScope ? "local" : options.useScope;
}
function getGlobalComposer(i18n2) {
  return i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
}
function getComposer(i18n2, target, useComponent = false) {
  let composer = null;
  const root = target.root;
  let current = getParentComponentInstance(target, useComponent);
  while (current != null) {
    const i18nInternal = i18n2;
    if (i18n2.mode === "composition") {
      composer = i18nInternal.__getInstance(current);
    } else {
      if (__VUE_I18N_LEGACY_API__) {
        const vueI18n = i18nInternal.__getInstance(current);
        if (vueI18n != null) {
          composer = vueI18n.__composer;
          if (useComponent && composer && !composer[InejctWithOptionSymbol]) {
            composer = null;
          }
        }
      }
    }
    if (composer != null) {
      break;
    }
    if (root === current) {
      break;
    }
    current = current.parent;
  }
  return composer;
}
function getParentComponentInstance(target, useComponent = false) {
  if (target == null) {
    return null;
  }
  {
    return !useComponent ? target.parent : target.vnode.ctx || target.parent;
  }
}
function setupLifeCycle(i18n2, target, composer) {
  {
    onMounted(() => {
    }, target);
    onUnmounted(() => {
      const _composer = composer;
      i18n2.__deleteInstance(target);
      const dispose = _composer[DisposeSymbol];
      if (dispose) {
        dispose();
        delete _composer[DisposeSymbol];
      }
    }, target);
  }
}
function useI18nForLegacy(instance2, scope, root, options = {}) {
  const isLocalScope = scope === "local";
  const _composer = shallowRef(null);
  if (isLocalScope && instance2.proxy && !(instance2.proxy.$options.i18n || instance2.proxy.$options.__i18n)) {
    throw createI18nError(I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
  }
  const _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : !isString$1(options.locale);
  const _locale = ref(
    // prettier-ignore
    !isLocalScope || _inheritLocale ? root.locale.value : isString$1(options.locale) ? options.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = ref(
    // prettier-ignore
    !isLocalScope || _inheritLocale ? root.fallbackLocale.value : isString$1(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
  );
  const _messages = ref(getLocaleMessages(_locale.value, options));
  const _datetimeFormats = ref(isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = ref(isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
  const _missingWarn = isLocalScope ? root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  const _fallbackWarn = isLocalScope ? root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  const _fallbackRoot = isLocalScope ? root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  const _fallbackFormat = !!options.fallbackFormat;
  const _missing = isFunction(options.missing) ? options.missing : null;
  const _postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  const _warnHtmlMessage = isLocalScope ? root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  const _escapeParameter = !!options.escapeParameter;
  const _modifiers = isLocalScope ? root.modifiers : isPlainObject(options.modifiers) ? options.modifiers : {};
  const _pluralRules = options.pluralRules || isLocalScope && root.pluralRules;
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale = computed({
    get: () => {
      return _composer.value ? _composer.value.locale.value : _locale.value;
    },
    set: (val) => {
      if (_composer.value) {
        _composer.value.locale.value = val;
      }
      _locale.value = val;
    }
  });
  const fallbackLocale = computed({
    get: () => {
      return _composer.value ? _composer.value.fallbackLocale.value : _fallbackLocale.value;
    },
    set: (val) => {
      if (_composer.value) {
        _composer.value.fallbackLocale.value = val;
      }
      _fallbackLocale.value = val;
    }
  });
  const messages = computed(() => {
    if (_composer.value) {
      return _composer.value.messages.value;
    } else {
      return _messages.value;
    }
  });
  const datetimeFormats = computed(() => _datetimeFormats.value);
  const numberFormats = computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return _composer.value ? _composer.value.getPostTranslationHandler() : _postTranslation;
  }
  function setPostTranslationHandler(handler) {
    if (_composer.value) {
      _composer.value.setPostTranslationHandler(handler);
    }
  }
  function getMissingHandler() {
    return _composer.value ? _composer.value.getMissingHandler() : _missing;
  }
  function setMissingHandler(handler) {
    if (_composer.value) {
      _composer.value.setMissingHandler(handler);
    }
  }
  function warpWithDeps(fn) {
    trackReactivityValues();
    return fn();
  }
  function t(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.t, null, [...args])) : warpWithDeps(() => "");
  }
  function rt(...args) {
    return _composer.value ? Reflect.apply(_composer.value.rt, null, [...args]) : "";
  }
  function d(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.d, null, [...args])) : warpWithDeps(() => "");
  }
  function n(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.n, null, [...args])) : warpWithDeps(() => "");
  }
  function tm(key) {
    return _composer.value ? _composer.value.tm(key) : {};
  }
  function te(key, locale2) {
    return _composer.value ? _composer.value.te(key, locale2) : false;
  }
  function getLocaleMessage(locale2) {
    return _composer.value ? _composer.value.getLocaleMessage(locale2) : {};
  }
  function setLocaleMessage(locale2, message) {
    if (_composer.value) {
      _composer.value.setLocaleMessage(locale2, message);
      _messages.value[locale2] = message;
    }
  }
  function mergeLocaleMessage(locale2, message) {
    if (_composer.value) {
      _composer.value.mergeLocaleMessage(locale2, message);
    }
  }
  function getDateTimeFormat(locale2) {
    return _composer.value ? _composer.value.getDateTimeFormat(locale2) : {};
  }
  function setDateTimeFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.setDateTimeFormat(locale2, format2);
      _datetimeFormats.value[locale2] = format2;
    }
  }
  function mergeDateTimeFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.mergeDateTimeFormat(locale2, format2);
    }
  }
  function getNumberFormat(locale2) {
    return _composer.value ? _composer.value.getNumberFormat(locale2) : {};
  }
  function setNumberFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.setNumberFormat(locale2, format2);
      _numberFormats.value[locale2] = format2;
    }
  }
  function mergeNumberFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.mergeNumberFormat(locale2, format2);
    }
  }
  const wrapper = {
    get id() {
      return _composer.value ? _composer.value.id : -1;
    },
    locale,
    fallbackLocale,
    messages,
    datetimeFormats,
    numberFormats,
    get inheritLocale() {
      return _composer.value ? _composer.value.inheritLocale : _inheritLocale;
    },
    set inheritLocale(val) {
      if (_composer.value) {
        _composer.value.inheritLocale = val;
      }
    },
    get availableLocales() {
      return _composer.value ? _composer.value.availableLocales : Object.keys(_messages.value);
    },
    get modifiers() {
      return _composer.value ? _composer.value.modifiers : _modifiers;
    },
    get pluralRules() {
      return _composer.value ? _composer.value.pluralRules : _pluralRules;
    },
    get isGlobal() {
      return _composer.value ? _composer.value.isGlobal : false;
    },
    get missingWarn() {
      return _composer.value ? _composer.value.missingWarn : _missingWarn;
    },
    set missingWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackWarn() {
      return _composer.value ? _composer.value.fallbackWarn : _fallbackWarn;
    },
    set fallbackWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackRoot() {
      return _composer.value ? _composer.value.fallbackRoot : _fallbackRoot;
    },
    set fallbackRoot(val) {
      if (_composer.value) {
        _composer.value.fallbackRoot = val;
      }
    },
    get fallbackFormat() {
      return _composer.value ? _composer.value.fallbackFormat : _fallbackFormat;
    },
    set fallbackFormat(val) {
      if (_composer.value) {
        _composer.value.fallbackFormat = val;
      }
    },
    get warnHtmlMessage() {
      return _composer.value ? _composer.value.warnHtmlMessage : _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      if (_composer.value) {
        _composer.value.warnHtmlMessage = val;
      }
    },
    get escapeParameter() {
      return _composer.value ? _composer.value.escapeParameter : _escapeParameter;
    },
    set escapeParameter(val) {
      if (_composer.value) {
        _composer.value.escapeParameter = val;
      }
    },
    t,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    rt,
    d,
    n,
    tm,
    te,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getDateTimeFormat,
    setDateTimeFormat,
    mergeDateTimeFormat,
    getNumberFormat,
    setNumberFormat,
    mergeNumberFormat
  };
  function sync(composer) {
    composer.locale.value = _locale.value;
    composer.fallbackLocale.value = _fallbackLocale.value;
    Object.keys(_messages.value).forEach((locale2) => {
      composer.mergeLocaleMessage(locale2, _messages.value[locale2]);
    });
    Object.keys(_datetimeFormats.value).forEach((locale2) => {
      composer.mergeDateTimeFormat(locale2, _datetimeFormats.value[locale2]);
    });
    Object.keys(_numberFormats.value).forEach((locale2) => {
      composer.mergeNumberFormat(locale2, _numberFormats.value[locale2]);
    });
    composer.escapeParameter = _escapeParameter;
    composer.fallbackFormat = _fallbackFormat;
    composer.fallbackRoot = _fallbackRoot;
    composer.fallbackWarn = _fallbackWarn;
    composer.missingWarn = _missingWarn;
    composer.warnHtmlMessage = _warnHtmlMessage;
  }
  onBeforeMount(() => {
    if (instance2.proxy == null || instance2.proxy.$i18n == null) {
      throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
    }
    const composer = _composer.value = instance2.proxy.$i18n.__composer;
    if (scope === "global") {
      _locale.value = composer.locale.value;
      _fallbackLocale.value = composer.fallbackLocale.value;
      _messages.value = composer.messages.value;
      _datetimeFormats.value = composer.datetimeFormats.value;
      _numberFormats.value = composer.numberFormats.value;
    } else if (isLocalScope) {
      sync(composer);
    }
  });
  return wrapper;
}
const globalExportProps = [
  "locale",
  "fallbackLocale",
  "availableLocales"
];
const globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];
function injectGlobalFields(app2, composer) {
  const i18n2 = /* @__PURE__ */ Object.create(null);
  globalExportProps.forEach((prop) => {
    const desc = Object.getOwnPropertyDescriptor(composer, prop);
    if (!desc) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const wrap = isRef(desc.value) ? {
      get() {
        return desc.value.value;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(val) {
        desc.value.value = val;
      }
    } : {
      get() {
        return desc.get && desc.get();
      }
    };
    Object.defineProperty(i18n2, prop, wrap);
  });
  app2.config.globalProperties.$i18n = i18n2;
  globalExportMethods.forEach((method) => {
    const desc = Object.getOwnPropertyDescriptor(composer, method);
    if (!desc || !desc.value) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    Object.defineProperty(app2.config.globalProperties, `$${method}`, desc);
  });
  const dispose = () => {
    delete app2.config.globalProperties.$i18n;
    globalExportMethods.forEach((method) => {
      delete app2.config.globalProperties[`$${method}`];
    });
  };
  return dispose;
}
{
  initFeatureFlags();
}
if (__INTLIFY_JIT_COMPILATION__) {
  registerMessageCompiler(compile);
} else {
  registerMessageCompiler(compileToFunction);
}
registerMessageResolver(resolveValue);
registerLocaleFallbacker(fallbackWithLocaleChain);
if (__INTLIFY_PROD_DEVTOOLS__) {
  const target = getGlobalThis();
  target.__INTLIFY__ = true;
  setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
const i18n = createI18n({
  legacy: false,
  locale: navigator.language,
  // set locale
  messages: { en },
  fallbackLocale: "en",
  silentFallbackWarn: true,
  pluralizationRules: {
    /**
     * @param choice {number} a choice index given by the input to $t: `$t('path.to.rule', choiceIndex)`
     * @param choicesLength {number} an overall amount of available choices
     * @returns a final choice index to select plural word by
     */
    ru: function(n, choicesLength) {
      let retval = choicesLength - 1;
      if (n === 0) {
        retval = 0;
      } else {
        const nMod10 = n % 10;
        const nMod100 = n % 100;
        const teen = nMod100 > 10 && nMod100 < 20;
        const endsWithOne = nMod10 === 1;
        if (choicesLength < 4) {
          retval = !teen && endsWithOne ? 1 : 2;
        } else if (!teen && endsWithOne) {
          retval = 1;
        } else if (!teen && nMod10 >= 2 && nMod10 <= 4) {
          retval = 2;
        } else {
          retval = 3;
        }
      }
      return retval;
    }
  }
});
const _hoisted_1$9 = { style: { "display": "none" } };
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "DocumentKeycapture",
  emits: ["keypress", "keydown", "keyup"],
  setup(__props, { emit: __emit }) {
    const which = ref("");
    const listeners = {};
    const keytypes = ["keypress", "keydown", "keyup"];
    const emits = __emit;
    onMounted(() => {
      for (const key of keytypes) {
        const listener = (e2) => {
          which.value = e2.which;
          emits(key, e2);
        };
        document.addEventListener(key, listener);
        listeners[key] = listener;
      }
    });
    onUnmounted(() => {
      for (const key of keytypes) {
        document.removeEventListener(key, listeners[key]);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$9, toDisplayString$1(which.value), 1);
    };
  }
});
const MultiplayerMixin = {
  data() {
    return {
      joinCode: localStorage.gameId || ""
    };
  },
  computed: {
    players() {
      return this.$root.players;
    },
    shared() {
      return this.$root.shared;
    },
    state() {
      return this.$root.state;
    },
    code() {
      return this.$root.gameId;
    }
  },
  async mounted() {
    await this.$socket.ensureConnected();
  },
  // TODO: figure out when to disconnect
  // unmounted() {
  //   if (this.$socket.connected) {
  //     this.$socket.close();
  //   }
  // },
  methods: {}
};
class DeferredList {
  constructor() {
    this.queue = [];
    this.running = false;
  }
  add(func) {
    const promise = new Deferred();
    this.queue.push({ promise, func });
    this.run();
    return promise;
  }
  async run() {
    if (!this.running) {
      this.running = true;
      while (this.queue.length > 0) {
        const item = this.queue.shift();
        try {
          await Promise.race([item.promise.promise, item.func(item.promise)]);
          item.promise.resolve();
        } catch (ex) {
          console.log("error", ex);
          item.promise.reject(ex);
        }
      }
      this.running = false;
    }
  }
}
const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let nanoid = (size2 = 21) => {
  let id = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size2));
  while (size2--) {
    id += urlAlphabet[bytes[size2] & 63];
  }
  return id;
};
function basename(str) {
  let base = str.substring(str.lastIndexOf("/") + 1);
  if (base.lastIndexOf(".") !== -1) {
    base = base.substring(0, base.lastIndexOf("."));
  }
  return base;
}
const BYTE_UNITS = [
  "B",
  "kB",
  "MB",
  "GB",
  "TB",
  "PB",
  "EB",
  "ZB",
  "YB"
];
const BIBYTE_UNITS = [
  "B",
  "KiB",
  "MiB",
  "GiB",
  "TiB",
  "PiB",
  "EiB",
  "ZiB",
  "YiB"
];
const BIT_UNITS = [
  "b",
  "kbit",
  "Mbit",
  "Gbit",
  "Tbit",
  "Pbit",
  "Ebit",
  "Zbit",
  "Ybit"
];
const BIBIT_UNITS = [
  "b",
  "kibit",
  "Mibit",
  "Gibit",
  "Tibit",
  "Pibit",
  "Eibit",
  "Zibit",
  "Yibit"
];
const toLocaleString = (number2, locale, options) => {
  let result = number2;
  if (typeof locale === "string" || Array.isArray(locale)) {
    result = number2.toLocaleString(locale, options);
  } else if (locale === true || options !== void 0) {
    result = number2.toLocaleString(void 0, options);
  }
  return result;
};
function prettyBytes(number2, options) {
  if (!Number.isFinite(number2)) {
    throw new TypeError(`Expected a finite number, got ${typeof number2}: ${number2}`);
  }
  options = {
    bits: false,
    binary: false,
    space: true,
    ...options
  };
  const UNITS = options.bits ? options.binary ? BIBIT_UNITS : BIT_UNITS : options.binary ? BIBYTE_UNITS : BYTE_UNITS;
  const separator = options.space ? " " : "";
  if (options.signed && number2 === 0) {
    return ` 0${separator}${UNITS[0]}`;
  }
  const isNegative = number2 < 0;
  const prefix = isNegative ? "-" : options.signed ? "+" : "";
  if (isNegative) {
    number2 = -number2;
  }
  let localeOptions;
  if (options.minimumFractionDigits !== void 0) {
    localeOptions = { minimumFractionDigits: options.minimumFractionDigits };
  }
  if (options.maximumFractionDigits !== void 0) {
    localeOptions = { maximumFractionDigits: options.maximumFractionDigits, ...localeOptions };
  }
  if (number2 < 1) {
    const numberString2 = toLocaleString(number2, options.locale, localeOptions);
    return prefix + numberString2 + separator + UNITS[0];
  }
  const exponent = Math.min(Math.floor(options.binary ? Math.log(number2) / Math.log(1024) : Math.log10(number2) / 3), UNITS.length - 1);
  number2 /= (options.binary ? 1024 : 1e3) ** exponent;
  if (!localeOptions) {
    number2 = number2.toPrecision(3);
  }
  const numberString = toLocaleString(Number(number2), options.locale, localeOptions);
  const unit = UNITS[exponent];
  return prefix + numberString + separator + unit;
}
function countWords(str) {
  if (str) {
    const arr = str.toString().split(/[ -]/);
    return arr.filter((word) => word !== "").length;
  }
  return 0;
}
class Scene extends BaseModel {
  static get objectName() {
    return "scene";
  }
  static get defaultObject() {
    return {
      id: null,
      title: null,
      directions: [],
      start: false,
      microcosm: false,
      act: false,
      color: null,
      updated: (/* @__PURE__ */ new Date()).toISOString(),
      story: null,
      wc: 0
    };
  }
  getLabel(width = 50) {
    const d = this.directions.find((d2) => d2.type === "text");
    return ((d ? d.content : null) || `(Scene ${this.id})`).slice(0, width).replace("\n", " ").trim();
  }
  async deleteCheck() {
    const Story2 = (await __vitePreload(() => Promise.resolve().then(() => story), true ? void 0 : void 0, import.meta.url)).default;
    if (this.story) {
      const story2 = await Story2.load(this.story);
      if (story2 && story2.scenes.indexOf(this.id) > -1) {
        return [`Scene used by story ${story2}`];
      }
    } else {
      for (const story2 of await Story2.objects.list()) {
        if (story2.scenes.indexOf(this.id) > -1) {
          this.story = story2.id;
          await this.save();
          if (story2.cloudSync) {
            await this.push();
          }
          return [`Scene used by story ${story2}`];
        }
      }
    }
    return [];
  }
  async save() {
    await this.countWords();
    return super.save();
  }
  async countWords() {
    let wc = 10;
    wc += countWords(this.title);
    for (const d of this.directions) {
      wc += countWords(d.content);
      wc += countWords(d.label);
    }
    if (this.wc != wc) {
      this.wc = wc;
      return true;
    }
    return false;
  }
  toString() {
    return this.title || this.getLabel();
  }
}
var js = {};
function new_byte$4(count) {
  return new Int8Array(count);
}
function new_short(count) {
  return new Int16Array(count);
}
function new_int$c(count) {
  return new Int32Array(count);
}
function new_float$c(count) {
  return new Float32Array(count);
}
function new_double$1(count) {
  return new Float64Array(count);
}
function new_float_n$4(args) {
  if (args.length == 1) {
    return new_float$c(args[0]);
  }
  var sz = args[0];
  args = args.slice(1);
  var A = [];
  for (var i = 0; i < sz; i++) {
    A.push(new_float_n$4(args));
  }
  return A;
}
function new_int_n$2(args) {
  if (args.length == 1) {
    return new_int$c(args[0]);
  }
  var sz = args[0];
  args = args.slice(1);
  var A = [];
  for (var i = 0; i < sz; i++) {
    A.push(new_int_n$2(args));
  }
  return A;
}
function new_short_n$1(args) {
  if (args.length == 1) {
    return new_short(args[0]);
  }
  var sz = args[0];
  args = args.slice(1);
  var A = [];
  for (var i = 0; i < sz; i++) {
    A.push(new_short_n$1(args));
  }
  return A;
}
function new_array_n(args) {
  if (args.length == 1) {
    return new Array(args[0]);
  }
  var sz = args[0];
  args = args.slice(1);
  var A = [];
  for (var i = 0; i < sz; i++) {
    A.push(new_array_n(args));
  }
  return A;
}
var Arrays$6 = {};
Arrays$6.fill = function(a, fromIndex, toIndex, val) {
  if (arguments.length == 2) {
    for (var i = 0; i < a.length; i++) {
      a[i] = arguments[1];
    }
  } else {
    for (var i = fromIndex; i < toIndex; i++) {
      a[i] = val;
    }
  }
};
var System$7 = {};
System$7.arraycopy = function(src, srcPos, dest, destPos, length) {
  var srcEnd = srcPos + length;
  while (srcPos < srcEnd)
    dest[destPos++] = src[srcPos++];
};
System$7.out = {};
System$7.out.println = function(message) {
  console.log(message);
};
System$7.out.printf = function() {
  console.log.apply(console, arguments);
};
var Util$4 = {};
Util$4.SQRT2 = 1.4142135623730951;
Util$4.FAST_LOG10 = function(x) {
  return Math.log10(x);
};
Util$4.FAST_LOG10_X = function(x, y) {
  return Math.log10(x) * y;
};
function ShortBlock$3(ordinal) {
  this.ordinal = ordinal;
}
ShortBlock$3.short_block_allowed = new ShortBlock$3(0);
ShortBlock$3.short_block_coupled = new ShortBlock$3(1);
ShortBlock$3.short_block_dispensed = new ShortBlock$3(2);
ShortBlock$3.short_block_forced = new ShortBlock$3(3);
var Float$2 = {};
Float$2.MAX_VALUE = 34028235e31;
function VbrMode$6(ordinal) {
  this.ordinal = ordinal;
}
VbrMode$6.vbr_off = new VbrMode$6(0);
VbrMode$6.vbr_mt = new VbrMode$6(1);
VbrMode$6.vbr_rh = new VbrMode$6(2);
VbrMode$6.vbr_abr = new VbrMode$6(3);
VbrMode$6.vbr_mtrh = new VbrMode$6(4);
VbrMode$6.vbr_default = VbrMode$6.vbr_mtrh;
var assert$a = function(x) {
};
var common$l = {
  "System": System$7,
  "VbrMode": VbrMode$6,
  "Float": Float$2,
  "ShortBlock": ShortBlock$3,
  "Util": Util$4,
  "Arrays": Arrays$6,
  "new_array_n": new_array_n,
  "new_byte": new_byte$4,
  "new_double": new_double$1,
  "new_float": new_float$c,
  "new_float_n": new_float_n$4,
  "new_int": new_int$c,
  "new_int_n": new_int_n$2,
  "new_short": new_short,
  "new_short_n": new_short_n$1,
  "assert": assert$a
};
var NewMDCT_1;
var hasRequiredNewMDCT;
function requireNewMDCT() {
  if (hasRequiredNewMDCT)
    return NewMDCT_1;
  hasRequiredNewMDCT = 1;
  var common2 = common$l;
  var System2 = common2.System;
  common2.VbrMode;
  common2.Float;
  common2.ShortBlock;
  var Util2 = common2.Util;
  var Arrays2 = common2.Arrays;
  common2.new_array_n;
  common2.new_byte;
  common2.new_double;
  var new_float2 = common2.new_float;
  common2.new_float_n;
  common2.new_int;
  common2.new_int_n;
  common2.assert;
  var Encoder2 = requireEncoder();
  function NewMDCT() {
    var enwindow = [
      -477e-9 * 0.740951125354959 / 2384e-9,
      103951e-9 * 0.740951125354959 / 2384e-9,
      953674e-9 * 0.740951125354959 / 2384e-9,
      2841473e-9 * 0.740951125354959 / 2384e-9,
      0.035758972 * 0.740951125354959 / 2384e-9,
      3401756e-9 * 0.740951125354959 / 2384e-9,
      983715e-9 * 0.740951125354959 / 2384e-9,
      99182e-9 * 0.740951125354959 / 2384e-9,
      /* 15 */
      12398e-9 * 0.740951125354959 / 2384e-9,
      191212e-9 * 0.740951125354959 / 2384e-9,
      2283096e-9 * 0.740951125354959 / 2384e-9,
      0.016994476 * 0.740951125354959 / 2384e-9,
      -0.018756866 * 0.740951125354959 / 2384e-9,
      -2630711e-9 * 0.740951125354959 / 2384e-9,
      -247478e-9 * 0.740951125354959 / 2384e-9,
      -14782e-9 * 0.740951125354959 / 2384e-9,
      0.9063471690191471,
      0.1960342806591213,
      -477e-9 * 0.773010453362737 / 2384e-9,
      105858e-9 * 0.773010453362737 / 2384e-9,
      930786e-9 * 0.773010453362737 / 2384e-9,
      2521515e-9 * 0.773010453362737 / 2384e-9,
      0.035694122 * 0.773010453362737 / 2384e-9,
      3643036e-9 * 0.773010453362737 / 2384e-9,
      991821e-9 * 0.773010453362737 / 2384e-9,
      96321e-9 * 0.773010453362737 / 2384e-9,
      /* 14 */
      11444e-9 * 0.773010453362737 / 2384e-9,
      165462e-9 * 0.773010453362737 / 2384e-9,
      2110004e-9 * 0.773010453362737 / 2384e-9,
      0.016112804 * 0.773010453362737 / 2384e-9,
      -0.019634247 * 0.773010453362737 / 2384e-9,
      -2803326e-9 * 0.773010453362737 / 2384e-9,
      -277042e-9 * 0.773010453362737 / 2384e-9,
      -16689e-9 * 0.773010453362737 / 2384e-9,
      0.8206787908286602,
      0.3901806440322567,
      -477e-9 * 0.803207531480645 / 2384e-9,
      107288e-9 * 0.803207531480645 / 2384e-9,
      902653e-9 * 0.803207531480645 / 2384e-9,
      2174854e-9 * 0.803207531480645 / 2384e-9,
      0.035586357 * 0.803207531480645 / 2384e-9,
      3858566e-9 * 0.803207531480645 / 2384e-9,
      995159e-9 * 0.803207531480645 / 2384e-9,
      9346e-8 * 0.803207531480645 / 2384e-9,
      /* 13 */
      10014e-9 * 0.803207531480645 / 2384e-9,
      14019e-8 * 0.803207531480645 / 2384e-9,
      1937389e-9 * 0.803207531480645 / 2384e-9,
      0.015233517 * 0.803207531480645 / 2384e-9,
      -0.020506859 * 0.803207531480645 / 2384e-9,
      -2974033e-9 * 0.803207531480645 / 2384e-9,
      -30756e-8 * 0.803207531480645 / 2384e-9,
      -1812e-8 * 0.803207531480645 / 2384e-9,
      0.7416505462720353,
      0.5805693545089249,
      -477e-9 * 0.831469612302545 / 2384e-9,
      108242e-9 * 0.831469612302545 / 2384e-9,
      868797e-9 * 0.831469612302545 / 2384e-9,
      1800537e-9 * 0.831469612302545 / 2384e-9,
      0.0354352 * 0.831469612302545 / 2384e-9,
      4049301e-9 * 0.831469612302545 / 2384e-9,
      994205e-9 * 0.831469612302545 / 2384e-9,
      90599e-9 * 0.831469612302545 / 2384e-9,
      /* 12 */
      906e-8 * 0.831469612302545 / 2384e-9,
      116348e-9 * 0.831469612302545 / 2384e-9,
      1766682e-9 * 0.831469612302545 / 2384e-9,
      0.014358521 * 0.831469612302545 / 2384e-9,
      -0.021372318 * 0.831469612302545 / 2384e-9,
      -314188e-8 * 0.831469612302545 / 2384e-9,
      -339031e-9 * 0.831469612302545 / 2384e-9,
      -1955e-8 * 0.831469612302545 / 2384e-9,
      0.6681786379192989,
      0.7653668647301797,
      -477e-9 * 0.857728610000272 / 2384e-9,
      108719e-9 * 0.857728610000272 / 2384e-9,
      82922e-8 * 0.857728610000272 / 2384e-9,
      1399517e-9 * 0.857728610000272 / 2384e-9,
      0.035242081 * 0.857728610000272 / 2384e-9,
      421524e-8 * 0.857728610000272 / 2384e-9,
      989437e-9 * 0.857728610000272 / 2384e-9,
      87261e-9 * 0.857728610000272 / 2384e-9,
      /* 11 */
      8106e-9 * 0.857728610000272 / 2384e-9,
      93937e-9 * 0.857728610000272 / 2384e-9,
      1597881e-9 * 0.857728610000272 / 2384e-9,
      0.013489246 * 0.857728610000272 / 2384e-9,
      -0.022228718 * 0.857728610000272 / 2384e-9,
      -3306866e-9 * 0.857728610000272 / 2384e-9,
      -371456e-9 * 0.857728610000272 / 2384e-9,
      -21458e-9 * 0.857728610000272 / 2384e-9,
      0.5993769336819237,
      0.9427934736519954,
      -477e-9 * 0.881921264348355 / 2384e-9,
      108719e-9 * 0.881921264348355 / 2384e-9,
      78392e-8 * 0.881921264348355 / 2384e-9,
      971317e-9 * 0.881921264348355 / 2384e-9,
      0.035007 * 0.881921264348355 / 2384e-9,
      4357815e-9 * 0.881921264348355 / 2384e-9,
      980854e-9 * 0.881921264348355 / 2384e-9,
      83923e-9 * 0.881921264348355 / 2384e-9,
      /* 10 */
      7629e-9 * 0.881921264348355 / 2384e-9,
      72956e-9 * 0.881921264348355 / 2384e-9,
      1432419e-9 * 0.881921264348355 / 2384e-9,
      0.012627602 * 0.881921264348355 / 2384e-9,
      -0.02307415 * 0.881921264348355 / 2384e-9,
      -3467083e-9 * 0.881921264348355 / 2384e-9,
      -404358e-9 * 0.881921264348355 / 2384e-9,
      -23365e-9 * 0.881921264348355 / 2384e-9,
      0.5345111359507916,
      1.111140466039205,
      -954e-9 * 0.903989293123443 / 2384e-9,
      108242e-9 * 0.903989293123443 / 2384e-9,
      731945e-9 * 0.903989293123443 / 2384e-9,
      515938e-9 * 0.903989293123443 / 2384e-9,
      0.034730434 * 0.903989293123443 / 2384e-9,
      4477024e-9 * 0.903989293123443 / 2384e-9,
      968933e-9 * 0.903989293123443 / 2384e-9,
      80585e-9 * 0.903989293123443 / 2384e-9,
      /* 9 */
      6676e-9 * 0.903989293123443 / 2384e-9,
      52929e-9 * 0.903989293123443 / 2384e-9,
      1269817e-9 * 0.903989293123443 / 2384e-9,
      0.011775017 * 0.903989293123443 / 2384e-9,
      -0.023907185 * 0.903989293123443 / 2384e-9,
      -3622532e-9 * 0.903989293123443 / 2384e-9,
      -438213e-9 * 0.903989293123443 / 2384e-9,
      -25272e-9 * 0.903989293123443 / 2384e-9,
      0.4729647758913199,
      1.268786568327291,
      -954e-9 * 0.9238795325112867 / 2384e-9,
      106812e-9 * 0.9238795325112867 / 2384e-9,
      674248e-9 * 0.9238795325112867 / 2384e-9,
      33379e-9 * 0.9238795325112867 / 2384e-9,
      0.034412861 * 0.9238795325112867 / 2384e-9,
      4573822e-9 * 0.9238795325112867 / 2384e-9,
      954151e-9 * 0.9238795325112867 / 2384e-9,
      76771e-9 * 0.9238795325112867 / 2384e-9,
      6199e-9 * 0.9238795325112867 / 2384e-9,
      34332e-9 * 0.9238795325112867 / 2384e-9,
      1111031e-9 * 0.9238795325112867 / 2384e-9,
      0.010933399 * 0.9238795325112867 / 2384e-9,
      -0.024725437 * 0.9238795325112867 / 2384e-9,
      -3771782e-9 * 0.9238795325112867 / 2384e-9,
      -472546e-9 * 0.9238795325112867 / 2384e-9,
      -27657e-9 * 0.9238795325112867 / 2384e-9,
      0.41421356237309503,
      /* tan(PI/8) */
      1.414213562373095,
      -954e-9 * 0.941544065183021 / 2384e-9,
      105381e-9 * 0.941544065183021 / 2384e-9,
      610352e-9 * 0.941544065183021 / 2384e-9,
      -475883e-9 * 0.941544065183021 / 2384e-9,
      0.03405571 * 0.941544065183021 / 2384e-9,
      4649162e-9 * 0.941544065183021 / 2384e-9,
      935555e-9 * 0.941544065183021 / 2384e-9,
      73433e-9 * 0.941544065183021 / 2384e-9,
      /* 7 */
      5245e-9 * 0.941544065183021 / 2384e-9,
      17166e-9 * 0.941544065183021 / 2384e-9,
      956535e-9 * 0.941544065183021 / 2384e-9,
      0.010103703 * 0.941544065183021 / 2384e-9,
      -0.025527 * 0.941544065183021 / 2384e-9,
      -3914356e-9 * 0.941544065183021 / 2384e-9,
      -507355e-9 * 0.941544065183021 / 2384e-9,
      -30041e-9 * 0.941544065183021 / 2384e-9,
      0.3578057213145241,
      1.546020906725474,
      -954e-9 * 0.956940335732209 / 2384e-9,
      10252e-8 * 0.956940335732209 / 2384e-9,
      539303e-9 * 0.956940335732209 / 2384e-9,
      -1011848e-9 * 0.956940335732209 / 2384e-9,
      0.033659935 * 0.956940335732209 / 2384e-9,
      4703045e-9 * 0.956940335732209 / 2384e-9,
      915051e-9 * 0.956940335732209 / 2384e-9,
      70095e-9 * 0.956940335732209 / 2384e-9,
      /* 6 */
      4768e-9 * 0.956940335732209 / 2384e-9,
      954e-9 * 0.956940335732209 / 2384e-9,
      806808e-9 * 0.956940335732209 / 2384e-9,
      9287834e-9 * 0.956940335732209 / 2384e-9,
      -0.026310921 * 0.956940335732209 / 2384e-9,
      -4048824e-9 * 0.956940335732209 / 2384e-9,
      -542164e-9 * 0.956940335732209 / 2384e-9,
      -32425e-9 * 0.956940335732209 / 2384e-9,
      0.3033466836073424,
      1.66293922460509,
      -1431e-9 * 0.970031253194544 / 2384e-9,
      99182e-9 * 0.970031253194544 / 2384e-9,
      462532e-9 * 0.970031253194544 / 2384e-9,
      -1573563e-9 * 0.970031253194544 / 2384e-9,
      0.033225536 * 0.970031253194544 / 2384e-9,
      4737377e-9 * 0.970031253194544 / 2384e-9,
      891685e-9 * 0.970031253194544 / 2384e-9,
      6628e-8 * 0.970031253194544 / 2384e-9,
      /* 5 */
      4292e-9 * 0.970031253194544 / 2384e-9,
      -13828e-9 * 0.970031253194544 / 2384e-9,
      66185e-8 * 0.970031253194544 / 2384e-9,
      8487225e-9 * 0.970031253194544 / 2384e-9,
      -0.02707386 * 0.970031253194544 / 2384e-9,
      -4174709e-9 * 0.970031253194544 / 2384e-9,
      -576973e-9 * 0.970031253194544 / 2384e-9,
      -34809e-9 * 0.970031253194544 / 2384e-9,
      0.2504869601913055,
      1.76384252869671,
      -1431e-9 * 0.98078528040323 / 2384e-9,
      95367e-9 * 0.98078528040323 / 2384e-9,
      378609e-9 * 0.98078528040323 / 2384e-9,
      -2161503e-9 * 0.98078528040323 / 2384e-9,
      0.032754898 * 0.98078528040323 / 2384e-9,
      4752159e-9 * 0.98078528040323 / 2384e-9,
      866413e-9 * 0.98078528040323 / 2384e-9,
      62943e-9 * 0.98078528040323 / 2384e-9,
      /* 4 */
      3815e-9 * 0.98078528040323 / 2384e-9,
      -2718e-8 * 0.98078528040323 / 2384e-9,
      522137e-9 * 0.98078528040323 / 2384e-9,
      7703304e-9 * 0.98078528040323 / 2384e-9,
      -0.027815342 * 0.98078528040323 / 2384e-9,
      -4290581e-9 * 0.98078528040323 / 2384e-9,
      -611782e-9 * 0.98078528040323 / 2384e-9,
      -3767e-8 * 0.98078528040323 / 2384e-9,
      0.198912367379658,
      1.847759065022573,
      -1907e-9 * 0.989176509964781 / 2384e-9,
      90122e-9 * 0.989176509964781 / 2384e-9,
      288486e-9 * 0.989176509964781 / 2384e-9,
      -2774239e-9 * 0.989176509964781 / 2384e-9,
      0.03224802 * 0.989176509964781 / 2384e-9,
      4748821e-9 * 0.989176509964781 / 2384e-9,
      838757e-9 * 0.989176509964781 / 2384e-9,
      59605e-9 * 0.989176509964781 / 2384e-9,
      /* 3 */
      3338e-9 * 0.989176509964781 / 2384e-9,
      -39577e-9 * 0.989176509964781 / 2384e-9,
      388145e-9 * 0.989176509964781 / 2384e-9,
      6937027e-9 * 0.989176509964781 / 2384e-9,
      -0.028532982 * 0.989176509964781 / 2384e-9,
      -4395962e-9 * 0.989176509964781 / 2384e-9,
      -646591e-9 * 0.989176509964781 / 2384e-9,
      -40531e-9 * 0.989176509964781 / 2384e-9,
      0.1483359875383474,
      1.913880671464418,
      -1907e-9 * 0.995184726672197 / 2384e-9,
      844e-7 * 0.995184726672197 / 2384e-9,
      191689e-9 * 0.995184726672197 / 2384e-9,
      -3411293e-9 * 0.995184726672197 / 2384e-9,
      0.03170681 * 0.995184726672197 / 2384e-9,
      4728317e-9 * 0.995184726672197 / 2384e-9,
      809669e-9 * 0.995184726672197 / 2384e-9,
      5579e-8 * 0.995184726672197 / 2384e-9,
      3338e-9 * 0.995184726672197 / 2384e-9,
      -50545e-9 * 0.995184726672197 / 2384e-9,
      259876e-9 * 0.995184726672197 / 2384e-9,
      6189346e-9 * 0.995184726672197 / 2384e-9,
      -0.029224873 * 0.995184726672197 / 2384e-9,
      -4489899e-9 * 0.995184726672197 / 2384e-9,
      -680923e-9 * 0.995184726672197 / 2384e-9,
      -43392e-9 * 0.995184726672197 / 2384e-9,
      0.09849140335716425,
      1.961570560806461,
      -2384e-9 * 0.998795456205172 / 2384e-9,
      77724e-9 * 0.998795456205172 / 2384e-9,
      88215e-9 * 0.998795456205172 / 2384e-9,
      -4072189e-9 * 0.998795456205172 / 2384e-9,
      0.031132698 * 0.998795456205172 / 2384e-9,
      4691124e-9 * 0.998795456205172 / 2384e-9,
      779152e-9 * 0.998795456205172 / 2384e-9,
      52929e-9 * 0.998795456205172 / 2384e-9,
      2861e-9 * 0.998795456205172 / 2384e-9,
      -60558e-9 * 0.998795456205172 / 2384e-9,
      137329e-9 * 0.998795456205172 / 2384e-9,
      546217e-8 * 0.998795456205172 / 2384e-9,
      -0.02989006 * 0.998795456205172 / 2384e-9,
      -4570484e-9 * 0.998795456205172 / 2384e-9,
      -714302e-9 * 0.998795456205172 / 2384e-9,
      -46253e-9 * 0.998795456205172 / 2384e-9,
      0.04912684976946725,
      1.990369453344394,
      0.035780907 * Util2.SQRT2 * 0.5 / 2384e-9,
      0.017876148 * Util2.SQRT2 * 0.5 / 2384e-9,
      3134727e-9 * Util2.SQRT2 * 0.5 / 2384e-9,
      2457142e-9 * Util2.SQRT2 * 0.5 / 2384e-9,
      971317e-9 * Util2.SQRT2 * 0.5 / 2384e-9,
      218868e-9 * Util2.SQRT2 * 0.5 / 2384e-9,
      101566e-9 * Util2.SQRT2 * 0.5 / 2384e-9,
      13828e-9 * Util2.SQRT2 * 0.5 / 2384e-9,
      0.030526638 / 2384e-9,
      4638195e-9 / 2384e-9,
      747204e-9 / 2384e-9,
      49591e-9 / 2384e-9,
      4756451e-9 / 2384e-9,
      21458e-9 / 2384e-9,
      -69618e-9 / 2384e-9
      /* 2.384e-06/2.384e-06 */
    ];
    var NS = 12;
    var NL = 36;
    var win = [
      [
        2382191739347913e-28,
        6423305872147834e-28,
        9400849094049688e-28,
        1122435026096556e-27,
        1183840321267481e-27,
        1122435026096556e-27,
        940084909404969e-27,
        6423305872147839e-28,
        2382191739347918e-28,
        5456116108943412e-27,
        4878985199565852e-27,
        4240448995017367e-27,
        3559909094758252e-27,
        2858043359288075e-27,
        2156177623817898e-27,
        1475637723558783e-27,
        8371015190102974e-28,
        2599706096327376e-28,
        -5456116108943412e-27,
        -4878985199565852e-27,
        -4240448995017367e-27,
        -3559909094758252e-27,
        -2858043359288076e-27,
        -2156177623817898e-27,
        -1475637723558783e-27,
        -8371015190102975e-28,
        -2599706096327376e-28,
        -2382191739347923e-28,
        -6423305872147843e-28,
        -9400849094049696e-28,
        -1122435026096556e-27,
        -1183840321267481e-27,
        -1122435026096556e-27,
        -9400849094049694e-28,
        -642330587214784e-27,
        -2382191739347918e-28
      ],
      [
        2382191739347913e-28,
        6423305872147834e-28,
        9400849094049688e-28,
        1122435026096556e-27,
        1183840321267481e-27,
        1122435026096556e-27,
        9400849094049688e-28,
        6423305872147841e-28,
        2382191739347918e-28,
        5456116108943413e-27,
        4878985199565852e-27,
        4240448995017367e-27,
        3559909094758253e-27,
        2858043359288075e-27,
        2156177623817898e-27,
        1475637723558782e-27,
        8371015190102975e-28,
        2599706096327376e-28,
        -5461314069809755e-27,
        -4921085770524055e-27,
        -4343405037091838e-27,
        -3732668368707687e-27,
        -3093523840190885e-27,
        -2430835727329465e-27,
        -1734679010007751e-27,
        -974825365660928e-27,
        -2797435120168326e-28,
        0,
        0,
        0,
        0,
        0,
        0,
        -2283748241799531e-28,
        -4037858874020686e-28,
        -2146547464825323e-28
      ],
      [
        0.1316524975873958,
        /* win[SHORT_TYPE] */
        0.414213562373095,
        0.7673269879789602,
        1.091308501069271,
        /* tantab_l */
        1.303225372841206,
        1.56968557711749,
        1.920982126971166,
        2.414213562373094,
        3.171594802363212,
        4.510708503662055,
        7.595754112725146,
        22.90376554843115,
        0.984807753012208,
        /* cx */
        0.6427876096865394,
        0.3420201433256688,
        0.9396926207859084,
        -0.1736481776669303,
        -0.7660444431189779,
        0.8660254037844387,
        0.5,
        -0.5144957554275265,
        /* ca */
        -0.4717319685649723,
        -0.3133774542039019,
        -0.1819131996109812,
        -0.09457419252642064,
        -0.04096558288530405,
        -0.01419856857247115,
        -0.003699974673760037,
        0.8574929257125442,
        /* cs */
        0.8817419973177052,
        0.9496286491027329,
        0.9833145924917901,
        0.9955178160675857,
        0.9991605581781475,
        0.999899195244447,
        0.9999931550702802
      ],
      [
        0,
        0,
        0,
        0,
        0,
        0,
        2283748241799531e-28,
        4037858874020686e-28,
        2146547464825323e-28,
        5461314069809755e-27,
        4921085770524055e-27,
        4343405037091838e-27,
        3732668368707687e-27,
        3093523840190885e-27,
        2430835727329466e-27,
        1734679010007751e-27,
        974825365660928e-27,
        2797435120168326e-28,
        -5456116108943413e-27,
        -4878985199565852e-27,
        -4240448995017367e-27,
        -3559909094758253e-27,
        -2858043359288075e-27,
        -2156177623817898e-27,
        -1475637723558782e-27,
        -8371015190102975e-28,
        -2599706096327376e-28,
        -2382191739347913e-28,
        -6423305872147834e-28,
        -9400849094049688e-28,
        -1122435026096556e-27,
        -1183840321267481e-27,
        -1122435026096556e-27,
        -9400849094049688e-28,
        -6423305872147841e-28,
        -2382191739347918e-28
      ]
    ];
    var tantab_l = win[Encoder2.SHORT_TYPE];
    var cx = win[Encoder2.SHORT_TYPE];
    var ca = win[Encoder2.SHORT_TYPE];
    var cs = win[Encoder2.SHORT_TYPE];
    var order = [
      0,
      1,
      16,
      17,
      8,
      9,
      24,
      25,
      4,
      5,
      20,
      21,
      12,
      13,
      28,
      29,
      2,
      3,
      18,
      19,
      10,
      11,
      26,
      27,
      6,
      7,
      22,
      23,
      14,
      15,
      30,
      31
    ];
    function window_subband(x1, x1Pos, a) {
      var wp = 10;
      var x2 = x1Pos + 238 - 14 - 286;
      for (var i = -15; i < 0; i++) {
        var w, s, t;
        w = enwindow[wp + -10];
        s = x1[x2 + -224] * w;
        t = x1[x1Pos + 224] * w;
        w = enwindow[wp + -9];
        s += x1[x2 + -160] * w;
        t += x1[x1Pos + 160] * w;
        w = enwindow[wp + -8];
        s += x1[x2 + -96] * w;
        t += x1[x1Pos + 96] * w;
        w = enwindow[wp + -7];
        s += x1[x2 + -32] * w;
        t += x1[x1Pos + 32] * w;
        w = enwindow[wp + -6];
        s += x1[x2 + 32] * w;
        t += x1[x1Pos + -32] * w;
        w = enwindow[wp + -5];
        s += x1[x2 + 96] * w;
        t += x1[x1Pos + -96] * w;
        w = enwindow[wp + -4];
        s += x1[x2 + 160] * w;
        t += x1[x1Pos + -160] * w;
        w = enwindow[wp + -3];
        s += x1[x2 + 224] * w;
        t += x1[x1Pos + -224] * w;
        w = enwindow[wp + -2];
        s += x1[x1Pos + -256] * w;
        t -= x1[x2 + 256] * w;
        w = enwindow[wp + -1];
        s += x1[x1Pos + -192] * w;
        t -= x1[x2 + 192] * w;
        w = enwindow[wp + 0];
        s += x1[x1Pos + -128] * w;
        t -= x1[x2 + 128] * w;
        w = enwindow[wp + 1];
        s += x1[x1Pos + -64] * w;
        t -= x1[x2 + 64] * w;
        w = enwindow[wp + 2];
        s += x1[x1Pos + 0] * w;
        t -= x1[x2 + 0] * w;
        w = enwindow[wp + 3];
        s += x1[x1Pos + 64] * w;
        t -= x1[x2 + -64] * w;
        w = enwindow[wp + 4];
        s += x1[x1Pos + 128] * w;
        t -= x1[x2 + -128] * w;
        w = enwindow[wp + 5];
        s += x1[x1Pos + 192] * w;
        t -= x1[x2 + -192] * w;
        s *= enwindow[wp + 6];
        w = t - s;
        a[30 + i * 2] = t + s;
        a[31 + i * 2] = enwindow[wp + 7] * w;
        wp += 18;
        x1Pos--;
        x2++;
      }
      {
        var s, t, u, v;
        t = x1[x1Pos + -16] * enwindow[wp + -10];
        s = x1[x1Pos + -32] * enwindow[wp + -2];
        t += (x1[x1Pos + -48] - x1[x1Pos + 16]) * enwindow[wp + -9];
        s += x1[x1Pos + -96] * enwindow[wp + -1];
        t += (x1[x1Pos + -80] + x1[x1Pos + 48]) * enwindow[wp + -8];
        s += x1[x1Pos + -160] * enwindow[wp + 0];
        t += (x1[x1Pos + -112] - x1[x1Pos + 80]) * enwindow[wp + -7];
        s += x1[x1Pos + -224] * enwindow[wp + 1];
        t += (x1[x1Pos + -144] + x1[x1Pos + 112]) * enwindow[wp + -6];
        s -= x1[x1Pos + 32] * enwindow[wp + 2];
        t += (x1[x1Pos + -176] - x1[x1Pos + 144]) * enwindow[wp + -5];
        s -= x1[x1Pos + 96] * enwindow[wp + 3];
        t += (x1[x1Pos + -208] + x1[x1Pos + 176]) * enwindow[wp + -4];
        s -= x1[x1Pos + 160] * enwindow[wp + 4];
        t += (x1[x1Pos + -240] - x1[x1Pos + 208]) * enwindow[wp + -3];
        s -= x1[x1Pos + 224];
        u = s - t;
        v = s + t;
        t = a[14];
        s = a[15] - t;
        a[31] = v + t;
        a[30] = u + s;
        a[15] = u - s;
        a[14] = v - t;
      }
      {
        var xr;
        xr = a[28] - a[0];
        a[0] += a[28];
        a[28] = xr * enwindow[wp + -2 * 18 + 7];
        xr = a[29] - a[1];
        a[1] += a[29];
        a[29] = xr * enwindow[wp + -2 * 18 + 7];
        xr = a[26] - a[2];
        a[2] += a[26];
        a[26] = xr * enwindow[wp + -4 * 18 + 7];
        xr = a[27] - a[3];
        a[3] += a[27];
        a[27] = xr * enwindow[wp + -4 * 18 + 7];
        xr = a[24] - a[4];
        a[4] += a[24];
        a[24] = xr * enwindow[wp + -6 * 18 + 7];
        xr = a[25] - a[5];
        a[5] += a[25];
        a[25] = xr * enwindow[wp + -6 * 18 + 7];
        xr = a[22] - a[6];
        a[6] += a[22];
        a[22] = xr * Util2.SQRT2;
        xr = a[23] - a[7];
        a[7] += a[23];
        a[23] = xr * Util2.SQRT2 - a[7];
        a[7] -= a[6];
        a[22] -= a[7];
        a[23] -= a[22];
        xr = a[6];
        a[6] = a[31] - xr;
        a[31] = a[31] + xr;
        xr = a[7];
        a[7] = a[30] - xr;
        a[30] = a[30] + xr;
        xr = a[22];
        a[22] = a[15] - xr;
        a[15] = a[15] + xr;
        xr = a[23];
        a[23] = a[14] - xr;
        a[14] = a[14] + xr;
        xr = a[20] - a[8];
        a[8] += a[20];
        a[20] = xr * enwindow[wp + -10 * 18 + 7];
        xr = a[21] - a[9];
        a[9] += a[21];
        a[21] = xr * enwindow[wp + -10 * 18 + 7];
        xr = a[18] - a[10];
        a[10] += a[18];
        a[18] = xr * enwindow[wp + -12 * 18 + 7];
        xr = a[19] - a[11];
        a[11] += a[19];
        a[19] = xr * enwindow[wp + -12 * 18 + 7];
        xr = a[16] - a[12];
        a[12] += a[16];
        a[16] = xr * enwindow[wp + -14 * 18 + 7];
        xr = a[17] - a[13];
        a[13] += a[17];
        a[17] = xr * enwindow[wp + -14 * 18 + 7];
        xr = -a[20] + a[24];
        a[20] += a[24];
        a[24] = xr * enwindow[wp + -12 * 18 + 7];
        xr = -a[21] + a[25];
        a[21] += a[25];
        a[25] = xr * enwindow[wp + -12 * 18 + 7];
        xr = a[4] - a[8];
        a[4] += a[8];
        a[8] = xr * enwindow[wp + -12 * 18 + 7];
        xr = a[5] - a[9];
        a[5] += a[9];
        a[9] = xr * enwindow[wp + -12 * 18 + 7];
        xr = a[0] - a[12];
        a[0] += a[12];
        a[12] = xr * enwindow[wp + -4 * 18 + 7];
        xr = a[1] - a[13];
        a[1] += a[13];
        a[13] = xr * enwindow[wp + -4 * 18 + 7];
        xr = a[16] - a[28];
        a[16] += a[28];
        a[28] = xr * enwindow[wp + -4 * 18 + 7];
        xr = -a[17] + a[29];
        a[17] += a[29];
        a[29] = xr * enwindow[wp + -4 * 18 + 7];
        xr = Util2.SQRT2 * (a[2] - a[10]);
        a[2] += a[10];
        a[10] = xr;
        xr = Util2.SQRT2 * (a[3] - a[11]);
        a[3] += a[11];
        a[11] = xr;
        xr = Util2.SQRT2 * (-a[18] + a[26]);
        a[18] += a[26];
        a[26] = xr - a[18];
        xr = Util2.SQRT2 * (-a[19] + a[27]);
        a[19] += a[27];
        a[27] = xr - a[19];
        xr = a[2];
        a[19] -= a[3];
        a[3] -= xr;
        a[2] = a[31] - xr;
        a[31] += xr;
        xr = a[3];
        a[11] -= a[19];
        a[18] -= xr;
        a[3] = a[30] - xr;
        a[30] += xr;
        xr = a[18];
        a[27] -= a[11];
        a[19] -= xr;
        a[18] = a[15] - xr;
        a[15] += xr;
        xr = a[19];
        a[10] -= xr;
        a[19] = a[14] - xr;
        a[14] += xr;
        xr = a[10];
        a[11] -= xr;
        a[10] = a[23] - xr;
        a[23] += xr;
        xr = a[11];
        a[26] -= xr;
        a[11] = a[22] - xr;
        a[22] += xr;
        xr = a[26];
        a[27] -= xr;
        a[26] = a[7] - xr;
        a[7] += xr;
        xr = a[27];
        a[27] = a[6] - xr;
        a[6] += xr;
        xr = Util2.SQRT2 * (a[0] - a[4]);
        a[0] += a[4];
        a[4] = xr;
        xr = Util2.SQRT2 * (a[1] - a[5]);
        a[1] += a[5];
        a[5] = xr;
        xr = Util2.SQRT2 * (a[16] - a[20]);
        a[16] += a[20];
        a[20] = xr;
        xr = Util2.SQRT2 * (a[17] - a[21]);
        a[17] += a[21];
        a[21] = xr;
        xr = -Util2.SQRT2 * (a[8] - a[12]);
        a[8] += a[12];
        a[12] = xr - a[8];
        xr = -Util2.SQRT2 * (a[9] - a[13]);
        a[9] += a[13];
        a[13] = xr - a[9];
        xr = -Util2.SQRT2 * (a[25] - a[29]);
        a[25] += a[29];
        a[29] = xr - a[25];
        xr = -Util2.SQRT2 * (a[24] + a[28]);
        a[24] -= a[28];
        a[28] = xr - a[24];
        xr = a[24] - a[16];
        a[24] = xr;
        xr = a[20] - xr;
        a[20] = xr;
        xr = a[28] - xr;
        a[28] = xr;
        xr = a[25] - a[17];
        a[25] = xr;
        xr = a[21] - xr;
        a[21] = xr;
        xr = a[29] - xr;
        a[29] = xr;
        xr = a[17] - a[1];
        a[17] = xr;
        xr = a[9] - xr;
        a[9] = xr;
        xr = a[25] - xr;
        a[25] = xr;
        xr = a[5] - xr;
        a[5] = xr;
        xr = a[21] - xr;
        a[21] = xr;
        xr = a[13] - xr;
        a[13] = xr;
        xr = a[29] - xr;
        a[29] = xr;
        xr = a[1] - a[0];
        a[1] = xr;
        xr = a[16] - xr;
        a[16] = xr;
        xr = a[17] - xr;
        a[17] = xr;
        xr = a[8] - xr;
        a[8] = xr;
        xr = a[9] - xr;
        a[9] = xr;
        xr = a[24] - xr;
        a[24] = xr;
        xr = a[25] - xr;
        a[25] = xr;
        xr = a[4] - xr;
        a[4] = xr;
        xr = a[5] - xr;
        a[5] = xr;
        xr = a[20] - xr;
        a[20] = xr;
        xr = a[21] - xr;
        a[21] = xr;
        xr = a[12] - xr;
        a[12] = xr;
        xr = a[13] - xr;
        a[13] = xr;
        xr = a[28] - xr;
        a[28] = xr;
        xr = a[29] - xr;
        a[29] = xr;
        xr = a[0];
        a[0] += a[31];
        a[31] -= xr;
        xr = a[1];
        a[1] += a[30];
        a[30] -= xr;
        xr = a[16];
        a[16] += a[15];
        a[15] -= xr;
        xr = a[17];
        a[17] += a[14];
        a[14] -= xr;
        xr = a[8];
        a[8] += a[23];
        a[23] -= xr;
        xr = a[9];
        a[9] += a[22];
        a[22] -= xr;
        xr = a[24];
        a[24] += a[7];
        a[7] -= xr;
        xr = a[25];
        a[25] += a[6];
        a[6] -= xr;
        xr = a[4];
        a[4] += a[27];
        a[27] -= xr;
        xr = a[5];
        a[5] += a[26];
        a[26] -= xr;
        xr = a[20];
        a[20] += a[11];
        a[11] -= xr;
        xr = a[21];
        a[21] += a[10];
        a[10] -= xr;
        xr = a[12];
        a[12] += a[19];
        a[19] -= xr;
        xr = a[13];
        a[13] += a[18];
        a[18] -= xr;
        xr = a[28];
        a[28] += a[3];
        a[3] -= xr;
        xr = a[29];
        a[29] += a[2];
        a[2] -= xr;
      }
    }
    function mdct_short(inout, inoutPos) {
      for (var l = 0; l < 3; l++) {
        var tc0, tc1, tc2, ts0, ts1, ts2;
        ts0 = inout[inoutPos + 2 * 3] * win[Encoder2.SHORT_TYPE][0] - inout[inoutPos + 5 * 3];
        tc0 = inout[inoutPos + 0 * 3] * win[Encoder2.SHORT_TYPE][2] - inout[inoutPos + 3 * 3];
        tc1 = ts0 + tc0;
        tc2 = ts0 - tc0;
        ts0 = inout[inoutPos + 5 * 3] * win[Encoder2.SHORT_TYPE][0] + inout[inoutPos + 2 * 3];
        tc0 = inout[inoutPos + 3 * 3] * win[Encoder2.SHORT_TYPE][2] + inout[inoutPos + 0 * 3];
        ts1 = ts0 + tc0;
        ts2 = -ts0 + tc0;
        tc0 = (inout[inoutPos + 1 * 3] * win[Encoder2.SHORT_TYPE][1] - inout[inoutPos + 4 * 3]) * 2069978111953089e-26;
        ts0 = (inout[inoutPos + 4 * 3] * win[Encoder2.SHORT_TYPE][1] + inout[inoutPos + 1 * 3]) * 2069978111953089e-26;
        inout[inoutPos + 3 * 0] = tc1 * 190752519173728e-25 + tc0;
        inout[inoutPos + 3 * 5] = -ts1 * 190752519173728e-25 + ts0;
        tc2 = tc2 * 0.8660254037844387 * 1907525191737281e-26;
        ts1 = ts1 * 0.5 * 1907525191737281e-26 + ts0;
        inout[inoutPos + 3 * 1] = tc2 - ts1;
        inout[inoutPos + 3 * 2] = tc2 + ts1;
        tc1 = tc1 * 0.5 * 1907525191737281e-26 - tc0;
        ts2 = ts2 * 0.8660254037844387 * 1907525191737281e-26;
        inout[inoutPos + 3 * 3] = tc1 + ts2;
        inout[inoutPos + 3 * 4] = tc1 - ts2;
        inoutPos++;
      }
    }
    function mdct_long(out, outPos, _in) {
      var ct, st;
      {
        var tc1, tc2, tc3, tc4, ts5, ts6, ts7, ts8;
        tc1 = _in[17] - _in[9];
        tc3 = _in[15] - _in[11];
        tc4 = _in[14] - _in[12];
        ts5 = _in[0] + _in[8];
        ts6 = _in[1] + _in[7];
        ts7 = _in[2] + _in[6];
        ts8 = _in[3] + _in[5];
        out[outPos + 17] = ts5 + ts7 - ts8 - (ts6 - _in[4]);
        st = (ts5 + ts7 - ts8) * cx[12 + 7] + (ts6 - _in[4]);
        ct = (tc1 - tc3 - tc4) * cx[12 + 6];
        out[outPos + 5] = ct + st;
        out[outPos + 6] = ct - st;
        tc2 = (_in[16] - _in[10]) * cx[12 + 6];
        ts6 = ts6 * cx[12 + 7] + _in[4];
        ct = tc1 * cx[12 + 0] + tc2 + tc3 * cx[12 + 1] + tc4 * cx[12 + 2];
        st = -ts5 * cx[12 + 4] + ts6 - ts7 * cx[12 + 5] + ts8 * cx[12 + 3];
        out[outPos + 1] = ct + st;
        out[outPos + 2] = ct - st;
        ct = tc1 * cx[12 + 1] - tc2 - tc3 * cx[12 + 2] + tc4 * cx[12 + 0];
        st = -ts5 * cx[12 + 5] + ts6 - ts7 * cx[12 + 3] + ts8 * cx[12 + 4];
        out[outPos + 9] = ct + st;
        out[outPos + 10] = ct - st;
        ct = tc1 * cx[12 + 2] - tc2 + tc3 * cx[12 + 0] - tc4 * cx[12 + 1];
        st = ts5 * cx[12 + 3] - ts6 + ts7 * cx[12 + 4] - ts8 * cx[12 + 5];
        out[outPos + 13] = ct + st;
        out[outPos + 14] = ct - st;
      }
      {
        var ts1, ts2, ts3, ts4, tc5, tc6, tc7, tc8;
        ts1 = _in[8] - _in[0];
        ts3 = _in[6] - _in[2];
        ts4 = _in[5] - _in[3];
        tc5 = _in[17] + _in[9];
        tc6 = _in[16] + _in[10];
        tc7 = _in[15] + _in[11];
        tc8 = _in[14] + _in[12];
        out[outPos + 0] = tc5 + tc7 + tc8 + (tc6 + _in[13]);
        ct = (tc5 + tc7 + tc8) * cx[12 + 7] - (tc6 + _in[13]);
        st = (ts1 - ts3 + ts4) * cx[12 + 6];
        out[outPos + 11] = ct + st;
        out[outPos + 12] = ct - st;
        ts2 = (_in[7] - _in[1]) * cx[12 + 6];
        tc6 = _in[13] - tc6 * cx[12 + 7];
        ct = tc5 * cx[12 + 3] - tc6 + tc7 * cx[12 + 4] + tc8 * cx[12 + 5];
        st = ts1 * cx[12 + 2] + ts2 + ts3 * cx[12 + 0] + ts4 * cx[12 + 1];
        out[outPos + 3] = ct + st;
        out[outPos + 4] = ct - st;
        ct = -tc5 * cx[12 + 5] + tc6 - tc7 * cx[12 + 3] - tc8 * cx[12 + 4];
        st = ts1 * cx[12 + 1] + ts2 - ts3 * cx[12 + 2] - ts4 * cx[12 + 0];
        out[outPos + 7] = ct + st;
        out[outPos + 8] = ct - st;
        ct = -tc5 * cx[12 + 4] + tc6 - tc7 * cx[12 + 5] - tc8 * cx[12 + 3];
        st = ts1 * cx[12 + 0] - ts2 + ts3 * cx[12 + 1] - ts4 * cx[12 + 2];
        out[outPos + 15] = ct + st;
        out[outPos + 16] = ct - st;
      }
    }
    this.mdct_sub48 = function(gfc, w0, w1) {
      var wk = w0;
      var wkPos = 286;
      for (var ch = 0; ch < gfc.channels_out; ch++) {
        for (var gr = 0; gr < gfc.mode_gr; gr++) {
          var band;
          var gi = gfc.l3_side.tt[gr][ch];
          var mdct_enc = gi.xr;
          var mdct_encPos = 0;
          var samp = gfc.sb_sample[ch][1 - gr];
          var sampPos = 0;
          for (var k = 0; k < 18 / 2; k++) {
            window_subband(wk, wkPos, samp[sampPos]);
            window_subband(wk, wkPos + 32, samp[sampPos + 1]);
            sampPos += 2;
            wkPos += 64;
            for (band = 1; band < 32; band += 2) {
              samp[sampPos - 1][band] *= -1;
            }
          }
          for (band = 0; band < 32; band++, mdct_encPos += 18) {
            var type2 = gi.block_type;
            var band0 = gfc.sb_sample[ch][gr];
            var band1 = gfc.sb_sample[ch][1 - gr];
            if (gi.mixed_block_flag != 0 && band < 2)
              type2 = 0;
            if (gfc.amp_filter[band] < 1e-12) {
              Arrays2.fill(
                mdct_enc,
                mdct_encPos + 0,
                mdct_encPos + 18,
                0
              );
            } else {
              if (gfc.amp_filter[band] < 1) {
                for (var k = 0; k < 18; k++)
                  band1[k][order[band]] *= gfc.amp_filter[band];
              }
              if (type2 == Encoder2.SHORT_TYPE) {
                for (var k = -NS / 4; k < 0; k++) {
                  var w = win[Encoder2.SHORT_TYPE][k + 3];
                  mdct_enc[mdct_encPos + k * 3 + 9] = band0[9 + k][order[band]] * w - band0[8 - k][order[band]];
                  mdct_enc[mdct_encPos + k * 3 + 18] = band0[14 - k][order[band]] * w + band0[15 + k][order[band]];
                  mdct_enc[mdct_encPos + k * 3 + 10] = band0[15 + k][order[band]] * w - band0[14 - k][order[band]];
                  mdct_enc[mdct_encPos + k * 3 + 19] = band1[2 - k][order[band]] * w + band1[3 + k][order[band]];
                  mdct_enc[mdct_encPos + k * 3 + 11] = band1[3 + k][order[band]] * w - band1[2 - k][order[band]];
                  mdct_enc[mdct_encPos + k * 3 + 20] = band1[8 - k][order[band]] * w + band1[9 + k][order[band]];
                }
                mdct_short(mdct_enc, mdct_encPos);
              } else {
                var work = new_float2(18);
                for (var k = -NL / 4; k < 0; k++) {
                  var a, b;
                  a = win[type2][k + 27] * band1[k + 9][order[band]] + win[type2][k + 36] * band1[8 - k][order[band]];
                  b = win[type2][k + 9] * band0[k + 9][order[band]] - win[type2][k + 18] * band0[8 - k][order[band]];
                  work[k + 9] = a - b * tantab_l[3 + k + 9];
                  work[k + 18] = a * tantab_l[3 + k + 9] + b;
                }
                mdct_long(mdct_enc, mdct_encPos, work);
              }
            }
            if (type2 != Encoder2.SHORT_TYPE && band != 0) {
              for (var k = 7; k >= 0; --k) {
                var bu, bd;
                bu = mdct_enc[mdct_encPos + k] * ca[20 + k] + mdct_enc[mdct_encPos + -1 - k] * cs[28 + k];
                bd = mdct_enc[mdct_encPos + k] * cs[28 + k] - mdct_enc[mdct_encPos + -1 - k] * ca[20 + k];
                mdct_enc[mdct_encPos + -1 - k] = bu;
                mdct_enc[mdct_encPos + k] = bd;
              }
            }
          }
        }
        wk = w1;
        wkPos = 286;
        if (gfc.mode_gr == 1) {
          for (var i = 0; i < 18; i++) {
            System2.arraycopy(
              gfc.sb_sample[ch][1][i],
              0,
              gfc.sb_sample[ch][0][i],
              0,
              32
            );
          }
        }
      }
    };
  }
  NewMDCT_1 = NewMDCT;
  return NewMDCT_1;
}
var III_psy_xmin_1;
var hasRequiredIII_psy_xmin;
function requireIII_psy_xmin() {
  if (hasRequiredIII_psy_xmin)
    return III_psy_xmin_1;
  hasRequiredIII_psy_xmin = 1;
  var Encoder2 = requireEncoder();
  var common2 = common$l;
  var System2 = common2.System;
  common2.VbrMode;
  common2.Float;
  common2.ShortBlock;
  common2.Util;
  common2.Arrays;
  common2.new_array_n;
  common2.new_byte;
  common2.new_double;
  var new_float2 = common2.new_float;
  var new_float_n2 = common2.new_float_n;
  common2.new_int;
  common2.new_int_n;
  common2.assert;
  function III_psy_xmin2() {
    this.l = new_float2(Encoder2.SBMAX_l);
    this.s = new_float_n2([Encoder2.SBMAX_s, 3]);
    var self2 = this;
    this.assign = function(iii_psy_xmin) {
      System2.arraycopy(iii_psy_xmin.l, 0, self2.l, 0, Encoder2.SBMAX_l);
      for (var i = 0; i < Encoder2.SBMAX_s; i++) {
        for (var j = 0; j < 3; j++) {
          self2.s[i][j] = iii_psy_xmin.s[i][j];
        }
      }
    };
  }
  III_psy_xmin_1 = III_psy_xmin2;
  return III_psy_xmin_1;
}
var III_psy_ratio_1;
var hasRequiredIII_psy_ratio;
function requireIII_psy_ratio() {
  if (hasRequiredIII_psy_ratio)
    return III_psy_ratio_1;
  hasRequiredIII_psy_ratio = 1;
  var III_psy_xmin2 = requireIII_psy_xmin();
  function III_psy_ratio() {
    this.thm = new III_psy_xmin2();
    this.en = new III_psy_xmin2();
  }
  III_psy_ratio_1 = III_psy_ratio;
  return III_psy_ratio_1;
}
var Encoder_1;
var hasRequiredEncoder;
function requireEncoder() {
  if (hasRequiredEncoder)
    return Encoder_1;
  hasRequiredEncoder = 1;
  var common2 = common$l;
  var System2 = common2.System;
  var VbrMode2 = common2.VbrMode;
  common2.Float;
  common2.ShortBlock;
  common2.Util;
  common2.Arrays;
  var new_array_n2 = common2.new_array_n;
  common2.new_byte;
  common2.new_double;
  var new_float2 = common2.new_float;
  var new_float_n2 = common2.new_float_n;
  var new_int2 = common2.new_int;
  common2.new_int_n;
  var assert2 = common2.assert;
  Encoder2.ENCDELAY = 576;
  Encoder2.POSTDELAY = 1152;
  Encoder2.MDCTDELAY = 48;
  Encoder2.FFTOFFSET = 224 + Encoder2.MDCTDELAY;
  Encoder2.DECDELAY = 528;
  Encoder2.SBLIMIT = 32;
  Encoder2.CBANDS = 64;
  Encoder2.SBPSY_l = 21;
  Encoder2.SBPSY_s = 12;
  Encoder2.SBMAX_l = 22;
  Encoder2.SBMAX_s = 13;
  Encoder2.PSFB21 = 6;
  Encoder2.PSFB12 = 6;
  Encoder2.BLKSIZE = 1024;
  Encoder2.HBLKSIZE = Encoder2.BLKSIZE / 2 + 1;
  Encoder2.BLKSIZE_s = 256;
  Encoder2.HBLKSIZE_s = Encoder2.BLKSIZE_s / 2 + 1;
  Encoder2.NORM_TYPE = 0;
  Encoder2.START_TYPE = 1;
  Encoder2.SHORT_TYPE = 2;
  Encoder2.STOP_TYPE = 3;
  Encoder2.MPG_MD_LR_LR = 0;
  Encoder2.MPG_MD_LR_I = 1;
  Encoder2.MPG_MD_MS_LR = 2;
  Encoder2.MPG_MD_MS_I = 3;
  Encoder2.fircoef = [
    -0.0207887 * 5,
    -0.0378413 * 5,
    -0.0432472 * 5,
    -0.031183 * 5,
    779609e-23 * 5,
    0.0467745 * 5,
    0.10091 * 5,
    0.151365 * 5,
    0.187098 * 5
  ];
  function Encoder2() {
    var NewMDCT = requireNewMDCT();
    var III_psy_ratio = requireIII_psy_ratio();
    var FFTOFFSET = Encoder2.FFTOFFSET;
    var MPG_MD_MS_LR = Encoder2.MPG_MD_MS_LR;
    var bs = null;
    this.psy = null;
    var psy = null;
    var vbr = null;
    var qupvt = null;
    this.setModules = function(_bs, _psy, _qupvt, _vbr) {
      bs = _bs;
      this.psy = _psy;
      psy = _psy;
      vbr = _vbr;
      qupvt = _qupvt;
    };
    var newMDCT = new NewMDCT();
    function adjust_ATH(gfc) {
      var gr2_max, max_pow;
      if (gfc.ATH.useAdjust == 0) {
        gfc.ATH.adjust = 1;
        return;
      }
      max_pow = gfc.loudness_sq[0][0];
      gr2_max = gfc.loudness_sq[1][0];
      if (gfc.channels_out == 2) {
        max_pow += gfc.loudness_sq[0][1];
        gr2_max += gfc.loudness_sq[1][1];
      } else {
        max_pow += max_pow;
        gr2_max += gr2_max;
      }
      if (gfc.mode_gr == 2) {
        max_pow = Math.max(max_pow, gr2_max);
      }
      max_pow *= 0.5;
      max_pow *= gfc.ATH.aaSensitivityP;
      if (max_pow > 0.03125) {
        if (gfc.ATH.adjust >= 1) {
          gfc.ATH.adjust = 1;
        } else {
          if (gfc.ATH.adjust < gfc.ATH.adjustLimit) {
            gfc.ATH.adjust = gfc.ATH.adjustLimit;
          }
        }
        gfc.ATH.adjustLimit = 1;
      } else {
        var adj_lim_new = 31.98 * max_pow + 625e-6;
        if (gfc.ATH.adjust >= adj_lim_new) {
          gfc.ATH.adjust *= adj_lim_new * 0.075 + 0.925;
          if (gfc.ATH.adjust < adj_lim_new) {
            gfc.ATH.adjust = adj_lim_new;
          }
        } else {
          if (gfc.ATH.adjustLimit >= adj_lim_new) {
            gfc.ATH.adjust = adj_lim_new;
          } else {
            if (gfc.ATH.adjust < gfc.ATH.adjustLimit) {
              gfc.ATH.adjust = gfc.ATH.adjustLimit;
            }
          }
        }
        gfc.ATH.adjustLimit = adj_lim_new;
      }
    }
    function updateStats(gfc) {
      var gr, ch;
      assert2(0 <= gfc.bitrate_index && gfc.bitrate_index < 16);
      assert2(0 <= gfc.mode_ext && gfc.mode_ext < 4);
      gfc.bitrate_stereoMode_Hist[gfc.bitrate_index][4]++;
      gfc.bitrate_stereoMode_Hist[15][4]++;
      if (gfc.channels_out == 2) {
        gfc.bitrate_stereoMode_Hist[gfc.bitrate_index][gfc.mode_ext]++;
        gfc.bitrate_stereoMode_Hist[15][gfc.mode_ext]++;
      }
      for (gr = 0; gr < gfc.mode_gr; ++gr) {
        for (ch = 0; ch < gfc.channels_out; ++ch) {
          var bt = gfc.l3_side.tt[gr][ch].block_type | 0;
          if (gfc.l3_side.tt[gr][ch].mixed_block_flag != 0)
            bt = 4;
          gfc.bitrate_blockType_Hist[gfc.bitrate_index][bt]++;
          gfc.bitrate_blockType_Hist[gfc.bitrate_index][5]++;
          gfc.bitrate_blockType_Hist[15][bt]++;
          gfc.bitrate_blockType_Hist[15][5]++;
        }
      }
    }
    function lame_encode_frame_init(gfp, inbuf) {
      var gfc = gfp.internal_flags;
      var ch, gr;
      if (gfc.lame_encode_frame_init == 0) {
        var i, j;
        var primebuff0 = new_float2(286 + 1152 + 576);
        var primebuff1 = new_float2(286 + 1152 + 576);
        gfc.lame_encode_frame_init = 1;
        for (i = 0, j = 0; i < 286 + 576 * (1 + gfc.mode_gr); ++i) {
          if (i < 576 * gfc.mode_gr) {
            primebuff0[i] = 0;
            if (gfc.channels_out == 2)
              primebuff1[i] = 0;
          } else {
            primebuff0[i] = inbuf[0][j];
            if (gfc.channels_out == 2)
              primebuff1[i] = inbuf[1][j];
            ++j;
          }
        }
        for (gr = 0; gr < gfc.mode_gr; gr++) {
          for (ch = 0; ch < gfc.channels_out; ch++) {
            gfc.l3_side.tt[gr][ch].block_type = Encoder2.SHORT_TYPE;
          }
        }
        newMDCT.mdct_sub48(gfc, primebuff0, primebuff1);
        assert2(576 >= Encoder2.FFTOFFSET);
        assert2(gfc.mf_size >= Encoder2.BLKSIZE + gfp.framesize - Encoder2.FFTOFFSET);
        assert2(gfc.mf_size >= 512 + gfp.framesize - 32);
      }
    }
    this.lame_encode_mp3_frame = function(gfp, inbuf_l, inbuf_r, mp3buf, mp3bufPos, mp3buf_size) {
      var mp3count;
      var masking_LR = new_array_n2([2, 2]);
      masking_LR[0][0] = new III_psy_ratio();
      masking_LR[0][1] = new III_psy_ratio();
      masking_LR[1][0] = new III_psy_ratio();
      masking_LR[1][1] = new III_psy_ratio();
      var masking_MS = new_array_n2([2, 2]);
      masking_MS[0][0] = new III_psy_ratio();
      masking_MS[0][1] = new III_psy_ratio();
      masking_MS[1][0] = new III_psy_ratio();
      masking_MS[1][1] = new III_psy_ratio();
      var masking;
      var inbuf = [null, null];
      var gfc = gfp.internal_flags;
      var tot_ener = new_float_n2([2, 4]);
      var ms_ener_ratio = [0.5, 0.5];
      var pe = [[0, 0], [0, 0]];
      var pe_MS = [[0, 0], [0, 0]];
      var pe_use;
      var ch, gr;
      inbuf[0] = inbuf_l;
      inbuf[1] = inbuf_r;
      if (gfc.lame_encode_frame_init == 0) {
        lame_encode_frame_init(gfp, inbuf);
      }
      gfc.padding = 0;
      if ((gfc.slot_lag -= gfc.frac_SpF) < 0) {
        gfc.slot_lag += gfp.out_samplerate;
        gfc.padding = 1;
      }
      if (gfc.psymodel != 0) {
        var ret;
        var bufp = [null, null];
        var bufpPos = 0;
        var blocktype = new_int2(2);
        for (gr = 0; gr < gfc.mode_gr; gr++) {
          for (ch = 0; ch < gfc.channels_out; ch++) {
            bufp[ch] = inbuf[ch];
            bufpPos = 576 + gr * 576 - Encoder2.FFTOFFSET;
          }
          if (gfp.VBR == VbrMode2.vbr_mtrh || gfp.VBR == VbrMode2.vbr_mt) {
            ret = psy.L3psycho_anal_vbr(
              gfp,
              bufp,
              bufpPos,
              gr,
              masking_LR,
              masking_MS,
              pe[gr],
              pe_MS[gr],
              tot_ener[gr],
              blocktype
            );
          } else {
            ret = psy.L3psycho_anal_ns(
              gfp,
              bufp,
              bufpPos,
              gr,
              masking_LR,
              masking_MS,
              pe[gr],
              pe_MS[gr],
              tot_ener[gr],
              blocktype
            );
          }
          if (ret != 0)
            return -4;
          if (gfp.mode == MPEGMode.JOINT_STEREO) {
            ms_ener_ratio[gr] = tot_ener[gr][2] + tot_ener[gr][3];
            if (ms_ener_ratio[gr] > 0)
              ms_ener_ratio[gr] = tot_ener[gr][3] / ms_ener_ratio[gr];
          }
          for (ch = 0; ch < gfc.channels_out; ch++) {
            var cod_info = gfc.l3_side.tt[gr][ch];
            cod_info.block_type = blocktype[ch];
            cod_info.mixed_block_flag = 0;
          }
        }
      } else {
        for (gr = 0; gr < gfc.mode_gr; gr++)
          for (ch = 0; ch < gfc.channels_out; ch++) {
            gfc.l3_side.tt[gr][ch].block_type = Encoder2.NORM_TYPE;
            gfc.l3_side.tt[gr][ch].mixed_block_flag = 0;
            pe_MS[gr][ch] = pe[gr][ch] = 700;
          }
      }
      adjust_ATH(gfc);
      newMDCT.mdct_sub48(gfc, inbuf[0], inbuf[1]);
      gfc.mode_ext = Encoder2.MPG_MD_LR_LR;
      if (gfp.force_ms) {
        gfc.mode_ext = Encoder2.MPG_MD_MS_LR;
      } else if (gfp.mode == MPEGMode.JOINT_STEREO) {
        var sum_pe_MS = 0;
        var sum_pe_LR = 0;
        for (gr = 0; gr < gfc.mode_gr; gr++) {
          for (ch = 0; ch < gfc.channels_out; ch++) {
            sum_pe_MS += pe_MS[gr][ch];
            sum_pe_LR += pe[gr][ch];
          }
        }
        if (sum_pe_MS <= 1 * sum_pe_LR) {
          var gi0 = gfc.l3_side.tt[0];
          var gi1 = gfc.l3_side.tt[gfc.mode_gr - 1];
          if (gi0[0].block_type == gi0[1].block_type && gi1[0].block_type == gi1[1].block_type) {
            gfc.mode_ext = Encoder2.MPG_MD_MS_LR;
          }
        }
      }
      if (gfc.mode_ext == MPG_MD_MS_LR) {
        masking = masking_MS;
        pe_use = pe_MS;
      } else {
        masking = masking_LR;
        pe_use = pe;
      }
      if (gfp.analysis && gfc.pinfo != null) {
        for (gr = 0; gr < gfc.mode_gr; gr++) {
          for (ch = 0; ch < gfc.channels_out; ch++) {
            gfc.pinfo.ms_ratio[gr] = gfc.ms_ratio[gr];
            gfc.pinfo.ms_ener_ratio[gr] = ms_ener_ratio[gr];
            gfc.pinfo.blocktype[gr][ch] = gfc.l3_side.tt[gr][ch].block_type;
            gfc.pinfo.pe[gr][ch] = pe_use[gr][ch];
            System2.arraycopy(
              gfc.l3_side.tt[gr][ch].xr,
              0,
              gfc.pinfo.xr[gr][ch],
              0,
              576
            );
            if (gfc.mode_ext == MPG_MD_MS_LR) {
              gfc.pinfo.ers[gr][ch] = gfc.pinfo.ers[gr][ch + 2];
              System2.arraycopy(
                gfc.pinfo.energy[gr][ch + 2],
                0,
                gfc.pinfo.energy[gr][ch],
                0,
                gfc.pinfo.energy[gr][ch].length
              );
            }
          }
        }
      }
      if (gfp.VBR == VbrMode2.vbr_off || gfp.VBR == VbrMode2.vbr_abr) {
        var i;
        var f;
        for (i = 0; i < 18; i++)
          gfc.nsPsy.pefirbuf[i] = gfc.nsPsy.pefirbuf[i + 1];
        f = 0;
        for (gr = 0; gr < gfc.mode_gr; gr++)
          for (ch = 0; ch < gfc.channels_out; ch++)
            f += pe_use[gr][ch];
        gfc.nsPsy.pefirbuf[18] = f;
        f = gfc.nsPsy.pefirbuf[9];
        for (i = 0; i < 9; i++)
          f += (gfc.nsPsy.pefirbuf[i] + gfc.nsPsy.pefirbuf[18 - i]) * Encoder2.fircoef[i];
        f = 670 * 5 * gfc.mode_gr * gfc.channels_out / f;
        for (gr = 0; gr < gfc.mode_gr; gr++) {
          for (ch = 0; ch < gfc.channels_out; ch++) {
            pe_use[gr][ch] *= f;
          }
        }
      }
      gfc.iteration_loop.iteration_loop(gfp, pe_use, ms_ener_ratio, masking);
      bs.format_bitstream(gfp);
      mp3count = bs.copy_buffer(gfc, mp3buf, mp3bufPos, mp3buf_size, 1);
      if (gfp.bWriteVbrTag)
        vbr.addVbrFrame(gfp);
      if (gfp.analysis && gfc.pinfo != null) {
        for (ch = 0; ch < gfc.channels_out; ch++) {
          var j;
          for (j = 0; j < FFTOFFSET; j++)
            gfc.pinfo.pcmdata[ch][j] = gfc.pinfo.pcmdata[ch][j + gfp.framesize];
          for (j = FFTOFFSET; j < 1600; j++) {
            gfc.pinfo.pcmdata[ch][j] = inbuf[ch][j - FFTOFFSET];
          }
        }
        qupvt.set_frame_pinfo(gfp, masking);
      }
      updateStats(gfc);
      return mp3count;
    };
  }
  Encoder_1 = Encoder2;
  return Encoder_1;
}
var common$k = common$l;
common$k.System;
common$k.VbrMode;
common$k.Float;
common$k.ShortBlock;
var Util$3 = common$k.Util;
common$k.Arrays;
common$k.new_array_n;
common$k.new_byte;
common$k.new_double;
var new_float$b = common$k.new_float;
common$k.new_float_n;
common$k.new_int;
common$k.new_int_n;
common$k.assert;
var Encoder$c = requireEncoder();
function FFT$1() {
  var window2 = new_float$b(Encoder$c.BLKSIZE);
  var window_s = new_float$b(Encoder$c.BLKSIZE_s / 2);
  var costab = [
    0.9238795325112867,
    0.3826834323650898,
    0.9951847266721969,
    0.0980171403295606,
    0.9996988186962042,
    0.02454122852291229,
    0.9999811752826011,
    0.006135884649154475
  ];
  function fht(fz, fzPos, n) {
    var tri = 0;
    var k4;
    var fi;
    var gi;
    n <<= 1;
    var fn = fzPos + n;
    k4 = 4;
    do {
      var s1, c1;
      var i, k1, k2, k3, kx;
      kx = k4 >> 1;
      k1 = k4;
      k2 = k4 << 1;
      k3 = k2 + k1;
      k4 = k2 << 1;
      fi = fzPos;
      gi = fi + kx;
      do {
        var f0, f1, f2, f3;
        f1 = fz[fi + 0] - fz[fi + k1];
        f0 = fz[fi + 0] + fz[fi + k1];
        f3 = fz[fi + k2] - fz[fi + k3];
        f2 = fz[fi + k2] + fz[fi + k3];
        fz[fi + k2] = f0 - f2;
        fz[fi + 0] = f0 + f2;
        fz[fi + k3] = f1 - f3;
        fz[fi + k1] = f1 + f3;
        f1 = fz[gi + 0] - fz[gi + k1];
        f0 = fz[gi + 0] + fz[gi + k1];
        f3 = Util$3.SQRT2 * fz[gi + k3];
        f2 = Util$3.SQRT2 * fz[gi + k2];
        fz[gi + k2] = f0 - f2;
        fz[gi + 0] = f0 + f2;
        fz[gi + k3] = f1 - f3;
        fz[gi + k1] = f1 + f3;
        gi += k4;
        fi += k4;
      } while (fi < fn);
      c1 = costab[tri + 0];
      s1 = costab[tri + 1];
      for (i = 1; i < kx; i++) {
        var c2, s2;
        c2 = 1 - 2 * s1 * s1;
        s2 = 2 * s1 * c1;
        fi = fzPos + i;
        gi = fzPos + k1 - i;
        do {
          var a, b, g0, f0, f1, g1, f2, g2, f3, g3;
          b = s2 * fz[fi + k1] - c2 * fz[gi + k1];
          a = c2 * fz[fi + k1] + s2 * fz[gi + k1];
          f1 = fz[fi + 0] - a;
          f0 = fz[fi + 0] + a;
          g1 = fz[gi + 0] - b;
          g0 = fz[gi + 0] + b;
          b = s2 * fz[fi + k3] - c2 * fz[gi + k3];
          a = c2 * fz[fi + k3] + s2 * fz[gi + k3];
          f3 = fz[fi + k2] - a;
          f2 = fz[fi + k2] + a;
          g3 = fz[gi + k2] - b;
          g2 = fz[gi + k2] + b;
          b = s1 * f2 - c1 * g3;
          a = c1 * f2 + s1 * g3;
          fz[fi + k2] = f0 - a;
          fz[fi + 0] = f0 + a;
          fz[gi + k3] = g1 - b;
          fz[gi + k1] = g1 + b;
          b = c1 * g2 - s1 * f3;
          a = s1 * g2 + c1 * f3;
          fz[gi + k2] = g0 - a;
          fz[gi + 0] = g0 + a;
          fz[fi + k3] = f1 - b;
          fz[fi + k1] = f1 + b;
          gi += k4;
          fi += k4;
        } while (fi < fn);
        c2 = c1;
        c1 = c2 * costab[tri + 0] - s1 * costab[tri + 1];
        s1 = c2 * costab[tri + 1] + s1 * costab[tri + 0];
      }
      tri += 2;
    } while (k4 < n);
  }
  var rv_tbl = [
    0,
    128,
    64,
    192,
    32,
    160,
    96,
    224,
    16,
    144,
    80,
    208,
    48,
    176,
    112,
    240,
    8,
    136,
    72,
    200,
    40,
    168,
    104,
    232,
    24,
    152,
    88,
    216,
    56,
    184,
    120,
    248,
    4,
    132,
    68,
    196,
    36,
    164,
    100,
    228,
    20,
    148,
    84,
    212,
    52,
    180,
    116,
    244,
    12,
    140,
    76,
    204,
    44,
    172,
    108,
    236,
    28,
    156,
    92,
    220,
    60,
    188,
    124,
    252,
    2,
    130,
    66,
    194,
    34,
    162,
    98,
    226,
    18,
    146,
    82,
    210,
    50,
    178,
    114,
    242,
    10,
    138,
    74,
    202,
    42,
    170,
    106,
    234,
    26,
    154,
    90,
    218,
    58,
    186,
    122,
    250,
    6,
    134,
    70,
    198,
    38,
    166,
    102,
    230,
    22,
    150,
    86,
    214,
    54,
    182,
    118,
    246,
    14,
    142,
    78,
    206,
    46,
    174,
    110,
    238,
    30,
    158,
    94,
    222,
    62,
    190,
    126,
    254
  ];
  this.fft_short = function(gfc, x_real, chn, buffer, bufPos) {
    for (var b = 0; b < 3; b++) {
      var x = Encoder$c.BLKSIZE_s / 2;
      var k = 65535 & 576 / 3 * (b + 1);
      var j = Encoder$c.BLKSIZE_s / 8 - 1;
      do {
        var f0, f1, f2, f3, w;
        var i = rv_tbl[j << 2] & 255;
        f0 = window_s[i] * buffer[chn][bufPos + i + k];
        w = window_s[127 - i] * buffer[chn][bufPos + i + k + 128];
        f1 = f0 - w;
        f0 = f0 + w;
        f2 = window_s[i + 64] * buffer[chn][bufPos + i + k + 64];
        w = window_s[63 - i] * buffer[chn][bufPos + i + k + 192];
        f3 = f2 - w;
        f2 = f2 + w;
        x -= 4;
        x_real[b][x + 0] = f0 + f2;
        x_real[b][x + 2] = f0 - f2;
        x_real[b][x + 1] = f1 + f3;
        x_real[b][x + 3] = f1 - f3;
        f0 = window_s[i + 1] * buffer[chn][bufPos + i + k + 1];
        w = window_s[126 - i] * buffer[chn][bufPos + i + k + 129];
        f1 = f0 - w;
        f0 = f0 + w;
        f2 = window_s[i + 65] * buffer[chn][bufPos + i + k + 65];
        w = window_s[62 - i] * buffer[chn][bufPos + i + k + 193];
        f3 = f2 - w;
        f2 = f2 + w;
        x_real[b][x + Encoder$c.BLKSIZE_s / 2 + 0] = f0 + f2;
        x_real[b][x + Encoder$c.BLKSIZE_s / 2 + 2] = f0 - f2;
        x_real[b][x + Encoder$c.BLKSIZE_s / 2 + 1] = f1 + f3;
        x_real[b][x + Encoder$c.BLKSIZE_s / 2 + 3] = f1 - f3;
      } while (--j >= 0);
      fht(x_real[b], x, Encoder$c.BLKSIZE_s / 2);
    }
  };
  this.fft_long = function(gfc, y, chn, buffer, bufPos) {
    var jj = Encoder$c.BLKSIZE / 8 - 1;
    var x = Encoder$c.BLKSIZE / 2;
    do {
      var f0, f1, f2, f3, w;
      var i = rv_tbl[jj] & 255;
      f0 = window2[i] * buffer[chn][bufPos + i];
      w = window2[i + 512] * buffer[chn][bufPos + i + 512];
      f1 = f0 - w;
      f0 = f0 + w;
      f2 = window2[i + 256] * buffer[chn][bufPos + i + 256];
      w = window2[i + 768] * buffer[chn][bufPos + i + 768];
      f3 = f2 - w;
      f2 = f2 + w;
      x -= 4;
      y[x + 0] = f0 + f2;
      y[x + 2] = f0 - f2;
      y[x + 1] = f1 + f3;
      y[x + 3] = f1 - f3;
      f0 = window2[i + 1] * buffer[chn][bufPos + i + 1];
      w = window2[i + 513] * buffer[chn][bufPos + i + 513];
      f1 = f0 - w;
      f0 = f0 + w;
      f2 = window2[i + 257] * buffer[chn][bufPos + i + 257];
      w = window2[i + 769] * buffer[chn][bufPos + i + 769];
      f3 = f2 - w;
      f2 = f2 + w;
      y[x + Encoder$c.BLKSIZE / 2 + 0] = f0 + f2;
      y[x + Encoder$c.BLKSIZE / 2 + 2] = f0 - f2;
      y[x + Encoder$c.BLKSIZE / 2 + 1] = f1 + f3;
      y[x + Encoder$c.BLKSIZE / 2 + 3] = f1 - f3;
    } while (--jj >= 0);
    fht(y, x, Encoder$c.BLKSIZE / 2);
  };
  this.init_fft = function(gfc) {
    for (var i = 0; i < Encoder$c.BLKSIZE; i++)
      window2[i] = 0.42 - 0.5 * Math.cos(2 * Math.PI * (i + 0.5) / Encoder$c.BLKSIZE) + 0.08 * Math.cos(4 * Math.PI * (i + 0.5) / Encoder$c.BLKSIZE);
    for (var i = 0; i < Encoder$c.BLKSIZE_s / 2; i++)
      window_s[i] = 0.5 * (1 - Math.cos(2 * Math.PI * (i + 0.5) / Encoder$c.BLKSIZE_s));
  };
}
var FFT_1 = FFT$1;
var common$j = common$l;
common$j.System;
var VbrMode$5 = common$j.VbrMode;
var Float$1 = common$j.Float;
var ShortBlock$2 = common$j.ShortBlock;
var Util$2 = common$j.Util;
var Arrays$5 = common$j.Arrays;
common$j.new_array_n;
common$j.new_byte;
common$j.new_double;
var new_float$a = common$j.new_float;
var new_float_n$3 = common$j.new_float_n;
var new_int$b = common$j.new_int;
common$j.new_int_n;
var assert$9 = common$j.assert;
var FFT = FFT_1;
var Encoder$b = requireEncoder();
function PsyModel$1() {
  var fft = new FFT();
  var LOG10 = 2.302585092994046;
  var rpelev = 2;
  var rpelev2 = 16;
  var rpelev_s = 2;
  var rpelev2_s = 16;
  var DELBARK = 0.34;
  var VO_SCALE = 1 / (14752 * 14752) / (Encoder$b.BLKSIZE / 2);
  var temporalmask_sustain_sec = 0.01;
  var NS_PREECHO_ATT0 = 0.8;
  var NS_PREECHO_ATT1 = 0.6;
  var NS_PREECHO_ATT2 = 0.3;
  var NS_MSFIX = 3.5;
  var NSFIRLEN = 21;
  var LN_TO_LOG10 = 0.2302585093;
  function NON_LINEAR_SCALE_ENERGY(x) {
    return x;
  }
  function psycho_loudness_approx(energy, gfc) {
    var loudness_power = 0;
    for (var i = 0; i < Encoder$b.BLKSIZE / 2; ++i)
      loudness_power += energy[i] * gfc.ATH.eql_w[i];
    loudness_power *= VO_SCALE;
    return loudness_power;
  }
  function compute_ffts(gfp, fftenergy, fftenergy_s, wsamp_l, wsamp_lPos, wsamp_s, wsamp_sPos, gr_out, chn, buffer, bufPos) {
    var gfc = gfp.internal_flags;
    if (chn < 2) {
      fft.fft_long(gfc, wsamp_l[wsamp_lPos], chn, buffer, bufPos);
      fft.fft_short(gfc, wsamp_s[wsamp_sPos], chn, buffer, bufPos);
    } else if (chn == 2) {
      for (var j = Encoder$b.BLKSIZE - 1; j >= 0; --j) {
        var l = wsamp_l[wsamp_lPos + 0][j];
        var r = wsamp_l[wsamp_lPos + 1][j];
        wsamp_l[wsamp_lPos + 0][j] = (l + r) * Util$2.SQRT2 * 0.5;
        wsamp_l[wsamp_lPos + 1][j] = (l - r) * Util$2.SQRT2 * 0.5;
      }
      for (var b = 2; b >= 0; --b) {
        for (var j = Encoder$b.BLKSIZE_s - 1; j >= 0; --j) {
          var l = wsamp_s[wsamp_sPos + 0][b][j];
          var r = wsamp_s[wsamp_sPos + 1][b][j];
          wsamp_s[wsamp_sPos + 0][b][j] = (l + r) * Util$2.SQRT2 * 0.5;
          wsamp_s[wsamp_sPos + 1][b][j] = (l - r) * Util$2.SQRT2 * 0.5;
        }
      }
    }
    fftenergy[0] = NON_LINEAR_SCALE_ENERGY(wsamp_l[wsamp_lPos + 0][0]);
    fftenergy[0] *= fftenergy[0];
    for (var j = Encoder$b.BLKSIZE / 2 - 1; j >= 0; --j) {
      var re = wsamp_l[wsamp_lPos + 0][Encoder$b.BLKSIZE / 2 - j];
      var im = wsamp_l[wsamp_lPos + 0][Encoder$b.BLKSIZE / 2 + j];
      fftenergy[Encoder$b.BLKSIZE / 2 - j] = NON_LINEAR_SCALE_ENERGY((re * re + im * im) * 0.5);
    }
    for (var b = 2; b >= 0; --b) {
      fftenergy_s[b][0] = wsamp_s[wsamp_sPos + 0][b][0];
      fftenergy_s[b][0] *= fftenergy_s[b][0];
      for (var j = Encoder$b.BLKSIZE_s / 2 - 1; j >= 0; --j) {
        var re = wsamp_s[wsamp_sPos + 0][b][Encoder$b.BLKSIZE_s / 2 - j];
        var im = wsamp_s[wsamp_sPos + 0][b][Encoder$b.BLKSIZE_s / 2 + j];
        fftenergy_s[b][Encoder$b.BLKSIZE_s / 2 - j] = NON_LINEAR_SCALE_ENERGY((re * re + im * im) * 0.5);
      }
    }
    {
      var totalenergy = 0;
      for (var j = 11; j < Encoder$b.HBLKSIZE; j++)
        totalenergy += fftenergy[j];
      gfc.tot_ener[chn] = totalenergy;
    }
    if (gfp.analysis) {
      for (var j = 0; j < Encoder$b.HBLKSIZE; j++) {
        gfc.pinfo.energy[gr_out][chn][j] = gfc.pinfo.energy_save[chn][j];
        gfc.pinfo.energy_save[chn][j] = fftenergy[j];
      }
      gfc.pinfo.pe[gr_out][chn] = gfc.pe[chn];
    }
    if (gfp.athaa_loudapprox == 2 && chn < 2) {
      gfc.loudness_sq[gr_out][chn] = gfc.loudness_sq_save[chn];
      gfc.loudness_sq_save[chn] = psycho_loudness_approx(fftenergy, gfc);
    }
  }
  var I1LIMIT = 8;
  var I2LIMIT = 23;
  var MLIMIT = 15;
  var ma_max_i1;
  var ma_max_i2;
  var ma_max_m;
  var tab = [
    1,
    0.79433,
    0.63096,
    0.63096,
    0.63096,
    0.63096,
    0.63096,
    0.25119,
    0.11749
  ];
  function init_mask_add_max_values() {
    ma_max_i1 = Math.pow(10, (I1LIMIT + 1) / 16);
    ma_max_i2 = Math.pow(10, (I2LIMIT + 1) / 16);
    ma_max_m = Math.pow(10, MLIMIT / 10);
  }
  var table1 = [
    3.3246 * 3.3246,
    3.23837 * 3.23837,
    3.15437 * 3.15437,
    3.00412 * 3.00412,
    2.86103 * 2.86103,
    2.65407 * 2.65407,
    2.46209 * 2.46209,
    2.284 * 2.284,
    2.11879 * 2.11879,
    1.96552 * 1.96552,
    1.82335 * 1.82335,
    1.69146 * 1.69146,
    1.56911 * 1.56911,
    1.46658 * 1.46658,
    1.37074 * 1.37074,
    1.31036 * 1.31036,
    1.25264 * 1.25264,
    1.20648 * 1.20648,
    1.16203 * 1.16203,
    1.12765 * 1.12765,
    1.09428 * 1.09428,
    1.0659 * 1.0659,
    1.03826 * 1.03826,
    1.01895 * 1.01895,
    1
  ];
  var table2 = [
    1.33352 * 1.33352,
    1.35879 * 1.35879,
    1.38454 * 1.38454,
    1.39497 * 1.39497,
    1.40548 * 1.40548,
    1.3537 * 1.3537,
    1.30382 * 1.30382,
    1.22321 * 1.22321,
    1.14758 * 1.14758,
    1
  ];
  var table3 = [
    2.35364 * 2.35364,
    2.29259 * 2.29259,
    2.23313 * 2.23313,
    2.12675 * 2.12675,
    2.02545 * 2.02545,
    1.87894 * 1.87894,
    1.74303 * 1.74303,
    1.61695 * 1.61695,
    1.49999 * 1.49999,
    1.39148 * 1.39148,
    1.29083 * 1.29083,
    1.19746 * 1.19746,
    1.11084 * 1.11084,
    1.03826 * 1.03826
  ];
  function mask_add(m1, m2, kk, b, gfc, shortblock) {
    var ratio;
    if (m2 > m1) {
      if (m2 < m1 * ma_max_i2)
        ratio = m2 / m1;
      else
        return m1 + m2;
    } else {
      if (m1 >= m2 * ma_max_i2)
        return m1 + m2;
      ratio = m1 / m2;
    }
    assert$9(m1 >= 0);
    assert$9(m2 >= 0);
    m1 += m2;
    if (b + 3 <= 3 + 3) {
      if (ratio >= ma_max_i1) {
        return m1;
      }
      var i = 0 | Util$2.FAST_LOG10_X(ratio, 16);
      return m1 * table2[i];
    }
    var i = 0 | Util$2.FAST_LOG10_X(ratio, 16);
    if (shortblock != 0) {
      m2 = gfc.ATH.cb_s[kk] * gfc.ATH.adjust;
    } else {
      m2 = gfc.ATH.cb_l[kk] * gfc.ATH.adjust;
    }
    assert$9(m2 >= 0);
    if (m1 < ma_max_m * m2) {
      if (m1 > m2) {
        var f, r;
        f = 1;
        if (i <= 13)
          f = table3[i];
        r = Util$2.FAST_LOG10_X(m1 / m2, 10 / 15);
        return m1 * ((table1[i] - f) * r + f);
      }
      if (i > 13)
        return m1;
      return m1 * table3[i];
    }
    return m1 * table1[i];
  }
  var table2_ = [
    1.33352 * 1.33352,
    1.35879 * 1.35879,
    1.38454 * 1.38454,
    1.39497 * 1.39497,
    1.40548 * 1.40548,
    1.3537 * 1.3537,
    1.30382 * 1.30382,
    1.22321 * 1.22321,
    1.14758 * 1.14758,
    1
  ];
  function vbrpsy_mask_add(m1, m2, b) {
    var ratio;
    if (m1 < 0) {
      m1 = 0;
    }
    if (m2 < 0) {
      m2 = 0;
    }
    if (m1 <= 0) {
      return m2;
    }
    if (m2 <= 0) {
      return m1;
    }
    if (m2 > m1) {
      ratio = m2 / m1;
    } else {
      ratio = m1 / m2;
    }
    if (-2 <= b && b <= 2) {
      if (ratio >= ma_max_i1) {
        return m1 + m2;
      } else {
        var i = 0 | Util$2.FAST_LOG10_X(ratio, 16);
        return (m1 + m2) * table2_[i];
      }
    }
    if (ratio < ma_max_i2) {
      return m1 + m2;
    }
    if (m1 < m2) {
      m1 = m2;
    }
    return m1;
  }
  function calc_interchannel_masking(gfp, ratio) {
    var gfc = gfp.internal_flags;
    if (gfc.channels_out > 1) {
      for (var sb = 0; sb < Encoder$b.SBMAX_l; sb++) {
        var l = gfc.thm[0].l[sb];
        var r = gfc.thm[1].l[sb];
        gfc.thm[0].l[sb] += r * ratio;
        gfc.thm[1].l[sb] += l * ratio;
      }
      for (var sb = 0; sb < Encoder$b.SBMAX_s; sb++) {
        for (var sblock = 0; sblock < 3; sblock++) {
          var l = gfc.thm[0].s[sb][sblock];
          var r = gfc.thm[1].s[sb][sblock];
          gfc.thm[0].s[sb][sblock] += r * ratio;
          gfc.thm[1].s[sb][sblock] += l * ratio;
        }
      }
    }
  }
  function msfix1(gfc) {
    for (var sb = 0; sb < Encoder$b.SBMAX_l; sb++) {
      if (gfc.thm[0].l[sb] > 1.58 * gfc.thm[1].l[sb] || gfc.thm[1].l[sb] > 1.58 * gfc.thm[0].l[sb])
        continue;
      var mld = gfc.mld_l[sb] * gfc.en[3].l[sb];
      var rmid = Math.max(
        gfc.thm[2].l[sb],
        Math.min(gfc.thm[3].l[sb], mld)
      );
      mld = gfc.mld_l[sb] * gfc.en[2].l[sb];
      var rside = Math.max(
        gfc.thm[3].l[sb],
        Math.min(gfc.thm[2].l[sb], mld)
      );
      gfc.thm[2].l[sb] = rmid;
      gfc.thm[3].l[sb] = rside;
    }
    for (var sb = 0; sb < Encoder$b.SBMAX_s; sb++) {
      for (var sblock = 0; sblock < 3; sblock++) {
        if (gfc.thm[0].s[sb][sblock] > 1.58 * gfc.thm[1].s[sb][sblock] || gfc.thm[1].s[sb][sblock] > 1.58 * gfc.thm[0].s[sb][sblock])
          continue;
        var mld = gfc.mld_s[sb] * gfc.en[3].s[sb][sblock];
        var rmid = Math.max(
          gfc.thm[2].s[sb][sblock],
          Math.min(gfc.thm[3].s[sb][sblock], mld)
        );
        mld = gfc.mld_s[sb] * gfc.en[2].s[sb][sblock];
        var rside = Math.max(
          gfc.thm[3].s[sb][sblock],
          Math.min(gfc.thm[2].s[sb][sblock], mld)
        );
        gfc.thm[2].s[sb][sblock] = rmid;
        gfc.thm[3].s[sb][sblock] = rside;
      }
    }
  }
  function ns_msfix(gfc, msfix, athadjust) {
    var msfix2 = msfix;
    var athlower = Math.pow(10, athadjust);
    msfix *= 2;
    msfix2 *= 2;
    for (var sb = 0; sb < Encoder$b.SBMAX_l; sb++) {
      var thmLR, thmM, thmS, ath;
      ath = gfc.ATH.cb_l[gfc.bm_l[sb]] * athlower;
      thmLR = Math.min(
        Math.max(gfc.thm[0].l[sb], ath),
        Math.max(gfc.thm[1].l[sb], ath)
      );
      thmM = Math.max(gfc.thm[2].l[sb], ath);
      thmS = Math.max(gfc.thm[3].l[sb], ath);
      if (thmLR * msfix < thmM + thmS) {
        var f = thmLR * msfix2 / (thmM + thmS);
        thmM *= f;
        thmS *= f;
        assert$9(thmM + thmS > 0);
      }
      gfc.thm[2].l[sb] = Math.min(thmM, gfc.thm[2].l[sb]);
      gfc.thm[3].l[sb] = Math.min(thmS, gfc.thm[3].l[sb]);
    }
    athlower *= Encoder$b.BLKSIZE_s / Encoder$b.BLKSIZE;
    for (var sb = 0; sb < Encoder$b.SBMAX_s; sb++) {
      for (var sblock = 0; sblock < 3; sblock++) {
        var thmLR, thmM, thmS, ath;
        ath = gfc.ATH.cb_s[gfc.bm_s[sb]] * athlower;
        thmLR = Math.min(
          Math.max(gfc.thm[0].s[sb][sblock], ath),
          Math.max(gfc.thm[1].s[sb][sblock], ath)
        );
        thmM = Math.max(gfc.thm[2].s[sb][sblock], ath);
        thmS = Math.max(gfc.thm[3].s[sb][sblock], ath);
        if (thmLR * msfix < thmM + thmS) {
          var f = thmLR * msfix / (thmM + thmS);
          thmM *= f;
          thmS *= f;
          assert$9(thmM + thmS > 0);
        }
        gfc.thm[2].s[sb][sblock] = Math.min(
          gfc.thm[2].s[sb][sblock],
          thmM
        );
        gfc.thm[3].s[sb][sblock] = Math.min(
          gfc.thm[3].s[sb][sblock],
          thmS
        );
      }
    }
  }
  function convert_partition2scalefac_s(gfc, eb, thr, chn, sblock) {
    var sb, b;
    var enn = 0;
    var thmm = 0;
    for (sb = b = 0; sb < Encoder$b.SBMAX_s; ++b, ++sb) {
      var bo_s_sb = gfc.bo_s[sb];
      var npart_s = gfc.npart_s;
      var b_lim = bo_s_sb < npart_s ? bo_s_sb : npart_s;
      while (b < b_lim) {
        assert$9(eb[b] >= 0);
        assert$9(thr[b] >= 0);
        enn += eb[b];
        thmm += thr[b];
        b++;
      }
      gfc.en[chn].s[sb][sblock] = enn;
      gfc.thm[chn].s[sb][sblock] = thmm;
      if (b >= npart_s) {
        ++sb;
        break;
      }
      assert$9(eb[b] >= 0);
      assert$9(thr[b] >= 0);
      {
        var w_curr = gfc.PSY.bo_s_weight[sb];
        var w_next = 1 - w_curr;
        enn = w_curr * eb[b];
        thmm = w_curr * thr[b];
        gfc.en[chn].s[sb][sblock] += enn;
        gfc.thm[chn].s[sb][sblock] += thmm;
        enn = w_next * eb[b];
        thmm = w_next * thr[b];
      }
    }
    for (; sb < Encoder$b.SBMAX_s; ++sb) {
      gfc.en[chn].s[sb][sblock] = 0;
      gfc.thm[chn].s[sb][sblock] = 0;
    }
  }
  function convert_partition2scalefac_l(gfc, eb, thr, chn) {
    var sb, b;
    var enn = 0;
    var thmm = 0;
    for (sb = b = 0; sb < Encoder$b.SBMAX_l; ++b, ++sb) {
      var bo_l_sb = gfc.bo_l[sb];
      var npart_l = gfc.npart_l;
      var b_lim = bo_l_sb < npart_l ? bo_l_sb : npart_l;
      while (b < b_lim) {
        assert$9(eb[b] >= 0);
        assert$9(thr[b] >= 0);
        enn += eb[b];
        thmm += thr[b];
        b++;
      }
      gfc.en[chn].l[sb] = enn;
      gfc.thm[chn].l[sb] = thmm;
      if (b >= npart_l) {
        ++sb;
        break;
      }
      assert$9(eb[b] >= 0);
      assert$9(thr[b] >= 0);
      {
        var w_curr = gfc.PSY.bo_l_weight[sb];
        var w_next = 1 - w_curr;
        enn = w_curr * eb[b];
        thmm = w_curr * thr[b];
        gfc.en[chn].l[sb] += enn;
        gfc.thm[chn].l[sb] += thmm;
        enn = w_next * eb[b];
        thmm = w_next * thr[b];
      }
    }
    for (; sb < Encoder$b.SBMAX_l; ++sb) {
      gfc.en[chn].l[sb] = 0;
      gfc.thm[chn].l[sb] = 0;
    }
  }
  function compute_masking_s(gfp, fftenergy_s, eb, thr, chn, sblock) {
    var gfc = gfp.internal_flags;
    var j, b;
    for (b = j = 0; b < gfc.npart_s; ++b) {
      var ebb = 0;
      var n = gfc.numlines_s[b];
      for (var i = 0; i < n; ++i, ++j) {
        var el = fftenergy_s[sblock][j];
        ebb += el;
      }
      eb[b] = ebb;
    }
    assert$9(b == gfc.npart_s);
    assert$9(j == 129);
    for (j = b = 0; b < gfc.npart_s; b++) {
      var kk = gfc.s3ind_s[b][0];
      var ecb = gfc.s3_ss[j++] * eb[kk];
      ++kk;
      while (kk <= gfc.s3ind_s[b][1]) {
        ecb += gfc.s3_ss[j] * eb[kk];
        ++j;
        ++kk;
      }
      {
        var x = rpelev_s * gfc.nb_s1[chn][b];
        thr[b] = Math.min(ecb, x);
      }
      if (gfc.blocktype_old[chn & 1] == Encoder$b.SHORT_TYPE) {
        var x = rpelev2_s * gfc.nb_s2[chn][b];
        var y = thr[b];
        thr[b] = Math.min(x, y);
      }
      gfc.nb_s2[chn][b] = gfc.nb_s1[chn][b];
      gfc.nb_s1[chn][b] = ecb;
      assert$9(thr[b] >= 0);
    }
    for (; b <= Encoder$b.CBANDS; ++b) {
      eb[b] = 0;
      thr[b] = 0;
    }
  }
  function block_type_set(gfp, uselongblock, blocktype_d, blocktype) {
    var gfc = gfp.internal_flags;
    if (gfp.short_blocks == ShortBlock$2.short_block_coupled && !(uselongblock[0] != 0 && uselongblock[1] != 0))
      uselongblock[0] = uselongblock[1] = 0;
    for (var chn = 0; chn < gfc.channels_out; chn++) {
      blocktype[chn] = Encoder$b.NORM_TYPE;
      if (gfp.short_blocks == ShortBlock$2.short_block_dispensed)
        uselongblock[chn] = 1;
      if (gfp.short_blocks == ShortBlock$2.short_block_forced)
        uselongblock[chn] = 0;
      if (uselongblock[chn] != 0) {
        assert$9(gfc.blocktype_old[chn] != Encoder$b.START_TYPE);
        if (gfc.blocktype_old[chn] == Encoder$b.SHORT_TYPE)
          blocktype[chn] = Encoder$b.STOP_TYPE;
      } else {
        blocktype[chn] = Encoder$b.SHORT_TYPE;
        if (gfc.blocktype_old[chn] == Encoder$b.NORM_TYPE) {
          gfc.blocktype_old[chn] = Encoder$b.START_TYPE;
        }
        if (gfc.blocktype_old[chn] == Encoder$b.STOP_TYPE)
          gfc.blocktype_old[chn] = Encoder$b.SHORT_TYPE;
      }
      blocktype_d[chn] = gfc.blocktype_old[chn];
      gfc.blocktype_old[chn] = blocktype[chn];
    }
  }
  function NS_INTERP(x, y, r) {
    if (r >= 1) {
      return x;
    }
    if (r <= 0)
      return y;
    if (y > 0) {
      return Math.pow(x / y, r) * y;
    }
    return 0;
  }
  var regcoef_s = [
    11.8,
    13.6,
    17.2,
    32,
    46.5,
    51.3,
    57.5,
    67.1,
    71.5,
    84.6,
    97.6,
    130
    /* 255.8 */
  ];
  function pecalc_s(mr, masking_lower) {
    var pe_s = 1236.28 / 4;
    for (var sb = 0; sb < Encoder$b.SBMAX_s - 1; sb++) {
      for (var sblock = 0; sblock < 3; sblock++) {
        var thm = mr.thm.s[sb][sblock];
        assert$9(sb < regcoef_s.length);
        if (thm > 0) {
          var x = thm * masking_lower;
          var en2 = mr.en.s[sb][sblock];
          if (en2 > x) {
            if (en2 > x * 1e10) {
              pe_s += regcoef_s[sb] * (10 * LOG10);
            } else {
              assert$9(x > 0);
              pe_s += regcoef_s[sb] * Util$2.FAST_LOG10(en2 / x);
            }
          }
        }
      }
    }
    return pe_s;
  }
  var regcoef_l = [
    6.8,
    5.8,
    5.8,
    6.4,
    6.5,
    9.9,
    12.1,
    14.4,
    15,
    18.9,
    21.6,
    26.9,
    34.2,
    40.2,
    46.8,
    56.5,
    60.7,
    73.9,
    85.7,
    93.4,
    126.1
    /* 241.3 */
  ];
  function pecalc_l(mr, masking_lower) {
    var pe_l = 1124.23 / 4;
    for (var sb = 0; sb < Encoder$b.SBMAX_l - 1; sb++) {
      var thm = mr.thm.l[sb];
      assert$9(sb < regcoef_l.length);
      if (thm > 0) {
        var x = thm * masking_lower;
        var en2 = mr.en.l[sb];
        if (en2 > x) {
          if (en2 > x * 1e10) {
            pe_l += regcoef_l[sb] * (10 * LOG10);
          } else {
            assert$9(x > 0);
            pe_l += regcoef_l[sb] * Util$2.FAST_LOG10(en2 / x);
          }
        }
      }
    }
    return pe_l;
  }
  function calc_energy(gfc, fftenergy, eb, max2, avg) {
    var b, j;
    for (b = j = 0; b < gfc.npart_l; ++b) {
      var ebb = 0, m = 0;
      var i;
      for (i = 0; i < gfc.numlines_l[b]; ++i, ++j) {
        var el = fftenergy[j];
        assert$9(el >= 0);
        ebb += el;
        if (m < el)
          m = el;
      }
      eb[b] = ebb;
      max2[b] = m;
      avg[b] = ebb * gfc.rnumlines_l[b];
      assert$9(gfc.rnumlines_l[b] >= 0);
      assert$9(ebb >= 0);
      assert$9(eb[b] >= 0);
      assert$9(max2[b] >= 0);
      assert$9(avg[b] >= 0);
    }
  }
  function calc_mask_index_l(gfc, max2, avg, mask_idx) {
    var last_tab_entry = tab.length - 1;
    var b = 0;
    var a = avg[b] + avg[b + 1];
    assert$9(a >= 0);
    if (a > 0) {
      var m = max2[b];
      if (m < max2[b + 1])
        m = max2[b + 1];
      assert$9(gfc.numlines_l[b] + gfc.numlines_l[b + 1] - 1 > 0);
      a = 20 * (m * 2 - a) / (a * (gfc.numlines_l[b] + gfc.numlines_l[b + 1] - 1));
      var k = 0 | a;
      if (k > last_tab_entry)
        k = last_tab_entry;
      mask_idx[b] = k;
    } else {
      mask_idx[b] = 0;
    }
    for (b = 1; b < gfc.npart_l - 1; b++) {
      a = avg[b - 1] + avg[b] + avg[b + 1];
      assert$9(a >= 0);
      if (a > 0) {
        var m = max2[b - 1];
        if (m < max2[b])
          m = max2[b];
        if (m < max2[b + 1])
          m = max2[b + 1];
        assert$9(gfc.numlines_l[b - 1] + gfc.numlines_l[b] + gfc.numlines_l[b + 1] - 1 > 0);
        a = 20 * (m * 3 - a) / (a * (gfc.numlines_l[b - 1] + gfc.numlines_l[b] + gfc.numlines_l[b + 1] - 1));
        var k = 0 | a;
        if (k > last_tab_entry)
          k = last_tab_entry;
        mask_idx[b] = k;
      } else {
        mask_idx[b] = 0;
      }
    }
    assert$9(b > 0);
    assert$9(b == gfc.npart_l - 1);
    a = avg[b - 1] + avg[b];
    assert$9(a >= 0);
    if (a > 0) {
      var m = max2[b - 1];
      if (m < max2[b])
        m = max2[b];
      assert$9(gfc.numlines_l[b - 1] + gfc.numlines_l[b] - 1 > 0);
      a = 20 * (m * 2 - a) / (a * (gfc.numlines_l[b - 1] + gfc.numlines_l[b] - 1));
      var k = 0 | a;
      if (k > last_tab_entry)
        k = last_tab_entry;
      mask_idx[b] = k;
    } else {
      mask_idx[b] = 0;
    }
    assert$9(b == gfc.npart_l - 1);
  }
  var fircoef = [
    -865163e-23 * 2,
    -851586e-8 * 2,
    -674764e-23 * 2,
    0.0209036 * 2,
    -336639e-22 * 2,
    -0.0438162 * 2,
    -154175e-22 * 2,
    0.0931738 * 2,
    -552212e-22 * 2,
    -0.313819 * 2
  ];
  this.L3psycho_anal_ns = function(gfp, buffer, bufPos, gr_out, masking_ratio, masking_MS_ratio, percep_entropy, percep_MS_entropy, energy, blocktype_d) {
    var gfc = gfp.internal_flags;
    var wsamp_L = new_float_n$3([2, Encoder$b.BLKSIZE]);
    var wsamp_S = new_float_n$3([2, 3, Encoder$b.BLKSIZE_s]);
    var eb_l = new_float$a(Encoder$b.CBANDS + 1);
    var eb_s = new_float$a(Encoder$b.CBANDS + 1);
    var thr = new_float$a(Encoder$b.CBANDS + 2);
    var blocktype = new_int$b(2), uselongblock = new_int$b(2);
    var numchn, chn;
    var b, i, j, k;
    var sb, sblock;
    var ns_hpfsmpl = new_float_n$3([2, 576]);
    var pcfact;
    var mask_idx_l = new_int$b(Encoder$b.CBANDS + 2), mask_idx_s = new_int$b(Encoder$b.CBANDS + 2);
    Arrays$5.fill(mask_idx_s, 0);
    numchn = gfc.channels_out;
    if (gfp.mode == MPEGMode.JOINT_STEREO)
      numchn = 4;
    if (gfp.VBR == VbrMode$5.vbr_off)
      pcfact = gfc.ResvMax == 0 ? 0 : gfc.ResvSize / gfc.ResvMax * 0.5;
    else if (gfp.VBR == VbrMode$5.vbr_rh || gfp.VBR == VbrMode$5.vbr_mtrh || gfp.VBR == VbrMode$5.vbr_mt) {
      pcfact = 0.6;
    } else
      pcfact = 1;
    for (chn = 0; chn < gfc.channels_out; chn++) {
      var firbuf2 = buffer[chn];
      var firbufPos = bufPos + 576 - 350 - NSFIRLEN + 192;
      assert$9(fircoef.length == (NSFIRLEN - 1) / 2);
      for (i = 0; i < 576; i++) {
        var sum1, sum2;
        sum1 = firbuf2[firbufPos + i + 10];
        sum2 = 0;
        for (j = 0; j < (NSFIRLEN - 1) / 2 - 1; j += 2) {
          sum1 += fircoef[j] * (firbuf2[firbufPos + i + j] + firbuf2[firbufPos + i + NSFIRLEN - j]);
          sum2 += fircoef[j + 1] * (firbuf2[firbufPos + i + j + 1] + firbuf2[firbufPos + i + NSFIRLEN - j - 1]);
        }
        ns_hpfsmpl[chn][i] = sum1 + sum2;
      }
      masking_ratio[gr_out][chn].en.assign(gfc.en[chn]);
      masking_ratio[gr_out][chn].thm.assign(gfc.thm[chn]);
      if (numchn > 2) {
        masking_MS_ratio[gr_out][chn].en.assign(gfc.en[chn + 2]);
        masking_MS_ratio[gr_out][chn].thm.assign(gfc.thm[chn + 2]);
      }
    }
    for (chn = 0; chn < numchn; chn++) {
      var wsamp_l;
      var wsamp_s;
      var en_subshort = new_float$a(12);
      var en_short = [0, 0, 0, 0];
      var attack_intensity = new_float$a(12);
      var ns_uselongblock = 1;
      var attackThreshold;
      var max2 = new_float$a(Encoder$b.CBANDS), avg = new_float$a(Encoder$b.CBANDS);
      var ns_attacks = [0, 0, 0, 0];
      var fftenergy = new_float$a(Encoder$b.HBLKSIZE);
      var fftenergy_s = new_float_n$3([3, Encoder$b.HBLKSIZE_s]);
      assert$9(gfc.npart_s <= Encoder$b.CBANDS);
      assert$9(gfc.npart_l <= Encoder$b.CBANDS);
      for (i = 0; i < 3; i++) {
        en_subshort[i] = gfc.nsPsy.last_en_subshort[chn][i + 6];
        assert$9(gfc.nsPsy.last_en_subshort[chn][i + 4] > 0);
        attack_intensity[i] = en_subshort[i] / gfc.nsPsy.last_en_subshort[chn][i + 4];
        en_short[0] += en_subshort[i];
      }
      if (chn == 2) {
        for (i = 0; i < 576; i++) {
          var l, r;
          l = ns_hpfsmpl[0][i];
          r = ns_hpfsmpl[1][i];
          ns_hpfsmpl[0][i] = l + r;
          ns_hpfsmpl[1][i] = l - r;
        }
      }
      {
        var pf = ns_hpfsmpl[chn & 1];
        var pfPos = 0;
        for (i = 0; i < 9; i++) {
          var pfe = pfPos + 576 / 9;
          var p2 = 1;
          for (; pfPos < pfe; pfPos++)
            if (p2 < Math.abs(pf[pfPos]))
              p2 = Math.abs(pf[pfPos]);
          gfc.nsPsy.last_en_subshort[chn][i] = en_subshort[i + 3] = p2;
          en_short[1 + i / 3] += p2;
          if (p2 > en_subshort[i + 3 - 2]) {
            assert$9(en_subshort[i + 3 - 2] > 0);
            p2 = p2 / en_subshort[i + 3 - 2];
          } else if (en_subshort[i + 3 - 2] > p2 * 10) {
            assert$9(p2 > 0);
            p2 = en_subshort[i + 3 - 2] / (p2 * 10);
          } else
            p2 = 0;
          attack_intensity[i + 3] = p2;
        }
      }
      if (gfp.analysis) {
        var x = attack_intensity[0];
        for (i = 1; i < 12; i++)
          if (x < attack_intensity[i])
            x = attack_intensity[i];
        gfc.pinfo.ers[gr_out][chn] = gfc.pinfo.ers_save[chn];
        gfc.pinfo.ers_save[chn] = x;
      }
      attackThreshold = chn == 3 ? gfc.nsPsy.attackthre_s : gfc.nsPsy.attackthre;
      for (i = 0; i < 12; i++)
        if (0 == ns_attacks[i / 3] && attack_intensity[i] > attackThreshold)
          ns_attacks[i / 3] = i % 3 + 1;
      for (i = 1; i < 4; i++) {
        var ratio;
        if (en_short[i - 1] > en_short[i]) {
          assert$9(en_short[i] > 0);
          ratio = en_short[i - 1] / en_short[i];
        } else {
          assert$9(en_short[i - 1] > 0);
          ratio = en_short[i] / en_short[i - 1];
        }
        if (ratio < 1.7) {
          ns_attacks[i] = 0;
          if (i == 1)
            ns_attacks[0] = 0;
        }
      }
      if (ns_attacks[0] != 0 && gfc.nsPsy.lastAttacks[chn] != 0)
        ns_attacks[0] = 0;
      if (gfc.nsPsy.lastAttacks[chn] == 3 || ns_attacks[0] + ns_attacks[1] + ns_attacks[2] + ns_attacks[3] != 0) {
        ns_uselongblock = 0;
        if (ns_attacks[1] != 0 && ns_attacks[0] != 0)
          ns_attacks[1] = 0;
        if (ns_attacks[2] != 0 && ns_attacks[1] != 0)
          ns_attacks[2] = 0;
        if (ns_attacks[3] != 0 && ns_attacks[2] != 0)
          ns_attacks[3] = 0;
      }
      if (chn < 2) {
        uselongblock[chn] = ns_uselongblock;
      } else {
        if (ns_uselongblock == 0) {
          uselongblock[0] = uselongblock[1] = 0;
        }
      }
      energy[chn] = gfc.tot_ener[chn];
      wsamp_s = wsamp_S;
      wsamp_l = wsamp_L;
      compute_ffts(
        gfp,
        fftenergy,
        fftenergy_s,
        wsamp_l,
        chn & 1,
        wsamp_s,
        chn & 1,
        gr_out,
        chn,
        buffer,
        bufPos
      );
      calc_energy(gfc, fftenergy, eb_l, max2, avg);
      calc_mask_index_l(gfc, max2, avg, mask_idx_l);
      for (sblock = 0; sblock < 3; sblock++) {
        var enn, thmm;
        compute_masking_s(gfp, fftenergy_s, eb_s, thr, chn, sblock);
        convert_partition2scalefac_s(gfc, eb_s, thr, chn, sblock);
        for (sb = 0; sb < Encoder$b.SBMAX_s; sb++) {
          thmm = gfc.thm[chn].s[sb][sblock];
          thmm *= NS_PREECHO_ATT0;
          if (ns_attacks[sblock] >= 2 || ns_attacks[sblock + 1] == 1) {
            var idx = sblock != 0 ? sblock - 1 : 2;
            var p2 = NS_INTERP(
              gfc.thm[chn].s[sb][idx],
              thmm,
              NS_PREECHO_ATT1 * pcfact
            );
            thmm = Math.min(thmm, p2);
          }
          if (ns_attacks[sblock] == 1) {
            var idx = sblock != 0 ? sblock - 1 : 2;
            var p2 = NS_INTERP(
              gfc.thm[chn].s[sb][idx],
              thmm,
              NS_PREECHO_ATT2 * pcfact
            );
            thmm = Math.min(thmm, p2);
          } else if (sblock != 0 && ns_attacks[sblock - 1] == 3 || sblock == 0 && gfc.nsPsy.lastAttacks[chn] == 3) {
            var idx = sblock != 2 ? sblock + 1 : 0;
            var p2 = NS_INTERP(
              gfc.thm[chn].s[sb][idx],
              thmm,
              NS_PREECHO_ATT2 * pcfact
            );
            thmm = Math.min(thmm, p2);
          }
          enn = en_subshort[sblock * 3 + 3] + en_subshort[sblock * 3 + 4] + en_subshort[sblock * 3 + 5];
          if (en_subshort[sblock * 3 + 5] * 6 < enn) {
            thmm *= 0.5;
            if (en_subshort[sblock * 3 + 4] * 6 < enn)
              thmm *= 0.5;
          }
          gfc.thm[chn].s[sb][sblock] = thmm;
        }
      }
      gfc.nsPsy.lastAttacks[chn] = ns_attacks[2];
      k = 0;
      {
        for (b = 0; b < gfc.npart_l; b++) {
          var kk = gfc.s3ind[b][0];
          var eb2 = eb_l[kk] * tab[mask_idx_l[kk]];
          var ecb = gfc.s3_ll[k++] * eb2;
          while (++kk <= gfc.s3ind[b][1]) {
            eb2 = eb_l[kk] * tab[mask_idx_l[kk]];
            ecb = mask_add(
              ecb,
              gfc.s3_ll[k++] * eb2,
              kk,
              kk - b,
              gfc,
              0
            );
          }
          ecb *= 0.158489319246111;
          if (gfc.blocktype_old[chn & 1] == Encoder$b.SHORT_TYPE)
            thr[b] = ecb;
          else
            thr[b] = NS_INTERP(
              Math.min(ecb, Math.min(rpelev * gfc.nb_1[chn][b], rpelev2 * gfc.nb_2[chn][b])),
              ecb,
              pcfact
            );
          gfc.nb_2[chn][b] = gfc.nb_1[chn][b];
          gfc.nb_1[chn][b] = ecb;
        }
      }
      for (; b <= Encoder$b.CBANDS; ++b) {
        eb_l[b] = 0;
        thr[b] = 0;
      }
      convert_partition2scalefac_l(gfc, eb_l, thr, chn);
    }
    if (gfp.mode == MPEGMode.STEREO || gfp.mode == MPEGMode.JOINT_STEREO) {
      if (gfp.interChRatio > 0) {
        calc_interchannel_masking(gfp, gfp.interChRatio);
      }
    }
    if (gfp.mode == MPEGMode.JOINT_STEREO) {
      var msfix;
      msfix1(gfc);
      msfix = gfp.msfix;
      if (Math.abs(msfix) > 0)
        ns_msfix(gfc, msfix, gfp.ATHlower * gfc.ATH.adjust);
    }
    block_type_set(gfp, uselongblock, blocktype_d, blocktype);
    for (chn = 0; chn < numchn; chn++) {
      var ppe;
      var ppePos = 0;
      var type2;
      var mr;
      if (chn > 1) {
        ppe = percep_MS_entropy;
        ppePos = -2;
        type2 = Encoder$b.NORM_TYPE;
        if (blocktype_d[0] == Encoder$b.SHORT_TYPE || blocktype_d[1] == Encoder$b.SHORT_TYPE)
          type2 = Encoder$b.SHORT_TYPE;
        mr = masking_MS_ratio[gr_out][chn - 2];
      } else {
        ppe = percep_entropy;
        ppePos = 0;
        type2 = blocktype_d[chn];
        mr = masking_ratio[gr_out][chn];
      }
      if (type2 == Encoder$b.SHORT_TYPE)
        ppe[ppePos + chn] = pecalc_s(mr, gfc.masking_lower);
      else
        ppe[ppePos + chn] = pecalc_l(mr, gfc.masking_lower);
      if (gfp.analysis)
        gfc.pinfo.pe[gr_out][chn] = ppe[ppePos + chn];
    }
    return 0;
  };
  function vbrpsy_compute_fft_l(gfp, buffer, bufPos, chn, gr_out, fftenergy, wsamp_l, wsamp_lPos) {
    var gfc = gfp.internal_flags;
    if (chn < 2) {
      fft.fft_long(gfc, wsamp_l[wsamp_lPos], chn, buffer, bufPos);
    } else if (chn == 2) {
      for (var j = Encoder$b.BLKSIZE - 1; j >= 0; --j) {
        var l = wsamp_l[wsamp_lPos + 0][j];
        var r = wsamp_l[wsamp_lPos + 1][j];
        wsamp_l[wsamp_lPos + 0][j] = (l + r) * Util$2.SQRT2 * 0.5;
        wsamp_l[wsamp_lPos + 1][j] = (l - r) * Util$2.SQRT2 * 0.5;
      }
    }
    fftenergy[0] = NON_LINEAR_SCALE_ENERGY(wsamp_l[wsamp_lPos + 0][0]);
    fftenergy[0] *= fftenergy[0];
    for (var j = Encoder$b.BLKSIZE / 2 - 1; j >= 0; --j) {
      var re = wsamp_l[wsamp_lPos + 0][Encoder$b.BLKSIZE / 2 - j];
      var im = wsamp_l[wsamp_lPos + 0][Encoder$b.BLKSIZE / 2 + j];
      fftenergy[Encoder$b.BLKSIZE / 2 - j] = NON_LINEAR_SCALE_ENERGY((re * re + im * im) * 0.5);
    }
    {
      var totalenergy = 0;
      for (var j = 11; j < Encoder$b.HBLKSIZE; j++)
        totalenergy += fftenergy[j];
      gfc.tot_ener[chn] = totalenergy;
    }
    if (gfp.analysis) {
      for (var j = 0; j < Encoder$b.HBLKSIZE; j++) {
        gfc.pinfo.energy[gr_out][chn][j] = gfc.pinfo.energy_save[chn][j];
        gfc.pinfo.energy_save[chn][j] = fftenergy[j];
      }
      gfc.pinfo.pe[gr_out][chn] = gfc.pe[chn];
    }
  }
  function vbrpsy_compute_fft_s(gfp, buffer, bufPos, chn, sblock, fftenergy_s, wsamp_s, wsamp_sPos) {
    var gfc = gfp.internal_flags;
    if (sblock == 0 && chn < 2) {
      fft.fft_short(gfc, wsamp_s[wsamp_sPos], chn, buffer, bufPos);
    }
    if (chn == 2) {
      for (var j = Encoder$b.BLKSIZE_s - 1; j >= 0; --j) {
        var l = wsamp_s[wsamp_sPos + 0][sblock][j];
        var r = wsamp_s[wsamp_sPos + 1][sblock][j];
        wsamp_s[wsamp_sPos + 0][sblock][j] = (l + r) * Util$2.SQRT2 * 0.5;
        wsamp_s[wsamp_sPos + 1][sblock][j] = (l - r) * Util$2.SQRT2 * 0.5;
      }
    }
    fftenergy_s[sblock][0] = wsamp_s[wsamp_sPos + 0][sblock][0];
    fftenergy_s[sblock][0] *= fftenergy_s[sblock][0];
    for (var j = Encoder$b.BLKSIZE_s / 2 - 1; j >= 0; --j) {
      var re = wsamp_s[wsamp_sPos + 0][sblock][Encoder$b.BLKSIZE_s / 2 - j];
      var im = wsamp_s[wsamp_sPos + 0][sblock][Encoder$b.BLKSIZE_s / 2 + j];
      fftenergy_s[sblock][Encoder$b.BLKSIZE_s / 2 - j] = NON_LINEAR_SCALE_ENERGY((re * re + im * im) * 0.5);
    }
  }
  function vbrpsy_compute_loudness_approximation_l(gfp, gr_out, chn, fftenergy) {
    var gfc = gfp.internal_flags;
    if (gfp.athaa_loudapprox == 2 && chn < 2) {
      gfc.loudness_sq[gr_out][chn] = gfc.loudness_sq_save[chn];
      gfc.loudness_sq_save[chn] = psycho_loudness_approx(fftenergy, gfc);
    }
  }
  var fircoef_ = [
    -865163e-23 * 2,
    -851586e-8 * 2,
    -674764e-23 * 2,
    0.0209036 * 2,
    -336639e-22 * 2,
    -0.0438162 * 2,
    -154175e-22 * 2,
    0.0931738 * 2,
    -552212e-22 * 2,
    -0.313819 * 2
  ];
  function vbrpsy_attack_detection(gfp, buffer, bufPos, gr_out, masking_ratio, masking_MS_ratio, energy, sub_short_factor, ns_attacks, uselongblock) {
    var ns_hpfsmpl = new_float_n$3([2, 576]);
    var gfc = gfp.internal_flags;
    var n_chn_out = gfc.channels_out;
    var n_chn_psy = gfp.mode == MPEGMode.JOINT_STEREO ? 4 : n_chn_out;
    for (var chn = 0; chn < n_chn_out; chn++) {
      firbuf = buffer[chn];
      var firbufPos = bufPos + 576 - 350 - NSFIRLEN + 192;
      assert$9(fircoef_.length == (NSFIRLEN - 1) / 2);
      for (var i = 0; i < 576; i++) {
        var sum1, sum2;
        sum1 = firbuf[firbufPos + i + 10];
        sum2 = 0;
        for (var j = 0; j < (NSFIRLEN - 1) / 2 - 1; j += 2) {
          sum1 += fircoef_[j] * (firbuf[firbufPos + i + j] + firbuf[firbufPos + i + NSFIRLEN - j]);
          sum2 += fircoef_[j + 1] * (firbuf[firbufPos + i + j + 1] + firbuf[firbufPos + i + NSFIRLEN - j - 1]);
        }
        ns_hpfsmpl[chn][i] = sum1 + sum2;
      }
      masking_ratio[gr_out][chn].en.assign(gfc.en[chn]);
      masking_ratio[gr_out][chn].thm.assign(gfc.thm[chn]);
      if (n_chn_psy > 2) {
        masking_MS_ratio[gr_out][chn].en.assign(gfc.en[chn + 2]);
        masking_MS_ratio[gr_out][chn].thm.assign(gfc.thm[chn + 2]);
      }
    }
    for (var chn = 0; chn < n_chn_psy; chn++) {
      var attack_intensity = new_float$a(12);
      var en_subshort = new_float$a(12);
      var en_short = [0, 0, 0, 0];
      var pf = ns_hpfsmpl[chn & 1];
      var pfPos = 0;
      var attackThreshold = chn == 3 ? gfc.nsPsy.attackthre_s : gfc.nsPsy.attackthre;
      var ns_uselongblock = 1;
      if (chn == 2) {
        for (var i = 0, j = 576; j > 0; ++i, --j) {
          var l = ns_hpfsmpl[0][i];
          var r = ns_hpfsmpl[1][i];
          ns_hpfsmpl[0][i] = l + r;
          ns_hpfsmpl[1][i] = l - r;
        }
      }
      for (var i = 0; i < 3; i++) {
        en_subshort[i] = gfc.nsPsy.last_en_subshort[chn][i + 6];
        assert$9(gfc.nsPsy.last_en_subshort[chn][i + 4] > 0);
        attack_intensity[i] = en_subshort[i] / gfc.nsPsy.last_en_subshort[chn][i + 4];
        en_short[0] += en_subshort[i];
      }
      for (var i = 0; i < 9; i++) {
        var pfe = pfPos + 576 / 9;
        var p2 = 1;
        for (; pfPos < pfe; pfPos++)
          if (p2 < Math.abs(pf[pfPos]))
            p2 = Math.abs(pf[pfPos]);
        gfc.nsPsy.last_en_subshort[chn][i] = en_subshort[i + 3] = p2;
        en_short[1 + i / 3] += p2;
        if (p2 > en_subshort[i + 3 - 2]) {
          assert$9(en_subshort[i + 3 - 2] > 0);
          p2 = p2 / en_subshort[i + 3 - 2];
        } else if (en_subshort[i + 3 - 2] > p2 * 10) {
          assert$9(p2 > 0);
          p2 = en_subshort[i + 3 - 2] / (p2 * 10);
        } else {
          p2 = 0;
        }
        attack_intensity[i + 3] = p2;
      }
      for (var i = 0; i < 3; ++i) {
        var enn = en_subshort[i * 3 + 3] + en_subshort[i * 3 + 4] + en_subshort[i * 3 + 5];
        var factor = 1;
        if (en_subshort[i * 3 + 5] * 6 < enn) {
          factor *= 0.5;
          if (en_subshort[i * 3 + 4] * 6 < enn) {
            factor *= 0.5;
          }
        }
        sub_short_factor[chn][i] = factor;
      }
      if (gfp.analysis) {
        var x = attack_intensity[0];
        for (var i = 1; i < 12; i++) {
          if (x < attack_intensity[i]) {
            x = attack_intensity[i];
          }
        }
        gfc.pinfo.ers[gr_out][chn] = gfc.pinfo.ers_save[chn];
        gfc.pinfo.ers_save[chn] = x;
      }
      for (var i = 0; i < 12; i++) {
        if (0 == ns_attacks[chn][i / 3] && attack_intensity[i] > attackThreshold) {
          ns_attacks[chn][i / 3] = i % 3 + 1;
        }
      }
      for (var i = 1; i < 4; i++) {
        var u = en_short[i - 1];
        var v = en_short[i];
        var m = Math.max(u, v);
        if (m < 4e4) {
          if (u < 1.7 * v && v < 1.7 * u) {
            if (i == 1 && ns_attacks[chn][0] <= ns_attacks[chn][i]) {
              ns_attacks[chn][0] = 0;
            }
            ns_attacks[chn][i] = 0;
          }
        }
      }
      if (ns_attacks[chn][0] <= gfc.nsPsy.lastAttacks[chn]) {
        ns_attacks[chn][0] = 0;
      }
      if (gfc.nsPsy.lastAttacks[chn] == 3 || ns_attacks[chn][0] + ns_attacks[chn][1] + ns_attacks[chn][2] + ns_attacks[chn][3] != 0) {
        ns_uselongblock = 0;
        if (ns_attacks[chn][1] != 0 && ns_attacks[chn][0] != 0) {
          ns_attacks[chn][1] = 0;
        }
        if (ns_attacks[chn][2] != 0 && ns_attacks[chn][1] != 0) {
          ns_attacks[chn][2] = 0;
        }
        if (ns_attacks[chn][3] != 0 && ns_attacks[chn][2] != 0) {
          ns_attacks[chn][3] = 0;
        }
      }
      if (chn < 2) {
        uselongblock[chn] = ns_uselongblock;
      } else {
        if (ns_uselongblock == 0) {
          uselongblock[0] = uselongblock[1] = 0;
        }
      }
      energy[chn] = gfc.tot_ener[chn];
    }
  }
  function vbrpsy_skip_masking_s(gfc, chn, sblock) {
    if (sblock == 0) {
      for (var b = 0; b < gfc.npart_s; b++) {
        gfc.nb_s2[chn][b] = gfc.nb_s1[chn][b];
        gfc.nb_s1[chn][b] = 0;
      }
    }
  }
  function vbrpsy_skip_masking_l(gfc, chn) {
    for (var b = 0; b < gfc.npart_l; b++) {
      gfc.nb_2[chn][b] = gfc.nb_1[chn][b];
      gfc.nb_1[chn][b] = 0;
    }
  }
  function psyvbr_calc_mask_index_s(gfc, max2, avg, mask_idx) {
    var last_tab_entry = tab.length - 1;
    var b = 0;
    var a = avg[b] + avg[b + 1];
    assert$9(a >= 0);
    if (a > 0) {
      var m = max2[b];
      if (m < max2[b + 1])
        m = max2[b + 1];
      assert$9(gfc.numlines_s[b] + gfc.numlines_s[b + 1] - 1 > 0);
      a = 20 * (m * 2 - a) / (a * (gfc.numlines_s[b] + gfc.numlines_s[b + 1] - 1));
      var k = 0 | a;
      if (k > last_tab_entry)
        k = last_tab_entry;
      mask_idx[b] = k;
    } else {
      mask_idx[b] = 0;
    }
    for (b = 1; b < gfc.npart_s - 1; b++) {
      a = avg[b - 1] + avg[b] + avg[b + 1];
      assert$9(b + 1 < gfc.npart_s);
      assert$9(a >= 0);
      if (a > 0) {
        var m = max2[b - 1];
        if (m < max2[b])
          m = max2[b];
        if (m < max2[b + 1])
          m = max2[b + 1];
        assert$9(gfc.numlines_s[b - 1] + gfc.numlines_s[b] + gfc.numlines_s[b + 1] - 1 > 0);
        a = 20 * (m * 3 - a) / (a * (gfc.numlines_s[b - 1] + gfc.numlines_s[b] + gfc.numlines_s[b + 1] - 1));
        var k = 0 | a;
        if (k > last_tab_entry)
          k = last_tab_entry;
        mask_idx[b] = k;
      } else {
        mask_idx[b] = 0;
      }
    }
    assert$9(b > 0);
    assert$9(b == gfc.npart_s - 1);
    a = avg[b - 1] + avg[b];
    assert$9(a >= 0);
    if (a > 0) {
      var m = max2[b - 1];
      if (m < max2[b])
        m = max2[b];
      assert$9(gfc.numlines_s[b - 1] + gfc.numlines_s[b] - 1 > 0);
      a = 20 * (m * 2 - a) / (a * (gfc.numlines_s[b - 1] + gfc.numlines_s[b] - 1));
      var k = 0 | a;
      if (k > last_tab_entry)
        k = last_tab_entry;
      mask_idx[b] = k;
    } else {
      mask_idx[b] = 0;
    }
    assert$9(b == gfc.npart_s - 1);
  }
  function vbrpsy_compute_masking_s(gfp, fftenergy_s, eb, thr, chn, sblock) {
    var gfc = gfp.internal_flags;
    var max2 = new float[Encoder$b.CBANDS](), avg = new_float$a(Encoder$b.CBANDS);
    var i, j, b;
    var mask_idx_s = new int[Encoder$b.CBANDS]();
    for (b = j = 0; b < gfc.npart_s; ++b) {
      var ebb = 0, m = 0;
      var n = gfc.numlines_s[b];
      for (i = 0; i < n; ++i, ++j) {
        var el = fftenergy_s[sblock][j];
        ebb += el;
        if (m < el)
          m = el;
      }
      eb[b] = ebb;
      assert$9(ebb >= 0);
      max2[b] = m;
      assert$9(n > 0);
      avg[b] = ebb / n;
      assert$9(avg[b] >= 0);
    }
    assert$9(b == gfc.npart_s);
    assert$9(j == 129);
    for (; b < Encoder$b.CBANDS; ++b) {
      max2[b] = 0;
      avg[b] = 0;
    }
    psyvbr_calc_mask_index_s(gfc, max2, avg, mask_idx_s);
    for (j = b = 0; b < gfc.npart_s; b++) {
      var kk = gfc.s3ind_s[b][0];
      var last = gfc.s3ind_s[b][1];
      var dd, dd_n;
      var x, ecb, avg_mask;
      dd = mask_idx_s[kk];
      dd_n = 1;
      ecb = gfc.s3_ss[j] * eb[kk] * tab[mask_idx_s[kk]];
      ++j;
      ++kk;
      while (kk <= last) {
        dd += mask_idx_s[kk];
        dd_n += 1;
        x = gfc.s3_ss[j] * eb[kk] * tab[mask_idx_s[kk]];
        ecb = vbrpsy_mask_add(ecb, x, kk - b);
        ++j;
        ++kk;
      }
      dd = (1 + 2 * dd) / (2 * dd_n);
      avg_mask = tab[dd] * 0.5;
      ecb *= avg_mask;
      thr[b] = ecb;
      gfc.nb_s2[chn][b] = gfc.nb_s1[chn][b];
      gfc.nb_s1[chn][b] = ecb;
      {
        x = max2[b];
        x *= gfc.minval_s[b];
        x *= avg_mask;
        if (thr[b] > x) {
          thr[b] = x;
        }
      }
      if (gfc.masking_lower > 1) {
        thr[b] *= gfc.masking_lower;
      }
      if (thr[b] > eb[b]) {
        thr[b] = eb[b];
      }
      if (gfc.masking_lower < 1) {
        thr[b] *= gfc.masking_lower;
      }
      assert$9(thr[b] >= 0);
    }
    for (; b < Encoder$b.CBANDS; ++b) {
      eb[b] = 0;
      thr[b] = 0;
    }
  }
  function vbrpsy_compute_masking_l(gfc, fftenergy, eb_l, thr, chn) {
    var max2 = new_float$a(Encoder$b.CBANDS), avg = new_float$a(Encoder$b.CBANDS);
    var mask_idx_l = new_int$b(Encoder$b.CBANDS + 2);
    var b;
    calc_energy(gfc, fftenergy, eb_l, max2, avg);
    calc_mask_index_l(gfc, max2, avg, mask_idx_l);
    var k = 0;
    for (b = 0; b < gfc.npart_l; b++) {
      var x, ecb, avg_mask, t;
      var kk = gfc.s3ind[b][0];
      var last = gfc.s3ind[b][1];
      var dd = 0, dd_n = 0;
      dd = mask_idx_l[kk];
      dd_n += 1;
      ecb = gfc.s3_ll[k] * eb_l[kk] * tab[mask_idx_l[kk]];
      ++k;
      ++kk;
      while (kk <= last) {
        dd += mask_idx_l[kk];
        dd_n += 1;
        x = gfc.s3_ll[k] * eb_l[kk] * tab[mask_idx_l[kk]];
        t = vbrpsy_mask_add(ecb, x, kk - b);
        ecb = t;
        ++k;
        ++kk;
      }
      dd = (1 + 2 * dd) / (2 * dd_n);
      avg_mask = tab[dd] * 0.5;
      ecb *= avg_mask;
      if (gfc.blocktype_old[chn & 1] == Encoder$b.SHORT_TYPE) {
        var ecb_limit = rpelev * gfc.nb_1[chn][b];
        if (ecb_limit > 0) {
          thr[b] = Math.min(ecb, ecb_limit);
        } else {
          thr[b] = Math.min(ecb, eb_l[b] * NS_PREECHO_ATT2);
        }
      } else {
        var ecb_limit_2 = rpelev2 * gfc.nb_2[chn][b];
        var ecb_limit_1 = rpelev * gfc.nb_1[chn][b];
        var ecb_limit;
        if (ecb_limit_2 <= 0) {
          ecb_limit_2 = ecb;
        }
        if (ecb_limit_1 <= 0) {
          ecb_limit_1 = ecb;
        }
        if (gfc.blocktype_old[chn & 1] == Encoder$b.NORM_TYPE) {
          ecb_limit = Math.min(ecb_limit_1, ecb_limit_2);
        } else {
          ecb_limit = ecb_limit_1;
        }
        thr[b] = Math.min(ecb, ecb_limit);
      }
      gfc.nb_2[chn][b] = gfc.nb_1[chn][b];
      gfc.nb_1[chn][b] = ecb;
      {
        x = max2[b];
        x *= gfc.minval_l[b];
        x *= avg_mask;
        if (thr[b] > x) {
          thr[b] = x;
        }
      }
      if (gfc.masking_lower > 1) {
        thr[b] *= gfc.masking_lower;
      }
      if (thr[b] > eb_l[b]) {
        thr[b] = eb_l[b];
      }
      if (gfc.masking_lower < 1) {
        thr[b] *= gfc.masking_lower;
      }
      assert$9(thr[b] >= 0);
    }
    for (; b < Encoder$b.CBANDS; ++b) {
      eb_l[b] = 0;
      thr[b] = 0;
    }
  }
  function vbrpsy_compute_block_type(gfp, uselongblock) {
    var gfc = gfp.internal_flags;
    if (gfp.short_blocks == ShortBlock$2.short_block_coupled && !(uselongblock[0] != 0 && uselongblock[1] != 0))
      uselongblock[0] = uselongblock[1] = 0;
    for (var chn = 0; chn < gfc.channels_out; chn++) {
      if (gfp.short_blocks == ShortBlock$2.short_block_dispensed) {
        uselongblock[chn] = 1;
      }
      if (gfp.short_blocks == ShortBlock$2.short_block_forced) {
        uselongblock[chn] = 0;
      }
    }
  }
  function vbrpsy_apply_block_type(gfp, uselongblock, blocktype_d) {
    var gfc = gfp.internal_flags;
    for (var chn = 0; chn < gfc.channels_out; chn++) {
      var blocktype = Encoder$b.NORM_TYPE;
      if (uselongblock[chn] != 0) {
        assert$9(gfc.blocktype_old[chn] != Encoder$b.START_TYPE);
        if (gfc.blocktype_old[chn] == Encoder$b.SHORT_TYPE)
          blocktype = Encoder$b.STOP_TYPE;
      } else {
        blocktype = Encoder$b.SHORT_TYPE;
        if (gfc.blocktype_old[chn] == Encoder$b.NORM_TYPE) {
          gfc.blocktype_old[chn] = Encoder$b.START_TYPE;
        }
        if (gfc.blocktype_old[chn] == Encoder$b.STOP_TYPE)
          gfc.blocktype_old[chn] = Encoder$b.SHORT_TYPE;
      }
      blocktype_d[chn] = gfc.blocktype_old[chn];
      gfc.blocktype_old[chn] = blocktype;
    }
  }
  function vbrpsy_compute_MS_thresholds(eb, thr, cb_mld, ath_cb, athadjust, msfix, n) {
    var msfix2 = msfix * 2;
    var athlower = msfix > 0 ? Math.pow(10, athadjust) : 1;
    var rside, rmid;
    for (var b = 0; b < n; ++b) {
      var ebM = eb[2][b];
      var ebS = eb[3][b];
      var thmL = thr[0][b];
      var thmR = thr[1][b];
      var thmM = thr[2][b];
      var thmS = thr[3][b];
      if (thmL <= 1.58 * thmR && thmR <= 1.58 * thmL) {
        var mld_m = cb_mld[b] * ebS;
        var mld_s = cb_mld[b] * ebM;
        rmid = Math.max(thmM, Math.min(thmS, mld_m));
        rside = Math.max(thmS, Math.min(thmM, mld_s));
      } else {
        rmid = thmM;
        rside = thmS;
      }
      if (msfix > 0) {
        var thmLR, thmMS;
        var ath = ath_cb[b] * athlower;
        thmLR = Math.min(Math.max(thmL, ath), Math.max(thmR, ath));
        thmM = Math.max(rmid, ath);
        thmS = Math.max(rside, ath);
        thmMS = thmM + thmS;
        if (thmMS > 0 && thmLR * msfix2 < thmMS) {
          var f = thmLR * msfix2 / thmMS;
          thmM *= f;
          thmS *= f;
          assert$9(thmMS > 0);
        }
        rmid = Math.min(thmM, rmid);
        rside = Math.min(thmS, rside);
      }
      if (rmid > ebM) {
        rmid = ebM;
      }
      if (rside > ebS) {
        rside = ebS;
      }
      thr[2][b] = rmid;
      thr[3][b] = rside;
    }
  }
  this.L3psycho_anal_vbr = function(gfp, buffer, bufPos, gr_out, masking_ratio, masking_MS_ratio, percep_entropy, percep_MS_entropy, energy, blocktype_d) {
    var gfc = gfp.internal_flags;
    var wsamp_l;
    var wsamp_s;
    var fftenergy = new_float$a(Encoder$b.HBLKSIZE);
    var fftenergy_s = new_float_n$3([3, Encoder$b.HBLKSIZE_s]);
    var wsamp_L = new_float_n$3([2, Encoder$b.BLKSIZE]);
    var wsamp_S = new_float_n$3([2, 3, Encoder$b.BLKSIZE_s]);
    var eb = new_float_n$3([4, Encoder$b.CBANDS]), thr = new_float_n$3([4, Encoder$b.CBANDS]);
    var sub_short_factor = new_float_n$3([4, 3]);
    var pcfact = 0.6;
    var ns_attacks = [
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0]
    ];
    var uselongblock = new_int$b(2);
    var n_chn_psy = gfp.mode == MPEGMode.JOINT_STEREO ? 4 : gfc.channels_out;
    vbrpsy_attack_detection(
      gfp,
      buffer,
      bufPos,
      gr_out,
      masking_ratio,
      masking_MS_ratio,
      energy,
      sub_short_factor,
      ns_attacks,
      uselongblock
    );
    vbrpsy_compute_block_type(gfp, uselongblock);
    {
      for (var chn = 0; chn < n_chn_psy; chn++) {
        var ch01 = chn & 1;
        wsamp_l = wsamp_L;
        vbrpsy_compute_fft_l(
          gfp,
          buffer,
          bufPos,
          chn,
          gr_out,
          fftenergy,
          wsamp_l,
          ch01
        );
        vbrpsy_compute_loudness_approximation_l(
          gfp,
          gr_out,
          chn,
          fftenergy
        );
        if (uselongblock[ch01] != 0) {
          vbrpsy_compute_masking_l(
            gfc,
            fftenergy,
            eb[chn],
            thr[chn],
            chn
          );
        } else {
          vbrpsy_skip_masking_l(gfc, chn);
        }
      }
      if (uselongblock[0] + uselongblock[1] == 2) {
        if (gfp.mode == MPEGMode.JOINT_STEREO) {
          vbrpsy_compute_MS_thresholds(
            eb,
            thr,
            gfc.mld_cb_l,
            gfc.ATH.cb_l,
            gfp.ATHlower * gfc.ATH.adjust,
            gfp.msfix,
            gfc.npart_l
          );
        }
      }
      for (var chn = 0; chn < n_chn_psy; chn++) {
        var ch01 = chn & 1;
        if (uselongblock[ch01] != 0) {
          convert_partition2scalefac_l(gfc, eb[chn], thr[chn], chn);
        }
      }
    }
    {
      for (var sblock = 0; sblock < 3; sblock++) {
        for (var chn = 0; chn < n_chn_psy; ++chn) {
          var ch01 = chn & 1;
          if (uselongblock[ch01] != 0) {
            vbrpsy_skip_masking_s(gfc, chn, sblock);
          } else {
            wsamp_s = wsamp_S;
            vbrpsy_compute_fft_s(
              gfp,
              buffer,
              bufPos,
              chn,
              sblock,
              fftenergy_s,
              wsamp_s,
              ch01
            );
            vbrpsy_compute_masking_s(
              gfp,
              fftenergy_s,
              eb[chn],
              thr[chn],
              chn,
              sblock
            );
          }
        }
        if (uselongblock[0] + uselongblock[1] == 0) {
          if (gfp.mode == MPEGMode.JOINT_STEREO) {
            vbrpsy_compute_MS_thresholds(
              eb,
              thr,
              gfc.mld_cb_s,
              gfc.ATH.cb_s,
              gfp.ATHlower * gfc.ATH.adjust,
              gfp.msfix,
              gfc.npart_s
            );
          }
        }
        for (var chn = 0; chn < n_chn_psy; ++chn) {
          var ch01 = chn & 1;
          if (0 == uselongblock[ch01]) {
            convert_partition2scalefac_s(
              gfc,
              eb[chn],
              thr[chn],
              chn,
              sblock
            );
          }
        }
      }
      for (var chn = 0; chn < n_chn_psy; chn++) {
        var ch01 = chn & 1;
        if (uselongblock[ch01] != 0) {
          continue;
        }
        for (var sb = 0; sb < Encoder$b.SBMAX_s; sb++) {
          var new_thmm = new_float$a(3);
          for (var sblock = 0; sblock < 3; sblock++) {
            var thmm = gfc.thm[chn].s[sb][sblock];
            thmm *= NS_PREECHO_ATT0;
            if (ns_attacks[chn][sblock] >= 2 || ns_attacks[chn][sblock + 1] == 1) {
              var idx = sblock != 0 ? sblock - 1 : 2;
              var p2 = NS_INTERP(
                gfc.thm[chn].s[sb][idx],
                thmm,
                NS_PREECHO_ATT1 * pcfact
              );
              thmm = Math.min(thmm, p2);
            } else if (ns_attacks[chn][sblock] == 1) {
              var idx = sblock != 0 ? sblock - 1 : 2;
              var p2 = NS_INTERP(
                gfc.thm[chn].s[sb][idx],
                thmm,
                NS_PREECHO_ATT2 * pcfact
              );
              thmm = Math.min(thmm, p2);
            } else if (sblock != 0 && ns_attacks[chn][sblock - 1] == 3 || sblock == 0 && gfc.nsPsy.lastAttacks[chn] == 3) {
              var idx = sblock != 2 ? sblock + 1 : 0;
              var p2 = NS_INTERP(
                gfc.thm[chn].s[sb][idx],
                thmm,
                NS_PREECHO_ATT2 * pcfact
              );
              thmm = Math.min(thmm, p2);
            }
            thmm *= sub_short_factor[chn][sblock];
            new_thmm[sblock] = thmm;
          }
          for (var sblock = 0; sblock < 3; sblock++) {
            gfc.thm[chn].s[sb][sblock] = new_thmm[sblock];
          }
        }
      }
    }
    for (var chn = 0; chn < n_chn_psy; chn++) {
      gfc.nsPsy.lastAttacks[chn] = ns_attacks[chn][2];
    }
    vbrpsy_apply_block_type(gfp, uselongblock, blocktype_d);
    for (var chn = 0; chn < n_chn_psy; chn++) {
      var ppe;
      var ppePos;
      var type2;
      var mr;
      if (chn > 1) {
        ppe = percep_MS_entropy;
        ppePos = -2;
        type2 = Encoder$b.NORM_TYPE;
        if (blocktype_d[0] == Encoder$b.SHORT_TYPE || blocktype_d[1] == Encoder$b.SHORT_TYPE)
          type2 = Encoder$b.SHORT_TYPE;
        mr = masking_MS_ratio[gr_out][chn - 2];
      } else {
        ppe = percep_entropy;
        ppePos = 0;
        type2 = blocktype_d[chn];
        mr = masking_ratio[gr_out][chn];
      }
      if (type2 == Encoder$b.SHORT_TYPE) {
        ppe[ppePos + chn] = pecalc_s(mr, gfc.masking_lower);
      } else {
        ppe[ppePos + chn] = pecalc_l(mr, gfc.masking_lower);
      }
      if (gfp.analysis) {
        gfc.pinfo.pe[gr_out][chn] = ppe[ppePos + chn];
      }
    }
    return 0;
  };
  function s3_func_x(bark, hf_slope) {
    var tempx = bark, tempy;
    if (tempx >= 0) {
      tempy = -tempx * 27;
    } else {
      tempy = tempx * hf_slope;
    }
    if (tempy <= -72) {
      return 0;
    }
    return Math.exp(tempy * LN_TO_LOG10);
  }
  function norm_s3_func_x(hf_slope) {
    var lim_a = 0, lim_b = 0;
    {
      var x = 0, l, h2;
      for (x = 0; s3_func_x(x, hf_slope) > 1e-20; x -= 1)
        ;
      l = x;
      h2 = 0;
      while (Math.abs(h2 - l) > 1e-12) {
        x = (h2 + l) / 2;
        if (s3_func_x(x, hf_slope) > 0) {
          h2 = x;
        } else {
          l = x;
        }
      }
      lim_a = l;
    }
    {
      var x = 0, l, h2;
      for (x = 0; s3_func_x(x, hf_slope) > 1e-20; x += 1)
        ;
      l = 0;
      h2 = x;
      while (Math.abs(h2 - l) > 1e-12) {
        x = (h2 + l) / 2;
        if (s3_func_x(x, hf_slope) > 0) {
          l = x;
        } else {
          h2 = x;
        }
      }
      lim_b = h2;
    }
    {
      var sum = 0;
      var m = 1e3;
      var i;
      for (i = 0; i <= m; ++i) {
        var x = lim_a + i * (lim_b - lim_a) / m;
        var y = s3_func_x(x, hf_slope);
        sum += y;
      }
      {
        var norm = (m + 1) / (sum * (lim_b - lim_a));
        return norm;
      }
    }
  }
  function s3_func(bark) {
    var tempx, x, tempy, temp;
    tempx = bark;
    if (tempx >= 0)
      tempx *= 3;
    else
      tempx *= 1.5;
    if (tempx >= 0.5 && tempx <= 2.5) {
      temp = tempx - 0.5;
      x = 8 * (temp * temp - 2 * temp);
    } else
      x = 0;
    tempx += 0.474;
    tempy = 15.811389 + 7.5 * tempx - 17.5 * Math.sqrt(1 + tempx * tempx);
    if (tempy <= -60)
      return 0;
    tempx = Math.exp((x + tempy) * LN_TO_LOG10);
    tempx /= 0.6609193;
    return tempx;
  }
  function freq2bark(freq) {
    if (freq < 0)
      freq = 0;
    freq = freq * 1e-3;
    return 13 * Math.atan(0.76 * freq) + 3.5 * Math.atan(freq * freq / (7.5 * 7.5));
  }
  function init_numline(numlines, bo, bm, bval, bval_width, mld, bo_w, sfreq, blksize, scalepos, deltafreq, sbmax) {
    var b_frq = new_float$a(Encoder$b.CBANDS + 1);
    var sample_freq_frac = sfreq / (sbmax > 15 ? 2 * 576 : 2 * 192);
    var partition = new_int$b(Encoder$b.HBLKSIZE);
    var i;
    sfreq /= blksize;
    var j = 0;
    var ni = 0;
    for (i = 0; i < Encoder$b.CBANDS; i++) {
      var bark1;
      var j2;
      bark1 = freq2bark(sfreq * j);
      b_frq[i] = sfreq * j;
      for (j2 = j; freq2bark(sfreq * j2) - bark1 < DELBARK && j2 <= blksize / 2; j2++)
        ;
      numlines[i] = j2 - j;
      ni = i + 1;
      while (j < j2) {
        assert$9(j < Encoder$b.HBLKSIZE);
        partition[j++] = i;
      }
      if (j > blksize / 2) {
        j = blksize / 2;
        ++i;
        break;
      }
    }
    assert$9(i < Encoder$b.CBANDS);
    b_frq[i] = sfreq * j;
    for (var sfb = 0; sfb < sbmax; sfb++) {
      var i1, i2, start, end;
      var arg;
      start = scalepos[sfb];
      end = scalepos[sfb + 1];
      i1 = 0 | Math.floor(0.5 + deltafreq * (start - 0.5));
      if (i1 < 0)
        i1 = 0;
      i2 = 0 | Math.floor(0.5 + deltafreq * (end - 0.5));
      if (i2 > blksize / 2)
        i2 = blksize / 2;
      bm[sfb] = (partition[i1] + partition[i2]) / 2;
      bo[sfb] = partition[i2];
      var f_tmp = sample_freq_frac * end;
      bo_w[sfb] = (f_tmp - b_frq[bo[sfb]]) / (b_frq[bo[sfb] + 1] - b_frq[bo[sfb]]);
      if (bo_w[sfb] < 0) {
        bo_w[sfb] = 0;
      } else {
        if (bo_w[sfb] > 1) {
          bo_w[sfb] = 1;
        }
      }
      arg = freq2bark(sfreq * scalepos[sfb] * deltafreq);
      arg = Math.min(arg, 15.5) / 15.5;
      mld[sfb] = Math.pow(
        10,
        1.25 * (1 - Math.cos(Math.PI * arg)) - 2.5
      );
    }
    j = 0;
    for (var k = 0; k < ni; k++) {
      var w = numlines[k];
      var bark1, bark2;
      bark1 = freq2bark(sfreq * j);
      bark2 = freq2bark(sfreq * (j + w - 1));
      bval[k] = 0.5 * (bark1 + bark2);
      bark1 = freq2bark(sfreq * (j - 0.5));
      bark2 = freq2bark(sfreq * (j + w - 0.5));
      bval_width[k] = bark2 - bark1;
      j += w;
    }
    return ni;
  }
  function init_s3_values(s3ind, npart, bval, bval_width, norm, use_old_s3) {
    var s3 = new_float_n$3([Encoder$b.CBANDS, Encoder$b.CBANDS]);
    var j;
    var numberOfNoneZero = 0;
    if (use_old_s3) {
      for (var i = 0; i < npart; i++) {
        for (j = 0; j < npart; j++) {
          var v = s3_func(bval[i] - bval[j]) * bval_width[j];
          s3[i][j] = v * norm[i];
        }
      }
    } else {
      for (j = 0; j < npart; j++) {
        var hf_slope = 15 + Math.min(21 / bval[j], 12);
        var s3_x_norm = norm_s3_func_x(hf_slope);
        for (var i = 0; i < npart; i++) {
          var v = s3_x_norm * s3_func_x(bval[i] - bval[j], hf_slope) * bval_width[j];
          s3[i][j] = v * norm[i];
        }
      }
    }
    for (var i = 0; i < npart; i++) {
      for (j = 0; j < npart; j++) {
        if (s3[i][j] > 0)
          break;
      }
      s3ind[i][0] = j;
      for (j = npart - 1; j > 0; j--) {
        if (s3[i][j] > 0)
          break;
      }
      s3ind[i][1] = j;
      numberOfNoneZero += s3ind[i][1] - s3ind[i][0] + 1;
    }
    var p2 = new_float$a(numberOfNoneZero);
    var k = 0;
    for (var i = 0; i < npart; i++)
      for (j = s3ind[i][0]; j <= s3ind[i][1]; j++)
        p2[k++] = s3[i][j];
    return p2;
  }
  function stereo_demask(f) {
    var arg = freq2bark(f);
    arg = Math.min(arg, 15.5) / 15.5;
    return Math.pow(
      10,
      1.25 * (1 - Math.cos(Math.PI * arg)) - 2.5
    );
  }
  this.psymodel_init = function(gfp) {
    var gfc = gfp.internal_flags;
    var i;
    var useOldS3 = true;
    var bvl_a = 13, bvl_b = 24;
    var snr_l_a = 0, snr_l_b = 0;
    var snr_s_a = -8.25, snr_s_b = -4.5;
    var bval = new_float$a(Encoder$b.CBANDS);
    var bval_width = new_float$a(Encoder$b.CBANDS);
    var norm = new_float$a(Encoder$b.CBANDS);
    var sfreq = gfp.out_samplerate;
    switch (gfp.experimentalZ) {
      default:
      case 0:
        useOldS3 = true;
        break;
      case 1:
        useOldS3 = gfp.VBR == VbrMode$5.vbr_mtrh || gfp.VBR == VbrMode$5.vbr_mt ? false : true;
        break;
      case 2:
        useOldS3 = false;
        break;
      case 3:
        bvl_a = 8;
        snr_l_a = -1.75;
        snr_l_b = -0.0125;
        snr_s_a = -8.25;
        snr_s_b = -2.25;
        break;
    }
    gfc.ms_ener_ratio_old = 0.25;
    gfc.blocktype_old[0] = gfc.blocktype_old[1] = Encoder$b.NORM_TYPE;
    for (i = 0; i < 4; ++i) {
      for (var j = 0; j < Encoder$b.CBANDS; ++j) {
        gfc.nb_1[i][j] = 1e20;
        gfc.nb_2[i][j] = 1e20;
        gfc.nb_s1[i][j] = gfc.nb_s2[i][j] = 1;
      }
      for (var sb = 0; sb < Encoder$b.SBMAX_l; sb++) {
        gfc.en[i].l[sb] = 1e20;
        gfc.thm[i].l[sb] = 1e20;
      }
      for (var j = 0; j < 3; ++j) {
        for (var sb = 0; sb < Encoder$b.SBMAX_s; sb++) {
          gfc.en[i].s[sb][j] = 1e20;
          gfc.thm[i].s[sb][j] = 1e20;
        }
        gfc.nsPsy.lastAttacks[i] = 0;
      }
      for (var j = 0; j < 9; j++)
        gfc.nsPsy.last_en_subshort[i][j] = 10;
    }
    gfc.loudness_sq_save[0] = gfc.loudness_sq_save[1] = 0;
    gfc.npart_l = init_numline(
      gfc.numlines_l,
      gfc.bo_l,
      gfc.bm_l,
      bval,
      bval_width,
      gfc.mld_l,
      gfc.PSY.bo_l_weight,
      sfreq,
      Encoder$b.BLKSIZE,
      gfc.scalefac_band.l,
      Encoder$b.BLKSIZE / (2 * 576),
      Encoder$b.SBMAX_l
    );
    assert$9(gfc.npart_l < Encoder$b.CBANDS);
    for (i = 0; i < gfc.npart_l; i++) {
      var snr = snr_l_a;
      if (bval[i] >= bvl_a) {
        snr = snr_l_b * (bval[i] - bvl_a) / (bvl_b - bvl_a) + snr_l_a * (bvl_b - bval[i]) / (bvl_b - bvl_a);
      }
      norm[i] = Math.pow(10, snr / 10);
      if (gfc.numlines_l[i] > 0) {
        gfc.rnumlines_l[i] = 1 / gfc.numlines_l[i];
      } else {
        gfc.rnumlines_l[i] = 0;
      }
    }
    gfc.s3_ll = init_s3_values(
      gfc.s3ind,
      gfc.npart_l,
      bval,
      bval_width,
      norm,
      useOldS3
    );
    var j = 0;
    for (i = 0; i < gfc.npart_l; i++) {
      var x;
      x = Float$1.MAX_VALUE;
      for (var k = 0; k < gfc.numlines_l[i]; k++, j++) {
        var freq = sfreq * j / (1e3 * Encoder$b.BLKSIZE);
        var level;
        level = this.ATHformula(freq * 1e3, gfp) - 20;
        level = Math.pow(10, 0.1 * level);
        level *= gfc.numlines_l[i];
        if (x > level)
          x = level;
      }
      gfc.ATH.cb_l[i] = x;
      x = -20 + bval[i] * 20 / 10;
      if (x > 6) {
        x = 100;
      }
      if (x < -15) {
        x = -15;
      }
      x -= 8;
      gfc.minval_l[i] = Math.pow(10, x / 10) * gfc.numlines_l[i];
    }
    gfc.npart_s = init_numline(
      gfc.numlines_s,
      gfc.bo_s,
      gfc.bm_s,
      bval,
      bval_width,
      gfc.mld_s,
      gfc.PSY.bo_s_weight,
      sfreq,
      Encoder$b.BLKSIZE_s,
      gfc.scalefac_band.s,
      Encoder$b.BLKSIZE_s / (2 * 192),
      Encoder$b.SBMAX_s
    );
    assert$9(gfc.npart_s < Encoder$b.CBANDS);
    j = 0;
    for (i = 0; i < gfc.npart_s; i++) {
      var x;
      var snr = snr_s_a;
      if (bval[i] >= bvl_a) {
        snr = snr_s_b * (bval[i] - bvl_a) / (bvl_b - bvl_a) + snr_s_a * (bvl_b - bval[i]) / (bvl_b - bvl_a);
      }
      norm[i] = Math.pow(10, snr / 10);
      x = Float$1.MAX_VALUE;
      for (var k = 0; k < gfc.numlines_s[i]; k++, j++) {
        var freq = sfreq * j / (1e3 * Encoder$b.BLKSIZE_s);
        var level;
        level = this.ATHformula(freq * 1e3, gfp) - 20;
        level = Math.pow(10, 0.1 * level);
        level *= gfc.numlines_s[i];
        if (x > level)
          x = level;
      }
      gfc.ATH.cb_s[i] = x;
      x = -7 + bval[i] * 7 / 12;
      if (bval[i] > 12) {
        x *= 1 + Math.log(1 + x) * 3.1;
      }
      if (bval[i] < 12) {
        x *= 1 + Math.log(1 - x) * 2.3;
      }
      if (x < -15) {
        x = -15;
      }
      x -= 8;
      gfc.minval_s[i] = Math.pow(10, x / 10) * gfc.numlines_s[i];
    }
    gfc.s3_ss = init_s3_values(
      gfc.s3ind_s,
      gfc.npart_s,
      bval,
      bval_width,
      norm,
      useOldS3
    );
    init_mask_add_max_values();
    fft.init_fft(gfc);
    gfc.decay = Math.exp(-1 * LOG10 / (temporalmask_sustain_sec * sfreq / 192));
    {
      var msfix;
      msfix = NS_MSFIX;
      if ((gfp.exp_nspsytune & 2) != 0)
        msfix = 1;
      if (Math.abs(gfp.msfix) > 0)
        msfix = gfp.msfix;
      gfp.msfix = msfix;
      for (var b = 0; b < gfc.npart_l; b++)
        if (gfc.s3ind[b][1] > gfc.npart_l - 1)
          gfc.s3ind[b][1] = gfc.npart_l - 1;
    }
    var frame_duration = 576 * gfc.mode_gr / sfreq;
    gfc.ATH.decay = Math.pow(10, -12 / 10 * frame_duration);
    gfc.ATH.adjust = 0.01;
    gfc.ATH.adjustLimit = 1;
    assert$9(gfc.bo_l[Encoder$b.SBMAX_l - 1] <= gfc.npart_l);
    assert$9(gfc.bo_s[Encoder$b.SBMAX_s - 1] <= gfc.npart_s);
    if (gfp.ATHtype != -1) {
      var freq;
      var freq_inc = gfp.out_samplerate / Encoder$b.BLKSIZE;
      var eql_balance = 0;
      freq = 0;
      for (i = 0; i < Encoder$b.BLKSIZE / 2; ++i) {
        freq += freq_inc;
        gfc.ATH.eql_w[i] = 1 / Math.pow(10, this.ATHformula(freq, gfp) / 10);
        eql_balance += gfc.ATH.eql_w[i];
      }
      eql_balance = 1 / eql_balance;
      for (i = Encoder$b.BLKSIZE / 2; --i >= 0; ) {
        gfc.ATH.eql_w[i] *= eql_balance;
      }
    }
    {
      for (var b = j = 0; b < gfc.npart_s; ++b) {
        for (i = 0; i < gfc.numlines_s[b]; ++i) {
          ++j;
        }
      }
      assert$9(j == 129);
      for (var b = j = 0; b < gfc.npart_l; ++b) {
        for (i = 0; i < gfc.numlines_l[b]; ++i) {
          ++j;
        }
      }
      assert$9(j == 513);
    }
    j = 0;
    for (i = 0; i < gfc.npart_l; i++) {
      var freq = sfreq * (j + gfc.numlines_l[i] / 2) / (1 * Encoder$b.BLKSIZE);
      gfc.mld_cb_l[i] = stereo_demask(freq);
      j += gfc.numlines_l[i];
    }
    for (; i < Encoder$b.CBANDS; ++i) {
      gfc.mld_cb_l[i] = 1;
    }
    j = 0;
    for (i = 0; i < gfc.npart_s; i++) {
      var freq = sfreq * (j + gfc.numlines_s[i] / 2) / (1 * Encoder$b.BLKSIZE_s);
      gfc.mld_cb_s[i] = stereo_demask(freq);
      j += gfc.numlines_s[i];
    }
    for (; i < Encoder$b.CBANDS; ++i) {
      gfc.mld_cb_s[i] = 1;
    }
    return 0;
  };
  function ATHformula_GB(f, value) {
    if (f < -0.3)
      f = 3410;
    f /= 1e3;
    f = Math.max(0.1, f);
    var ath = 3.64 * Math.pow(f, -0.8) - 6.8 * Math.exp(-0.6 * Math.pow(f - 3.4, 2)) + 6 * Math.exp(-0.15 * Math.pow(f - 8.7, 2)) + (0.6 + 0.04 * value) * 1e-3 * Math.pow(f, 4);
    return ath;
  }
  this.ATHformula = function(f, gfp) {
    var ath;
    switch (gfp.ATHtype) {
      case 0:
        ath = ATHformula_GB(f, 9);
        break;
      case 1:
        ath = ATHformula_GB(f, -1);
        break;
      case 2:
        ath = ATHformula_GB(f, 0);
        break;
      case 3:
        ath = ATHformula_GB(f, 1) + 6;
        break;
      case 4:
        ath = ATHformula_GB(f, gfp.ATHcurve);
        break;
      default:
        ath = ATHformula_GB(f, 0);
        break;
    }
    return ath;
  };
}
var PsyModel_1 = PsyModel$1;
function MPEGMode$3(ordinal) {
  var _ordinal = ordinal;
  this.ordinal = function() {
    return _ordinal;
  };
}
MPEGMode$3.STEREO = new MPEGMode$3(0);
MPEGMode$3.JOINT_STEREO = new MPEGMode$3(1);
MPEGMode$3.DUAL_CHANNEL = new MPEGMode$3(2);
MPEGMode$3.MONO = new MPEGMode$3(3);
MPEGMode$3.NOT_SET = new MPEGMode$3(4);
var MPEGMode_1 = MPEGMode$3;
var MPEGMode$2 = MPEGMode_1;
function LameGlobalFlags$1() {
  this.class_id = 0;
  this.num_samples = 0;
  this.num_channels = 0;
  this.in_samplerate = 0;
  this.out_samplerate = 0;
  this.scale = 0;
  this.scale_left = 0;
  this.scale_right = 0;
  this.analysis = false;
  this.bWriteVbrTag = false;
  this.decode_only = false;
  this.quality = 0;
  this.mode = MPEGMode$2.STEREO;
  this.force_ms = false;
  this.free_format = false;
  this.findReplayGain = false;
  this.decode_on_the_fly = false;
  this.write_id3tag_automatic = false;
  this.brate = 0;
  this.compression_ratio = 0;
  this.copyright = 0;
  this.original = 0;
  this.extension = 0;
  this.emphasis = 0;
  this.error_protection = 0;
  this.strict_ISO = false;
  this.disable_reservoir = false;
  this.quant_comp = 0;
  this.quant_comp_short = 0;
  this.experimentalY = false;
  this.experimentalZ = 0;
  this.exp_nspsytune = 0;
  this.preset = 0;
  this.VBR = null;
  this.VBR_q_frac = 0;
  this.VBR_q = 0;
  this.VBR_mean_bitrate_kbps = 0;
  this.VBR_min_bitrate_kbps = 0;
  this.VBR_max_bitrate_kbps = 0;
  this.VBR_hard_min = 0;
  this.lowpassfreq = 0;
  this.highpassfreq = 0;
  this.lowpasswidth = 0;
  this.highpasswidth = 0;
  this.maskingadjust = 0;
  this.maskingadjust_short = 0;
  this.ATHonly = false;
  this.ATHshort = false;
  this.noATH = false;
  this.ATHtype = 0;
  this.ATHcurve = 0;
  this.ATHlower = 0;
  this.athaa_type = 0;
  this.athaa_loudapprox = 0;
  this.athaa_sensitivity = 0;
  this.short_blocks = null;
  this.useTemporal = false;
  this.interChRatio = 0;
  this.msfix = 0;
  this.tune = false;
  this.tune_value_a = 0;
  this.version = 0;
  this.encoder_delay = 0;
  this.encoder_padding = 0;
  this.framesize = 0;
  this.frameNum = 0;
  this.lame_allocated_gfp = 0;
  this.internal_flags = null;
}
var LameGlobalFlags_1 = LameGlobalFlags$1;
var Encoder$a = requireEncoder();
var L3Side$5 = {};
L3Side$5.SFBMAX = Encoder$a.SBMAX_s * 3;
var L3Side_1 = L3Side$5;
var common$i = common$l;
common$i.System;
common$i.VbrMode;
common$i.Float;
common$i.ShortBlock;
common$i.Util;
common$i.Arrays;
common$i.new_array_n;
common$i.new_byte;
common$i.new_double;
var new_float$9 = common$i.new_float;
common$i.new_float_n;
var new_int$a = common$i.new_int;
common$i.new_int_n;
common$i.assert;
var L3Side$4 = L3Side_1;
function GrInfo$3() {
  this.xr = new_float$9(576);
  this.l3_enc = new_int$a(576);
  this.scalefac = new_int$a(L3Side$4.SFBMAX);
  this.xrpow_max = 0;
  this.part2_3_length = 0;
  this.big_values = 0;
  this.count1 = 0;
  this.global_gain = 0;
  this.scalefac_compress = 0;
  this.block_type = 0;
  this.mixed_block_flag = 0;
  this.table_select = new_int$a(3);
  this.subblock_gain = new_int$a(3 + 1);
  this.region0_count = 0;
  this.region1_count = 0;
  this.preflag = 0;
  this.scalefac_scale = 0;
  this.count1table_select = 0;
  this.part2_length = 0;
  this.sfb_lmax = 0;
  this.sfb_smin = 0;
  this.psy_lmax = 0;
  this.sfbmax = 0;
  this.psymax = 0;
  this.sfbdivide = 0;
  this.width = new_int$a(L3Side$4.SFBMAX);
  this.window = new_int$a(L3Side$4.SFBMAX);
  this.count1bits = 0;
  this.sfb_partition_table = null;
  this.slen = new_int$a(4);
  this.max_nonzero_coeff = 0;
  var self2 = this;
  function clone_int(array) {
    return new Int32Array(array);
  }
  function clone_float(array) {
    return new Float32Array(array);
  }
  this.assign = function(other) {
    self2.xr = clone_float(other.xr);
    self2.l3_enc = clone_int(other.l3_enc);
    self2.scalefac = clone_int(other.scalefac);
    self2.xrpow_max = other.xrpow_max;
    self2.part2_3_length = other.part2_3_length;
    self2.big_values = other.big_values;
    self2.count1 = other.count1;
    self2.global_gain = other.global_gain;
    self2.scalefac_compress = other.scalefac_compress;
    self2.block_type = other.block_type;
    self2.mixed_block_flag = other.mixed_block_flag;
    self2.table_select = clone_int(other.table_select);
    self2.subblock_gain = clone_int(other.subblock_gain);
    self2.region0_count = other.region0_count;
    self2.region1_count = other.region1_count;
    self2.preflag = other.preflag;
    self2.scalefac_scale = other.scalefac_scale;
    self2.count1table_select = other.count1table_select;
    self2.part2_length = other.part2_length;
    self2.sfb_lmax = other.sfb_lmax;
    self2.sfb_smin = other.sfb_smin;
    self2.psy_lmax = other.psy_lmax;
    self2.sfbmax = other.sfbmax;
    self2.psymax = other.psymax;
    self2.sfbdivide = other.sfbdivide;
    self2.width = clone_int(other.width);
    self2.window = clone_int(other.window);
    self2.count1bits = other.count1bits;
    self2.sfb_partition_table = other.sfb_partition_table.slice(0);
    self2.slen = clone_int(other.slen);
    self2.max_nonzero_coeff = other.max_nonzero_coeff;
  };
}
var GrInfo_1 = GrInfo$3;
var common$h = common$l;
common$h.System;
common$h.VbrMode;
common$h.Float;
common$h.ShortBlock;
common$h.Util;
common$h.Arrays;
common$h.new_array_n;
common$h.new_byte;
common$h.new_double;
common$h.new_float;
common$h.new_float_n;
var new_int$9 = common$h.new_int;
common$h.new_int_n;
common$h.assert;
var GrInfo$2 = GrInfo_1;
function IIISideInfo$1() {
  this.tt = [[null, null], [null, null]];
  this.main_data_begin = 0;
  this.private_bits = 0;
  this.resvDrain_pre = 0;
  this.resvDrain_post = 0;
  this.scfsi = [new_int$9(4), new_int$9(4)];
  for (var gr = 0; gr < 2; gr++) {
    for (var ch = 0; ch < 2; ch++) {
      this.tt[gr][ch] = new GrInfo$2();
    }
  }
}
var IIISideInfo_1 = IIISideInfo$1;
var common$g = common$l;
var System$6 = common$g.System;
common$g.VbrMode;
common$g.Float;
common$g.ShortBlock;
common$g.Util;
common$g.Arrays;
common$g.new_array_n;
common$g.new_byte;
common$g.new_double;
common$g.new_float;
common$g.new_float_n;
var new_int$8 = common$g.new_int;
common$g.new_int_n;
common$g.assert;
var Encoder$9 = requireEncoder();
function ScaleFac$2(arrL, arrS, arr21, arr12) {
  this.l = new_int$8(1 + Encoder$9.SBMAX_l);
  this.s = new_int$8(1 + Encoder$9.SBMAX_s);
  this.psfb21 = new_int$8(1 + Encoder$9.PSFB21);
  this.psfb12 = new_int$8(1 + Encoder$9.PSFB12);
  var l = this.l;
  var s = this.s;
  if (arguments.length == 4) {
    this.arrL = arguments[0];
    this.arrS = arguments[1];
    this.arr21 = arguments[2];
    this.arr12 = arguments[3];
    System$6.arraycopy(this.arrL, 0, l, 0, Math.min(this.arrL.length, this.l.length));
    System$6.arraycopy(this.arrS, 0, s, 0, Math.min(this.arrS.length, this.s.length));
    System$6.arraycopy(this.arr21, 0, this.psfb21, 0, Math.min(this.arr21.length, this.psfb21.length));
    System$6.arraycopy(this.arr12, 0, this.psfb12, 0, Math.min(this.arr12.length, this.psfb12.length));
  }
}
var ScaleFac_1 = ScaleFac$2;
var common$f = common$l;
common$f.System;
common$f.VbrMode;
common$f.Float;
common$f.ShortBlock;
common$f.Util;
common$f.Arrays;
common$f.new_array_n;
common$f.new_byte;
common$f.new_double;
var new_float$8 = common$f.new_float;
var new_float_n$2 = common$f.new_float_n;
var new_int$7 = common$f.new_int;
common$f.new_int_n;
common$f.assert;
var Encoder$8 = requireEncoder();
function NsPsy$1() {
  this.last_en_subshort = new_float_n$2([4, 9]);
  this.lastAttacks = new_int$7(4);
  this.pefirbuf = new_float$8(19);
  this.longfact = new_float$8(Encoder$8.SBMAX_l);
  this.shortfact = new_float$8(Encoder$8.SBMAX_s);
  this.attackthre = 0;
  this.attackthre_s = 0;
}
var NsPsy_1 = NsPsy$1;
function VBRSeekInfo$1() {
  this.sum = 0;
  this.seen = 0;
  this.want = 0;
  this.pos = 0;
  this.size = 0;
  this.bag = null;
  this.nVbrNumFrames = 0;
  this.nBytesWritten = 0;
  this.TotalFrameSize = 0;
}
var VBRSeekInfo_1 = VBRSeekInfo$1;
var common$e = common$l;
common$e.System;
common$e.VbrMode;
common$e.Float;
common$e.ShortBlock;
common$e.Util;
common$e.Arrays;
common$e.new_array_n;
var new_byte$3 = common$e.new_byte;
var new_double = common$e.new_double;
var new_float$7 = common$e.new_float;
var new_float_n$1 = common$e.new_float_n;
var new_int$6 = common$e.new_int;
var new_int_n$1 = common$e.new_int_n;
common$e.assert;
var IIISideInfo = IIISideInfo_1;
var ScaleFac$1 = ScaleFac_1;
var NsPsy = NsPsy_1;
var VBRSeekInfo = VBRSeekInfo_1;
var III_psy_xmin = requireIII_psy_xmin();
var Encoder$7 = requireEncoder();
var L3Side$3 = L3Side_1;
LameInternalFlags$5.MFSIZE = 3 * 1152 + Encoder$7.ENCDELAY - Encoder$7.MDCTDELAY;
LameInternalFlags$5.MAX_HEADER_BUF = 256;
LameInternalFlags$5.MAX_BITS_PER_CHANNEL = 4095;
LameInternalFlags$5.MAX_BITS_PER_GRANULE = 7680;
LameInternalFlags$5.BPC = 320;
function LameInternalFlags$5() {
  var MAX_HEADER_LEN = 40;
  this.Class_ID = 0;
  this.lame_encode_frame_init = 0;
  this.iteration_init_init = 0;
  this.fill_buffer_resample_init = 0;
  this.mfbuf = new_float_n$1([2, LameInternalFlags$5.MFSIZE]);
  this.mode_gr = 0;
  this.channels_in = 0;
  this.channels_out = 0;
  this.resample_ratio = 0;
  this.mf_samples_to_encode = 0;
  this.mf_size = 0;
  this.VBR_min_bitrate = 0;
  this.VBR_max_bitrate = 0;
  this.bitrate_index = 0;
  this.samplerate_index = 0;
  this.mode_ext = 0;
  this.lowpass1 = 0;
  this.lowpass2 = 0;
  this.highpass1 = 0;
  this.highpass2 = 0;
  this.noise_shaping = 0;
  this.noise_shaping_amp = 0;
  this.substep_shaping = 0;
  this.psymodel = 0;
  this.noise_shaping_stop = 0;
  this.subblock_gain = 0;
  this.use_best_huffman = 0;
  this.full_outer_loop = 0;
  this.l3_side = new IIISideInfo();
  this.ms_ratio = new_float$7(2);
  this.padding = 0;
  this.frac_SpF = 0;
  this.slot_lag = 0;
  this.tag_spec = null;
  this.nMusicCRC = 0;
  this.OldValue = new_int$6(2);
  this.CurrentStep = new_int$6(2);
  this.masking_lower = 0;
  this.bv_scf = new_int$6(576);
  this.pseudohalf = new_int$6(L3Side$3.SFBMAX);
  this.sfb21_extra = false;
  this.inbuf_old = new Array(2);
  this.blackfilt = new Array(2 * LameInternalFlags$5.BPC + 1);
  this.itime = new_double(2);
  this.sideinfo_len = 0;
  this.sb_sample = new_float_n$1([2, 2, 18, Encoder$7.SBLIMIT]);
  this.amp_filter = new_float$7(32);
  function Header() {
    this.write_timing = 0;
    this.ptr = 0;
    this.buf = new_byte$3(MAX_HEADER_LEN);
  }
  this.header = new Array(LameInternalFlags$5.MAX_HEADER_BUF);
  this.h_ptr = 0;
  this.w_ptr = 0;
  this.ancillary_flag = 0;
  this.ResvSize = 0;
  this.ResvMax = 0;
  this.scalefac_band = new ScaleFac$1();
  this.minval_l = new_float$7(Encoder$7.CBANDS);
  this.minval_s = new_float$7(Encoder$7.CBANDS);
  this.nb_1 = new_float_n$1([4, Encoder$7.CBANDS]);
  this.nb_2 = new_float_n$1([4, Encoder$7.CBANDS]);
  this.nb_s1 = new_float_n$1([4, Encoder$7.CBANDS]);
  this.nb_s2 = new_float_n$1([4, Encoder$7.CBANDS]);
  this.s3_ss = null;
  this.s3_ll = null;
  this.decay = 0;
  this.thm = new Array(4);
  this.en = new Array(4);
  this.tot_ener = new_float$7(4);
  this.loudness_sq = new_float_n$1([2, 2]);
  this.loudness_sq_save = new_float$7(2);
  this.mld_l = new_float$7(Encoder$7.SBMAX_l);
  this.mld_s = new_float$7(Encoder$7.SBMAX_s);
  this.bm_l = new_int$6(Encoder$7.SBMAX_l);
  this.bo_l = new_int$6(Encoder$7.SBMAX_l);
  this.bm_s = new_int$6(Encoder$7.SBMAX_s);
  this.bo_s = new_int$6(Encoder$7.SBMAX_s);
  this.npart_l = 0;
  this.npart_s = 0;
  this.s3ind = new_int_n$1([Encoder$7.CBANDS, 2]);
  this.s3ind_s = new_int_n$1([Encoder$7.CBANDS, 2]);
  this.numlines_s = new_int$6(Encoder$7.CBANDS);
  this.numlines_l = new_int$6(Encoder$7.CBANDS);
  this.rnumlines_l = new_float$7(Encoder$7.CBANDS);
  this.mld_cb_l = new_float$7(Encoder$7.CBANDS);
  this.mld_cb_s = new_float$7(Encoder$7.CBANDS);
  this.numlines_s_num1 = 0;
  this.numlines_l_num1 = 0;
  this.pe = new_float$7(4);
  this.ms_ratio_s_old = 0;
  this.ms_ratio_l_old = 0;
  this.ms_ener_ratio_old = 0;
  this.blocktype_old = new_int$6(2);
  this.nsPsy = new NsPsy();
  this.VBR_seek_table = new VBRSeekInfo();
  this.ATH = null;
  this.PSY = null;
  this.nogap_total = 0;
  this.nogap_current = 0;
  this.decode_on_the_fly = true;
  this.findReplayGain = true;
  this.findPeakSample = true;
  this.PeakSample = 0;
  this.RadioGain = 0;
  this.AudiophileGain = 0;
  this.rgdata = null;
  this.noclipGainChange = 0;
  this.noclipScale = 0;
  this.bitrate_stereoMode_Hist = new_int_n$1([16, 4 + 1]);
  this.bitrate_blockType_Hist = new_int_n$1([16, 4 + 1 + 1]);
  this.pinfo = null;
  this.hip = null;
  this.in_buffer_nsamples = 0;
  this.in_buffer_0 = null;
  this.in_buffer_1 = null;
  this.iteration_loop = null;
  for (var i = 0; i < this.en.length; i++) {
    this.en[i] = new III_psy_xmin();
  }
  for (var i = 0; i < this.thm.length; i++) {
    this.thm[i] = new III_psy_xmin();
  }
  for (var i = 0; i < this.header.length; i++) {
    this.header[i] = new Header();
  }
}
var LameInternalFlags_1 = LameInternalFlags$5;
var common$d = common$l;
common$d.System;
common$d.VbrMode;
common$d.Float;
common$d.ShortBlock;
common$d.Util;
common$d.Arrays;
common$d.new_array_n;
common$d.new_byte;
common$d.new_double;
var new_float$6 = common$d.new_float;
common$d.new_float_n;
common$d.new_int;
common$d.new_int_n;
common$d.assert;
var Encoder$6 = requireEncoder();
function ATH$1() {
  this.useAdjust = 0;
  this.aaSensitivityP = 0;
  this.adjust = 0;
  this.adjustLimit = 0;
  this.decay = 0;
  this.floor = 0;
  this.l = new_float$6(Encoder$6.SBMAX_l);
  this.s = new_float$6(Encoder$6.SBMAX_s);
  this.psfb21 = new_float$6(Encoder$6.PSFB21);
  this.psfb12 = new_float$6(Encoder$6.PSFB12);
  this.cb_l = new_float$6(Encoder$6.CBANDS);
  this.cb_s = new_float$6(Encoder$6.CBANDS);
  this.eql_w = new_float$6(Encoder$6.BLKSIZE / 2);
}
var ATH_1 = ATH$1;
var common$c = common$l;
var System$5 = common$c.System;
common$c.VbrMode;
common$c.Float;
common$c.ShortBlock;
common$c.Util;
var Arrays$4 = common$c.Arrays;
common$c.new_array_n;
common$c.new_byte;
common$c.new_double;
common$c.new_float;
common$c.new_float_n;
common$c.new_int;
common$c.new_int_n;
common$c.assert;
GainAnalysis$3.STEPS_per_dB = 100;
GainAnalysis$3.MAX_dB = 120;
GainAnalysis$3.GAIN_NOT_ENOUGH_SAMPLES = -24601;
GainAnalysis$3.GAIN_ANALYSIS_ERROR = 0;
GainAnalysis$3.GAIN_ANALYSIS_OK = 1;
GainAnalysis$3.INIT_GAIN_ANALYSIS_ERROR = 0;
GainAnalysis$3.INIT_GAIN_ANALYSIS_OK = 1;
GainAnalysis$3.YULE_ORDER = 10;
GainAnalysis$3.MAX_ORDER = GainAnalysis$3.YULE_ORDER;
GainAnalysis$3.MAX_SAMP_FREQ = 48e3;
GainAnalysis$3.RMS_WINDOW_TIME_NUMERATOR = 1;
GainAnalysis$3.RMS_WINDOW_TIME_DENOMINATOR = 20;
GainAnalysis$3.MAX_SAMPLES_PER_WINDOW = GainAnalysis$3.MAX_SAMP_FREQ * GainAnalysis$3.RMS_WINDOW_TIME_NUMERATOR / GainAnalysis$3.RMS_WINDOW_TIME_DENOMINATOR + 1;
function GainAnalysis$3() {
  var PINK_REF = 64.82;
  GainAnalysis$3.YULE_ORDER;
  var RMS_PERCENTILE = 0.95;
  GainAnalysis$3.MAX_SAMP_FREQ;
  var RMS_WINDOW_TIME_NUMERATOR = GainAnalysis$3.RMS_WINDOW_TIME_NUMERATOR;
  var RMS_WINDOW_TIME_DENOMINATOR = GainAnalysis$3.RMS_WINDOW_TIME_DENOMINATOR;
  GainAnalysis$3.MAX_SAMPLES_PER_WINDOW;
  var ABYule = [
    [
      0.038575994352,
      -3.84664617118067,
      -0.02160367184185,
      7.81501653005538,
      -0.00123395316851,
      -11.34170355132042,
      -9291677959e-14,
      13.05504219327545,
      -0.01655260341619,
      -12.28759895145294,
      0.02161526843274,
      9.4829380631979,
      -0.02074045215285,
      -5.87257861775999,
      0.00594298065125,
      2.75465861874613,
      0.00306428023191,
      -0.86984376593551,
      12025322027e-14,
      0.13919314567432,
      0.00288463683916
    ],
    [
      0.0541865640643,
      -3.47845948550071,
      -0.02911007808948,
      6.36317777566148,
      -0.00848709379851,
      -8.54751527471874,
      -0.00851165645469,
      9.4769360780128,
      -0.00834990904936,
      -8.81498681370155,
      0.02245293253339,
      6.85401540936998,
      -0.02596338512915,
      -4.39470996079559,
      0.01624864962975,
      2.19611684890774,
      -0.00240879051584,
      -0.75104302451432,
      0.00674613682247,
      0.13149317958808,
      -0.00187763777362
    ],
    [
      0.15457299681924,
      -2.37898834973084,
      -0.09331049056315,
      2.84868151156327,
      -0.06247880153653,
      -2.64577170229825,
      0.02163541888798,
      2.23697657451713,
      -0.05588393329856,
      -1.67148153367602,
      0.04781476674921,
      1.00595954808547,
      0.00222312597743,
      -0.45953458054983,
      0.03174092540049,
      0.16378164858596,
      -0.01390589421898,
      -0.05032077717131,
      0.00651420667831,
      0.0234789740702,
      -0.00881362733839
    ],
    [
      0.30296907319327,
      -1.61273165137247,
      -0.22613988682123,
      1.0797749225997,
      -0.08587323730772,
      -0.2565625775407,
      0.03282930172664,
      -0.1627671912044,
      -0.00915702933434,
      -0.22638893773906,
      -0.02364141202522,
      0.39120800788284,
      -0.00584456039913,
      -0.22138138954925,
      0.06276101321749,
      0.04500235387352,
      -828086748e-14,
      0.02005851806501,
      0.00205861885564,
      0.00302439095741,
      -0.02950134983287
    ],
    [
      0.33642304856132,
      -1.49858979367799,
      -0.2557224142557,
      0.87350271418188,
      -0.11828570177555,
      0.12205022308084,
      0.11921148675203,
      -0.80774944671438,
      -0.07834489609479,
      0.47854794562326,
      -0.0046997791438,
      -0.12453458140019,
      -0.0058950022444,
      -0.04067510197014,
      0.05724228140351,
      0.08333755284107,
      0.00832043980773,
      -0.04237348025746,
      -0.0163538138454,
      0.02977207319925,
      -0.0176017656815
    ],
    [
      0.4491525660845,
      -0.62820619233671,
      -0.14351757464547,
      0.29661783706366,
      -0.22784394429749,
      -0.372563729424,
      -0.01419140100551,
      0.00213767857124,
      0.04078262797139,
      -0.42029820170918,
      -0.12398163381748,
      0.22199650564824,
      0.04097565135648,
      0.00613424350682,
      0.10478503600251,
      0.06747620744683,
      -0.01863887810927,
      0.05784820375801,
      -0.03193428438915,
      0.03222754072173,
      0.00541907748707
    ],
    [
      0.56619470757641,
      -1.04800335126349,
      -0.75464456939302,
      0.29156311971249,
      0.1624213774223,
      -0.26806001042947,
      0.16744243493672,
      0.00819999645858,
      -0.18901604199609,
      0.45054734505008,
      0.3093178284183,
      -0.33032403314006,
      -0.27562961986224,
      0.0673936833311,
      0.00647310677246,
      -0.04784254229033,
      0.08647503780351,
      0.01639907836189,
      -0.0378898455484,
      0.01807364323573,
      -0.00588215443421
    ],
    [
      0.58100494960553,
      -0.51035327095184,
      -0.53174909058578,
      -0.31863563325245,
      -0.14289799034253,
      -0.20256413484477,
      0.17520704835522,
      0.1472815413433,
      0.02377945217615,
      0.38952639978999,
      0.15558449135573,
      -0.23313271880868,
      -0.25344790059353,
      -0.05246019024463,
      0.01628462406333,
      -0.02505961724053,
      0.06920467763959,
      0.02442357316099,
      -0.03721611395801,
      0.01818801111503,
      -0.00749618797172
    ],
    [
      0.53648789255105,
      -0.2504987195602,
      -0.42163034350696,
      -0.43193942311114,
      -0.00275953611929,
      -0.03424681017675,
      0.04267842219415,
      -0.04678328784242,
      -0.10214864179676,
      0.26408300200955,
      0.14590772289388,
      0.15113130533216,
      -0.02459864859345,
      -0.17556493366449,
      -0.11202315195388,
      -0.18823009262115,
      -0.04060034127,
      0.05477720428674,
      0.0478866554818,
      0.0470440968812,
      -0.02217936801134
    ]
  ];
  var ABButter = [
    [
      0.98621192462708,
      -1.97223372919527,
      -1.97242384925416,
      0.97261396931306,
      0.98621192462708
    ],
    [
      0.98500175787242,
      -1.96977855582618,
      -1.97000351574484,
      0.9702284756635,
      0.98500175787242
    ],
    [
      0.97938932735214,
      -1.95835380975398,
      -1.95877865470428,
      0.95920349965459,
      0.97938932735214
    ],
    [
      0.97531843204928,
      -1.95002759149878,
      -1.95063686409857,
      0.95124613669835,
      0.97531843204928
    ],
    [
      0.97316523498161,
      -1.94561023566527,
      -1.94633046996323,
      0.94705070426118,
      0.97316523498161
    ],
    [
      0.96454515552826,
      -1.92783286977036,
      -1.92909031105652,
      0.93034775234268,
      0.96454515552826
    ],
    [
      0.96009142950541,
      -1.91858953033784,
      -1.92018285901082,
      0.92177618768381,
      0.96009142950541
    ],
    [
      0.95856916599601,
      -1.9154210807478,
      -1.91713833199203,
      0.91885558323625,
      0.95856916599601
    ],
    [
      0.94597685600279,
      -1.88903307939452,
      -1.89195371200558,
      0.89487434461664,
      0.94597685600279
    ]
  ];
  function filterYule(input, inputPos, output, outputPos, nSamples, kernel) {
    while (nSamples-- != 0) {
      output[outputPos] = 1e-10 + input[inputPos + 0] * kernel[0] - output[outputPos - 1] * kernel[1] + input[inputPos - 1] * kernel[2] - output[outputPos - 2] * kernel[3] + input[inputPos - 2] * kernel[4] - output[outputPos - 3] * kernel[5] + input[inputPos - 3] * kernel[6] - output[outputPos - 4] * kernel[7] + input[inputPos - 4] * kernel[8] - output[outputPos - 5] * kernel[9] + input[inputPos - 5] * kernel[10] - output[outputPos - 6] * kernel[11] + input[inputPos - 6] * kernel[12] - output[outputPos - 7] * kernel[13] + input[inputPos - 7] * kernel[14] - output[outputPos - 8] * kernel[15] + input[inputPos - 8] * kernel[16] - output[outputPos - 9] * kernel[17] + input[inputPos - 9] * kernel[18] - output[outputPos - 10] * kernel[19] + input[inputPos - 10] * kernel[20];
      ++outputPos;
      ++inputPos;
    }
  }
  function filterButter(input, inputPos, output, outputPos, nSamples, kernel) {
    while (nSamples-- != 0) {
      output[outputPos] = input[inputPos + 0] * kernel[0] - output[outputPos - 1] * kernel[1] + input[inputPos - 1] * kernel[2] - output[outputPos - 2] * kernel[3] + input[inputPos - 2] * kernel[4];
      ++outputPos;
      ++inputPos;
    }
  }
  function ResetSampleFrequency(rgData, samplefreq) {
    for (var i = 0; i < MAX_ORDER; i++)
      rgData.linprebuf[i] = rgData.lstepbuf[i] = rgData.loutbuf[i] = rgData.rinprebuf[i] = rgData.rstepbuf[i] = rgData.routbuf[i] = 0;
    switch (0 | samplefreq) {
      case 48e3:
        rgData.reqindex = 0;
        break;
      case 44100:
        rgData.reqindex = 1;
        break;
      case 32e3:
        rgData.reqindex = 2;
        break;
      case 24e3:
        rgData.reqindex = 3;
        break;
      case 22050:
        rgData.reqindex = 4;
        break;
      case 16e3:
        rgData.reqindex = 5;
        break;
      case 12e3:
        rgData.reqindex = 6;
        break;
      case 11025:
        rgData.reqindex = 7;
        break;
      case 8e3:
        rgData.reqindex = 8;
        break;
      default:
        return INIT_GAIN_ANALYSIS_ERROR;
    }
    rgData.sampleWindow = 0 | (samplefreq * RMS_WINDOW_TIME_NUMERATOR + RMS_WINDOW_TIME_DENOMINATOR - 1) / RMS_WINDOW_TIME_DENOMINATOR;
    rgData.lsum = 0;
    rgData.rsum = 0;
    rgData.totsamp = 0;
    Arrays$4.ill(rgData.A, 0);
    return INIT_GAIN_ANALYSIS_OK;
  }
  this.InitGainAnalysis = function(rgData, samplefreq) {
    if (ResetSampleFrequency(rgData, samplefreq) != INIT_GAIN_ANALYSIS_OK) {
      return INIT_GAIN_ANALYSIS_ERROR;
    }
    rgData.linpre = MAX_ORDER;
    rgData.rinpre = MAX_ORDER;
    rgData.lstep = MAX_ORDER;
    rgData.rstep = MAX_ORDER;
    rgData.lout = MAX_ORDER;
    rgData.rout = MAX_ORDER;
    Arrays$4.fill(rgData.B, 0);
    return INIT_GAIN_ANALYSIS_OK;
  };
  function fsqr(d) {
    return d * d;
  }
  this.AnalyzeSamples = function(rgData, left_samples, left_samplesPos, right_samples, right_samplesPos, num_samples, num_channels) {
    var curleft;
    var curleftBase;
    var curright;
    var currightBase;
    var batchsamples;
    var cursamples;
    var cursamplepos;
    if (num_samples == 0)
      return GAIN_ANALYSIS_OK;
    cursamplepos = 0;
    batchsamples = num_samples;
    switch (num_channels) {
      case 1:
        right_samples = left_samples;
        right_samplesPos = left_samplesPos;
        break;
      case 2:
        break;
      default:
        return GAIN_ANALYSIS_ERROR;
    }
    if (num_samples < MAX_ORDER) {
      System$5.arraycopy(
        left_samples,
        left_samplesPos,
        rgData.linprebuf,
        MAX_ORDER,
        num_samples
      );
      System$5.arraycopy(
        right_samples,
        right_samplesPos,
        rgData.rinprebuf,
        MAX_ORDER,
        num_samples
      );
    } else {
      System$5.arraycopy(
        left_samples,
        left_samplesPos,
        rgData.linprebuf,
        MAX_ORDER,
        MAX_ORDER
      );
      System$5.arraycopy(
        right_samples,
        right_samplesPos,
        rgData.rinprebuf,
        MAX_ORDER,
        MAX_ORDER
      );
    }
    while (batchsamples > 0) {
      cursamples = batchsamples > rgData.sampleWindow - rgData.totsamp ? rgData.sampleWindow - rgData.totsamp : batchsamples;
      if (cursamplepos < MAX_ORDER) {
        curleft = rgData.linpre + cursamplepos;
        curleftBase = rgData.linprebuf;
        curright = rgData.rinpre + cursamplepos;
        currightBase = rgData.rinprebuf;
        if (cursamples > MAX_ORDER - cursamplepos)
          cursamples = MAX_ORDER - cursamplepos;
      } else {
        curleft = left_samplesPos + cursamplepos;
        curleftBase = left_samples;
        curright = right_samplesPos + cursamplepos;
        currightBase = right_samples;
      }
      filterYule(curleftBase, curleft, rgData.lstepbuf, rgData.lstep + rgData.totsamp, cursamples, ABYule[rgData.reqindex]);
      filterYule(currightBase, curright, rgData.rstepbuf, rgData.rstep + rgData.totsamp, cursamples, ABYule[rgData.reqindex]);
      filterButter(
        rgData.lstepbuf,
        rgData.lstep + rgData.totsamp,
        rgData.loutbuf,
        rgData.lout + rgData.totsamp,
        cursamples,
        ABButter[rgData.reqindex]
      );
      filterButter(
        rgData.rstepbuf,
        rgData.rstep + rgData.totsamp,
        rgData.routbuf,
        rgData.rout + rgData.totsamp,
        cursamples,
        ABButter[rgData.reqindex]
      );
      curleft = rgData.lout + rgData.totsamp;
      curleftBase = rgData.loutbuf;
      curright = rgData.rout + rgData.totsamp;
      currightBase = rgData.routbuf;
      var i = cursamples % 8;
      while (i-- != 0) {
        rgData.lsum += fsqr(curleftBase[curleft++]);
        rgData.rsum += fsqr(currightBase[curright++]);
      }
      i = cursamples / 8;
      while (i-- != 0) {
        rgData.lsum += fsqr(curleftBase[curleft + 0]) + fsqr(curleftBase[curleft + 1]) + fsqr(curleftBase[curleft + 2]) + fsqr(curleftBase[curleft + 3]) + fsqr(curleftBase[curleft + 4]) + fsqr(curleftBase[curleft + 5]) + fsqr(curleftBase[curleft + 6]) + fsqr(curleftBase[curleft + 7]);
        curleft += 8;
        rgData.rsum += fsqr(currightBase[curright + 0]) + fsqr(currightBase[curright + 1]) + fsqr(currightBase[curright + 2]) + fsqr(currightBase[curright + 3]) + fsqr(currightBase[curright + 4]) + fsqr(currightBase[curright + 5]) + fsqr(currightBase[curright + 6]) + fsqr(currightBase[curright + 7]);
        curright += 8;
      }
      batchsamples -= cursamples;
      cursamplepos += cursamples;
      rgData.totsamp += cursamples;
      if (rgData.totsamp == rgData.sampleWindow) {
        var val = GainAnalysis$3.STEPS_per_dB * 10 * Math.log10((rgData.lsum + rgData.rsum) / rgData.totsamp * 0.5 + 1e-37);
        var ival = val <= 0 ? 0 : 0 | val;
        if (ival >= rgData.A.length)
          ival = rgData.A.length - 1;
        rgData.A[ival]++;
        rgData.lsum = rgData.rsum = 0;
        System$5.arraycopy(
          rgData.loutbuf,
          rgData.totsamp,
          rgData.loutbuf,
          0,
          MAX_ORDER
        );
        System$5.arraycopy(
          rgData.routbuf,
          rgData.totsamp,
          rgData.routbuf,
          0,
          MAX_ORDER
        );
        System$5.arraycopy(
          rgData.lstepbuf,
          rgData.totsamp,
          rgData.lstepbuf,
          0,
          MAX_ORDER
        );
        System$5.arraycopy(
          rgData.rstepbuf,
          rgData.totsamp,
          rgData.rstepbuf,
          0,
          MAX_ORDER
        );
        rgData.totsamp = 0;
      }
      if (rgData.totsamp > rgData.sampleWindow) {
        return GAIN_ANALYSIS_ERROR;
      }
    }
    if (num_samples < MAX_ORDER) {
      System$5.arraycopy(
        rgData.linprebuf,
        num_samples,
        rgData.linprebuf,
        0,
        MAX_ORDER - num_samples
      );
      System$5.arraycopy(
        rgData.rinprebuf,
        num_samples,
        rgData.rinprebuf,
        0,
        MAX_ORDER - num_samples
      );
      System$5.arraycopy(
        left_samples,
        left_samplesPos,
        rgData.linprebuf,
        MAX_ORDER - num_samples,
        num_samples
      );
      System$5.arraycopy(
        right_samples,
        right_samplesPos,
        rgData.rinprebuf,
        MAX_ORDER - num_samples,
        num_samples
      );
    } else {
      System$5.arraycopy(left_samples, left_samplesPos + num_samples - MAX_ORDER, rgData.linprebuf, 0, MAX_ORDER);
      System$5.arraycopy(right_samples, right_samplesPos + num_samples - MAX_ORDER, rgData.rinprebuf, 0, MAX_ORDER);
    }
    return GAIN_ANALYSIS_OK;
  };
  function analyzeResult(Array2, len) {
    var i;
    var elems = 0;
    for (i = 0; i < len; i++)
      elems += Array2[i];
    if (elems == 0)
      return GAIN_NOT_ENOUGH_SAMPLES;
    var upper = 0 | Math.ceil(elems * (1 - RMS_PERCENTILE));
    for (i = len; i-- > 0; ) {
      if ((upper -= Array2[i]) <= 0)
        break;
    }
    return PINK_REF - i / GainAnalysis$3.STEPS_per_dB;
  }
  this.GetTitleGain = function(rgData) {
    var retval = analyzeResult(rgData.A, rgData.A.length);
    for (var i = 0; i < rgData.A.length; i++) {
      rgData.B[i] += rgData.A[i];
      rgData.A[i] = 0;
    }
    for (var i = 0; i < MAX_ORDER; i++)
      rgData.linprebuf[i] = rgData.lstepbuf[i] = rgData.loutbuf[i] = rgData.rinprebuf[i] = rgData.rstepbuf[i] = rgData.routbuf[i] = 0;
    rgData.totsamp = 0;
    rgData.lsum = rgData.rsum = 0;
    return retval;
  };
}
var GainAnalysis_1 = GainAnalysis$3;
var common$b = common$l;
common$b.System;
common$b.VbrMode;
common$b.Float;
common$b.ShortBlock;
common$b.Util;
common$b.Arrays;
common$b.new_array_n;
common$b.new_byte;
common$b.new_double;
var new_float$5 = common$b.new_float;
common$b.new_float_n;
var new_int$5 = common$b.new_int;
common$b.new_int_n;
common$b.assert;
var GainAnalysis$2 = GainAnalysis_1;
function ReplayGain$1() {
  this.linprebuf = new_float$5(GainAnalysis$2.MAX_ORDER * 2);
  this.linpre = 0;
  this.lstepbuf = new_float$5(GainAnalysis$2.MAX_SAMPLES_PER_WINDOW + GainAnalysis$2.MAX_ORDER);
  this.lstep = 0;
  this.loutbuf = new_float$5(GainAnalysis$2.MAX_SAMPLES_PER_WINDOW + GainAnalysis$2.MAX_ORDER);
  this.lout = 0;
  this.rinprebuf = new_float$5(GainAnalysis$2.MAX_ORDER * 2);
  this.rinpre = 0;
  this.rstepbuf = new_float$5(GainAnalysis$2.MAX_SAMPLES_PER_WINDOW + GainAnalysis$2.MAX_ORDER);
  this.rstep = 0;
  this.routbuf = new_float$5(GainAnalysis$2.MAX_SAMPLES_PER_WINDOW + GainAnalysis$2.MAX_ORDER);
  this.rout = 0;
  this.sampleWindow = 0;
  this.totsamp = 0;
  this.lsum = 0;
  this.rsum = 0;
  this.freqindex = 0;
  this.first = 0;
  this.A = new_int$5(0 | GainAnalysis$2.STEPS_per_dB * GainAnalysis$2.MAX_dB);
  this.B = new_int$5(0 | GainAnalysis$2.STEPS_per_dB * GainAnalysis$2.MAX_dB);
}
var ReplayGain_1 = ReplayGain$1;
function MeanBits$3(meanBits) {
  this.bits = meanBits;
}
var MeanBits_1 = MeanBits$3;
var common$a = common$l;
common$a.System;
common$a.VbrMode;
common$a.Float;
common$a.ShortBlock;
common$a.Util;
common$a.Arrays;
common$a.new_array_n;
common$a.new_byte;
common$a.new_double;
var new_float$4 = common$a.new_float;
common$a.new_float_n;
var new_int$4 = common$a.new_int;
common$a.new_int_n;
var assert$8 = common$a.assert;
var MeanBits$2 = MeanBits_1;
var Encoder$5 = requireEncoder();
var L3Side$2 = L3Side_1;
var LameInternalFlags$4 = LameInternalFlags_1;
function CBRNewIterationLoop$1(_quantize) {
  var quantize = _quantize;
  this.quantize = quantize;
  this.iteration_loop = function(gfp, pe, ms_ener_ratio, ratio) {
    var gfc = gfp.internal_flags;
    var l3_xmin = new_float$4(L3Side$2.SFBMAX);
    var xrpow = new_float$4(576);
    var targ_bits = new_int$4(2);
    var mean_bits = 0, max_bits;
    var l3_side = gfc.l3_side;
    var mb = new MeanBits$2(mean_bits);
    this.quantize.rv.ResvFrameBegin(gfp, mb);
    mean_bits = mb.bits;
    for (var gr = 0; gr < gfc.mode_gr; gr++) {
      max_bits = this.quantize.qupvt.on_pe(
        gfp,
        pe,
        targ_bits,
        mean_bits,
        gr,
        gr
      );
      if (gfc.mode_ext == Encoder$5.MPG_MD_MS_LR) {
        this.quantize.ms_convert(gfc.l3_side, gr);
        this.quantize.qupvt.reduce_side(
          targ_bits,
          ms_ener_ratio[gr],
          mean_bits,
          max_bits
        );
      }
      for (var ch = 0; ch < gfc.channels_out; ch++) {
        var adjust, masking_lower_db;
        var cod_info = l3_side.tt[gr][ch];
        if (cod_info.block_type != Encoder$5.SHORT_TYPE) {
          adjust = 0;
          masking_lower_db = gfc.PSY.mask_adjust - adjust;
        } else {
          adjust = 0;
          masking_lower_db = gfc.PSY.mask_adjust_short - adjust;
        }
        gfc.masking_lower = Math.pow(
          10,
          masking_lower_db * 0.1
        );
        this.quantize.init_outer_loop(gfc, cod_info);
        if (this.quantize.init_xrpow(gfc, cod_info, xrpow)) {
          this.quantize.qupvt.calc_xmin(
            gfp,
            ratio[gr][ch],
            cod_info,
            l3_xmin
          );
          this.quantize.outer_loop(
            gfp,
            cod_info,
            l3_xmin,
            xrpow,
            ch,
            targ_bits[ch]
          );
        }
        this.quantize.iteration_finish_one(gfc, gr, ch);
        assert$8(cod_info.part2_3_length <= LameInternalFlags$4.MAX_BITS_PER_CHANNEL);
        assert$8(cod_info.part2_3_length <= targ_bits[ch]);
      }
    }
    this.quantize.rv.ResvFrameEnd(gfc, mean_bits);
  };
}
var CBRNewIterationLoop_1 = CBRNewIterationLoop$1;
function HuffCodeTab(len, max2, tab, hl) {
  this.xlen = len;
  this.linmax = max2;
  this.table = tab;
  this.hlen = hl;
}
var Tables$4 = {};
Tables$4.t1HB = [
  1,
  1,
  1,
  0
];
Tables$4.t2HB = [
  1,
  2,
  1,
  3,
  1,
  1,
  3,
  2,
  0
];
Tables$4.t3HB = [
  3,
  2,
  1,
  1,
  1,
  1,
  3,
  2,
  0
];
Tables$4.t5HB = [
  1,
  2,
  6,
  5,
  3,
  1,
  4,
  4,
  7,
  5,
  7,
  1,
  6,
  1,
  1,
  0
];
Tables$4.t6HB = [
  7,
  3,
  5,
  1,
  6,
  2,
  3,
  2,
  5,
  4,
  4,
  1,
  3,
  3,
  2,
  0
];
Tables$4.t7HB = [
  1,
  2,
  10,
  19,
  16,
  10,
  3,
  3,
  7,
  10,
  5,
  3,
  11,
  4,
  13,
  17,
  8,
  4,
  12,
  11,
  18,
  15,
  11,
  2,
  7,
  6,
  9,
  14,
  3,
  1,
  6,
  4,
  5,
  3,
  2,
  0
];
Tables$4.t8HB = [
  3,
  4,
  6,
  18,
  12,
  5,
  5,
  1,
  2,
  16,
  9,
  3,
  7,
  3,
  5,
  14,
  7,
  3,
  19,
  17,
  15,
  13,
  10,
  4,
  13,
  5,
  8,
  11,
  5,
  1,
  12,
  4,
  4,
  1,
  1,
  0
];
Tables$4.t9HB = [
  7,
  5,
  9,
  14,
  15,
  7,
  6,
  4,
  5,
  5,
  6,
  7,
  7,
  6,
  8,
  8,
  8,
  5,
  15,
  6,
  9,
  10,
  5,
  1,
  11,
  7,
  9,
  6,
  4,
  1,
  14,
  4,
  6,
  2,
  6,
  0
];
Tables$4.t10HB = [
  1,
  2,
  10,
  23,
  35,
  30,
  12,
  17,
  3,
  3,
  8,
  12,
  18,
  21,
  12,
  7,
  11,
  9,
  15,
  21,
  32,
  40,
  19,
  6,
  14,
  13,
  22,
  34,
  46,
  23,
  18,
  7,
  20,
  19,
  33,
  47,
  27,
  22,
  9,
  3,
  31,
  22,
  41,
  26,
  21,
  20,
  5,
  3,
  14,
  13,
  10,
  11,
  16,
  6,
  5,
  1,
  9,
  8,
  7,
  8,
  4,
  4,
  2,
  0
];
Tables$4.t11HB = [
  3,
  4,
  10,
  24,
  34,
  33,
  21,
  15,
  5,
  3,
  4,
  10,
  32,
  17,
  11,
  10,
  11,
  7,
  13,
  18,
  30,
  31,
  20,
  5,
  25,
  11,
  19,
  59,
  27,
  18,
  12,
  5,
  35,
  33,
  31,
  58,
  30,
  16,
  7,
  5,
  28,
  26,
  32,
  19,
  17,
  15,
  8,
  14,
  14,
  12,
  9,
  13,
  14,
  9,
  4,
  1,
  11,
  4,
  6,
  6,
  6,
  3,
  2,
  0
];
Tables$4.t12HB = [
  9,
  6,
  16,
  33,
  41,
  39,
  38,
  26,
  7,
  5,
  6,
  9,
  23,
  16,
  26,
  11,
  17,
  7,
  11,
  14,
  21,
  30,
  10,
  7,
  17,
  10,
  15,
  12,
  18,
  28,
  14,
  5,
  32,
  13,
  22,
  19,
  18,
  16,
  9,
  5,
  40,
  17,
  31,
  29,
  17,
  13,
  4,
  2,
  27,
  12,
  11,
  15,
  10,
  7,
  4,
  1,
  27,
  12,
  8,
  12,
  6,
  3,
  1,
  0
];
Tables$4.t13HB = [
  1,
  5,
  14,
  21,
  34,
  51,
  46,
  71,
  42,
  52,
  68,
  52,
  67,
  44,
  43,
  19,
  3,
  4,
  12,
  19,
  31,
  26,
  44,
  33,
  31,
  24,
  32,
  24,
  31,
  35,
  22,
  14,
  15,
  13,
  23,
  36,
  59,
  49,
  77,
  65,
  29,
  40,
  30,
  40,
  27,
  33,
  42,
  16,
  22,
  20,
  37,
  61,
  56,
  79,
  73,
  64,
  43,
  76,
  56,
  37,
  26,
  31,
  25,
  14,
  35,
  16,
  60,
  57,
  97,
  75,
  114,
  91,
  54,
  73,
  55,
  41,
  48,
  53,
  23,
  24,
  58,
  27,
  50,
  96,
  76,
  70,
  93,
  84,
  77,
  58,
  79,
  29,
  74,
  49,
  41,
  17,
  47,
  45,
  78,
  74,
  115,
  94,
  90,
  79,
  69,
  83,
  71,
  50,
  59,
  38,
  36,
  15,
  72,
  34,
  56,
  95,
  92,
  85,
  91,
  90,
  86,
  73,
  77,
  65,
  51,
  44,
  43,
  42,
  43,
  20,
  30,
  44,
  55,
  78,
  72,
  87,
  78,
  61,
  46,
  54,
  37,
  30,
  20,
  16,
  53,
  25,
  41,
  37,
  44,
  59,
  54,
  81,
  66,
  76,
  57,
  54,
  37,
  18,
  39,
  11,
  35,
  33,
  31,
  57,
  42,
  82,
  72,
  80,
  47,
  58,
  55,
  21,
  22,
  26,
  38,
  22,
  53,
  25,
  23,
  38,
  70,
  60,
  51,
  36,
  55,
  26,
  34,
  23,
  27,
  14,
  9,
  7,
  34,
  32,
  28,
  39,
  49,
  75,
  30,
  52,
  48,
  40,
  52,
  28,
  18,
  17,
  9,
  5,
  45,
  21,
  34,
  64,
  56,
  50,
  49,
  45,
  31,
  19,
  12,
  15,
  10,
  7,
  6,
  3,
  48,
  23,
  20,
  39,
  36,
  35,
  53,
  21,
  16,
  23,
  13,
  10,
  6,
  1,
  4,
  2,
  16,
  15,
  17,
  27,
  25,
  20,
  29,
  11,
  17,
  12,
  16,
  8,
  1,
  1,
  0,
  1
];
Tables$4.t15HB = [
  7,
  12,
  18,
  53,
  47,
  76,
  124,
  108,
  89,
  123,
  108,
  119,
  107,
  81,
  122,
  63,
  13,
  5,
  16,
  27,
  46,
  36,
  61,
  51,
  42,
  70,
  52,
  83,
  65,
  41,
  59,
  36,
  19,
  17,
  15,
  24,
  41,
  34,
  59,
  48,
  40,
  64,
  50,
  78,
  62,
  80,
  56,
  33,
  29,
  28,
  25,
  43,
  39,
  63,
  55,
  93,
  76,
  59,
  93,
  72,
  54,
  75,
  50,
  29,
  52,
  22,
  42,
  40,
  67,
  57,
  95,
  79,
  72,
  57,
  89,
  69,
  49,
  66,
  46,
  27,
  77,
  37,
  35,
  66,
  58,
  52,
  91,
  74,
  62,
  48,
  79,
  63,
  90,
  62,
  40,
  38,
  125,
  32,
  60,
  56,
  50,
  92,
  78,
  65,
  55,
  87,
  71,
  51,
  73,
  51,
  70,
  30,
  109,
  53,
  49,
  94,
  88,
  75,
  66,
  122,
  91,
  73,
  56,
  42,
  64,
  44,
  21,
  25,
  90,
  43,
  41,
  77,
  73,
  63,
  56,
  92,
  77,
  66,
  47,
  67,
  48,
  53,
  36,
  20,
  71,
  34,
  67,
  60,
  58,
  49,
  88,
  76,
  67,
  106,
  71,
  54,
  38,
  39,
  23,
  15,
  109,
  53,
  51,
  47,
  90,
  82,
  58,
  57,
  48,
  72,
  57,
  41,
  23,
  27,
  62,
  9,
  86,
  42,
  40,
  37,
  70,
  64,
  52,
  43,
  70,
  55,
  42,
  25,
  29,
  18,
  11,
  11,
  118,
  68,
  30,
  55,
  50,
  46,
  74,
  65,
  49,
  39,
  24,
  16,
  22,
  13,
  14,
  7,
  91,
  44,
  39,
  38,
  34,
  63,
  52,
  45,
  31,
  52,
  28,
  19,
  14,
  8,
  9,
  3,
  123,
  60,
  58,
  53,
  47,
  43,
  32,
  22,
  37,
  24,
  17,
  12,
  15,
  10,
  2,
  1,
  71,
  37,
  34,
  30,
  28,
  20,
  17,
  26,
  21,
  16,
  10,
  6,
  8,
  6,
  2,
  0
];
Tables$4.t16HB = [
  1,
  5,
  14,
  44,
  74,
  63,
  110,
  93,
  172,
  149,
  138,
  242,
  225,
  195,
  376,
  17,
  3,
  4,
  12,
  20,
  35,
  62,
  53,
  47,
  83,
  75,
  68,
  119,
  201,
  107,
  207,
  9,
  15,
  13,
  23,
  38,
  67,
  58,
  103,
  90,
  161,
  72,
  127,
  117,
  110,
  209,
  206,
  16,
  45,
  21,
  39,
  69,
  64,
  114,
  99,
  87,
  158,
  140,
  252,
  212,
  199,
  387,
  365,
  26,
  75,
  36,
  68,
  65,
  115,
  101,
  179,
  164,
  155,
  264,
  246,
  226,
  395,
  382,
  362,
  9,
  66,
  30,
  59,
  56,
  102,
  185,
  173,
  265,
  142,
  253,
  232,
  400,
  388,
  378,
  445,
  16,
  111,
  54,
  52,
  100,
  184,
  178,
  160,
  133,
  257,
  244,
  228,
  217,
  385,
  366,
  715,
  10,
  98,
  48,
  91,
  88,
  165,
  157,
  148,
  261,
  248,
  407,
  397,
  372,
  380,
  889,
  884,
  8,
  85,
  84,
  81,
  159,
  156,
  143,
  260,
  249,
  427,
  401,
  392,
  383,
  727,
  713,
  708,
  7,
  154,
  76,
  73,
  141,
  131,
  256,
  245,
  426,
  406,
  394,
  384,
  735,
  359,
  710,
  352,
  11,
  139,
  129,
  67,
  125,
  247,
  233,
  229,
  219,
  393,
  743,
  737,
  720,
  885,
  882,
  439,
  4,
  243,
  120,
  118,
  115,
  227,
  223,
  396,
  746,
  742,
  736,
  721,
  712,
  706,
  223,
  436,
  6,
  202,
  224,
  222,
  218,
  216,
  389,
  386,
  381,
  364,
  888,
  443,
  707,
  440,
  437,
  1728,
  4,
  747,
  211,
  210,
  208,
  370,
  379,
  734,
  723,
  714,
  1735,
  883,
  877,
  876,
  3459,
  865,
  2,
  377,
  369,
  102,
  187,
  726,
  722,
  358,
  711,
  709,
  866,
  1734,
  871,
  3458,
  870,
  434,
  0,
  12,
  10,
  7,
  11,
  10,
  17,
  11,
  9,
  13,
  12,
  10,
  7,
  5,
  3,
  1,
  3
];
Tables$4.t24HB = [
  15,
  13,
  46,
  80,
  146,
  262,
  248,
  434,
  426,
  669,
  653,
  649,
  621,
  517,
  1032,
  88,
  14,
  12,
  21,
  38,
  71,
  130,
  122,
  216,
  209,
  198,
  327,
  345,
  319,
  297,
  279,
  42,
  47,
  22,
  41,
  74,
  68,
  128,
  120,
  221,
  207,
  194,
  182,
  340,
  315,
  295,
  541,
  18,
  81,
  39,
  75,
  70,
  134,
  125,
  116,
  220,
  204,
  190,
  178,
  325,
  311,
  293,
  271,
  16,
  147,
  72,
  69,
  135,
  127,
  118,
  112,
  210,
  200,
  188,
  352,
  323,
  306,
  285,
  540,
  14,
  263,
  66,
  129,
  126,
  119,
  114,
  214,
  202,
  192,
  180,
  341,
  317,
  301,
  281,
  262,
  12,
  249,
  123,
  121,
  117,
  113,
  215,
  206,
  195,
  185,
  347,
  330,
  308,
  291,
  272,
  520,
  10,
  435,
  115,
  111,
  109,
  211,
  203,
  196,
  187,
  353,
  332,
  313,
  298,
  283,
  531,
  381,
  17,
  427,
  212,
  208,
  205,
  201,
  193,
  186,
  177,
  169,
  320,
  303,
  286,
  268,
  514,
  377,
  16,
  335,
  199,
  197,
  191,
  189,
  181,
  174,
  333,
  321,
  305,
  289,
  275,
  521,
  379,
  371,
  11,
  668,
  184,
  183,
  179,
  175,
  344,
  331,
  314,
  304,
  290,
  277,
  530,
  383,
  373,
  366,
  10,
  652,
  346,
  171,
  168,
  164,
  318,
  309,
  299,
  287,
  276,
  263,
  513,
  375,
  368,
  362,
  6,
  648,
  322,
  316,
  312,
  307,
  302,
  292,
  284,
  269,
  261,
  512,
  376,
  370,
  364,
  359,
  4,
  620,
  300,
  296,
  294,
  288,
  282,
  273,
  266,
  515,
  380,
  374,
  369,
  365,
  361,
  357,
  2,
  1033,
  280,
  278,
  274,
  267,
  264,
  259,
  382,
  378,
  372,
  367,
  363,
  360,
  358,
  356,
  0,
  43,
  20,
  19,
  17,
  15,
  13,
  11,
  9,
  7,
  6,
  4,
  7,
  5,
  3,
  1,
  3
];
Tables$4.t32HB = [
  1 << 0,
  5 << 1,
  4 << 1,
  5 << 2,
  6 << 1,
  5 << 2,
  4 << 2,
  4 << 3,
  7 << 1,
  3 << 2,
  6 << 2,
  0 << 3,
  7 << 2,
  2 << 3,
  3 << 3,
  1 << 4
];
Tables$4.t33HB = [
  15 << 0,
  14 << 1,
  13 << 1,
  12 << 2,
  11 << 1,
  10 << 2,
  9 << 2,
  8 << 3,
  7 << 1,
  6 << 2,
  5 << 2,
  4 << 3,
  3 << 2,
  2 << 3,
  1 << 3,
  0 << 4
];
Tables$4.t1l = [
  1,
  4,
  3,
  5
];
Tables$4.t2l = [
  1,
  4,
  7,
  4,
  5,
  7,
  6,
  7,
  8
];
Tables$4.t3l = [
  2,
  3,
  7,
  4,
  4,
  7,
  6,
  7,
  8
];
Tables$4.t5l = [
  1,
  4,
  7,
  8,
  4,
  5,
  8,
  9,
  7,
  8,
  9,
  10,
  8,
  8,
  9,
  10
];
Tables$4.t6l = [
  3,
  4,
  6,
  8,
  4,
  4,
  6,
  7,
  5,
  6,
  7,
  8,
  7,
  7,
  8,
  9
];
Tables$4.t7l = [
  1,
  4,
  7,
  9,
  9,
  10,
  4,
  6,
  8,
  9,
  9,
  10,
  7,
  7,
  9,
  10,
  10,
  11,
  8,
  9,
  10,
  11,
  11,
  11,
  8,
  9,
  10,
  11,
  11,
  12,
  9,
  10,
  11,
  12,
  12,
  12
];
Tables$4.t8l = [
  2,
  4,
  7,
  9,
  9,
  10,
  4,
  4,
  6,
  10,
  10,
  10,
  7,
  6,
  8,
  10,
  10,
  11,
  9,
  10,
  10,
  11,
  11,
  12,
  9,
  9,
  10,
  11,
  12,
  12,
  10,
  10,
  11,
  11,
  13,
  13
];
Tables$4.t9l = [
  3,
  4,
  6,
  7,
  9,
  10,
  4,
  5,
  6,
  7,
  8,
  10,
  5,
  6,
  7,
  8,
  9,
  10,
  7,
  7,
  8,
  9,
  9,
  10,
  8,
  8,
  9,
  9,
  10,
  11,
  9,
  9,
  10,
  10,
  11,
  11
];
Tables$4.t10l = [
  1,
  4,
  7,
  9,
  10,
  10,
  10,
  11,
  4,
  6,
  8,
  9,
  10,
  11,
  10,
  10,
  7,
  8,
  9,
  10,
  11,
  12,
  11,
  11,
  8,
  9,
  10,
  11,
  12,
  12,
  11,
  12,
  9,
  10,
  11,
  12,
  12,
  12,
  12,
  12,
  10,
  11,
  12,
  12,
  13,
  13,
  12,
  13,
  9,
  10,
  11,
  12,
  12,
  12,
  13,
  13,
  10,
  10,
  11,
  12,
  12,
  13,
  13,
  13
];
Tables$4.t11l = [
  2,
  4,
  6,
  8,
  9,
  10,
  9,
  10,
  4,
  5,
  6,
  8,
  10,
  10,
  9,
  10,
  6,
  7,
  8,
  9,
  10,
  11,
  10,
  10,
  8,
  8,
  9,
  11,
  10,
  12,
  10,
  11,
  9,
  10,
  10,
  11,
  11,
  12,
  11,
  12,
  9,
  10,
  11,
  12,
  12,
  13,
  12,
  13,
  9,
  9,
  9,
  10,
  11,
  12,
  12,
  12,
  9,
  9,
  10,
  11,
  12,
  12,
  12,
  12
];
Tables$4.t12l = [
  4,
  4,
  6,
  8,
  9,
  10,
  10,
  10,
  4,
  5,
  6,
  7,
  9,
  9,
  10,
  10,
  6,
  6,
  7,
  8,
  9,
  10,
  9,
  10,
  7,
  7,
  8,
  8,
  9,
  10,
  10,
  10,
  8,
  8,
  9,
  9,
  10,
  10,
  10,
  11,
  9,
  9,
  10,
  10,
  10,
  11,
  10,
  11,
  9,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  10,
  10,
  10,
  11,
  11,
  11,
  11,
  12
];
Tables$4.t13l = [
  1,
  5,
  7,
  8,
  9,
  10,
  10,
  11,
  10,
  11,
  12,
  12,
  13,
  13,
  14,
  14,
  4,
  6,
  8,
  9,
  10,
  10,
  11,
  11,
  11,
  11,
  12,
  12,
  13,
  14,
  14,
  14,
  7,
  8,
  9,
  10,
  11,
  11,
  12,
  12,
  11,
  12,
  12,
  13,
  13,
  14,
  15,
  15,
  8,
  9,
  10,
  11,
  11,
  12,
  12,
  12,
  12,
  13,
  13,
  13,
  13,
  14,
  15,
  15,
  9,
  9,
  11,
  11,
  12,
  12,
  13,
  13,
  12,
  13,
  13,
  14,
  14,
  15,
  15,
  16,
  10,
  10,
  11,
  12,
  12,
  12,
  13,
  13,
  13,
  13,
  14,
  13,
  15,
  15,
  16,
  16,
  10,
  11,
  12,
  12,
  13,
  13,
  13,
  13,
  13,
  14,
  14,
  14,
  15,
  15,
  16,
  16,
  11,
  11,
  12,
  13,
  13,
  13,
  14,
  14,
  14,
  14,
  15,
  15,
  15,
  16,
  18,
  18,
  10,
  10,
  11,
  12,
  12,
  13,
  13,
  14,
  14,
  14,
  14,
  15,
  15,
  16,
  17,
  17,
  11,
  11,
  12,
  12,
  13,
  13,
  13,
  15,
  14,
  15,
  15,
  16,
  16,
  16,
  18,
  17,
  11,
  12,
  12,
  13,
  13,
  14,
  14,
  15,
  14,
  15,
  16,
  15,
  16,
  17,
  18,
  19,
  12,
  12,
  12,
  13,
  14,
  14,
  14,
  14,
  15,
  15,
  15,
  16,
  17,
  17,
  17,
  18,
  12,
  13,
  13,
  14,
  14,
  15,
  14,
  15,
  16,
  16,
  17,
  17,
  17,
  18,
  18,
  18,
  13,
  13,
  14,
  15,
  15,
  15,
  16,
  16,
  16,
  16,
  16,
  17,
  18,
  17,
  18,
  18,
  14,
  14,
  14,
  15,
  15,
  15,
  17,
  16,
  16,
  19,
  17,
  17,
  17,
  19,
  18,
  18,
  13,
  14,
  15,
  16,
  16,
  16,
  17,
  16,
  17,
  17,
  18,
  18,
  21,
  20,
  21,
  18
];
Tables$4.t15l = [
  3,
  5,
  6,
  8,
  8,
  9,
  10,
  10,
  10,
  11,
  11,
  12,
  12,
  12,
  13,
  14,
  5,
  5,
  7,
  8,
  9,
  9,
  10,
  10,
  10,
  11,
  11,
  12,
  12,
  12,
  13,
  13,
  6,
  7,
  7,
  8,
  9,
  9,
  10,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  13,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  11,
  12,
  12,
  12,
  13,
  13,
  13,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  11,
  11,
  12,
  12,
  12,
  13,
  13,
  13,
  9,
  9,
  9,
  10,
  10,
  10,
  11,
  11,
  11,
  11,
  12,
  12,
  13,
  13,
  13,
  14,
  10,
  9,
  10,
  10,
  10,
  11,
  11,
  11,
  11,
  12,
  12,
  12,
  13,
  13,
  14,
  14,
  10,
  10,
  10,
  11,
  11,
  11,
  11,
  12,
  12,
  12,
  12,
  12,
  13,
  13,
  13,
  14,
  10,
  10,
  10,
  11,
  11,
  11,
  11,
  12,
  12,
  12,
  12,
  13,
  13,
  14,
  14,
  14,
  10,
  10,
  11,
  11,
  11,
  11,
  12,
  12,
  12,
  13,
  13,
  13,
  13,
  14,
  14,
  14,
  11,
  11,
  11,
  11,
  12,
  12,
  12,
  12,
  12,
  13,
  13,
  13,
  13,
  14,
  15,
  14,
  11,
  11,
  11,
  11,
  12,
  12,
  12,
  12,
  13,
  13,
  13,
  13,
  14,
  14,
  14,
  15,
  12,
  12,
  11,
  12,
  12,
  12,
  13,
  13,
  13,
  13,
  13,
  13,
  14,
  14,
  15,
  15,
  12,
  12,
  12,
  12,
  12,
  13,
  13,
  13,
  13,
  14,
  14,
  14,
  14,
  14,
  15,
  15,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  14,
  14,
  14,
  14,
  15,
  15,
  14,
  15,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  14,
  14,
  14,
  14,
  14,
  15,
  15,
  15,
  15
];
Tables$4.t16_5l = [
  1,
  5,
  7,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  12,
  13,
  13,
  13,
  14,
  11,
  4,
  6,
  8,
  9,
  10,
  11,
  11,
  11,
  12,
  12,
  12,
  13,
  14,
  13,
  14,
  11,
  7,
  8,
  9,
  10,
  11,
  11,
  12,
  12,
  13,
  12,
  13,
  13,
  13,
  14,
  14,
  12,
  9,
  9,
  10,
  11,
  11,
  12,
  12,
  12,
  13,
  13,
  14,
  14,
  14,
  15,
  15,
  13,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  13,
  14,
  14,
  14,
  15,
  15,
  15,
  12,
  10,
  10,
  11,
  11,
  12,
  13,
  13,
  14,
  13,
  14,
  14,
  15,
  15,
  15,
  16,
  13,
  11,
  11,
  11,
  12,
  13,
  13,
  13,
  13,
  14,
  14,
  14,
  14,
  15,
  15,
  16,
  13,
  11,
  11,
  12,
  12,
  13,
  13,
  13,
  14,
  14,
  15,
  15,
  15,
  15,
  17,
  17,
  13,
  11,
  12,
  12,
  13,
  13,
  13,
  14,
  14,
  15,
  15,
  15,
  15,
  16,
  16,
  16,
  13,
  12,
  12,
  12,
  13,
  13,
  14,
  14,
  15,
  15,
  15,
  15,
  16,
  15,
  16,
  15,
  14,
  12,
  13,
  12,
  13,
  14,
  14,
  14,
  14,
  15,
  16,
  16,
  16,
  17,
  17,
  16,
  13,
  13,
  13,
  13,
  13,
  14,
  14,
  15,
  16,
  16,
  16,
  16,
  16,
  16,
  15,
  16,
  14,
  13,
  14,
  14,
  14,
  14,
  15,
  15,
  15,
  15,
  17,
  16,
  16,
  16,
  16,
  18,
  14,
  15,
  14,
  14,
  14,
  15,
  15,
  16,
  16,
  16,
  18,
  17,
  17,
  17,
  19,
  17,
  14,
  14,
  15,
  13,
  14,
  16,
  16,
  15,
  16,
  16,
  17,
  18,
  17,
  19,
  17,
  16,
  14,
  11,
  11,
  11,
  12,
  12,
  13,
  13,
  13,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  12
];
Tables$4.t16l = [
  1,
  5,
  7,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  12,
  13,
  13,
  13,
  14,
  10,
  4,
  6,
  8,
  9,
  10,
  11,
  11,
  11,
  12,
  12,
  12,
  13,
  14,
  13,
  14,
  10,
  7,
  8,
  9,
  10,
  11,
  11,
  12,
  12,
  13,
  12,
  13,
  13,
  13,
  14,
  14,
  11,
  9,
  9,
  10,
  11,
  11,
  12,
  12,
  12,
  13,
  13,
  14,
  14,
  14,
  15,
  15,
  12,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  13,
  14,
  14,
  14,
  15,
  15,
  15,
  11,
  10,
  10,
  11,
  11,
  12,
  13,
  13,
  14,
  13,
  14,
  14,
  15,
  15,
  15,
  16,
  12,
  11,
  11,
  11,
  12,
  13,
  13,
  13,
  13,
  14,
  14,
  14,
  14,
  15,
  15,
  16,
  12,
  11,
  11,
  12,
  12,
  13,
  13,
  13,
  14,
  14,
  15,
  15,
  15,
  15,
  17,
  17,
  12,
  11,
  12,
  12,
  13,
  13,
  13,
  14,
  14,
  15,
  15,
  15,
  15,
  16,
  16,
  16,
  12,
  12,
  12,
  12,
  13,
  13,
  14,
  14,
  15,
  15,
  15,
  15,
  16,
  15,
  16,
  15,
  13,
  12,
  13,
  12,
  13,
  14,
  14,
  14,
  14,
  15,
  16,
  16,
  16,
  17,
  17,
  16,
  12,
  13,
  13,
  13,
  13,
  14,
  14,
  15,
  16,
  16,
  16,
  16,
  16,
  16,
  15,
  16,
  13,
  13,
  14,
  14,
  14,
  14,
  15,
  15,
  15,
  15,
  17,
  16,
  16,
  16,
  16,
  18,
  13,
  15,
  14,
  14,
  14,
  15,
  15,
  16,
  16,
  16,
  18,
  17,
  17,
  17,
  19,
  17,
  13,
  14,
  15,
  13,
  14,
  16,
  16,
  15,
  16,
  16,
  17,
  18,
  17,
  19,
  17,
  16,
  13,
  10,
  10,
  10,
  11,
  11,
  12,
  12,
  12,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  10
];
Tables$4.t24l = [
  4,
  5,
  7,
  8,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  12,
  12,
  12,
  13,
  10,
  5,
  6,
  7,
  8,
  9,
  10,
  10,
  11,
  11,
  11,
  12,
  12,
  12,
  12,
  12,
  10,
  7,
  7,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  11,
  11,
  12,
  12,
  12,
  13,
  9,
  8,
  8,
  9,
  9,
  10,
  10,
  10,
  11,
  11,
  11,
  11,
  12,
  12,
  12,
  12,
  9,
  9,
  9,
  9,
  10,
  10,
  10,
  10,
  11,
  11,
  11,
  12,
  12,
  12,
  12,
  13,
  9,
  10,
  9,
  10,
  10,
  10,
  10,
  11,
  11,
  11,
  11,
  12,
  12,
  12,
  12,
  12,
  9,
  10,
  10,
  10,
  10,
  10,
  11,
  11,
  11,
  11,
  12,
  12,
  12,
  12,
  12,
  13,
  9,
  11,
  10,
  10,
  10,
  11,
  11,
  11,
  11,
  12,
  12,
  12,
  12,
  12,
  13,
  13,
  10,
  11,
  11,
  11,
  11,
  11,
  11,
  11,
  11,
  11,
  12,
  12,
  12,
  12,
  13,
  13,
  10,
  11,
  11,
  11,
  11,
  11,
  11,
  11,
  12,
  12,
  12,
  12,
  12,
  13,
  13,
  13,
  10,
  12,
  11,
  11,
  11,
  11,
  12,
  12,
  12,
  12,
  12,
  12,
  13,
  13,
  13,
  13,
  10,
  12,
  12,
  11,
  11,
  11,
  12,
  12,
  12,
  12,
  12,
  12,
  13,
  13,
  13,
  13,
  10,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  13,
  13,
  13,
  13,
  13,
  10,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  10,
  13,
  12,
  12,
  12,
  12,
  12,
  12,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  10,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  10,
  10,
  10,
  10,
  6
];
Tables$4.t32l = [
  1 + 0,
  4 + 1,
  4 + 1,
  5 + 2,
  4 + 1,
  6 + 2,
  5 + 2,
  6 + 3,
  4 + 1,
  5 + 2,
  5 + 2,
  6 + 3,
  5 + 2,
  6 + 3,
  6 + 3,
  6 + 4
];
Tables$4.t33l = [
  4 + 0,
  4 + 1,
  4 + 1,
  4 + 2,
  4 + 1,
  4 + 2,
  4 + 2,
  4 + 3,
  4 + 1,
  4 + 2,
  4 + 2,
  4 + 3,
  4 + 2,
  4 + 3,
  4 + 3,
  4 + 4
];
Tables$4.ht = [
  /* xlen, linmax, table, hlen */
  new HuffCodeTab(0, 0, null, null),
  new HuffCodeTab(2, 0, Tables$4.t1HB, Tables$4.t1l),
  new HuffCodeTab(3, 0, Tables$4.t2HB, Tables$4.t2l),
  new HuffCodeTab(3, 0, Tables$4.t3HB, Tables$4.t3l),
  new HuffCodeTab(0, 0, null, null),
  /* Apparently not used */
  new HuffCodeTab(4, 0, Tables$4.t5HB, Tables$4.t5l),
  new HuffCodeTab(4, 0, Tables$4.t6HB, Tables$4.t6l),
  new HuffCodeTab(6, 0, Tables$4.t7HB, Tables$4.t7l),
  new HuffCodeTab(6, 0, Tables$4.t8HB, Tables$4.t8l),
  new HuffCodeTab(6, 0, Tables$4.t9HB, Tables$4.t9l),
  new HuffCodeTab(8, 0, Tables$4.t10HB, Tables$4.t10l),
  new HuffCodeTab(8, 0, Tables$4.t11HB, Tables$4.t11l),
  new HuffCodeTab(8, 0, Tables$4.t12HB, Tables$4.t12l),
  new HuffCodeTab(16, 0, Tables$4.t13HB, Tables$4.t13l),
  new HuffCodeTab(0, 0, null, Tables$4.t16_5l),
  /* Apparently not used */
  new HuffCodeTab(16, 0, Tables$4.t15HB, Tables$4.t15l),
  new HuffCodeTab(1, 1, Tables$4.t16HB, Tables$4.t16l),
  new HuffCodeTab(2, 3, Tables$4.t16HB, Tables$4.t16l),
  new HuffCodeTab(3, 7, Tables$4.t16HB, Tables$4.t16l),
  new HuffCodeTab(4, 15, Tables$4.t16HB, Tables$4.t16l),
  new HuffCodeTab(6, 63, Tables$4.t16HB, Tables$4.t16l),
  new HuffCodeTab(8, 255, Tables$4.t16HB, Tables$4.t16l),
  new HuffCodeTab(10, 1023, Tables$4.t16HB, Tables$4.t16l),
  new HuffCodeTab(13, 8191, Tables$4.t16HB, Tables$4.t16l),
  new HuffCodeTab(4, 15, Tables$4.t24HB, Tables$4.t24l),
  new HuffCodeTab(5, 31, Tables$4.t24HB, Tables$4.t24l),
  new HuffCodeTab(6, 63, Tables$4.t24HB, Tables$4.t24l),
  new HuffCodeTab(7, 127, Tables$4.t24HB, Tables$4.t24l),
  new HuffCodeTab(8, 255, Tables$4.t24HB, Tables$4.t24l),
  new HuffCodeTab(9, 511, Tables$4.t24HB, Tables$4.t24l),
  new HuffCodeTab(11, 2047, Tables$4.t24HB, Tables$4.t24l),
  new HuffCodeTab(13, 8191, Tables$4.t24HB, Tables$4.t24l),
  new HuffCodeTab(0, 0, Tables$4.t32HB, Tables$4.t32l),
  new HuffCodeTab(0, 0, Tables$4.t33HB, Tables$4.t33l)
];
Tables$4.largetbl = [
  65540,
  327685,
  458759,
  589832,
  655369,
  655370,
  720906,
  720907,
  786443,
  786444,
  786444,
  851980,
  851980,
  851980,
  917517,
  655370,
  262149,
  393222,
  524295,
  589832,
  655369,
  720906,
  720906,
  720907,
  786443,
  786443,
  786444,
  851980,
  917516,
  851980,
  917516,
  655370,
  458759,
  524295,
  589832,
  655369,
  720905,
  720906,
  786442,
  786443,
  851979,
  786443,
  851979,
  851980,
  851980,
  917516,
  917517,
  720905,
  589832,
  589832,
  655369,
  720905,
  720906,
  786442,
  786442,
  786443,
  851979,
  851979,
  917515,
  917516,
  917516,
  983052,
  983052,
  786441,
  655369,
  655369,
  720905,
  720906,
  786442,
  786442,
  851978,
  851979,
  851979,
  917515,
  917516,
  917516,
  983052,
  983052,
  983053,
  720905,
  655370,
  655369,
  720906,
  720906,
  786442,
  851978,
  851979,
  917515,
  851979,
  917515,
  917516,
  983052,
  983052,
  983052,
  1048588,
  786441,
  720906,
  720906,
  720906,
  786442,
  851978,
  851979,
  851979,
  851979,
  917515,
  917516,
  917516,
  917516,
  983052,
  983052,
  1048589,
  786441,
  720907,
  720906,
  786442,
  786442,
  851979,
  851979,
  851979,
  917515,
  917516,
  983052,
  983052,
  983052,
  983052,
  1114125,
  1114125,
  786442,
  720907,
  786443,
  786443,
  851979,
  851979,
  851979,
  917515,
  917515,
  983051,
  983052,
  983052,
  983052,
  1048588,
  1048589,
  1048589,
  786442,
  786443,
  786443,
  786443,
  851979,
  851979,
  917515,
  917515,
  983052,
  983052,
  983052,
  983052,
  1048588,
  983053,
  1048589,
  983053,
  851978,
  786444,
  851979,
  786443,
  851979,
  917515,
  917516,
  917516,
  917516,
  983052,
  1048588,
  1048588,
  1048589,
  1114125,
  1114125,
  1048589,
  786442,
  851980,
  851980,
  851979,
  851979,
  917515,
  917516,
  983052,
  1048588,
  1048588,
  1048588,
  1048588,
  1048589,
  1048589,
  983053,
  1048589,
  851978,
  851980,
  917516,
  917516,
  917516,
  917516,
  983052,
  983052,
  983052,
  983052,
  1114124,
  1048589,
  1048589,
  1048589,
  1048589,
  1179661,
  851978,
  983052,
  917516,
  917516,
  917516,
  983052,
  983052,
  1048588,
  1048588,
  1048589,
  1179661,
  1114125,
  1114125,
  1114125,
  1245197,
  1114125,
  851978,
  917517,
  983052,
  851980,
  917516,
  1048588,
  1048588,
  983052,
  1048589,
  1048589,
  1114125,
  1179661,
  1114125,
  1245197,
  1114125,
  1048589,
  851978,
  655369,
  655369,
  655369,
  720905,
  720905,
  786441,
  786441,
  786441,
  851977,
  851977,
  851977,
  851978,
  851978,
  851978,
  851978,
  655366
];
Tables$4.table23 = [
  65538,
  262147,
  458759,
  262148,
  327684,
  458759,
  393222,
  458759,
  524296
];
Tables$4.table56 = [
  65539,
  262148,
  458758,
  524296,
  262148,
  327684,
  524294,
  589831,
  458757,
  524294,
  589831,
  655368,
  524295,
  524295,
  589832,
  655369
];
Tables$4.bitrate_table = [
  [0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, -1],
  /* MPEG 2 */
  [0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, -1],
  /* MPEG 1 */
  [0, 8, 16, 24, 32, 40, 48, 56, 64, -1, -1, -1, -1, -1, -1, -1]
  /* MPEG 2.5 */
];
Tables$4.samplerate_table = [
  [22050, 24e3, 16e3, -1],
  [44100, 48e3, 32e3, -1],
  [11025, 12e3, 8e3, -1]
];
Tables$4.scfsi_band = [0, 6, 11, 16, 21];
var Tables_1 = Tables$4;
var ScaleFac = ScaleFac_1;
var common$9 = common$l;
common$9.System;
var VbrMode$4 = common$9.VbrMode;
var Float = common$9.Float;
common$9.ShortBlock;
var Util$1 = common$9.Util;
common$9.Arrays;
common$9.new_array_n;
common$9.new_byte;
common$9.new_double;
var new_float$3 = common$9.new_float;
common$9.new_float_n;
var new_int$3 = common$9.new_int;
common$9.new_int_n;
var assert$7 = common$9.assert;
var Encoder$4 = requireEncoder();
var MeanBits$1 = MeanBits_1;
var LameInternalFlags$3 = LameInternalFlags_1;
QuantizePVT$2.Q_MAX = 256 + 1;
QuantizePVT$2.Q_MAX2 = 116;
QuantizePVT$2.LARGE_BITS = 1e5;
QuantizePVT$2.IXMAX_VAL = 8206;
function QuantizePVT$2() {
  var tak = null;
  var rv = null;
  var psy = null;
  this.setModules = function(_tk, _rv, _psy) {
    tak = _tk;
    rv = _rv;
    psy = _psy;
  };
  function POW20(x) {
    assert$7(0 <= x + QuantizePVT$2.Q_MAX2 && x < QuantizePVT$2.Q_MAX);
    return pow20[x + QuantizePVT$2.Q_MAX2];
  }
  this.IPOW20 = function(x) {
    assert$7(0 <= x && x < QuantizePVT$2.Q_MAX);
    return ipow20[x];
  };
  var DBL_EPSILON = 2220446049250313e-31;
  var IXMAX_VAL = QuantizePVT$2.IXMAX_VAL;
  var PRECALC_SIZE = IXMAX_VAL + 2;
  var Q_MAX = QuantizePVT$2.Q_MAX;
  var Q_MAX2 = QuantizePVT$2.Q_MAX2;
  QuantizePVT$2.LARGE_BITS;
  var NSATHSCALE = 100;
  this.nr_of_sfb_block = [
    [[6, 5, 5, 5], [9, 9, 9, 9], [6, 9, 9, 9]],
    [[6, 5, 7, 3], [9, 9, 12, 6], [6, 9, 12, 6]],
    [[11, 10, 0, 0], [18, 18, 0, 0], [15, 18, 0, 0]],
    [[7, 7, 7, 0], [12, 12, 12, 0], [6, 15, 12, 0]],
    [[6, 6, 6, 3], [12, 9, 9, 6], [6, 12, 9, 6]],
    [[8, 8, 5, 0], [15, 12, 9, 0], [6, 18, 9, 0]]
  ];
  var pretab = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    3,
    3,
    3,
    2,
    0
  ];
  this.pretab = pretab;
  this.sfBandIndex = [
    // Table B.2.b: 22.05 kHz
    new ScaleFac(
      [
        0,
        6,
        12,
        18,
        24,
        30,
        36,
        44,
        54,
        66,
        80,
        96,
        116,
        140,
        168,
        200,
        238,
        284,
        336,
        396,
        464,
        522,
        576
      ],
      [0, 4, 8, 12, 18, 24, 32, 42, 56, 74, 100, 132, 174, 192],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0]
      //  sfb12 pseudo sub bands
    ),
    /* Table B.2.c: 24 kHz */
    /* docs: 332. mpg123(broken): 330 */
    new ScaleFac(
      [
        0,
        6,
        12,
        18,
        24,
        30,
        36,
        44,
        54,
        66,
        80,
        96,
        114,
        136,
        162,
        194,
        232,
        278,
        332,
        394,
        464,
        540,
        576
      ],
      [0, 4, 8, 12, 18, 26, 36, 48, 62, 80, 104, 136, 180, 192],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0]
      /*  sfb12 pseudo sub bands */
    ),
    /* Table B.2.a: 16 kHz */
    new ScaleFac(
      [
        0,
        6,
        12,
        18,
        24,
        30,
        36,
        44,
        54,
        66,
        80,
        96,
        116,
        140,
        168,
        200,
        238,
        284,
        336,
        396,
        464,
        522,
        576
      ],
      [0, 4, 8, 12, 18, 26, 36, 48, 62, 80, 104, 134, 174, 192],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0]
      /*  sfb12 pseudo sub bands */
    ),
    /* Table B.8.b: 44.1 kHz */
    new ScaleFac(
      [
        0,
        4,
        8,
        12,
        16,
        20,
        24,
        30,
        36,
        44,
        52,
        62,
        74,
        90,
        110,
        134,
        162,
        196,
        238,
        288,
        342,
        418,
        576
      ],
      [0, 4, 8, 12, 16, 22, 30, 40, 52, 66, 84, 106, 136, 192],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0]
      /*  sfb12 pseudo sub bands */
    ),
    /* Table B.8.c: 48 kHz */
    new ScaleFac(
      [
        0,
        4,
        8,
        12,
        16,
        20,
        24,
        30,
        36,
        42,
        50,
        60,
        72,
        88,
        106,
        128,
        156,
        190,
        230,
        276,
        330,
        384,
        576
      ],
      [0, 4, 8, 12, 16, 22, 28, 38, 50, 64, 80, 100, 126, 192],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0]
      /*  sfb12 pseudo sub bands */
    ),
    /* Table B.8.a: 32 kHz */
    new ScaleFac(
      [
        0,
        4,
        8,
        12,
        16,
        20,
        24,
        30,
        36,
        44,
        54,
        66,
        82,
        102,
        126,
        156,
        194,
        240,
        296,
        364,
        448,
        550,
        576
      ],
      [0, 4, 8, 12, 16, 22, 30, 42, 58, 78, 104, 138, 180, 192],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0]
      /*  sfb12 pseudo sub bands */
    ),
    /* MPEG-2.5 11.025 kHz */
    new ScaleFac(
      [
        0,
        6,
        12,
        18,
        24,
        30,
        36,
        44,
        54,
        66,
        80,
        96,
        116,
        140,
        168,
        200,
        238,
        284,
        336,
        396,
        464,
        522,
        576
      ],
      [
        0 / 3,
        12 / 3,
        24 / 3,
        36 / 3,
        54 / 3,
        78 / 3,
        108 / 3,
        144 / 3,
        186 / 3,
        240 / 3,
        312 / 3,
        402 / 3,
        522 / 3,
        576 / 3
      ],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0]
      /*  sfb12 pseudo sub bands */
    ),
    /* MPEG-2.5 12 kHz */
    new ScaleFac(
      [
        0,
        6,
        12,
        18,
        24,
        30,
        36,
        44,
        54,
        66,
        80,
        96,
        116,
        140,
        168,
        200,
        238,
        284,
        336,
        396,
        464,
        522,
        576
      ],
      [
        0 / 3,
        12 / 3,
        24 / 3,
        36 / 3,
        54 / 3,
        78 / 3,
        108 / 3,
        144 / 3,
        186 / 3,
        240 / 3,
        312 / 3,
        402 / 3,
        522 / 3,
        576 / 3
      ],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0]
      /*  sfb12 pseudo sub bands */
    ),
    /* MPEG-2.5 8 kHz */
    new ScaleFac(
      [
        0,
        12,
        24,
        36,
        48,
        60,
        72,
        88,
        108,
        132,
        160,
        192,
        232,
        280,
        336,
        400,
        476,
        566,
        568,
        570,
        572,
        574,
        576
      ],
      [
        0 / 3,
        24 / 3,
        48 / 3,
        72 / 3,
        108 / 3,
        156 / 3,
        216 / 3,
        288 / 3,
        372 / 3,
        480 / 3,
        486 / 3,
        492 / 3,
        498 / 3,
        576 / 3
      ],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0]
      /*  sfb12 pseudo sub bands */
    )
  ];
  var pow20 = new_float$3(Q_MAX + Q_MAX2 + 1);
  var ipow20 = new_float$3(Q_MAX);
  var pow43 = new_float$3(PRECALC_SIZE);
  var adj43 = new_float$3(PRECALC_SIZE);
  this.adj43 = adj43;
  function ATHmdct(gfp, f) {
    var ath = psy.ATHformula(f, gfp);
    ath -= NSATHSCALE;
    ath = Math.pow(10, ath / 10 + gfp.ATHlower);
    return ath;
  }
  function compute_ath(gfp) {
    var ATH_l = gfp.internal_flags.ATH.l;
    var ATH_psfb21 = gfp.internal_flags.ATH.psfb21;
    var ATH_s = gfp.internal_flags.ATH.s;
    var ATH_psfb12 = gfp.internal_flags.ATH.psfb12;
    var gfc = gfp.internal_flags;
    var samp_freq = gfp.out_samplerate;
    for (var sfb = 0; sfb < Encoder$4.SBMAX_l; sfb++) {
      var start = gfc.scalefac_band.l[sfb];
      var end = gfc.scalefac_band.l[sfb + 1];
      ATH_l[sfb] = Float.MAX_VALUE;
      for (var i = start; i < end; i++) {
        var freq = i * samp_freq / (2 * 576);
        var ATH_f = ATHmdct(gfp, freq);
        ATH_l[sfb] = Math.min(ATH_l[sfb], ATH_f);
      }
    }
    for (var sfb = 0; sfb < Encoder$4.PSFB21; sfb++) {
      var start = gfc.scalefac_band.psfb21[sfb];
      var end = gfc.scalefac_band.psfb21[sfb + 1];
      ATH_psfb21[sfb] = Float.MAX_VALUE;
      for (var i = start; i < end; i++) {
        var freq = i * samp_freq / (2 * 576);
        var ATH_f = ATHmdct(gfp, freq);
        ATH_psfb21[sfb] = Math.min(ATH_psfb21[sfb], ATH_f);
      }
    }
    for (var sfb = 0; sfb < Encoder$4.SBMAX_s; sfb++) {
      var start = gfc.scalefac_band.s[sfb];
      var end = gfc.scalefac_band.s[sfb + 1];
      ATH_s[sfb] = Float.MAX_VALUE;
      for (var i = start; i < end; i++) {
        var freq = i * samp_freq / (2 * 192);
        var ATH_f = ATHmdct(gfp, freq);
        ATH_s[sfb] = Math.min(ATH_s[sfb], ATH_f);
      }
      ATH_s[sfb] *= gfc.scalefac_band.s[sfb + 1] - gfc.scalefac_band.s[sfb];
    }
    for (var sfb = 0; sfb < Encoder$4.PSFB12; sfb++) {
      var start = gfc.scalefac_band.psfb12[sfb];
      var end = gfc.scalefac_band.psfb12[sfb + 1];
      ATH_psfb12[sfb] = Float.MAX_VALUE;
      for (var i = start; i < end; i++) {
        var freq = i * samp_freq / (2 * 192);
        var ATH_f = ATHmdct(gfp, freq);
        ATH_psfb12[sfb] = Math.min(ATH_psfb12[sfb], ATH_f);
      }
      ATH_psfb12[sfb] *= gfc.scalefac_band.s[13] - gfc.scalefac_band.s[12];
    }
    if (gfp.noATH) {
      for (var sfb = 0; sfb < Encoder$4.SBMAX_l; sfb++) {
        ATH_l[sfb] = 1e-20;
      }
      for (var sfb = 0; sfb < Encoder$4.PSFB21; sfb++) {
        ATH_psfb21[sfb] = 1e-20;
      }
      for (var sfb = 0; sfb < Encoder$4.SBMAX_s; sfb++) {
        ATH_s[sfb] = 1e-20;
      }
      for (var sfb = 0; sfb < Encoder$4.PSFB12; sfb++) {
        ATH_psfb12[sfb] = 1e-20;
      }
    }
    gfc.ATH.floor = 10 * Math.log10(ATHmdct(gfp, -1));
  }
  this.iteration_init = function(gfp) {
    var gfc = gfp.internal_flags;
    var l3_side = gfc.l3_side;
    var i;
    if (gfc.iteration_init_init == 0) {
      gfc.iteration_init_init = 1;
      l3_side.main_data_begin = 0;
      compute_ath(gfp);
      pow43[0] = 0;
      for (i = 1; i < PRECALC_SIZE; i++)
        pow43[i] = Math.pow(i, 4 / 3);
      for (i = 0; i < PRECALC_SIZE - 1; i++)
        adj43[i] = i + 1 - Math.pow(
          0.5 * (pow43[i] + pow43[i + 1]),
          0.75
        );
      adj43[i] = 0.5;
      for (i = 0; i < Q_MAX; i++)
        ipow20[i] = Math.pow(2, (i - 210) * -0.1875);
      for (i = 0; i <= Q_MAX + Q_MAX2; i++)
        pow20[i] = Math.pow(2, (i - 210 - Q_MAX2) * 0.25);
      tak.huffman_init(gfc);
      {
        var bass, alto, treble, sfb21;
        i = gfp.exp_nspsytune >> 2 & 63;
        if (i >= 32)
          i -= 64;
        bass = Math.pow(10, i / 4 / 10);
        i = gfp.exp_nspsytune >> 8 & 63;
        if (i >= 32)
          i -= 64;
        alto = Math.pow(10, i / 4 / 10);
        i = gfp.exp_nspsytune >> 14 & 63;
        if (i >= 32)
          i -= 64;
        treble = Math.pow(10, i / 4 / 10);
        i = gfp.exp_nspsytune >> 20 & 63;
        if (i >= 32)
          i -= 64;
        sfb21 = treble * Math.pow(10, i / 4 / 10);
        for (i = 0; i < Encoder$4.SBMAX_l; i++) {
          var f;
          if (i <= 6)
            f = bass;
          else if (i <= 13)
            f = alto;
          else if (i <= 20)
            f = treble;
          else
            f = sfb21;
          gfc.nsPsy.longfact[i] = f;
        }
        for (i = 0; i < Encoder$4.SBMAX_s; i++) {
          var f;
          if (i <= 5)
            f = bass;
          else if (i <= 10)
            f = alto;
          else if (i <= 11)
            f = treble;
          else
            f = sfb21;
          gfc.nsPsy.shortfact[i] = f;
        }
      }
    }
  };
  this.on_pe = function(gfp, pe, targ_bits, mean_bits, gr, cbr) {
    var gfc = gfp.internal_flags;
    var tbits = 0, bits;
    var add_bits = new_int$3(2);
    var ch;
    var mb = new MeanBits$1(tbits);
    var extra_bits = rv.ResvMaxBits(gfp, mean_bits, mb, cbr);
    tbits = mb.bits;
    var max_bits = tbits + extra_bits;
    if (max_bits > LameInternalFlags$3.MAX_BITS_PER_GRANULE) {
      max_bits = LameInternalFlags$3.MAX_BITS_PER_GRANULE;
    }
    for (bits = 0, ch = 0; ch < gfc.channels_out; ++ch) {
      targ_bits[ch] = Math.min(
        LameInternalFlags$3.MAX_BITS_PER_CHANNEL,
        tbits / gfc.channels_out
      );
      add_bits[ch] = 0 | targ_bits[ch] * pe[gr][ch] / 700 - targ_bits[ch];
      if (add_bits[ch] > mean_bits * 3 / 4)
        add_bits[ch] = mean_bits * 3 / 4;
      if (add_bits[ch] < 0)
        add_bits[ch] = 0;
      if (add_bits[ch] + targ_bits[ch] > LameInternalFlags$3.MAX_BITS_PER_CHANNEL)
        add_bits[ch] = Math.max(
          0,
          LameInternalFlags$3.MAX_BITS_PER_CHANNEL - targ_bits[ch]
        );
      bits += add_bits[ch];
    }
    if (bits > extra_bits) {
      for (ch = 0; ch < gfc.channels_out; ++ch) {
        add_bits[ch] = extra_bits * add_bits[ch] / bits;
      }
    }
    for (ch = 0; ch < gfc.channels_out; ++ch) {
      targ_bits[ch] += add_bits[ch];
      extra_bits -= add_bits[ch];
    }
    for (bits = 0, ch = 0; ch < gfc.channels_out; ++ch) {
      bits += targ_bits[ch];
    }
    if (bits > LameInternalFlags$3.MAX_BITS_PER_GRANULE) {
      var sum = 0;
      for (ch = 0; ch < gfc.channels_out; ++ch) {
        targ_bits[ch] *= LameInternalFlags$3.MAX_BITS_PER_GRANULE;
        targ_bits[ch] /= bits;
        sum += targ_bits[ch];
      }
      assert$7(sum <= LameInternalFlags$3.MAX_BITS_PER_GRANULE);
    }
    return max_bits;
  };
  this.reduce_side = function(targ_bits, ms_ener_ratio, mean_bits, max_bits) {
    assert$7(max_bits <= LameInternalFlags$3.MAX_BITS_PER_GRANULE);
    assert$7(targ_bits[0] + targ_bits[1] <= LameInternalFlags$3.MAX_BITS_PER_GRANULE);
    var fac = 0.33 * (0.5 - ms_ener_ratio) / 0.5;
    if (fac < 0)
      fac = 0;
    if (fac > 0.5)
      fac = 0.5;
    var move_bits = 0 | fac * 0.5 * (targ_bits[0] + targ_bits[1]);
    if (move_bits > LameInternalFlags$3.MAX_BITS_PER_CHANNEL - targ_bits[0]) {
      move_bits = LameInternalFlags$3.MAX_BITS_PER_CHANNEL - targ_bits[0];
    }
    if (move_bits < 0)
      move_bits = 0;
    if (targ_bits[1] >= 125) {
      if (targ_bits[1] - move_bits > 125) {
        if (targ_bits[0] < mean_bits)
          targ_bits[0] += move_bits;
        targ_bits[1] -= move_bits;
      } else {
        targ_bits[0] += targ_bits[1] - 125;
        targ_bits[1] = 125;
      }
    }
    move_bits = targ_bits[0] + targ_bits[1];
    if (move_bits > max_bits) {
      targ_bits[0] = max_bits * targ_bits[0] / move_bits;
      targ_bits[1] = max_bits * targ_bits[1] / move_bits;
    }
    assert$7(targ_bits[0] <= LameInternalFlags$3.MAX_BITS_PER_CHANNEL);
    assert$7(targ_bits[1] <= LameInternalFlags$3.MAX_BITS_PER_CHANNEL);
    assert$7(targ_bits[0] + targ_bits[1] <= LameInternalFlags$3.MAX_BITS_PER_GRANULE);
  };
  this.athAdjust = function(a, x, athFloor) {
    var o = 90.30873362;
    var p2 = 94.82444863;
    var u = Util$1.FAST_LOG10_X(x, 10);
    var v = a * a;
    var w = 0;
    u -= athFloor;
    if (v > 1e-20)
      w = 1 + Util$1.FAST_LOG10_X(v, 10 / o);
    if (w < 0)
      w = 0;
    u *= w;
    u += athFloor + o - p2;
    return Math.pow(10, 0.1 * u);
  };
  this.calc_xmin = function(gfp, ratio, cod_info, pxmin) {
    var pxminPos = 0;
    var gfc = gfp.internal_flags;
    var gsfb, j = 0, ath_over = 0;
    var ATH2 = gfc.ATH;
    var xr = cod_info.xr;
    var enable_athaa_fix = gfp.VBR == VbrMode$4.vbr_mtrh ? 1 : 0;
    var masking_lower = gfc.masking_lower;
    if (gfp.VBR == VbrMode$4.vbr_mtrh || gfp.VBR == VbrMode$4.vbr_mt) {
      masking_lower = 1;
    }
    for (gsfb = 0; gsfb < cod_info.psy_lmax; gsfb++) {
      var en0, xmin;
      var rh1, rh2;
      var width, l;
      if (gfp.VBR == VbrMode$4.vbr_rh || gfp.VBR == VbrMode$4.vbr_mtrh)
        xmin = athAdjust(ATH2.adjust, ATH2.l[gsfb], ATH2.floor);
      else
        xmin = ATH2.adjust * ATH2.l[gsfb];
      width = cod_info.width[gsfb];
      rh1 = xmin / width;
      rh2 = DBL_EPSILON;
      l = width >> 1;
      en0 = 0;
      do {
        var xa, xb;
        xa = xr[j] * xr[j];
        en0 += xa;
        rh2 += xa < rh1 ? xa : rh1;
        j++;
        xb = xr[j] * xr[j];
        en0 += xb;
        rh2 += xb < rh1 ? xb : rh1;
        j++;
      } while (--l > 0);
      if (en0 > xmin)
        ath_over++;
      if (gsfb == Encoder$4.SBPSY_l) {
        var x = xmin * gfc.nsPsy.longfact[gsfb];
        if (rh2 < x) {
          rh2 = x;
        }
      }
      if (enable_athaa_fix != 0) {
        xmin = rh2;
      }
      if (!gfp.ATHonly) {
        var e2 = ratio.en.l[gsfb];
        if (e2 > 0) {
          var x;
          x = en0 * ratio.thm.l[gsfb] * masking_lower / e2;
          if (enable_athaa_fix != 0)
            x *= gfc.nsPsy.longfact[gsfb];
          if (xmin < x)
            xmin = x;
        }
      }
      if (enable_athaa_fix != 0)
        pxmin[pxminPos++] = xmin;
      else
        pxmin[pxminPos++] = xmin * gfc.nsPsy.longfact[gsfb];
    }
    var max_nonzero = 575;
    if (cod_info.block_type != Encoder$4.SHORT_TYPE) {
      var k = 576;
      while (k-- != 0 && BitStream.EQ(xr[k], 0)) {
        max_nonzero = k;
      }
    }
    cod_info.max_nonzero_coeff = max_nonzero;
    for (var sfb = cod_info.sfb_smin; gsfb < cod_info.psymax; sfb++, gsfb += 3) {
      var width, b;
      var tmpATH;
      if (gfp.VBR == VbrMode$4.vbr_rh || gfp.VBR == VbrMode$4.vbr_mtrh)
        tmpATH = athAdjust(ATH2.adjust, ATH2.s[sfb], ATH2.floor);
      else
        tmpATH = ATH2.adjust * ATH2.s[sfb];
      width = cod_info.width[gsfb];
      for (b = 0; b < 3; b++) {
        var en0 = 0, xmin;
        var rh1, rh2;
        var l = width >> 1;
        rh1 = tmpATH / width;
        rh2 = DBL_EPSILON;
        do {
          var xa, xb;
          xa = xr[j] * xr[j];
          en0 += xa;
          rh2 += xa < rh1 ? xa : rh1;
          j++;
          xb = xr[j] * xr[j];
          en0 += xb;
          rh2 += xb < rh1 ? xb : rh1;
          j++;
        } while (--l > 0);
        if (en0 > tmpATH)
          ath_over++;
        if (sfb == Encoder$4.SBPSY_s) {
          var x = tmpATH * gfc.nsPsy.shortfact[sfb];
          if (rh2 < x) {
            rh2 = x;
          }
        }
        if (enable_athaa_fix != 0)
          xmin = rh2;
        else
          xmin = tmpATH;
        if (!gfp.ATHonly && !gfp.ATHshort) {
          var e2 = ratio.en.s[sfb][b];
          if (e2 > 0) {
            var x;
            x = en0 * ratio.thm.s[sfb][b] * masking_lower / e2;
            if (enable_athaa_fix != 0)
              x *= gfc.nsPsy.shortfact[sfb];
            if (xmin < x)
              xmin = x;
          }
        }
        if (enable_athaa_fix != 0)
          pxmin[pxminPos++] = xmin;
        else
          pxmin[pxminPos++] = xmin * gfc.nsPsy.shortfact[sfb];
      }
      if (gfp.useTemporal) {
        if (pxmin[pxminPos - 3] > pxmin[pxminPos - 3 + 1])
          pxmin[pxminPos - 3 + 1] += (pxmin[pxminPos - 3] - pxmin[pxminPos - 3 + 1]) * gfc.decay;
        if (pxmin[pxminPos - 3 + 1] > pxmin[pxminPos - 3 + 2])
          pxmin[pxminPos - 3 + 2] += (pxmin[pxminPos - 3 + 1] - pxmin[pxminPos - 3 + 2]) * gfc.decay;
      }
    }
    return ath_over;
  };
  function StartLine(j) {
    this.s = j;
  }
  this.calc_noise_core = function(cod_info, startline, l, step) {
    var noise = 0;
    var j = startline.s;
    var ix = cod_info.l3_enc;
    if (j > cod_info.count1) {
      while (l-- != 0) {
        var temp;
        temp = cod_info.xr[j];
        j++;
        noise += temp * temp;
        temp = cod_info.xr[j];
        j++;
        noise += temp * temp;
      }
    } else if (j > cod_info.big_values) {
      var ix01 = new_float$3(2);
      ix01[0] = 0;
      ix01[1] = step;
      while (l-- != 0) {
        var temp;
        temp = Math.abs(cod_info.xr[j]) - ix01[ix[j]];
        j++;
        noise += temp * temp;
        temp = Math.abs(cod_info.xr[j]) - ix01[ix[j]];
        j++;
        noise += temp * temp;
      }
    } else {
      while (l-- != 0) {
        var temp;
        temp = Math.abs(cod_info.xr[j]) - pow43[ix[j]] * step;
        j++;
        noise += temp * temp;
        temp = Math.abs(cod_info.xr[j]) - pow43[ix[j]] * step;
        j++;
        noise += temp * temp;
      }
    }
    startline.s = j;
    return noise;
  };
  this.calc_noise = function(cod_info, l3_xmin, distort, res, prev_noise) {
    var distortPos = 0;
    var l3_xminPos = 0;
    var sfb, l, over = 0;
    var over_noise_db = 0;
    var tot_noise_db = 0;
    var max_noise = -20;
    var j = 0;
    var scalefac = cod_info.scalefac;
    var scalefacPos = 0;
    res.over_SSD = 0;
    for (sfb = 0; sfb < cod_info.psymax; sfb++) {
      var s = cod_info.global_gain - (scalefac[scalefacPos++] + (cod_info.preflag != 0 ? pretab[sfb] : 0) << cod_info.scalefac_scale + 1) - cod_info.subblock_gain[cod_info.window[sfb]] * 8;
      var noise = 0;
      if (prev_noise != null && prev_noise.step[sfb] == s) {
        noise = prev_noise.noise[sfb];
        j += cod_info.width[sfb];
        distort[distortPos++] = noise / l3_xmin[l3_xminPos++];
        noise = prev_noise.noise_log[sfb];
      } else {
        var step = POW20(s);
        l = cod_info.width[sfb] >> 1;
        if (j + cod_info.width[sfb] > cod_info.max_nonzero_coeff) {
          var usefullsize;
          usefullsize = cod_info.max_nonzero_coeff - j + 1;
          if (usefullsize > 0)
            l = usefullsize >> 1;
          else
            l = 0;
        }
        var sl = new StartLine(j);
        noise = this.calc_noise_core(cod_info, sl, l, step);
        j = sl.s;
        if (prev_noise != null) {
          prev_noise.step[sfb] = s;
          prev_noise.noise[sfb] = noise;
        }
        noise = distort[distortPos++] = noise / l3_xmin[l3_xminPos++];
        noise = Util$1.FAST_LOG10(Math.max(noise, 1e-20));
        if (prev_noise != null) {
          prev_noise.noise_log[sfb] = noise;
        }
      }
      if (prev_noise != null) {
        prev_noise.global_gain = cod_info.global_gain;
      }
      tot_noise_db += noise;
      if (noise > 0) {
        var tmp;
        tmp = Math.max(0 | noise * 10 + 0.5, 1);
        res.over_SSD += tmp * tmp;
        over++;
        over_noise_db += noise;
      }
      max_noise = Math.max(max_noise, noise);
    }
    res.over_count = over;
    res.tot_noise = tot_noise_db;
    res.over_noise = over_noise_db;
    res.max_noise = max_noise;
    return over;
  };
  this.set_pinfo = function(gfp, cod_info, ratio, gr, ch) {
    var gfc = gfp.internal_flags;
    var sfb, sfb2;
    var l;
    var en0, en1;
    var ifqstep = cod_info.scalefac_scale == 0 ? 0.5 : 1;
    var scalefac = cod_info.scalefac;
    var l3_xmin = new_float$3(L3Side.SFBMAX);
    var xfsf = new_float$3(L3Side.SFBMAX);
    var noise = new CalcNoiseResult();
    calc_xmin(gfp, ratio, cod_info, l3_xmin);
    calc_noise(cod_info, l3_xmin, xfsf, noise, null);
    var j = 0;
    sfb2 = cod_info.sfb_lmax;
    if (cod_info.block_type != Encoder$4.SHORT_TYPE && 0 == cod_info.mixed_block_flag)
      sfb2 = 22;
    for (sfb = 0; sfb < sfb2; sfb++) {
      var start = gfc.scalefac_band.l[sfb];
      var end = gfc.scalefac_band.l[sfb + 1];
      var bw = end - start;
      for (en0 = 0; j < end; j++)
        en0 += cod_info.xr[j] * cod_info.xr[j];
      en0 /= bw;
      en1 = 1e15;
      gfc.pinfo.en[gr][ch][sfb] = en1 * en0;
      gfc.pinfo.xfsf[gr][ch][sfb] = en1 * l3_xmin[sfb] * xfsf[sfb] / bw;
      if (ratio.en.l[sfb] > 0 && !gfp.ATHonly)
        en0 = en0 / ratio.en.l[sfb];
      else
        en0 = 0;
      gfc.pinfo.thr[gr][ch][sfb] = en1 * Math.max(en0 * ratio.thm.l[sfb], gfc.ATH.l[sfb]);
      gfc.pinfo.LAMEsfb[gr][ch][sfb] = 0;
      if (cod_info.preflag != 0 && sfb >= 11)
        gfc.pinfo.LAMEsfb[gr][ch][sfb] = -ifqstep * pretab[sfb];
      if (sfb < Encoder$4.SBPSY_l) {
        assert$7(scalefac[sfb] >= 0);
        gfc.pinfo.LAMEsfb[gr][ch][sfb] -= ifqstep * scalefac[sfb];
      }
    }
    if (cod_info.block_type == Encoder$4.SHORT_TYPE) {
      sfb2 = sfb;
      for (sfb = cod_info.sfb_smin; sfb < Encoder$4.SBMAX_s; sfb++) {
        var start = gfc.scalefac_band.s[sfb];
        var end = gfc.scalefac_band.s[sfb + 1];
        var bw = end - start;
        for (var i = 0; i < 3; i++) {
          for (en0 = 0, l = start; l < end; l++) {
            en0 += cod_info.xr[j] * cod_info.xr[j];
            j++;
          }
          en0 = Math.max(en0 / bw, 1e-20);
          en1 = 1e15;
          gfc.pinfo.en_s[gr][ch][3 * sfb + i] = en1 * en0;
          gfc.pinfo.xfsf_s[gr][ch][3 * sfb + i] = en1 * l3_xmin[sfb2] * xfsf[sfb2] / bw;
          if (ratio.en.s[sfb][i] > 0)
            en0 = en0 / ratio.en.s[sfb][i];
          else
            en0 = 0;
          if (gfp.ATHonly || gfp.ATHshort)
            en0 = 0;
          gfc.pinfo.thr_s[gr][ch][3 * sfb + i] = en1 * Math.max(
            en0 * ratio.thm.s[sfb][i],
            gfc.ATH.s[sfb]
          );
          gfc.pinfo.LAMEsfb_s[gr][ch][3 * sfb + i] = -2 * cod_info.subblock_gain[i];
          if (sfb < Encoder$4.SBPSY_s) {
            gfc.pinfo.LAMEsfb_s[gr][ch][3 * sfb + i] -= ifqstep * scalefac[sfb2];
          }
          sfb2++;
        }
      }
    }
    gfc.pinfo.LAMEqss[gr][ch] = cod_info.global_gain;
    gfc.pinfo.LAMEmainbits[gr][ch] = cod_info.part2_3_length + cod_info.part2_length;
    gfc.pinfo.LAMEsfbits[gr][ch] = cod_info.part2_length;
    gfc.pinfo.over[gr][ch] = noise.over_count;
    gfc.pinfo.max_noise[gr][ch] = noise.max_noise * 10;
    gfc.pinfo.over_noise[gr][ch] = noise.over_noise * 10;
    gfc.pinfo.tot_noise[gr][ch] = noise.tot_noise * 10;
    gfc.pinfo.over_SSD[gr][ch] = noise.over_SSD;
  };
}
var QuantizePVT_1 = QuantizePVT$2;
var common$8 = common$l;
var System$4 = common$8.System;
common$8.VbrMode;
common$8.Float;
common$8.ShortBlock;
common$8.Util;
var Arrays$3 = common$8.Arrays;
common$8.new_array_n;
common$8.new_byte;
common$8.new_double;
common$8.new_float;
common$8.new_float_n;
var new_int$2 = common$8.new_int;
common$8.new_int_n;
var assert$6 = common$8.assert;
var Encoder$3 = requireEncoder();
var Tables$3 = Tables_1;
var GrInfo$1 = GrInfo_1;
var QuantizePVT$1 = QuantizePVT_1;
function Takehiro$2() {
  var qupvt = null;
  this.qupvt = null;
  this.setModules = function(_qupvt) {
    this.qupvt = _qupvt;
    qupvt = _qupvt;
  };
  function Bits(b) {
    this.bits = 0 | b;
  }
  var subdv_table = [
    [0, 0],
    /* 0 bands */
    [0, 0],
    /* 1 bands */
    [0, 0],
    /* 2 bands */
    [0, 0],
    /* 3 bands */
    [0, 0],
    /* 4 bands */
    [0, 1],
    /* 5 bands */
    [1, 1],
    /* 6 bands */
    [1, 1],
    /* 7 bands */
    [1, 2],
    /* 8 bands */
    [2, 2],
    /* 9 bands */
    [2, 3],
    /* 10 bands */
    [2, 3],
    /* 11 bands */
    [3, 4],
    /* 12 bands */
    [3, 4],
    /* 13 bands */
    [3, 4],
    /* 14 bands */
    [4, 5],
    /* 15 bands */
    [4, 5],
    /* 16 bands */
    [4, 6],
    /* 17 bands */
    [5, 6],
    /* 18 bands */
    [5, 6],
    /* 19 bands */
    [5, 7],
    /* 20 bands */
    [6, 7],
    /* 21 bands */
    [6, 7]
    /* 22 bands */
  ];
  function quantize_lines_xrpow_01(l, istep, xr, xrPos, ix, ixPos) {
    var compareval0 = (1 - 0.4054) / istep;
    assert$6(l > 0);
    l = l >> 1;
    while (l-- != 0) {
      ix[ixPos++] = compareval0 > xr[xrPos++] ? 0 : 1;
      ix[ixPos++] = compareval0 > xr[xrPos++] ? 0 : 1;
    }
  }
  function quantize_lines_xrpow(l, istep, xr, xrPos, ix, ixPos) {
    assert$6(l > 0);
    l = l >> 1;
    var remaining = l % 2;
    l = l >> 1;
    while (l-- != 0) {
      var x0, x1, x2, x3;
      var rx0, rx1, rx2, rx3;
      x0 = xr[xrPos++] * istep;
      x1 = xr[xrPos++] * istep;
      rx0 = 0 | x0;
      x2 = xr[xrPos++] * istep;
      rx1 = 0 | x1;
      x3 = xr[xrPos++] * istep;
      rx2 = 0 | x2;
      x0 += qupvt.adj43[rx0];
      rx3 = 0 | x3;
      x1 += qupvt.adj43[rx1];
      ix[ixPos++] = 0 | x0;
      x2 += qupvt.adj43[rx2];
      ix[ixPos++] = 0 | x1;
      x3 += qupvt.adj43[rx3];
      ix[ixPos++] = 0 | x2;
      ix[ixPos++] = 0 | x3;
    }
    if (remaining != 0) {
      var x0, x1;
      var rx0, rx1;
      x0 = xr[xrPos++] * istep;
      x1 = xr[xrPos++] * istep;
      rx0 = 0 | x0;
      rx1 = 0 | x1;
      x0 += qupvt.adj43[rx0];
      x1 += qupvt.adj43[rx1];
      ix[ixPos++] = 0 | x0;
      ix[ixPos++] = 0 | x1;
    }
  }
  function quantize_xrpow(xp, pi, istep, codInfo, prevNoise) {
    var sfb;
    var sfbmax;
    var j = 0;
    var prev_data_use;
    var accumulate = 0;
    var accumulate01 = 0;
    var xpPos = 0;
    var iData = pi;
    var iDataPos = 0;
    var acc_iData = iData;
    var acc_iDataPos = 0;
    var acc_xp = xp;
    var acc_xpPos = 0;
    prev_data_use = prevNoise != null && codInfo.global_gain == prevNoise.global_gain;
    if (codInfo.block_type == Encoder$3.SHORT_TYPE)
      sfbmax = 38;
    else
      sfbmax = 21;
    for (sfb = 0; sfb <= sfbmax; sfb++) {
      var step = -1;
      if (prev_data_use || codInfo.block_type == Encoder$3.NORM_TYPE) {
        step = codInfo.global_gain - (codInfo.scalefac[sfb] + (codInfo.preflag != 0 ? qupvt.pretab[sfb] : 0) << codInfo.scalefac_scale + 1) - codInfo.subblock_gain[codInfo.window[sfb]] * 8;
      }
      assert$6(codInfo.width[sfb] >= 0);
      if (prev_data_use && prevNoise.step[sfb] == step) {
        if (accumulate != 0) {
          quantize_lines_xrpow(
            accumulate,
            istep,
            acc_xp,
            acc_xpPos,
            acc_iData,
            acc_iDataPos
          );
          accumulate = 0;
        }
        if (accumulate01 != 0) {
          quantize_lines_xrpow_01(
            accumulate01,
            istep,
            acc_xp,
            acc_xpPos,
            acc_iData,
            acc_iDataPos
          );
          accumulate01 = 0;
        }
      } else {
        var l = codInfo.width[sfb];
        if (j + codInfo.width[sfb] > codInfo.max_nonzero_coeff) {
          var usefullsize;
          usefullsize = codInfo.max_nonzero_coeff - j + 1;
          Arrays$3.fill(pi, codInfo.max_nonzero_coeff, 576, 0);
          l = usefullsize;
          if (l < 0) {
            l = 0;
          }
          sfb = sfbmax + 1;
        }
        if (0 == accumulate && 0 == accumulate01) {
          acc_iData = iData;
          acc_iDataPos = iDataPos;
          acc_xp = xp;
          acc_xpPos = xpPos;
        }
        if (prevNoise != null && prevNoise.sfb_count1 > 0 && sfb >= prevNoise.sfb_count1 && prevNoise.step[sfb] > 0 && step >= prevNoise.step[sfb]) {
          if (accumulate != 0) {
            quantize_lines_xrpow(
              accumulate,
              istep,
              acc_xp,
              acc_xpPos,
              acc_iData,
              acc_iDataPos
            );
            accumulate = 0;
            acc_iData = iData;
            acc_iDataPos = iDataPos;
            acc_xp = xp;
            acc_xpPos = xpPos;
          }
          accumulate01 += l;
        } else {
          if (accumulate01 != 0) {
            quantize_lines_xrpow_01(
              accumulate01,
              istep,
              acc_xp,
              acc_xpPos,
              acc_iData,
              acc_iDataPos
            );
            accumulate01 = 0;
            acc_iData = iData;
            acc_iDataPos = iDataPos;
            acc_xp = xp;
            acc_xpPos = xpPos;
          }
          accumulate += l;
        }
        if (l <= 0) {
          if (accumulate01 != 0) {
            quantize_lines_xrpow_01(
              accumulate01,
              istep,
              acc_xp,
              acc_xpPos,
              acc_iData,
              acc_iDataPos
            );
            accumulate01 = 0;
          }
          if (accumulate != 0) {
            quantize_lines_xrpow(
              accumulate,
              istep,
              acc_xp,
              acc_xpPos,
              acc_iData,
              acc_iDataPos
            );
            accumulate = 0;
          }
          break;
        }
      }
      if (sfb <= sfbmax) {
        iDataPos += codInfo.width[sfb];
        xpPos += codInfo.width[sfb];
        j += codInfo.width[sfb];
      }
    }
    if (accumulate != 0) {
      quantize_lines_xrpow(
        accumulate,
        istep,
        acc_xp,
        acc_xpPos,
        acc_iData,
        acc_iDataPos
      );
      accumulate = 0;
    }
    if (accumulate01 != 0) {
      quantize_lines_xrpow_01(
        accumulate01,
        istep,
        acc_xp,
        acc_xpPos,
        acc_iData,
        acc_iDataPos
      );
      accumulate01 = 0;
    }
  }
  function ix_max(ix, ixPos, endPos) {
    var max1 = 0, max2 = 0;
    do {
      var x1 = ix[ixPos++];
      var x2 = ix[ixPos++];
      if (max1 < x1)
        max1 = x1;
      if (max2 < x2)
        max2 = x2;
    } while (ixPos < endPos);
    if (max1 < max2)
      max1 = max2;
    return max1;
  }
  function count_bit_ESC(ix, ixPos, end, t1, t2, s) {
    var linbits = Tables$3.ht[t1].xlen * 65536 + Tables$3.ht[t2].xlen;
    var sum = 0, sum2;
    do {
      var x = ix[ixPos++];
      var y = ix[ixPos++];
      if (x != 0) {
        if (x > 14) {
          x = 15;
          sum += linbits;
        }
        x *= 16;
      }
      if (y != 0) {
        if (y > 14) {
          y = 15;
          sum += linbits;
        }
        x += y;
      }
      sum += Tables$3.largetbl[x];
    } while (ixPos < end);
    sum2 = sum & 65535;
    sum >>= 16;
    if (sum > sum2) {
      sum = sum2;
      t1 = t2;
    }
    s.bits += sum;
    return t1;
  }
  function count_bit_noESC(ix, ixPos, end, s) {
    var sum1 = 0;
    var hlen1 = Tables$3.ht[1].hlen;
    do {
      var x = ix[ixPos + 0] * 2 + ix[ixPos + 1];
      ixPos += 2;
      sum1 += hlen1[x];
    } while (ixPos < end);
    s.bits += sum1;
    return 1;
  }
  function count_bit_noESC_from2(ix, ixPos, end, t1, s) {
    var sum = 0, sum2;
    var xlen = Tables$3.ht[t1].xlen;
    var hlen;
    if (t1 == 2)
      hlen = Tables$3.table23;
    else
      hlen = Tables$3.table56;
    do {
      var x = ix[ixPos + 0] * xlen + ix[ixPos + 1];
      ixPos += 2;
      sum += hlen[x];
    } while (ixPos < end);
    sum2 = sum & 65535;
    sum >>= 16;
    if (sum > sum2) {
      sum = sum2;
      t1++;
    }
    s.bits += sum;
    return t1;
  }
  function count_bit_noESC_from3(ix, ixPos, end, t1, s) {
    var sum1 = 0;
    var sum2 = 0;
    var sum3 = 0;
    var xlen = Tables$3.ht[t1].xlen;
    var hlen1 = Tables$3.ht[t1].hlen;
    var hlen2 = Tables$3.ht[t1 + 1].hlen;
    var hlen3 = Tables$3.ht[t1 + 2].hlen;
    do {
      var x = ix[ixPos + 0] * xlen + ix[ixPos + 1];
      ixPos += 2;
      sum1 += hlen1[x];
      sum2 += hlen2[x];
      sum3 += hlen3[x];
    } while (ixPos < end);
    var t = t1;
    if (sum1 > sum2) {
      sum1 = sum2;
      t++;
    }
    if (sum1 > sum3) {
      sum1 = sum3;
      t = t1 + 2;
    }
    s.bits += sum1;
    return t;
  }
  var huf_tbl_noESC = [
    1,
    2,
    5,
    7,
    7,
    10,
    10,
    13,
    13,
    13,
    13,
    13,
    13,
    13,
    13
  ];
  function choose_table(ix, ixPos, endPos, s) {
    var max2 = ix_max(ix, ixPos, endPos);
    switch (max2) {
      case 0:
        return max2;
      case 1:
        return count_bit_noESC(ix, ixPos, endPos, s);
      case 2:
      case 3:
        return count_bit_noESC_from2(
          ix,
          ixPos,
          endPos,
          huf_tbl_noESC[max2 - 1],
          s
        );
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
        return count_bit_noESC_from3(
          ix,
          ixPos,
          endPos,
          huf_tbl_noESC[max2 - 1],
          s
        );
      default:
        if (max2 > QuantizePVT$1.IXMAX_VAL) {
          s.bits = QuantizePVT$1.LARGE_BITS;
          return -1;
        }
        max2 -= 15;
        var choice2;
        for (choice2 = 24; choice2 < 32; choice2++) {
          if (Tables$3.ht[choice2].linmax >= max2) {
            break;
          }
        }
        var choice3;
        for (choice3 = choice2 - 8; choice3 < 24; choice3++) {
          if (Tables$3.ht[choice3].linmax >= max2) {
            break;
          }
        }
        return count_bit_ESC(ix, ixPos, endPos, choice3, choice2, s);
    }
  }
  this.noquant_count_bits = function(gfc, gi, prev_noise) {
    var ix = gi.l3_enc;
    var i = Math.min(576, gi.max_nonzero_coeff + 2 >> 1 << 1);
    if (prev_noise != null)
      prev_noise.sfb_count1 = 0;
    for (; i > 1; i -= 2)
      if ((ix[i - 1] | ix[i - 2]) != 0)
        break;
    gi.count1 = i;
    var a1 = 0;
    var a2 = 0;
    for (; i > 3; i -= 4) {
      var p2;
      if (((ix[i - 1] | ix[i - 2] | ix[i - 3] | ix[i - 4]) & 2147483647) > 1) {
        break;
      }
      p2 = ((ix[i - 4] * 2 + ix[i - 3]) * 2 + ix[i - 2]) * 2 + ix[i - 1];
      a1 += Tables$3.t32l[p2];
      a2 += Tables$3.t33l[p2];
    }
    var bits = a1;
    gi.count1table_select = 0;
    if (a1 > a2) {
      bits = a2;
      gi.count1table_select = 1;
    }
    gi.count1bits = bits;
    gi.big_values = i;
    if (i == 0)
      return bits;
    if (gi.block_type == Encoder$3.SHORT_TYPE) {
      a1 = 3 * gfc.scalefac_band.s[3];
      if (a1 > gi.big_values)
        a1 = gi.big_values;
      a2 = gi.big_values;
    } else if (gi.block_type == Encoder$3.NORM_TYPE) {
      assert$6(i <= 576);
      a1 = gi.region0_count = gfc.bv_scf[i - 2];
      a2 = gi.region1_count = gfc.bv_scf[i - 1];
      assert$6(a1 + a2 + 2 < Encoder$3.SBPSY_l);
      a2 = gfc.scalefac_band.l[a1 + a2 + 2];
      a1 = gfc.scalefac_band.l[a1 + 1];
      if (a2 < i) {
        var bi = new Bits(bits);
        gi.table_select[2] = choose_table(ix, a2, i, bi);
        bits = bi.bits;
      }
    } else {
      gi.region0_count = 7;
      gi.region1_count = Encoder$3.SBMAX_l - 1 - 7 - 1;
      a1 = gfc.scalefac_band.l[7 + 1];
      a2 = i;
      if (a1 > a2) {
        a1 = a2;
      }
    }
    a1 = Math.min(a1, i);
    a2 = Math.min(a2, i);
    assert$6(a1 >= 0);
    assert$6(a2 >= 0);
    if (0 < a1) {
      var bi = new Bits(bits);
      gi.table_select[0] = choose_table(ix, 0, a1, bi);
      bits = bi.bits;
    }
    if (a1 < a2) {
      var bi = new Bits(bits);
      gi.table_select[1] = choose_table(ix, a1, a2, bi);
      bits = bi.bits;
    }
    if (gfc.use_best_huffman == 2) {
      gi.part2_3_length = bits;
      best_huffman_divide(gfc, gi);
      bits = gi.part2_3_length;
    }
    if (prev_noise != null) {
      if (gi.block_type == Encoder$3.NORM_TYPE) {
        var sfb = 0;
        while (gfc.scalefac_band.l[sfb] < gi.big_values) {
          sfb++;
        }
        prev_noise.sfb_count1 = sfb;
      }
    }
    return bits;
  };
  this.count_bits = function(gfc, xr, gi, prev_noise) {
    var ix = gi.l3_enc;
    var w = QuantizePVT$1.IXMAX_VAL / qupvt.IPOW20(gi.global_gain);
    if (gi.xrpow_max > w)
      return QuantizePVT$1.LARGE_BITS;
    quantize_xrpow(xr, ix, qupvt.IPOW20(gi.global_gain), gi, prev_noise);
    if ((gfc.substep_shaping & 2) != 0) {
      var j = 0;
      var gain = gi.global_gain + gi.scalefac_scale;
      var roundfac = 0.634521682242439 / qupvt.IPOW20(gain);
      for (var sfb = 0; sfb < gi.sfbmax; sfb++) {
        var width = gi.width[sfb];
        assert$6(width >= 0);
        if (0 == gfc.pseudohalf[sfb]) {
          j += width;
        } else {
          var k;
          for (k = j, j += width; k < j; ++k) {
            ix[k] = xr[k] >= roundfac ? ix[k] : 0;
          }
        }
      }
    }
    return this.noquant_count_bits(gfc, gi, prev_noise);
  };
  function recalc_divide_init(gfc, cod_info, ix, r01_bits, r01_div, r0_tbl, r1_tbl) {
    var bigv = cod_info.big_values;
    for (var r0 = 0; r0 <= 7 + 15; r0++) {
      r01_bits[r0] = QuantizePVT$1.LARGE_BITS;
    }
    for (var r0 = 0; r0 < 16; r0++) {
      var a1 = gfc.scalefac_band.l[r0 + 1];
      if (a1 >= bigv)
        break;
      var r0bits = 0;
      var bi = new Bits(r0bits);
      var r0t = choose_table(ix, 0, a1, bi);
      r0bits = bi.bits;
      for (var r1 = 0; r1 < 8; r1++) {
        var a2 = gfc.scalefac_band.l[r0 + r1 + 2];
        if (a2 >= bigv)
          break;
        var bits = r0bits;
        bi = new Bits(bits);
        var r1t = choose_table(ix, a1, a2, bi);
        bits = bi.bits;
        if (r01_bits[r0 + r1] > bits) {
          r01_bits[r0 + r1] = bits;
          r01_div[r0 + r1] = r0;
          r0_tbl[r0 + r1] = r0t;
          r1_tbl[r0 + r1] = r1t;
        }
      }
    }
  }
  function recalc_divide_sub(gfc, cod_info2, gi, ix, r01_bits, r01_div, r0_tbl, r1_tbl) {
    var bigv = cod_info2.big_values;
    for (var r2 = 2; r2 < Encoder$3.SBMAX_l + 1; r2++) {
      var a2 = gfc.scalefac_band.l[r2];
      if (a2 >= bigv)
        break;
      var bits = r01_bits[r2 - 2] + cod_info2.count1bits;
      if (gi.part2_3_length <= bits)
        break;
      var bi = new Bits(bits);
      var r2t = choose_table(ix, a2, bigv, bi);
      bits = bi.bits;
      if (gi.part2_3_length <= bits)
        continue;
      gi.assign(cod_info2);
      gi.part2_3_length = bits;
      gi.region0_count = r01_div[r2 - 2];
      gi.region1_count = r2 - 2 - r01_div[r2 - 2];
      gi.table_select[0] = r0_tbl[r2 - 2];
      gi.table_select[1] = r1_tbl[r2 - 2];
      gi.table_select[2] = r2t;
    }
  }
  this.best_huffman_divide = function(gfc, gi) {
    var cod_info2 = new GrInfo$1();
    var ix = gi.l3_enc;
    var r01_bits = new_int$2(7 + 15 + 1);
    var r01_div = new_int$2(7 + 15 + 1);
    var r0_tbl = new_int$2(7 + 15 + 1);
    var r1_tbl = new_int$2(7 + 15 + 1);
    if (gi.block_type == Encoder$3.SHORT_TYPE && gfc.mode_gr == 1)
      return;
    cod_info2.assign(gi);
    if (gi.block_type == Encoder$3.NORM_TYPE) {
      recalc_divide_init(gfc, gi, ix, r01_bits, r01_div, r0_tbl, r1_tbl);
      recalc_divide_sub(
        gfc,
        cod_info2,
        gi,
        ix,
        r01_bits,
        r01_div,
        r0_tbl,
        r1_tbl
      );
    }
    var i = cod_info2.big_values;
    if (i == 0 || (ix[i - 2] | ix[i - 1]) > 1)
      return;
    i = gi.count1 + 2;
    if (i > 576)
      return;
    cod_info2.assign(gi);
    cod_info2.count1 = i;
    var a1 = 0;
    var a2 = 0;
    assert$6(i <= 576);
    for (; i > cod_info2.big_values; i -= 4) {
      var p2 = ((ix[i - 4] * 2 + ix[i - 3]) * 2 + ix[i - 2]) * 2 + ix[i - 1];
      a1 += Tables$3.t32l[p2];
      a2 += Tables$3.t33l[p2];
    }
    cod_info2.big_values = i;
    cod_info2.count1table_select = 0;
    if (a1 > a2) {
      a1 = a2;
      cod_info2.count1table_select = 1;
    }
    cod_info2.count1bits = a1;
    if (cod_info2.block_type == Encoder$3.NORM_TYPE)
      recalc_divide_sub(
        gfc,
        cod_info2,
        gi,
        ix,
        r01_bits,
        r01_div,
        r0_tbl,
        r1_tbl
      );
    else {
      cod_info2.part2_3_length = a1;
      a1 = gfc.scalefac_band.l[7 + 1];
      if (a1 > i) {
        a1 = i;
      }
      if (a1 > 0) {
        var bi = new Bits(cod_info2.part2_3_length);
        cod_info2.table_select[0] = choose_table(ix, 0, a1, bi);
        cod_info2.part2_3_length = bi.bits;
      }
      if (i > a1) {
        var bi = new Bits(cod_info2.part2_3_length);
        cod_info2.table_select[1] = choose_table(ix, a1, i, bi);
        cod_info2.part2_3_length = bi.bits;
      }
      if (gi.part2_3_length > cod_info2.part2_3_length)
        gi.assign(cod_info2);
    }
  };
  var slen1_n = [1, 1, 1, 1, 8, 2, 2, 2, 4, 4, 4, 8, 8, 8, 16, 16];
  var slen2_n = [1, 2, 4, 8, 1, 2, 4, 8, 2, 4, 8, 2, 4, 8, 4, 8];
  var slen1_tab = [0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4];
  var slen2_tab = [0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3];
  Takehiro$2.slen1_tab = slen1_tab;
  Takehiro$2.slen2_tab = slen2_tab;
  function scfsi_calc(ch, l3_side) {
    var sfb;
    var gi = l3_side.tt[1][ch];
    var g0 = l3_side.tt[0][ch];
    for (var i = 0; i < Tables$3.scfsi_band.length - 1; i++) {
      for (sfb = Tables$3.scfsi_band[i]; sfb < Tables$3.scfsi_band[i + 1]; sfb++) {
        if (g0.scalefac[sfb] != gi.scalefac[sfb] && gi.scalefac[sfb] >= 0)
          break;
      }
      if (sfb == Tables$3.scfsi_band[i + 1]) {
        for (sfb = Tables$3.scfsi_band[i]; sfb < Tables$3.scfsi_band[i + 1]; sfb++) {
          gi.scalefac[sfb] = -1;
        }
        l3_side.scfsi[ch][i] = 1;
      }
    }
    var s1 = 0;
    var c1 = 0;
    for (sfb = 0; sfb < 11; sfb++) {
      if (gi.scalefac[sfb] == -1)
        continue;
      c1++;
      if (s1 < gi.scalefac[sfb])
        s1 = gi.scalefac[sfb];
    }
    var s2 = 0;
    var c2 = 0;
    for (; sfb < Encoder$3.SBPSY_l; sfb++) {
      if (gi.scalefac[sfb] == -1)
        continue;
      c2++;
      if (s2 < gi.scalefac[sfb])
        s2 = gi.scalefac[sfb];
    }
    for (var i = 0; i < 16; i++) {
      if (s1 < slen1_n[i] && s2 < slen2_n[i]) {
        var c = slen1_tab[i] * c1 + slen2_tab[i] * c2;
        if (gi.part2_length > c) {
          gi.part2_length = c;
          gi.scalefac_compress = i;
        }
      }
    }
  }
  this.best_scalefac_store = function(gfc, gr, ch, l3_side) {
    var gi = l3_side.tt[gr][ch];
    var sfb, i, j, l;
    var recalc = 0;
    j = 0;
    for (sfb = 0; sfb < gi.sfbmax; sfb++) {
      var width = gi.width[sfb];
      assert$6(width >= 0);
      j += width;
      for (l = -width; l < 0; l++) {
        if (gi.l3_enc[l + j] != 0)
          break;
      }
      if (l == 0)
        gi.scalefac[sfb] = recalc = -2;
    }
    if (0 == gi.scalefac_scale && 0 == gi.preflag) {
      var s = 0;
      for (sfb = 0; sfb < gi.sfbmax; sfb++)
        if (gi.scalefac[sfb] > 0)
          s |= gi.scalefac[sfb];
      if (0 == (s & 1) && s != 0) {
        for (sfb = 0; sfb < gi.sfbmax; sfb++)
          if (gi.scalefac[sfb] > 0)
            gi.scalefac[sfb] >>= 1;
        gi.scalefac_scale = recalc = 1;
      }
    }
    if (0 == gi.preflag && gi.block_type != Encoder$3.SHORT_TYPE && gfc.mode_gr == 2) {
      for (sfb = 11; sfb < Encoder$3.SBPSY_l; sfb++)
        if (gi.scalefac[sfb] < qupvt.pretab[sfb] && gi.scalefac[sfb] != -2)
          break;
      if (sfb == Encoder$3.SBPSY_l) {
        for (sfb = 11; sfb < Encoder$3.SBPSY_l; sfb++)
          if (gi.scalefac[sfb] > 0)
            gi.scalefac[sfb] -= qupvt.pretab[sfb];
        gi.preflag = recalc = 1;
      }
    }
    for (i = 0; i < 4; i++)
      l3_side.scfsi[ch][i] = 0;
    if (gfc.mode_gr == 2 && gr == 1 && l3_side.tt[0][ch].block_type != Encoder$3.SHORT_TYPE && l3_side.tt[1][ch].block_type != Encoder$3.SHORT_TYPE) {
      scfsi_calc(ch, l3_side);
      recalc = 0;
    }
    for (sfb = 0; sfb < gi.sfbmax; sfb++) {
      if (gi.scalefac[sfb] == -2) {
        gi.scalefac[sfb] = 0;
      }
    }
    if (recalc != 0) {
      if (gfc.mode_gr == 2) {
        this.scale_bitcount(gi);
      } else {
        this.scale_bitcount_lsf(gfc, gi);
      }
    }
  };
  function all_scalefactors_not_negative(scalefac, n) {
    for (var i = 0; i < n; ++i) {
      if (scalefac[i] < 0)
        return false;
    }
    return true;
  }
  var scale_short = [
    0,
    18,
    36,
    54,
    54,
    36,
    54,
    72,
    54,
    72,
    90,
    72,
    90,
    108,
    108,
    126
  ];
  var scale_mixed = [
    0,
    18,
    36,
    54,
    51,
    35,
    53,
    71,
    52,
    70,
    88,
    69,
    87,
    105,
    104,
    122
  ];
  var scale_long = [
    0,
    10,
    20,
    30,
    33,
    21,
    31,
    41,
    32,
    42,
    52,
    43,
    53,
    63,
    64,
    74
  ];
  this.scale_bitcount = function(cod_info) {
    var k, sfb, max_slen1 = 0, max_slen2 = 0;
    var tab;
    var scalefac = cod_info.scalefac;
    assert$6(all_scalefactors_not_negative(scalefac, cod_info.sfbmax));
    if (cod_info.block_type == Encoder$3.SHORT_TYPE) {
      tab = scale_short;
      if (cod_info.mixed_block_flag != 0)
        tab = scale_mixed;
    } else {
      tab = scale_long;
      if (0 == cod_info.preflag) {
        for (sfb = 11; sfb < Encoder$3.SBPSY_l; sfb++)
          if (scalefac[sfb] < qupvt.pretab[sfb])
            break;
        if (sfb == Encoder$3.SBPSY_l) {
          cod_info.preflag = 1;
          for (sfb = 11; sfb < Encoder$3.SBPSY_l; sfb++)
            scalefac[sfb] -= qupvt.pretab[sfb];
        }
      }
    }
    for (sfb = 0; sfb < cod_info.sfbdivide; sfb++)
      if (max_slen1 < scalefac[sfb])
        max_slen1 = scalefac[sfb];
    for (; sfb < cod_info.sfbmax; sfb++)
      if (max_slen2 < scalefac[sfb])
        max_slen2 = scalefac[sfb];
    cod_info.part2_length = QuantizePVT$1.LARGE_BITS;
    for (k = 0; k < 16; k++) {
      if (max_slen1 < slen1_n[k] && max_slen2 < slen2_n[k] && cod_info.part2_length > tab[k]) {
        cod_info.part2_length = tab[k];
        cod_info.scalefac_compress = k;
      }
    }
    return cod_info.part2_length == QuantizePVT$1.LARGE_BITS;
  };
  var max_range_sfac_tab = [
    [15, 15, 7, 7],
    [15, 15, 7, 0],
    [7, 3, 0, 0],
    [15, 31, 31, 0],
    [7, 7, 7, 0],
    [3, 3, 0, 0]
  ];
  this.scale_bitcount_lsf = function(gfc, cod_info) {
    var table_number, row_in_table, partition, nr_sfb, window2;
    var over;
    var i, sfb;
    var max_sfac = new_int$2(4);
    var scalefac = cod_info.scalefac;
    if (cod_info.preflag != 0)
      table_number = 2;
    else
      table_number = 0;
    for (i = 0; i < 4; i++)
      max_sfac[i] = 0;
    if (cod_info.block_type == Encoder$3.SHORT_TYPE) {
      row_in_table = 1;
      var partition_table = qupvt.nr_of_sfb_block[table_number][row_in_table];
      for (sfb = 0, partition = 0; partition < 4; partition++) {
        nr_sfb = partition_table[partition] / 3;
        for (i = 0; i < nr_sfb; i++, sfb++)
          for (window2 = 0; window2 < 3; window2++)
            if (scalefac[sfb * 3 + window2] > max_sfac[partition])
              max_sfac[partition] = scalefac[sfb * 3 + window2];
      }
    } else {
      row_in_table = 0;
      var partition_table = qupvt.nr_of_sfb_block[table_number][row_in_table];
      for (sfb = 0, partition = 0; partition < 4; partition++) {
        nr_sfb = partition_table[partition];
        for (i = 0; i < nr_sfb; i++, sfb++)
          if (scalefac[sfb] > max_sfac[partition])
            max_sfac[partition] = scalefac[sfb];
      }
    }
    for (over = false, partition = 0; partition < 4; partition++) {
      if (max_sfac[partition] > max_range_sfac_tab[table_number][partition])
        over = true;
    }
    if (!over) {
      var slen1, slen2, slen3, slen4;
      cod_info.sfb_partition_table = qupvt.nr_of_sfb_block[table_number][row_in_table];
      for (partition = 0; partition < 4; partition++)
        cod_info.slen[partition] = log2tab[max_sfac[partition]];
      slen1 = cod_info.slen[0];
      slen2 = cod_info.slen[1];
      slen3 = cod_info.slen[2];
      slen4 = cod_info.slen[3];
      switch (table_number) {
        case 0:
          cod_info.scalefac_compress = (slen1 * 5 + slen2 << 4) + (slen3 << 2) + slen4;
          break;
        case 1:
          cod_info.scalefac_compress = 400 + (slen1 * 5 + slen2 << 2) + slen3;
          break;
        case 2:
          cod_info.scalefac_compress = 500 + slen1 * 3 + slen2;
          break;
        default:
          System$4.err.printf("intensity stereo not implemented yet\n");
          break;
      }
    }
    if (!over) {
      assert$6(cod_info.sfb_partition_table != null);
      cod_info.part2_length = 0;
      for (partition = 0; partition < 4; partition++)
        cod_info.part2_length += cod_info.slen[partition] * cod_info.sfb_partition_table[partition];
    }
    return over;
  };
  var log2tab = [
    0,
    1,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4
  ];
  this.huffman_init = function(gfc) {
    for (var i = 2; i <= 576; i += 2) {
      var scfb_anz = 0, bv_index;
      while (gfc.scalefac_band.l[++scfb_anz] < i)
        ;
      bv_index = subdv_table[scfb_anz][0];
      while (gfc.scalefac_band.l[bv_index + 1] > i)
        bv_index--;
      if (bv_index < 0) {
        bv_index = subdv_table[scfb_anz][0];
      }
      gfc.bv_scf[i - 2] = bv_index;
      bv_index = subdv_table[scfb_anz][1];
      while (gfc.scalefac_band.l[bv_index + gfc.bv_scf[i - 2] + 2] > i)
        bv_index--;
      if (bv_index < 0) {
        bv_index = subdv_table[scfb_anz][1];
      }
      gfc.bv_scf[i - 1] = bv_index;
    }
  };
}
var Takehiro_1 = Takehiro$2;
var common$7 = common$l;
var System$3 = common$7.System;
common$7.VbrMode;
common$7.Float;
common$7.ShortBlock;
common$7.Util;
var Arrays$2 = common$7.Arrays;
common$7.new_array_n;
var new_byte$2 = common$7.new_byte;
common$7.new_double;
common$7.new_float;
var new_float_n = common$7.new_float_n;
var new_int$1 = common$7.new_int;
common$7.new_int_n;
var assert$5 = common$7.assert;
var Takehiro$1 = Takehiro_1;
var Tables$2 = Tables_1;
var Encoder$2 = requireEncoder();
var LameInternalFlags$2 = LameInternalFlags_1;
BitStream$3.EQ = function(a, b) {
  return Math.abs(a) > Math.abs(b) ? Math.abs(a - b) <= Math.abs(a) * 1e-6 : Math.abs(a - b) <= Math.abs(b) * 1e-6;
};
BitStream$3.NEQ = function(a, b) {
  return !BitStream$3.EQ(a, b);
};
function BitStream$3() {
  var self2 = this;
  var CRC16_POLYNOMIAL = 32773;
  var MAX_LENGTH = 32;
  var ga = null;
  var mpg = null;
  var ver = null;
  var vbr = null;
  this.setModules = function(_ga, _mpg, _ver, _vbr) {
    ga = _ga;
    mpg = _mpg;
    ver = _ver;
    vbr = _vbr;
  };
  var buf = null;
  var totbit = 0;
  var bufByteIdx = 0;
  var bufBitIdx = 0;
  this.getframebits = function(gfp) {
    var gfc = gfp.internal_flags;
    var bit_rate;
    if (gfc.bitrate_index != 0)
      bit_rate = Tables$2.bitrate_table[gfp.version][gfc.bitrate_index];
    else
      bit_rate = gfp.brate;
    assert$5(8 <= bit_rate && bit_rate <= 640);
    var bytes = 0 | (gfp.version + 1) * 72e3 * bit_rate / gfp.out_samplerate + gfc.padding;
    return 8 * bytes;
  };
  function putheader_bits(gfc) {
    System$3.arraycopy(gfc.header[gfc.w_ptr].buf, 0, buf, bufByteIdx, gfc.sideinfo_len);
    bufByteIdx += gfc.sideinfo_len;
    totbit += gfc.sideinfo_len * 8;
    gfc.w_ptr = gfc.w_ptr + 1 & LameInternalFlags$2.MAX_HEADER_BUF - 1;
  }
  function putbits2(gfc, val, j) {
    assert$5(j < MAX_LENGTH - 2);
    while (j > 0) {
      var k;
      if (bufBitIdx == 0) {
        bufBitIdx = 8;
        bufByteIdx++;
        assert$5(bufByteIdx < Lame.LAME_MAXMP3BUFFER);
        assert$5(gfc.header[gfc.w_ptr].write_timing >= totbit);
        if (gfc.header[gfc.w_ptr].write_timing == totbit) {
          putheader_bits(gfc);
        }
        buf[bufByteIdx] = 0;
      }
      k = Math.min(j, bufBitIdx);
      j -= k;
      bufBitIdx -= k;
      assert$5(j < MAX_LENGTH);
      assert$5(bufBitIdx < MAX_LENGTH);
      buf[bufByteIdx] |= val >> j << bufBitIdx;
      totbit += k;
    }
  }
  function putbits_noheaders(gfc, val, j) {
    assert$5(j < MAX_LENGTH - 2);
    while (j > 0) {
      var k;
      if (bufBitIdx == 0) {
        bufBitIdx = 8;
        bufByteIdx++;
        assert$5(bufByteIdx < Lame.LAME_MAXMP3BUFFER);
        buf[bufByteIdx] = 0;
      }
      k = Math.min(j, bufBitIdx);
      j -= k;
      bufBitIdx -= k;
      assert$5(j < MAX_LENGTH);
      assert$5(bufBitIdx < MAX_LENGTH);
      buf[bufByteIdx] |= val >> j << bufBitIdx;
      totbit += k;
    }
  }
  function drain_into_ancillary(gfp, remainingBits) {
    var gfc = gfp.internal_flags;
    var i;
    assert$5(remainingBits >= 0);
    if (remainingBits >= 8) {
      putbits2(gfc, 76, 8);
      remainingBits -= 8;
    }
    if (remainingBits >= 8) {
      putbits2(gfc, 65, 8);
      remainingBits -= 8;
    }
    if (remainingBits >= 8) {
      putbits2(gfc, 77, 8);
      remainingBits -= 8;
    }
    if (remainingBits >= 8) {
      putbits2(gfc, 69, 8);
      remainingBits -= 8;
    }
    if (remainingBits >= 32) {
      var version2 = ver.getLameShortVersion();
      if (remainingBits >= 32)
        for (i = 0; i < version2.length && remainingBits >= 8; ++i) {
          remainingBits -= 8;
          putbits2(gfc, version2.charAt(i), 8);
        }
    }
    for (; remainingBits >= 1; remainingBits -= 1) {
      putbits2(gfc, gfc.ancillary_flag, 1);
      gfc.ancillary_flag ^= !gfp.disable_reservoir ? 1 : 0;
    }
    assert$5(remainingBits == 0);
  }
  function writeheader(gfc, val, j) {
    var ptr = gfc.header[gfc.h_ptr].ptr;
    while (j > 0) {
      var k = Math.min(j, 8 - (ptr & 7));
      j -= k;
      assert$5(j < MAX_LENGTH);
      gfc.header[gfc.h_ptr].buf[ptr >> 3] |= val >> j << 8 - (ptr & 7) - k;
      ptr += k;
    }
    gfc.header[gfc.h_ptr].ptr = ptr;
  }
  function CRC_update(value, crc) {
    value <<= 8;
    for (var i = 0; i < 8; i++) {
      value <<= 1;
      crc <<= 1;
      if (((crc ^ value) & 65536) != 0)
        crc ^= CRC16_POLYNOMIAL;
    }
    return crc;
  }
  this.CRC_writeheader = function(gfc, header) {
    var crc = 65535;
    crc = CRC_update(header[2] & 255, crc);
    crc = CRC_update(header[3] & 255, crc);
    for (var i = 6; i < gfc.sideinfo_len; i++) {
      crc = CRC_update(header[i] & 255, crc);
    }
    header[4] = byte(crc >> 8);
    header[5] = byte(crc & 255);
  };
  function encodeSideInfo2(gfp, bitsPerFrame) {
    var gfc = gfp.internal_flags;
    var l3_side;
    var gr, ch;
    l3_side = gfc.l3_side;
    gfc.header[gfc.h_ptr].ptr = 0;
    Arrays$2.fill(gfc.header[gfc.h_ptr].buf, 0, gfc.sideinfo_len, 0);
    if (gfp.out_samplerate < 16e3)
      writeheader(gfc, 4094, 12);
    else
      writeheader(gfc, 4095, 12);
    writeheader(gfc, gfp.version, 1);
    writeheader(gfc, 4 - 3, 2);
    writeheader(gfc, !gfp.error_protection ? 1 : 0, 1);
    writeheader(gfc, gfc.bitrate_index, 4);
    writeheader(gfc, gfc.samplerate_index, 2);
    writeheader(gfc, gfc.padding, 1);
    writeheader(gfc, gfp.extension, 1);
    writeheader(gfc, gfp.mode.ordinal(), 2);
    writeheader(gfc, gfc.mode_ext, 2);
    writeheader(gfc, gfp.copyright, 1);
    writeheader(gfc, gfp.original, 1);
    writeheader(gfc, gfp.emphasis, 2);
    if (gfp.error_protection) {
      writeheader(gfc, 0, 16);
    }
    if (gfp.version == 1) {
      assert$5(l3_side.main_data_begin >= 0);
      writeheader(gfc, l3_side.main_data_begin, 9);
      if (gfc.channels_out == 2)
        writeheader(gfc, l3_side.private_bits, 3);
      else
        writeheader(gfc, l3_side.private_bits, 5);
      for (ch = 0; ch < gfc.channels_out; ch++) {
        var band;
        for (band = 0; band < 4; band++) {
          writeheader(gfc, l3_side.scfsi[ch][band], 1);
        }
      }
      for (gr = 0; gr < 2; gr++) {
        for (ch = 0; ch < gfc.channels_out; ch++) {
          var gi = l3_side.tt[gr][ch];
          writeheader(gfc, gi.part2_3_length + gi.part2_length, 12);
          writeheader(gfc, gi.big_values / 2, 9);
          writeheader(gfc, gi.global_gain, 8);
          writeheader(gfc, gi.scalefac_compress, 4);
          if (gi.block_type != Encoder$2.NORM_TYPE) {
            writeheader(gfc, 1, 1);
            writeheader(gfc, gi.block_type, 2);
            writeheader(gfc, gi.mixed_block_flag, 1);
            if (gi.table_select[0] == 14)
              gi.table_select[0] = 16;
            writeheader(gfc, gi.table_select[0], 5);
            if (gi.table_select[1] == 14)
              gi.table_select[1] = 16;
            writeheader(gfc, gi.table_select[1], 5);
            writeheader(gfc, gi.subblock_gain[0], 3);
            writeheader(gfc, gi.subblock_gain[1], 3);
            writeheader(gfc, gi.subblock_gain[2], 3);
          } else {
            writeheader(gfc, 0, 1);
            if (gi.table_select[0] == 14)
              gi.table_select[0] = 16;
            writeheader(gfc, gi.table_select[0], 5);
            if (gi.table_select[1] == 14)
              gi.table_select[1] = 16;
            writeheader(gfc, gi.table_select[1], 5);
            if (gi.table_select[2] == 14)
              gi.table_select[2] = 16;
            writeheader(gfc, gi.table_select[2], 5);
            assert$5(0 <= gi.region0_count && gi.region0_count < 16);
            assert$5(0 <= gi.region1_count && gi.region1_count < 8);
            writeheader(gfc, gi.region0_count, 4);
            writeheader(gfc, gi.region1_count, 3);
          }
          writeheader(gfc, gi.preflag, 1);
          writeheader(gfc, gi.scalefac_scale, 1);
          writeheader(gfc, gi.count1table_select, 1);
        }
      }
    } else {
      assert$5(l3_side.main_data_begin >= 0);
      writeheader(gfc, l3_side.main_data_begin, 8);
      writeheader(gfc, l3_side.private_bits, gfc.channels_out);
      gr = 0;
      for (ch = 0; ch < gfc.channels_out; ch++) {
        var gi = l3_side.tt[gr][ch];
        writeheader(gfc, gi.part2_3_length + gi.part2_length, 12);
        writeheader(gfc, gi.big_values / 2, 9);
        writeheader(gfc, gi.global_gain, 8);
        writeheader(gfc, gi.scalefac_compress, 9);
        if (gi.block_type != Encoder$2.NORM_TYPE) {
          writeheader(gfc, 1, 1);
          writeheader(gfc, gi.block_type, 2);
          writeheader(gfc, gi.mixed_block_flag, 1);
          if (gi.table_select[0] == 14)
            gi.table_select[0] = 16;
          writeheader(gfc, gi.table_select[0], 5);
          if (gi.table_select[1] == 14)
            gi.table_select[1] = 16;
          writeheader(gfc, gi.table_select[1], 5);
          writeheader(gfc, gi.subblock_gain[0], 3);
          writeheader(gfc, gi.subblock_gain[1], 3);
          writeheader(gfc, gi.subblock_gain[2], 3);
        } else {
          writeheader(gfc, 0, 1);
          if (gi.table_select[0] == 14)
            gi.table_select[0] = 16;
          writeheader(gfc, gi.table_select[0], 5);
          if (gi.table_select[1] == 14)
            gi.table_select[1] = 16;
          writeheader(gfc, gi.table_select[1], 5);
          if (gi.table_select[2] == 14)
            gi.table_select[2] = 16;
          writeheader(gfc, gi.table_select[2], 5);
          assert$5(0 <= gi.region0_count && gi.region0_count < 16);
          assert$5(0 <= gi.region1_count && gi.region1_count < 8);
          writeheader(gfc, gi.region0_count, 4);
          writeheader(gfc, gi.region1_count, 3);
        }
        writeheader(gfc, gi.scalefac_scale, 1);
        writeheader(gfc, gi.count1table_select, 1);
      }
    }
    if (gfp.error_protection) {
      CRC_writeheader(gfc, gfc.header[gfc.h_ptr].buf);
    }
    {
      var old = gfc.h_ptr;
      assert$5(gfc.header[old].ptr == gfc.sideinfo_len * 8);
      gfc.h_ptr = old + 1 & LameInternalFlags$2.MAX_HEADER_BUF - 1;
      gfc.header[gfc.h_ptr].write_timing = gfc.header[old].write_timing + bitsPerFrame;
      if (gfc.h_ptr == gfc.w_ptr) {
        System$3.err.println("Error: MAX_HEADER_BUF too small in bitstream.c \n");
      }
    }
  }
  function huffman_coder_count1(gfc, gi) {
    var h2 = Tables$2.ht[gi.count1table_select + 32];
    var i, bits = 0;
    var ix = gi.big_values;
    var xr = gi.big_values;
    assert$5(gi.count1table_select < 2);
    for (i = (gi.count1 - gi.big_values) / 4; i > 0; --i) {
      var huffbits = 0;
      var p2 = 0, v;
      v = gi.l3_enc[ix + 0];
      if (v != 0) {
        p2 += 8;
        if (gi.xr[xr + 0] < 0)
          huffbits++;
        assert$5(v <= 1);
      }
      v = gi.l3_enc[ix + 1];
      if (v != 0) {
        p2 += 4;
        huffbits *= 2;
        if (gi.xr[xr + 1] < 0)
          huffbits++;
        assert$5(v <= 1);
      }
      v = gi.l3_enc[ix + 2];
      if (v != 0) {
        p2 += 2;
        huffbits *= 2;
        if (gi.xr[xr + 2] < 0)
          huffbits++;
        assert$5(v <= 1);
      }
      v = gi.l3_enc[ix + 3];
      if (v != 0) {
        p2++;
        huffbits *= 2;
        if (gi.xr[xr + 3] < 0)
          huffbits++;
        assert$5(v <= 1);
      }
      ix += 4;
      xr += 4;
      putbits2(gfc, huffbits + h2.table[p2], h2.hlen[p2]);
      bits += h2.hlen[p2];
    }
    return bits;
  }
  function Huffmancode(gfc, tableindex, start, end, gi) {
    var h2 = Tables$2.ht[tableindex];
    var bits = 0;
    assert$5(tableindex < 32);
    if (0 == tableindex)
      return bits;
    for (var i = start; i < end; i += 2) {
      var cbits = 0;
      var xbits = 0;
      var linbits = h2.xlen;
      var xlen = h2.xlen;
      var ext = 0;
      var x1 = gi.l3_enc[i];
      var x2 = gi.l3_enc[i + 1];
      if (x1 != 0) {
        if (gi.xr[i] < 0)
          ext++;
        cbits--;
      }
      if (tableindex > 15) {
        if (x1 > 14) {
          var linbits_x1 = x1 - 15;
          assert$5(linbits_x1 <= h2.linmax);
          ext |= linbits_x1 << 1;
          xbits = linbits;
          x1 = 15;
        }
        if (x2 > 14) {
          var linbits_x2 = x2 - 15;
          assert$5(linbits_x2 <= h2.linmax);
          ext <<= linbits;
          ext |= linbits_x2;
          xbits += linbits;
          x2 = 15;
        }
        xlen = 16;
      }
      if (x2 != 0) {
        ext <<= 1;
        if (gi.xr[i + 1] < 0)
          ext++;
        cbits--;
      }
      assert$5((x1 | x2) < 16);
      x1 = x1 * xlen + x2;
      xbits -= cbits;
      cbits += h2.hlen[x1];
      assert$5(cbits <= MAX_LENGTH);
      assert$5(xbits <= MAX_LENGTH);
      putbits2(gfc, h2.table[x1], cbits);
      putbits2(gfc, ext, xbits);
      bits += cbits + xbits;
    }
    return bits;
  }
  function ShortHuffmancodebits(gfc, gi) {
    var region1Start = 3 * gfc.scalefac_band.s[3];
    if (region1Start > gi.big_values)
      region1Start = gi.big_values;
    var bits = Huffmancode(gfc, gi.table_select[0], 0, region1Start, gi);
    bits += Huffmancode(
      gfc,
      gi.table_select[1],
      region1Start,
      gi.big_values,
      gi
    );
    return bits;
  }
  function LongHuffmancodebits(gfc, gi) {
    var bigvalues, bits;
    var region1Start, region2Start;
    bigvalues = gi.big_values;
    assert$5(0 <= bigvalues && bigvalues <= 576);
    var i = gi.region0_count + 1;
    assert$5(0 <= i);
    assert$5(i < gfc.scalefac_band.l.length);
    region1Start = gfc.scalefac_band.l[i];
    i += gi.region1_count + 1;
    assert$5(0 <= i);
    assert$5(i < gfc.scalefac_band.l.length);
    region2Start = gfc.scalefac_band.l[i];
    if (region1Start > bigvalues)
      region1Start = bigvalues;
    if (region2Start > bigvalues)
      region2Start = bigvalues;
    bits = Huffmancode(gfc, gi.table_select[0], 0, region1Start, gi);
    bits += Huffmancode(
      gfc,
      gi.table_select[1],
      region1Start,
      region2Start,
      gi
    );
    bits += Huffmancode(
      gfc,
      gi.table_select[2],
      region2Start,
      bigvalues,
      gi
    );
    return bits;
  }
  function writeMainData(gfp) {
    var gr, ch, sfb, data_bits, tot_bits = 0;
    var gfc = gfp.internal_flags;
    var l3_side = gfc.l3_side;
    if (gfp.version == 1) {
      for (gr = 0; gr < 2; gr++) {
        for (ch = 0; ch < gfc.channels_out; ch++) {
          var gi = l3_side.tt[gr][ch];
          var slen1 = Takehiro$1.slen1_tab[gi.scalefac_compress];
          var slen2 = Takehiro$1.slen2_tab[gi.scalefac_compress];
          data_bits = 0;
          for (sfb = 0; sfb < gi.sfbdivide; sfb++) {
            if (gi.scalefac[sfb] == -1)
              continue;
            putbits2(gfc, gi.scalefac[sfb], slen1);
            data_bits += slen1;
          }
          for (; sfb < gi.sfbmax; sfb++) {
            if (gi.scalefac[sfb] == -1)
              continue;
            putbits2(gfc, gi.scalefac[sfb], slen2);
            data_bits += slen2;
          }
          assert$5(data_bits == gi.part2_length);
          if (gi.block_type == Encoder$2.SHORT_TYPE) {
            data_bits += ShortHuffmancodebits(gfc, gi);
          } else {
            data_bits += LongHuffmancodebits(gfc, gi);
          }
          data_bits += huffman_coder_count1(gfc, gi);
          assert$5(data_bits == gi.part2_3_length + gi.part2_length);
          tot_bits += data_bits;
        }
      }
    } else {
      gr = 0;
      for (ch = 0; ch < gfc.channels_out; ch++) {
        var gi = l3_side.tt[gr][ch];
        var i, sfb_partition, scale_bits = 0;
        assert$5(gi.sfb_partition_table != null);
        data_bits = 0;
        sfb = 0;
        sfb_partition = 0;
        if (gi.block_type == Encoder$2.SHORT_TYPE) {
          for (; sfb_partition < 4; sfb_partition++) {
            var sfbs = gi.sfb_partition_table[sfb_partition] / 3;
            var slen = gi.slen[sfb_partition];
            for (i = 0; i < sfbs; i++, sfb++) {
              putbits2(
                gfc,
                Math.max(gi.scalefac[sfb * 3 + 0], 0),
                slen
              );
              putbits2(
                gfc,
                Math.max(gi.scalefac[sfb * 3 + 1], 0),
                slen
              );
              putbits2(
                gfc,
                Math.max(gi.scalefac[sfb * 3 + 2], 0),
                slen
              );
              scale_bits += 3 * slen;
            }
          }
          data_bits += ShortHuffmancodebits(gfc, gi);
        } else {
          for (; sfb_partition < 4; sfb_partition++) {
            var sfbs = gi.sfb_partition_table[sfb_partition];
            var slen = gi.slen[sfb_partition];
            for (i = 0; i < sfbs; i++, sfb++) {
              putbits2(gfc, Math.max(gi.scalefac[sfb], 0), slen);
              scale_bits += slen;
            }
          }
          data_bits += LongHuffmancodebits(gfc, gi);
        }
        data_bits += huffman_coder_count1(gfc, gi);
        assert$5(data_bits == gi.part2_3_length);
        assert$5(scale_bits == gi.part2_length);
        tot_bits += scale_bits + data_bits;
      }
    }
    return tot_bits;
  }
  function TotalBytes() {
    this.total = 0;
  }
  function compute_flushbits(gfp, total_bytes_output) {
    var gfc = gfp.internal_flags;
    var flushbits, remaining_headers;
    var bitsPerFrame;
    var last_ptr, first_ptr;
    first_ptr = gfc.w_ptr;
    last_ptr = gfc.h_ptr - 1;
    if (last_ptr == -1)
      last_ptr = LameInternalFlags$2.MAX_HEADER_BUF - 1;
    flushbits = gfc.header[last_ptr].write_timing - totbit;
    total_bytes_output.total = flushbits;
    if (flushbits >= 0) {
      remaining_headers = 1 + last_ptr - first_ptr;
      if (last_ptr < first_ptr)
        remaining_headers = 1 + last_ptr - first_ptr + LameInternalFlags$2.MAX_HEADER_BUF;
      flushbits -= remaining_headers * 8 * gfc.sideinfo_len;
    }
    bitsPerFrame = self2.getframebits(gfp);
    flushbits += bitsPerFrame;
    total_bytes_output.total += bitsPerFrame;
    if (total_bytes_output.total % 8 != 0)
      total_bytes_output.total = 1 + total_bytes_output.total / 8;
    else
      total_bytes_output.total = total_bytes_output.total / 8;
    total_bytes_output.total += bufByteIdx + 1;
    if (flushbits < 0) {
      System$3.err.println("strange error flushing buffer ... \n");
    }
    return flushbits;
  }
  this.flush_bitstream = function(gfp) {
    var gfc = gfp.internal_flags;
    var l3_side;
    var flushbits;
    var last_ptr = gfc.h_ptr - 1;
    if (last_ptr == -1)
      last_ptr = LameInternalFlags$2.MAX_HEADER_BUF - 1;
    l3_side = gfc.l3_side;
    if ((flushbits = compute_flushbits(gfp, new TotalBytes())) < 0)
      return;
    drain_into_ancillary(gfp, flushbits);
    assert$5(gfc.header[last_ptr].write_timing + this.getframebits(gfp) == totbit);
    gfc.ResvSize = 0;
    l3_side.main_data_begin = 0;
    if (gfc.findReplayGain) {
      var RadioGain = ga.GetTitleGain(gfc.rgdata);
      assert$5(NEQ(RadioGain, GainAnalysis.GAIN_NOT_ENOUGH_SAMPLES));
      gfc.RadioGain = Math.floor(RadioGain * 10 + 0.5) | 0;
    }
    if (gfc.findPeakSample) {
      gfc.noclipGainChange = Math.ceil(Math.log10(gfc.PeakSample / 32767) * 20 * 10) | 0;
      if (gfc.noclipGainChange > 0) {
        if (EQ(gfp.scale, 1) || EQ(gfp.scale, 0))
          gfc.noclipScale = Math.floor(32767 / gfc.PeakSample * 100) / 100;
        else {
          gfc.noclipScale = -1;
        }
      } else
        gfc.noclipScale = -1;
    }
  };
  this.add_dummy_byte = function(gfp, val, n) {
    var gfc = gfp.internal_flags;
    var i;
    while (n-- > 0) {
      putbits_noheaders(gfc, val, 8);
      for (i = 0; i < LameInternalFlags$2.MAX_HEADER_BUF; ++i)
        gfc.header[i].write_timing += 8;
    }
  };
  this.format_bitstream = function(gfp) {
    var gfc = gfp.internal_flags;
    var l3_side;
    l3_side = gfc.l3_side;
    var bitsPerFrame = this.getframebits(gfp);
    drain_into_ancillary(gfp, l3_side.resvDrain_pre);
    encodeSideInfo2(gfp, bitsPerFrame);
    var bits = 8 * gfc.sideinfo_len;
    bits += writeMainData(gfp);
    drain_into_ancillary(gfp, l3_side.resvDrain_post);
    bits += l3_side.resvDrain_post;
    l3_side.main_data_begin += (bitsPerFrame - bits) / 8;
    if (compute_flushbits(gfp, new TotalBytes()) != gfc.ResvSize) {
      System$3.err.println("Internal buffer inconsistency. flushbits <> ResvSize");
    }
    if (l3_side.main_data_begin * 8 != gfc.ResvSize) {
      System$3.err.printf(
        "bit reservoir error: \nl3_side.main_data_begin: %d \nResvoir size:             %d \nresv drain (post)         %d \nresv drain (pre)          %d \nheader and sideinfo:      %d \ndata bits:                %d \ntotal bits:               %d (remainder: %d) \nbitsperframe:             %d \n",
        8 * l3_side.main_data_begin,
        gfc.ResvSize,
        l3_side.resvDrain_post,
        l3_side.resvDrain_pre,
        8 * gfc.sideinfo_len,
        bits - l3_side.resvDrain_post - 8 * gfc.sideinfo_len,
        bits,
        bits % 8,
        bitsPerFrame
      );
      System$3.err.println("This is a fatal error.  It has several possible causes:");
      System$3.err.println("90%%  LAME compiled with buggy version of gcc using advanced optimizations");
      System$3.err.println(" 9%%  Your system is overclocked");
      System$3.err.println(" 1%%  bug in LAME encoding library");
      gfc.ResvSize = l3_side.main_data_begin * 8;
    }
    assert$5(totbit % 8 == 0);
    if (totbit > 1e9) {
      var i;
      for (i = 0; i < LameInternalFlags$2.MAX_HEADER_BUF; ++i)
        gfc.header[i].write_timing -= totbit;
      totbit = 0;
    }
    return 0;
  };
  this.copy_buffer = function(gfc, buffer, bufferPos, size2, mp3data) {
    var minimum = bufByteIdx + 1;
    if (minimum <= 0)
      return 0;
    if (size2 != 0 && minimum > size2) {
      return -1;
    }
    System$3.arraycopy(buf, 0, buffer, bufferPos, minimum);
    bufByteIdx = -1;
    bufBitIdx = 0;
    if (mp3data != 0) {
      var crc = new_int$1(1);
      crc[0] = gfc.nMusicCRC;
      vbr.updateMusicCRC(crc, buffer, bufferPos, minimum);
      gfc.nMusicCRC = crc[0];
      if (minimum > 0) {
        gfc.VBR_seek_table.nBytesWritten += minimum;
      }
      if (gfc.decode_on_the_fly) {
        var pcm_buf = new_float_n([2, 1152]);
        var mp3_in = minimum;
        var samples_out = -1;
        var i;
        while (samples_out != 0) {
          samples_out = mpg.hip_decode1_unclipped(
            gfc.hip,
            buffer,
            bufferPos,
            mp3_in,
            pcm_buf[0],
            pcm_buf[1]
          );
          mp3_in = 0;
          if (samples_out == -1) {
            samples_out = 0;
          }
          if (samples_out > 0) {
            assert$5(samples_out <= 1152);
            if (gfc.findPeakSample) {
              for (i = 0; i < samples_out; i++) {
                if (pcm_buf[0][i] > gfc.PeakSample)
                  gfc.PeakSample = pcm_buf[0][i];
                else if (-pcm_buf[0][i] > gfc.PeakSample)
                  gfc.PeakSample = -pcm_buf[0][i];
              }
              if (gfc.channels_out > 1)
                for (i = 0; i < samples_out; i++) {
                  if (pcm_buf[1][i] > gfc.PeakSample)
                    gfc.PeakSample = pcm_buf[1][i];
                  else if (-pcm_buf[1][i] > gfc.PeakSample)
                    gfc.PeakSample = -pcm_buf[1][i];
                }
            }
            if (gfc.findReplayGain) {
              if (ga.AnalyzeSamples(
                gfc.rgdata,
                pcm_buf[0],
                0,
                pcm_buf[1],
                0,
                samples_out,
                gfc.channels_out
              ) == GainAnalysis.GAIN_ANALYSIS_ERROR)
                return -6;
            }
          }
        }
      }
    }
    return minimum;
  };
  this.init_bit_stream_w = function(gfc) {
    buf = new_byte$2(Lame.LAME_MAXMP3BUFFER);
    gfc.h_ptr = gfc.w_ptr = 0;
    gfc.header[gfc.h_ptr].write_timing = 0;
    bufByteIdx = -1;
    bufBitIdx = 0;
    totbit = 0;
  };
}
var BitStream_1 = BitStream$3;
var common$6 = common$l;
var System$2 = common$6.System;
var VbrMode$3 = common$6.VbrMode;
common$6.Float;
var ShortBlock$1 = common$6.ShortBlock;
common$6.Util;
common$6.Arrays;
common$6.new_array_n;
common$6.new_byte;
common$6.new_double;
var new_float$2 = common$6.new_float;
common$6.new_float_n;
common$6.new_int;
var new_int_n = common$6.new_int_n;
var new_short_n = common$6.new_short_n;
var assert$4 = common$6.assert;
var PsyModel = PsyModel_1;
var LameGlobalFlags = LameGlobalFlags_1;
var LameInternalFlags$1 = LameInternalFlags_1;
var ATH = ATH_1;
var ReplayGain = ReplayGain_1;
var CBRNewIterationLoop = CBRNewIterationLoop_1;
var BitStream$2 = BitStream_1;
var Tables$1 = Tables_1;
var Encoder$1 = requireEncoder();
function Lame$2() {
  var self2 = this;
  var LAME_MAXALBUMART = 128 * 1024;
  Lame$2.V9 = 410;
  Lame$2.V8 = 420;
  Lame$2.V7 = 430;
  Lame$2.V6 = 440;
  Lame$2.V5 = 450;
  Lame$2.V4 = 460;
  Lame$2.V3 = 470;
  Lame$2.V2 = 480;
  Lame$2.V1 = 490;
  Lame$2.V0 = 500;
  Lame$2.R3MIX = 1e3;
  Lame$2.STANDARD = 1001;
  Lame$2.EXTREME = 1002;
  Lame$2.INSANE = 1003;
  Lame$2.STANDARD_FAST = 1004;
  Lame$2.EXTREME_FAST = 1005;
  Lame$2.MEDIUM = 1006;
  Lame$2.MEDIUM_FAST = 1007;
  var LAME_MAXMP3BUFFER = 16384 + LAME_MAXALBUMART;
  Lame$2.LAME_MAXMP3BUFFER = LAME_MAXMP3BUFFER;
  var ga;
  var bs;
  var p2;
  var qupvt;
  var qu;
  var psy = new PsyModel();
  var vbr;
  var id3;
  var mpglib;
  this.enc = new Encoder$1();
  this.setModules = function(_ga, _bs, _p, _qupvt, _qu, _vbr, _ver, _id3, _mpglib) {
    ga = _ga;
    bs = _bs;
    p2 = _p;
    qupvt = _qupvt;
    qu = _qu;
    vbr = _vbr;
    id3 = _id3;
    mpglib = _mpglib;
    this.enc.setModules(bs, psy, qupvt, vbr);
  };
  function PSY() {
    this.mask_adjust = 0;
    this.mask_adjust_short = 0;
    this.bo_l_weight = new_float$2(Encoder$1.SBMAX_l);
    this.bo_s_weight = new_float$2(Encoder$1.SBMAX_s);
  }
  function LowPassHighPass() {
    this.lowerlimit = 0;
  }
  function BandPass(bitrate, lPass) {
    this.lowpass = lPass;
  }
  var LAME_ID = 4294479419;
  function lame_init_old(gfp) {
    var gfc;
    gfp.class_id = LAME_ID;
    gfc = gfp.internal_flags = new LameInternalFlags$1();
    gfp.mode = MPEGMode.NOT_SET;
    gfp.original = 1;
    gfp.in_samplerate = 44100;
    gfp.num_channels = 2;
    gfp.num_samples = -1;
    gfp.bWriteVbrTag = true;
    gfp.quality = -1;
    gfp.short_blocks = null;
    gfc.subblock_gain = -1;
    gfp.lowpassfreq = 0;
    gfp.highpassfreq = 0;
    gfp.lowpasswidth = -1;
    gfp.highpasswidth = -1;
    gfp.VBR = VbrMode$3.vbr_off;
    gfp.VBR_q = 4;
    gfp.ATHcurve = -1;
    gfp.VBR_mean_bitrate_kbps = 128;
    gfp.VBR_min_bitrate_kbps = 0;
    gfp.VBR_max_bitrate_kbps = 0;
    gfp.VBR_hard_min = 0;
    gfc.VBR_min_bitrate = 1;
    gfc.VBR_max_bitrate = 13;
    gfp.quant_comp = -1;
    gfp.quant_comp_short = -1;
    gfp.msfix = -1;
    gfc.resample_ratio = 1;
    gfc.OldValue[0] = 180;
    gfc.OldValue[1] = 180;
    gfc.CurrentStep[0] = 4;
    gfc.CurrentStep[1] = 4;
    gfc.masking_lower = 1;
    gfc.nsPsy.attackthre = -1;
    gfc.nsPsy.attackthre_s = -1;
    gfp.scale = -1;
    gfp.athaa_type = -1;
    gfp.ATHtype = -1;
    gfp.athaa_loudapprox = -1;
    gfp.athaa_sensitivity = 0;
    gfp.useTemporal = null;
    gfp.interChRatio = -1;
    gfc.mf_samples_to_encode = Encoder$1.ENCDELAY + Encoder$1.POSTDELAY;
    gfp.encoder_padding = 0;
    gfc.mf_size = Encoder$1.ENCDELAY - Encoder$1.MDCTDELAY;
    gfp.findReplayGain = false;
    gfp.decode_on_the_fly = false;
    gfc.decode_on_the_fly = false;
    gfc.findReplayGain = false;
    gfc.findPeakSample = false;
    gfc.RadioGain = 0;
    gfc.AudiophileGain = 0;
    gfc.noclipGainChange = 0;
    gfc.noclipScale = -1;
    gfp.preset = 0;
    gfp.write_id3tag_automatic = true;
    return 0;
  }
  this.lame_init = function() {
    var gfp = new LameGlobalFlags();
    lame_init_old(gfp);
    gfp.lame_allocated_gfp = 1;
    return gfp;
  };
  function filter_coef(x) {
    if (x > 1)
      return 0;
    if (x <= 0)
      return 1;
    return Math.cos(Math.PI / 2 * x);
  }
  this.nearestBitrateFullIndex = function(bitrate) {
    var full_bitrate_table = [
      8,
      16,
      24,
      32,
      40,
      48,
      56,
      64,
      80,
      96,
      112,
      128,
      160,
      192,
      224,
      256,
      320
    ];
    var lower_range = 0, lower_range_kbps = 0, upper_range = 0, upper_range_kbps = 0;
    upper_range_kbps = full_bitrate_table[16];
    upper_range = 16;
    lower_range_kbps = full_bitrate_table[16];
    lower_range = 16;
    for (var b = 0; b < 16; b++) {
      if (Math.max(bitrate, full_bitrate_table[b + 1]) != bitrate) {
        upper_range_kbps = full_bitrate_table[b + 1];
        upper_range = b + 1;
        lower_range_kbps = full_bitrate_table[b];
        lower_range = b;
        break;
      }
    }
    if (upper_range_kbps - bitrate > bitrate - lower_range_kbps) {
      return lower_range;
    }
    return upper_range;
  };
  function optimum_samplefreq(lowpassfreq, input_samplefreq) {
    var suggested_samplefreq = 44100;
    if (input_samplefreq >= 48e3)
      suggested_samplefreq = 48e3;
    else if (input_samplefreq >= 44100)
      suggested_samplefreq = 44100;
    else if (input_samplefreq >= 32e3)
      suggested_samplefreq = 32e3;
    else if (input_samplefreq >= 24e3)
      suggested_samplefreq = 24e3;
    else if (input_samplefreq >= 22050)
      suggested_samplefreq = 22050;
    else if (input_samplefreq >= 16e3)
      suggested_samplefreq = 16e3;
    else if (input_samplefreq >= 12e3)
      suggested_samplefreq = 12e3;
    else if (input_samplefreq >= 11025)
      suggested_samplefreq = 11025;
    else if (input_samplefreq >= 8e3)
      suggested_samplefreq = 8e3;
    if (lowpassfreq == -1)
      return suggested_samplefreq;
    if (lowpassfreq <= 15960)
      suggested_samplefreq = 44100;
    if (lowpassfreq <= 15250)
      suggested_samplefreq = 32e3;
    if (lowpassfreq <= 11220)
      suggested_samplefreq = 24e3;
    if (lowpassfreq <= 9970)
      suggested_samplefreq = 22050;
    if (lowpassfreq <= 7230)
      suggested_samplefreq = 16e3;
    if (lowpassfreq <= 5420)
      suggested_samplefreq = 12e3;
    if (lowpassfreq <= 4510)
      suggested_samplefreq = 11025;
    if (lowpassfreq <= 3970)
      suggested_samplefreq = 8e3;
    if (input_samplefreq < suggested_samplefreq) {
      if (input_samplefreq > 44100) {
        return 48e3;
      }
      if (input_samplefreq > 32e3) {
        return 44100;
      }
      if (input_samplefreq > 24e3) {
        return 32e3;
      }
      if (input_samplefreq > 22050) {
        return 24e3;
      }
      if (input_samplefreq > 16e3) {
        return 22050;
      }
      if (input_samplefreq > 12e3) {
        return 16e3;
      }
      if (input_samplefreq > 11025) {
        return 12e3;
      }
      if (input_samplefreq > 8e3) {
        return 11025;
      }
      return 8e3;
    }
    return suggested_samplefreq;
  }
  function SmpFrqIndex(sample_freq, gpf) {
    switch (sample_freq) {
      case 44100:
        gpf.version = 1;
        return 0;
      case 48e3:
        gpf.version = 1;
        return 1;
      case 32e3:
        gpf.version = 1;
        return 2;
      case 22050:
        gpf.version = 0;
        return 0;
      case 24e3:
        gpf.version = 0;
        return 1;
      case 16e3:
        gpf.version = 0;
        return 2;
      case 11025:
        gpf.version = 0;
        return 0;
      case 12e3:
        gpf.version = 0;
        return 1;
      case 8e3:
        gpf.version = 0;
        return 2;
      default:
        gpf.version = 0;
        return -1;
    }
  }
  function FindNearestBitrate(bRate, version2, samplerate) {
    if (samplerate < 16e3)
      version2 = 2;
    var bitrate = Tables$1.bitrate_table[version2][1];
    for (var i = 2; i <= 14; i++) {
      if (Tables$1.bitrate_table[version2][i] > 0) {
        if (Math.abs(Tables$1.bitrate_table[version2][i] - bRate) < Math.abs(bitrate - bRate))
          bitrate = Tables$1.bitrate_table[version2][i];
      }
    }
    return bitrate;
  }
  function BitrateIndex(bRate, version2, samplerate) {
    if (samplerate < 16e3)
      version2 = 2;
    for (var i = 0; i <= 14; i++) {
      if (Tables$1.bitrate_table[version2][i] > 0) {
        if (Tables$1.bitrate_table[version2][i] == bRate) {
          return i;
        }
      }
    }
    return -1;
  }
  function optimum_bandwidth(lh, bitrate) {
    var freq_map = [
      new BandPass(8, 2e3),
      new BandPass(16, 3700),
      new BandPass(24, 3900),
      new BandPass(32, 5500),
      new BandPass(40, 7e3),
      new BandPass(48, 7500),
      new BandPass(56, 1e4),
      new BandPass(64, 11e3),
      new BandPass(80, 13500),
      new BandPass(96, 15100),
      new BandPass(112, 15600),
      new BandPass(128, 17e3),
      new BandPass(160, 17500),
      new BandPass(192, 18600),
      new BandPass(224, 19400),
      new BandPass(256, 19700),
      new BandPass(320, 20500)
    ];
    var table_index = self2.nearestBitrateFullIndex(bitrate);
    lh.lowerlimit = freq_map[table_index].lowpass;
  }
  function lame_init_params_ppflt(gfp) {
    var gfc = gfp.internal_flags;
    var lowpass_band = 32;
    var highpass_band = -1;
    if (gfc.lowpass1 > 0) {
      var minband = 999;
      for (var band = 0; band <= 31; band++) {
        var freq = band / 31;
        if (freq >= gfc.lowpass2) {
          lowpass_band = Math.min(lowpass_band, band);
        }
        if (gfc.lowpass1 < freq && freq < gfc.lowpass2) {
          minband = Math.min(minband, band);
        }
      }
      if (minband == 999) {
        gfc.lowpass1 = (lowpass_band - 0.75) / 31;
      } else {
        gfc.lowpass1 = (minband - 0.75) / 31;
      }
      gfc.lowpass2 = lowpass_band / 31;
    }
    if (gfc.highpass2 > 0) {
      if (gfc.highpass2 < 0.9 * (0.75 / 31)) {
        gfc.highpass1 = 0;
        gfc.highpass2 = 0;
        System$2.err.println("Warning: highpass filter disabled.  highpass frequency too small\n");
      }
    }
    if (gfc.highpass2 > 0) {
      var maxband = -1;
      for (var band = 0; band <= 31; band++) {
        var freq = band / 31;
        if (freq <= gfc.highpass1) {
          highpass_band = Math.max(highpass_band, band);
        }
        if (gfc.highpass1 < freq && freq < gfc.highpass2) {
          maxband = Math.max(maxband, band);
        }
      }
      gfc.highpass1 = highpass_band / 31;
      if (maxband == -1) {
        gfc.highpass2 = (highpass_band + 0.75) / 31;
      } else {
        gfc.highpass2 = (maxband + 0.75) / 31;
      }
    }
    for (var band = 0; band < 32; band++) {
      var fc1, fc2;
      var freq = band / 31;
      if (gfc.highpass2 > gfc.highpass1) {
        fc1 = filter_coef((gfc.highpass2 - freq) / (gfc.highpass2 - gfc.highpass1 + 1e-20));
      } else {
        fc1 = 1;
      }
      if (gfc.lowpass2 > gfc.lowpass1) {
        fc2 = filter_coef((freq - gfc.lowpass1) / (gfc.lowpass2 - gfc.lowpass1 + 1e-20));
      } else {
        fc2 = 1;
      }
      gfc.amp_filter[band] = fc1 * fc2;
    }
  }
  function lame_init_qval(gfp) {
    var gfc = gfp.internal_flags;
    switch (gfp.quality) {
      default:
      case 9:
        gfc.psymodel = 0;
        gfc.noise_shaping = 0;
        gfc.noise_shaping_amp = 0;
        gfc.noise_shaping_stop = 0;
        gfc.use_best_huffman = 0;
        gfc.full_outer_loop = 0;
        break;
      case 8:
        gfp.quality = 7;
      case 7:
        gfc.psymodel = 1;
        gfc.noise_shaping = 0;
        gfc.noise_shaping_amp = 0;
        gfc.noise_shaping_stop = 0;
        gfc.use_best_huffman = 0;
        gfc.full_outer_loop = 0;
        break;
      case 6:
        gfc.psymodel = 1;
        if (gfc.noise_shaping == 0)
          gfc.noise_shaping = 1;
        gfc.noise_shaping_amp = 0;
        gfc.noise_shaping_stop = 0;
        if (gfc.subblock_gain == -1)
          gfc.subblock_gain = 1;
        gfc.use_best_huffman = 0;
        gfc.full_outer_loop = 0;
        break;
      case 5:
        gfc.psymodel = 1;
        if (gfc.noise_shaping == 0)
          gfc.noise_shaping = 1;
        gfc.noise_shaping_amp = 0;
        gfc.noise_shaping_stop = 0;
        if (gfc.subblock_gain == -1)
          gfc.subblock_gain = 1;
        gfc.use_best_huffman = 0;
        gfc.full_outer_loop = 0;
        break;
      case 4:
        gfc.psymodel = 1;
        if (gfc.noise_shaping == 0)
          gfc.noise_shaping = 1;
        gfc.noise_shaping_amp = 0;
        gfc.noise_shaping_stop = 0;
        if (gfc.subblock_gain == -1)
          gfc.subblock_gain = 1;
        gfc.use_best_huffman = 1;
        gfc.full_outer_loop = 0;
        break;
      case 3:
        gfc.psymodel = 1;
        if (gfc.noise_shaping == 0)
          gfc.noise_shaping = 1;
        gfc.noise_shaping_amp = 1;
        gfc.noise_shaping_stop = 1;
        if (gfc.subblock_gain == -1)
          gfc.subblock_gain = 1;
        gfc.use_best_huffman = 1;
        gfc.full_outer_loop = 0;
        break;
      case 2:
        gfc.psymodel = 1;
        if (gfc.noise_shaping == 0)
          gfc.noise_shaping = 1;
        if (gfc.substep_shaping == 0)
          gfc.substep_shaping = 2;
        gfc.noise_shaping_amp = 1;
        gfc.noise_shaping_stop = 1;
        if (gfc.subblock_gain == -1)
          gfc.subblock_gain = 1;
        gfc.use_best_huffman = 1;
        gfc.full_outer_loop = 0;
        break;
      case 1:
        gfc.psymodel = 1;
        if (gfc.noise_shaping == 0)
          gfc.noise_shaping = 1;
        if (gfc.substep_shaping == 0)
          gfc.substep_shaping = 2;
        gfc.noise_shaping_amp = 2;
        gfc.noise_shaping_stop = 1;
        if (gfc.subblock_gain == -1)
          gfc.subblock_gain = 1;
        gfc.use_best_huffman = 1;
        gfc.full_outer_loop = 0;
        break;
      case 0:
        gfc.psymodel = 1;
        if (gfc.noise_shaping == 0)
          gfc.noise_shaping = 1;
        if (gfc.substep_shaping == 0)
          gfc.substep_shaping = 2;
        gfc.noise_shaping_amp = 2;
        gfc.noise_shaping_stop = 1;
        if (gfc.subblock_gain == -1)
          gfc.subblock_gain = 1;
        gfc.use_best_huffman = 1;
        gfc.full_outer_loop = 0;
        break;
    }
  }
  function lame_init_bitstream(gfp) {
    var gfc = gfp.internal_flags;
    gfp.frameNum = 0;
    if (gfp.write_id3tag_automatic) {
      id3.id3tag_write_v2(gfp);
    }
    gfc.bitrate_stereoMode_Hist = new_int_n([16, 4 + 1]);
    gfc.bitrate_blockType_Hist = new_int_n([16, 4 + 1 + 1]);
    gfc.PeakSample = 0;
    if (gfp.bWriteVbrTag)
      vbr.InitVbrTag(gfp);
  }
  this.lame_init_params = function(gfp) {
    var gfc = gfp.internal_flags;
    gfc.Class_ID = 0;
    if (gfc.ATH == null)
      gfc.ATH = new ATH();
    if (gfc.PSY == null)
      gfc.PSY = new PSY();
    if (gfc.rgdata == null)
      gfc.rgdata = new ReplayGain();
    gfc.channels_in = gfp.num_channels;
    if (gfc.channels_in == 1)
      gfp.mode = MPEGMode.MONO;
    gfc.channels_out = gfp.mode == MPEGMode.MONO ? 1 : 2;
    gfc.mode_ext = Encoder$1.MPG_MD_MS_LR;
    if (gfp.mode == MPEGMode.MONO)
      gfp.force_ms = false;
    if (gfp.VBR == VbrMode$3.vbr_off && gfp.VBR_mean_bitrate_kbps != 128 && gfp.brate == 0)
      gfp.brate = gfp.VBR_mean_bitrate_kbps;
    if (gfp.VBR == VbrMode$3.vbr_off || gfp.VBR == VbrMode$3.vbr_mtrh || gfp.VBR == VbrMode$3.vbr_mt)
      ;
    else {
      gfp.free_format = false;
    }
    if (gfp.VBR == VbrMode$3.vbr_off && gfp.brate == 0) {
      if (BitStream$2.EQ(gfp.compression_ratio, 0))
        gfp.compression_ratio = 11.025;
    }
    if (gfp.VBR == VbrMode$3.vbr_off && gfp.compression_ratio > 0) {
      if (gfp.out_samplerate == 0)
        gfp.out_samplerate = map2MP3Frequency(int(0.97 * gfp.in_samplerate));
      gfp.brate = 0 | gfp.out_samplerate * 16 * gfc.channels_out / (1e3 * gfp.compression_ratio);
      gfc.samplerate_index = SmpFrqIndex(gfp.out_samplerate, gfp);
      if (!gfp.free_format)
        gfp.brate = FindNearestBitrate(
          gfp.brate,
          gfp.version,
          gfp.out_samplerate
        );
    }
    if (gfp.out_samplerate != 0) {
      if (gfp.out_samplerate < 16e3) {
        gfp.VBR_mean_bitrate_kbps = Math.max(
          gfp.VBR_mean_bitrate_kbps,
          8
        );
        gfp.VBR_mean_bitrate_kbps = Math.min(
          gfp.VBR_mean_bitrate_kbps,
          64
        );
      } else if (gfp.out_samplerate < 32e3) {
        gfp.VBR_mean_bitrate_kbps = Math.max(
          gfp.VBR_mean_bitrate_kbps,
          8
        );
        gfp.VBR_mean_bitrate_kbps = Math.min(
          gfp.VBR_mean_bitrate_kbps,
          160
        );
      } else {
        gfp.VBR_mean_bitrate_kbps = Math.max(
          gfp.VBR_mean_bitrate_kbps,
          32
        );
        gfp.VBR_mean_bitrate_kbps = Math.min(
          gfp.VBR_mean_bitrate_kbps,
          320
        );
      }
    }
    if (gfp.lowpassfreq == 0) {
      var lowpass = 16e3;
      switch (gfp.VBR) {
        case VbrMode$3.vbr_off: {
          var lh = new LowPassHighPass();
          optimum_bandwidth(lh, gfp.brate);
          lowpass = lh.lowerlimit;
          break;
        }
        case VbrMode$3.vbr_abr: {
          var lh = new LowPassHighPass();
          optimum_bandwidth(lh, gfp.VBR_mean_bitrate_kbps);
          lowpass = lh.lowerlimit;
          break;
        }
        case VbrMode$3.vbr_rh: {
          var x = [
            19500,
            19e3,
            18600,
            18e3,
            17500,
            16e3,
            15600,
            14900,
            12500,
            1e4,
            3950
          ];
          if (0 <= gfp.VBR_q && gfp.VBR_q <= 9) {
            var a = x[gfp.VBR_q], b = x[gfp.VBR_q + 1], m = gfp.VBR_q_frac;
            lowpass = linear_int(a, b, m);
          } else {
            lowpass = 19500;
          }
          break;
        }
        default: {
          var x = [
            19500,
            19e3,
            18500,
            18e3,
            17500,
            16500,
            15500,
            14500,
            12500,
            9500,
            3950
          ];
          if (0 <= gfp.VBR_q && gfp.VBR_q <= 9) {
            var a = x[gfp.VBR_q], b = x[gfp.VBR_q + 1], m = gfp.VBR_q_frac;
            lowpass = linear_int(a, b, m);
          } else {
            lowpass = 19500;
          }
        }
      }
      if (gfp.mode == MPEGMode.MONO && (gfp.VBR == VbrMode$3.vbr_off || gfp.VBR == VbrMode$3.vbr_abr))
        lowpass *= 1.5;
      gfp.lowpassfreq = lowpass | 0;
    }
    if (gfp.out_samplerate == 0) {
      if (2 * gfp.lowpassfreq > gfp.in_samplerate) {
        gfp.lowpassfreq = gfp.in_samplerate / 2;
      }
      gfp.out_samplerate = optimum_samplefreq(
        gfp.lowpassfreq | 0,
        gfp.in_samplerate
      );
    }
    gfp.lowpassfreq = Math.min(20500, gfp.lowpassfreq);
    gfp.lowpassfreq = Math.min(gfp.out_samplerate / 2, gfp.lowpassfreq);
    if (gfp.VBR == VbrMode$3.vbr_off) {
      gfp.compression_ratio = gfp.out_samplerate * 16 * gfc.channels_out / (1e3 * gfp.brate);
    }
    if (gfp.VBR == VbrMode$3.vbr_abr) {
      gfp.compression_ratio = gfp.out_samplerate * 16 * gfc.channels_out / (1e3 * gfp.VBR_mean_bitrate_kbps);
    }
    if (!gfp.bWriteVbrTag) {
      gfp.findReplayGain = false;
      gfp.decode_on_the_fly = false;
      gfc.findPeakSample = false;
    }
    gfc.findReplayGain = gfp.findReplayGain;
    gfc.decode_on_the_fly = gfp.decode_on_the_fly;
    if (gfc.decode_on_the_fly)
      gfc.findPeakSample = true;
    if (gfc.findReplayGain) {
      if (ga.InitGainAnalysis(gfc.rgdata, gfp.out_samplerate) == GainAnalysis.INIT_GAIN_ANALYSIS_ERROR) {
        gfp.internal_flags = null;
        return -6;
      }
    }
    if (gfc.decode_on_the_fly && !gfp.decode_only) {
      if (gfc.hip != null) {
        mpglib.hip_decode_exit(gfc.hip);
      }
      gfc.hip = mpglib.hip_decode_init();
    }
    gfc.mode_gr = gfp.out_samplerate <= 24e3 ? 1 : 2;
    gfp.framesize = 576 * gfc.mode_gr;
    gfp.encoder_delay = Encoder$1.ENCDELAY;
    gfc.resample_ratio = gfp.in_samplerate / gfp.out_samplerate;
    switch (gfp.VBR) {
      case VbrMode$3.vbr_mt:
      case VbrMode$3.vbr_rh:
      case VbrMode$3.vbr_mtrh:
        {
          var cmp = [
            5.7,
            6.5,
            7.3,
            8.2,
            10,
            11.9,
            13,
            14,
            15,
            16.5
          ];
          gfp.compression_ratio = cmp[gfp.VBR_q];
        }
        break;
      case VbrMode$3.vbr_abr:
        gfp.compression_ratio = gfp.out_samplerate * 16 * gfc.channels_out / (1e3 * gfp.VBR_mean_bitrate_kbps);
        break;
      default:
        gfp.compression_ratio = gfp.out_samplerate * 16 * gfc.channels_out / (1e3 * gfp.brate);
        break;
    }
    if (gfp.mode == MPEGMode.NOT_SET) {
      gfp.mode = MPEGMode.JOINT_STEREO;
    }
    if (gfp.highpassfreq > 0) {
      gfc.highpass1 = 2 * gfp.highpassfreq;
      if (gfp.highpasswidth >= 0)
        gfc.highpass2 = 2 * (gfp.highpassfreq + gfp.highpasswidth);
      else
        gfc.highpass2 = (1 + 0) * 2 * gfp.highpassfreq;
      gfc.highpass1 /= gfp.out_samplerate;
      gfc.highpass2 /= gfp.out_samplerate;
    } else {
      gfc.highpass1 = 0;
      gfc.highpass2 = 0;
    }
    if (gfp.lowpassfreq > 0) {
      gfc.lowpass2 = 2 * gfp.lowpassfreq;
      if (gfp.lowpasswidth >= 0) {
        gfc.lowpass1 = 2 * (gfp.lowpassfreq - gfp.lowpasswidth);
        if (gfc.lowpass1 < 0)
          gfc.lowpass1 = 0;
      } else {
        gfc.lowpass1 = (1 - 0) * 2 * gfp.lowpassfreq;
      }
      gfc.lowpass1 /= gfp.out_samplerate;
      gfc.lowpass2 /= gfp.out_samplerate;
    } else {
      gfc.lowpass1 = 0;
      gfc.lowpass2 = 0;
    }
    lame_init_params_ppflt(gfp);
    gfc.samplerate_index = SmpFrqIndex(gfp.out_samplerate, gfp);
    if (gfc.samplerate_index < 0) {
      gfp.internal_flags = null;
      return -1;
    }
    if (gfp.VBR == VbrMode$3.vbr_off) {
      if (gfp.free_format) {
        gfc.bitrate_index = 0;
      } else {
        gfp.brate = FindNearestBitrate(
          gfp.brate,
          gfp.version,
          gfp.out_samplerate
        );
        gfc.bitrate_index = BitrateIndex(
          gfp.brate,
          gfp.version,
          gfp.out_samplerate
        );
        if (gfc.bitrate_index <= 0) {
          gfp.internal_flags = null;
          return -1;
        }
      }
    } else {
      gfc.bitrate_index = 1;
    }
    if (gfp.analysis)
      gfp.bWriteVbrTag = false;
    if (gfc.pinfo != null)
      gfp.bWriteVbrTag = false;
    bs.init_bit_stream_w(gfc);
    var j = gfc.samplerate_index + 3 * gfp.version + 6 * (gfp.out_samplerate < 16e3 ? 1 : 0);
    for (var i = 0; i < Encoder$1.SBMAX_l + 1; i++)
      gfc.scalefac_band.l[i] = qupvt.sfBandIndex[j].l[i];
    for (var i = 0; i < Encoder$1.PSFB21 + 1; i++) {
      var size2 = (gfc.scalefac_band.l[22] - gfc.scalefac_band.l[21]) / Encoder$1.PSFB21;
      var start = gfc.scalefac_band.l[21] + i * size2;
      gfc.scalefac_band.psfb21[i] = start;
    }
    gfc.scalefac_band.psfb21[Encoder$1.PSFB21] = 576;
    for (var i = 0; i < Encoder$1.SBMAX_s + 1; i++)
      gfc.scalefac_band.s[i] = qupvt.sfBandIndex[j].s[i];
    for (var i = 0; i < Encoder$1.PSFB12 + 1; i++) {
      var size2 = (gfc.scalefac_band.s[13] - gfc.scalefac_band.s[12]) / Encoder$1.PSFB12;
      var start = gfc.scalefac_band.s[12] + i * size2;
      gfc.scalefac_band.psfb12[i] = start;
    }
    gfc.scalefac_band.psfb12[Encoder$1.PSFB12] = 192;
    if (gfp.version == 1)
      gfc.sideinfo_len = gfc.channels_out == 1 ? 4 + 17 : 4 + 32;
    else
      gfc.sideinfo_len = gfc.channels_out == 1 ? 4 + 9 : 4 + 17;
    if (gfp.error_protection)
      gfc.sideinfo_len += 2;
    lame_init_bitstream(gfp);
    gfc.Class_ID = LAME_ID;
    {
      var k;
      for (k = 0; k < 19; k++)
        gfc.nsPsy.pefirbuf[k] = 700 * gfc.mode_gr * gfc.channels_out;
      if (gfp.ATHtype == -1)
        gfp.ATHtype = 4;
    }
    assert$4(gfp.VBR_q <= 9);
    assert$4(gfp.VBR_q >= 0);
    switch (gfp.VBR) {
      case VbrMode$3.vbr_mt:
        gfp.VBR = VbrMode$3.vbr_mtrh;
      case VbrMode$3.vbr_mtrh: {
        if (gfp.useTemporal == null) {
          gfp.useTemporal = false;
        }
        p2.apply_preset(gfp, 500 - gfp.VBR_q * 10, 0);
        if (gfp.quality < 0)
          gfp.quality = LAME_DEFAULT_QUALITY;
        if (gfp.quality < 5)
          gfp.quality = 0;
        if (gfp.quality > 5)
          gfp.quality = 5;
        gfc.PSY.mask_adjust = gfp.maskingadjust;
        gfc.PSY.mask_adjust_short = gfp.maskingadjust_short;
        if (gfp.experimentalY)
          gfc.sfb21_extra = false;
        else
          gfc.sfb21_extra = gfp.out_samplerate > 44e3;
        gfc.iteration_loop = new VBRNewIterationLoop(qu);
        break;
      }
      case VbrMode$3.vbr_rh: {
        p2.apply_preset(gfp, 500 - gfp.VBR_q * 10, 0);
        gfc.PSY.mask_adjust = gfp.maskingadjust;
        gfc.PSY.mask_adjust_short = gfp.maskingadjust_short;
        if (gfp.experimentalY)
          gfc.sfb21_extra = false;
        else
          gfc.sfb21_extra = gfp.out_samplerate > 44e3;
        if (gfp.quality > 6)
          gfp.quality = 6;
        if (gfp.quality < 0)
          gfp.quality = LAME_DEFAULT_QUALITY;
        gfc.iteration_loop = new VBROldIterationLoop(qu);
        break;
      }
      default: {
        var vbrmode;
        gfc.sfb21_extra = false;
        if (gfp.quality < 0)
          gfp.quality = LAME_DEFAULT_QUALITY;
        vbrmode = gfp.VBR;
        if (vbrmode == VbrMode$3.vbr_off)
          gfp.VBR_mean_bitrate_kbps = gfp.brate;
        p2.apply_preset(gfp, gfp.VBR_mean_bitrate_kbps, 0);
        gfp.VBR = vbrmode;
        gfc.PSY.mask_adjust = gfp.maskingadjust;
        gfc.PSY.mask_adjust_short = gfp.maskingadjust_short;
        if (vbrmode == VbrMode$3.vbr_off) {
          gfc.iteration_loop = new CBRNewIterationLoop(qu);
        } else {
          gfc.iteration_loop = new ABRIterationLoop(qu);
        }
        break;
      }
    }
    assert$4(gfp.scale >= 0);
    if (gfp.VBR != VbrMode$3.vbr_off) {
      gfc.VBR_min_bitrate = 1;
      gfc.VBR_max_bitrate = 14;
      if (gfp.out_samplerate < 16e3)
        gfc.VBR_max_bitrate = 8;
      if (gfp.VBR_min_bitrate_kbps != 0) {
        gfp.VBR_min_bitrate_kbps = FindNearestBitrate(
          gfp.VBR_min_bitrate_kbps,
          gfp.version,
          gfp.out_samplerate
        );
        gfc.VBR_min_bitrate = BitrateIndex(
          gfp.VBR_min_bitrate_kbps,
          gfp.version,
          gfp.out_samplerate
        );
        if (gfc.VBR_min_bitrate < 0)
          return -1;
      }
      if (gfp.VBR_max_bitrate_kbps != 0) {
        gfp.VBR_max_bitrate_kbps = FindNearestBitrate(
          gfp.VBR_max_bitrate_kbps,
          gfp.version,
          gfp.out_samplerate
        );
        gfc.VBR_max_bitrate = BitrateIndex(
          gfp.VBR_max_bitrate_kbps,
          gfp.version,
          gfp.out_samplerate
        );
        if (gfc.VBR_max_bitrate < 0)
          return -1;
      }
      gfp.VBR_min_bitrate_kbps = Tables$1.bitrate_table[gfp.version][gfc.VBR_min_bitrate];
      gfp.VBR_max_bitrate_kbps = Tables$1.bitrate_table[gfp.version][gfc.VBR_max_bitrate];
      gfp.VBR_mean_bitrate_kbps = Math.min(
        Tables$1.bitrate_table[gfp.version][gfc.VBR_max_bitrate],
        gfp.VBR_mean_bitrate_kbps
      );
      gfp.VBR_mean_bitrate_kbps = Math.max(
        Tables$1.bitrate_table[gfp.version][gfc.VBR_min_bitrate],
        gfp.VBR_mean_bitrate_kbps
      );
    }
    if (gfp.tune) {
      gfc.PSY.mask_adjust += gfp.tune_value_a;
      gfc.PSY.mask_adjust_short += gfp.tune_value_a;
    }
    lame_init_qval(gfp);
    assert$4(gfp.scale >= 0);
    if (gfp.athaa_type < 0)
      gfc.ATH.useAdjust = 3;
    else
      gfc.ATH.useAdjust = gfp.athaa_type;
    gfc.ATH.aaSensitivityP = Math.pow(10, gfp.athaa_sensitivity / -10);
    if (gfp.short_blocks == null) {
      gfp.short_blocks = ShortBlock$1.short_block_allowed;
    }
    if (gfp.short_blocks == ShortBlock$1.short_block_allowed && (gfp.mode == MPEGMode.JOINT_STEREO || gfp.mode == MPEGMode.STEREO)) {
      gfp.short_blocks = ShortBlock$1.short_block_coupled;
    }
    if (gfp.quant_comp < 0)
      gfp.quant_comp = 1;
    if (gfp.quant_comp_short < 0)
      gfp.quant_comp_short = 0;
    if (gfp.msfix < 0)
      gfp.msfix = 0;
    gfp.exp_nspsytune = gfp.exp_nspsytune | 1;
    if (gfp.internal_flags.nsPsy.attackthre < 0)
      gfp.internal_flags.nsPsy.attackthre = PsyModel.NSATTACKTHRE;
    if (gfp.internal_flags.nsPsy.attackthre_s < 0)
      gfp.internal_flags.nsPsy.attackthre_s = PsyModel.NSATTACKTHRE_S;
    assert$4(gfp.scale >= 0);
    if (gfp.scale < 0)
      gfp.scale = 1;
    if (gfp.ATHtype < 0)
      gfp.ATHtype = 4;
    if (gfp.ATHcurve < 0)
      gfp.ATHcurve = 4;
    if (gfp.athaa_loudapprox < 0)
      gfp.athaa_loudapprox = 2;
    if (gfp.interChRatio < 0)
      gfp.interChRatio = 0;
    if (gfp.useTemporal == null)
      gfp.useTemporal = true;
    gfc.slot_lag = gfc.frac_SpF = 0;
    if (gfp.VBR == VbrMode$3.vbr_off)
      gfc.slot_lag = gfc.frac_SpF = (gfp.version + 1) * 72e3 * gfp.brate % gfp.out_samplerate | 0;
    qupvt.iteration_init(gfp);
    psy.psymodel_init(gfp);
    assert$4(gfp.scale >= 0);
    return 0;
  };
  function update_inbuffer_size(gfc, nsamples) {
    if (gfc.in_buffer_0 == null || gfc.in_buffer_nsamples < nsamples) {
      gfc.in_buffer_0 = new_float$2(nsamples);
      gfc.in_buffer_1 = new_float$2(nsamples);
      gfc.in_buffer_nsamples = nsamples;
    }
  }
  this.lame_encode_flush = function(gfp, mp3buffer, mp3bufferPos, mp3buffer_size) {
    var gfc = gfp.internal_flags;
    var buffer = new_short_n([2, 1152]);
    var imp3 = 0, mp3count, mp3buffer_size_remaining;
    var end_padding;
    var frames_left;
    var samples_to_encode = gfc.mf_samples_to_encode - Encoder$1.POSTDELAY;
    var mf_needed = calcNeeded(gfp);
    if (gfc.mf_samples_to_encode < 1) {
      return 0;
    }
    mp3count = 0;
    if (gfp.in_samplerate != gfp.out_samplerate) {
      samples_to_encode += 16 * gfp.out_samplerate / gfp.in_samplerate;
    }
    end_padding = gfp.framesize - samples_to_encode % gfp.framesize;
    if (end_padding < 576)
      end_padding += gfp.framesize;
    gfp.encoder_padding = end_padding;
    frames_left = (samples_to_encode + end_padding) / gfp.framesize;
    while (frames_left > 0 && imp3 >= 0) {
      var bunch = mf_needed - gfc.mf_size;
      var frame_num = gfp.frameNum;
      bunch *= gfp.in_samplerate;
      bunch /= gfp.out_samplerate;
      if (bunch > 1152)
        bunch = 1152;
      if (bunch < 1)
        bunch = 1;
      mp3buffer_size_remaining = mp3buffer_size - mp3count;
      if (mp3buffer_size == 0)
        mp3buffer_size_remaining = 0;
      imp3 = this.lame_encode_buffer(
        gfp,
        buffer[0],
        buffer[1],
        bunch,
        mp3buffer,
        mp3bufferPos,
        mp3buffer_size_remaining
      );
      mp3bufferPos += imp3;
      mp3count += imp3;
      frames_left -= frame_num != gfp.frameNum ? 1 : 0;
    }
    gfc.mf_samples_to_encode = 0;
    if (imp3 < 0) {
      return imp3;
    }
    mp3buffer_size_remaining = mp3buffer_size - mp3count;
    if (mp3buffer_size == 0)
      mp3buffer_size_remaining = 0;
    bs.flush_bitstream(gfp);
    imp3 = bs.copy_buffer(
      gfc,
      mp3buffer,
      mp3bufferPos,
      mp3buffer_size_remaining,
      1
    );
    if (imp3 < 0) {
      return imp3;
    }
    mp3bufferPos += imp3;
    mp3count += imp3;
    mp3buffer_size_remaining = mp3buffer_size - mp3count;
    if (mp3buffer_size == 0)
      mp3buffer_size_remaining = 0;
    if (gfp.write_id3tag_automatic) {
      id3.id3tag_write_v1(gfp);
      imp3 = bs.copy_buffer(
        gfc,
        mp3buffer,
        mp3bufferPos,
        mp3buffer_size_remaining,
        0
      );
      if (imp3 < 0) {
        return imp3;
      }
      mp3count += imp3;
    }
    return mp3count;
  };
  this.lame_encode_buffer = function(gfp, buffer_l, buffer_r, nsamples, mp3buf, mp3bufPos, mp3buf_size) {
    var gfc = gfp.internal_flags;
    var in_buffer = [null, null];
    if (gfc.Class_ID != LAME_ID)
      return -3;
    if (nsamples == 0)
      return 0;
    update_inbuffer_size(gfc, nsamples);
    in_buffer[0] = gfc.in_buffer_0;
    in_buffer[1] = gfc.in_buffer_1;
    for (var i = 0; i < nsamples; i++) {
      in_buffer[0][i] = buffer_l[i];
      if (gfc.channels_in > 1)
        in_buffer[1][i] = buffer_r[i];
    }
    return lame_encode_buffer_sample(
      gfp,
      in_buffer[0],
      in_buffer[1],
      nsamples,
      mp3buf,
      mp3bufPos,
      mp3buf_size
    );
  };
  function calcNeeded(gfp) {
    var mf_needed = Encoder$1.BLKSIZE + gfp.framesize - Encoder$1.FFTOFFSET;
    mf_needed = Math.max(mf_needed, 512 + gfp.framesize - 32);
    assert$4(LameInternalFlags$1.MFSIZE >= mf_needed);
    return mf_needed;
  }
  function lame_encode_buffer_sample(gfp, buffer_l, buffer_r, nsamples, mp3buf, mp3bufPos, mp3buf_size) {
    var gfc = gfp.internal_flags;
    var mp3size = 0, ret, i, ch, mf_needed;
    var mp3out;
    var mfbuf = [null, null];
    var in_buffer = [null, null];
    if (gfc.Class_ID != LAME_ID)
      return -3;
    if (nsamples == 0)
      return 0;
    mp3out = bs.copy_buffer(gfc, mp3buf, mp3bufPos, mp3buf_size, 0);
    if (mp3out < 0)
      return mp3out;
    mp3bufPos += mp3out;
    mp3size += mp3out;
    in_buffer[0] = buffer_l;
    in_buffer[1] = buffer_r;
    if (BitStream$2.NEQ(gfp.scale, 0) && BitStream$2.NEQ(gfp.scale, 1)) {
      for (i = 0; i < nsamples; ++i) {
        in_buffer[0][i] *= gfp.scale;
        if (gfc.channels_out == 2)
          in_buffer[1][i] *= gfp.scale;
      }
    }
    if (BitStream$2.NEQ(gfp.scale_left, 0) && BitStream$2.NEQ(gfp.scale_left, 1)) {
      for (i = 0; i < nsamples; ++i) {
        in_buffer[0][i] *= gfp.scale_left;
      }
    }
    if (BitStream$2.NEQ(gfp.scale_right, 0) && BitStream$2.NEQ(gfp.scale_right, 1)) {
      for (i = 0; i < nsamples; ++i) {
        in_buffer[1][i] *= gfp.scale_right;
      }
    }
    if (gfp.num_channels == 2 && gfc.channels_out == 1) {
      for (i = 0; i < nsamples; ++i) {
        in_buffer[0][i] = 0.5 * (in_buffer[0][i] + in_buffer[1][i]);
        in_buffer[1][i] = 0;
      }
    }
    mf_needed = calcNeeded(gfp);
    mfbuf[0] = gfc.mfbuf[0];
    mfbuf[1] = gfc.mfbuf[1];
    var in_bufferPos = 0;
    while (nsamples > 0) {
      var in_buffer_ptr = [null, null];
      var n_in = 0;
      var n_out = 0;
      in_buffer_ptr[0] = in_buffer[0];
      in_buffer_ptr[1] = in_buffer[1];
      var inOut = new InOut();
      fill_buffer(
        gfp,
        mfbuf,
        in_buffer_ptr,
        in_bufferPos,
        nsamples,
        inOut
      );
      n_in = inOut.n_in;
      n_out = inOut.n_out;
      if (gfc.findReplayGain && !gfc.decode_on_the_fly) {
        if (ga.AnalyzeSamples(
          gfc.rgdata,
          mfbuf[0],
          gfc.mf_size,
          mfbuf[1],
          gfc.mf_size,
          n_out,
          gfc.channels_out
        ) == GainAnalysis.GAIN_ANALYSIS_ERROR)
          return -6;
      }
      nsamples -= n_in;
      in_bufferPos += n_in;
      if (gfc.channels_out == 2)
        ;
      gfc.mf_size += n_out;
      assert$4(gfc.mf_size <= LameInternalFlags$1.MFSIZE);
      if (gfc.mf_samples_to_encode < 1) {
        gfc.mf_samples_to_encode = Encoder$1.ENCDELAY + Encoder$1.POSTDELAY;
      }
      gfc.mf_samples_to_encode += n_out;
      if (gfc.mf_size >= mf_needed) {
        var buf_size = mp3buf_size - mp3size;
        if (mp3buf_size == 0)
          buf_size = 0;
        ret = lame_encode_frame(
          gfp,
          mfbuf[0],
          mfbuf[1],
          mp3buf,
          mp3bufPos,
          buf_size
        );
        if (ret < 0)
          return ret;
        mp3bufPos += ret;
        mp3size += ret;
        gfc.mf_size -= gfp.framesize;
        gfc.mf_samples_to_encode -= gfp.framesize;
        for (ch = 0; ch < gfc.channels_out; ch++)
          for (i = 0; i < gfc.mf_size; i++)
            mfbuf[ch][i] = mfbuf[ch][i + gfp.framesize];
      }
    }
    assert$4(nsamples == 0);
    return mp3size;
  }
  function lame_encode_frame(gfp, inbuf_l, inbuf_r, mp3buf, mp3bufPos, mp3buf_size) {
    var ret = self2.enc.lame_encode_mp3_frame(
      gfp,
      inbuf_l,
      inbuf_r,
      mp3buf,
      mp3bufPos,
      mp3buf_size
    );
    gfp.frameNum++;
    return ret;
  }
  function InOut() {
    this.n_in = 0;
    this.n_out = 0;
  }
  function NumUsed() {
    this.num_used = 0;
  }
  function gcd(i, j) {
    return j != 0 ? gcd(j, i % j) : i;
  }
  function blackman(x, fcn, l) {
    var wcn = Math.PI * fcn;
    x /= l;
    if (x < 0)
      x = 0;
    if (x > 1)
      x = 1;
    var x2 = x - 0.5;
    var bkwn = 0.42 - 0.5 * Math.cos(2 * x * Math.PI) + 0.08 * Math.cos(4 * x * Math.PI);
    if (Math.abs(x2) < 1e-9)
      return wcn / Math.PI;
    else
      return bkwn * Math.sin(l * wcn * x2) / (Math.PI * l * x2);
  }
  function fill_buffer_resample(gfp, outbuf, outbufPos, desired_len, inbuf, in_bufferPos, len, num_used, ch) {
    var gfc = gfp.internal_flags;
    var i, j = 0, k;
    var bpc = gfp.out_samplerate / gcd(gfp.out_samplerate, gfp.in_samplerate);
    if (bpc > LameInternalFlags$1.BPC)
      bpc = LameInternalFlags$1.BPC;
    var intratio = Math.abs(gfc.resample_ratio - Math.floor(0.5 + gfc.resample_ratio)) < 1e-4 ? 1 : 0;
    var fcn = 1 / gfc.resample_ratio;
    if (fcn > 1)
      fcn = 1;
    var filter_l = 31;
    if (0 == filter_l % 2)
      --filter_l;
    filter_l += intratio;
    var BLACKSIZE = filter_l + 1;
    if (gfc.fill_buffer_resample_init == 0) {
      gfc.inbuf_old[0] = new_float$2(BLACKSIZE);
      gfc.inbuf_old[1] = new_float$2(BLACKSIZE);
      for (i = 0; i <= 2 * bpc; ++i)
        gfc.blackfilt[i] = new_float$2(BLACKSIZE);
      gfc.itime[0] = 0;
      gfc.itime[1] = 0;
      for (j = 0; j <= 2 * bpc; j++) {
        var sum = 0;
        var offset2 = (j - bpc) / (2 * bpc);
        for (i = 0; i <= filter_l; i++)
          sum += gfc.blackfilt[j][i] = blackman(
            i - offset2,
            fcn,
            filter_l
          );
        for (i = 0; i <= filter_l; i++)
          gfc.blackfilt[j][i] /= sum;
      }
      gfc.fill_buffer_resample_init = 1;
    }
    var inbuf_old = gfc.inbuf_old[ch];
    for (k = 0; k < desired_len; k++) {
      var time0;
      var joff;
      time0 = k * gfc.resample_ratio;
      j = 0 | Math.floor(time0 - gfc.itime[ch]);
      if (filter_l + j - filter_l / 2 >= len)
        break;
      var offset2 = time0 - gfc.itime[ch] - (j + 0.5 * (filter_l % 2));
      assert$4(Math.abs(offset2) <= 0.501);
      joff = 0 | Math.floor(offset2 * 2 * bpc + bpc + 0.5);
      var xvalue = 0;
      for (i = 0; i <= filter_l; ++i) {
        var j2 = 0 | i + j - filter_l / 2;
        var y;
        assert$4(j2 < len);
        assert$4(j2 + BLACKSIZE >= 0);
        y = j2 < 0 ? inbuf_old[BLACKSIZE + j2] : inbuf[in_bufferPos + j2];
        xvalue += y * gfc.blackfilt[joff][i];
      }
      outbuf[outbufPos + k] = xvalue;
    }
    num_used.num_used = Math.min(len, filter_l + j - filter_l / 2);
    gfc.itime[ch] += num_used.num_used - k * gfc.resample_ratio;
    if (num_used.num_used >= BLACKSIZE) {
      for (i = 0; i < BLACKSIZE; i++)
        inbuf_old[i] = inbuf[in_bufferPos + num_used.num_used + i - BLACKSIZE];
    } else {
      var n_shift = BLACKSIZE - num_used.num_used;
      for (i = 0; i < n_shift; ++i)
        inbuf_old[i] = inbuf_old[i + num_used.num_used];
      for (j = 0; i < BLACKSIZE; ++i, ++j)
        inbuf_old[i] = inbuf[in_bufferPos + j];
      assert$4(j == num_used.num_used);
    }
    return k;
  }
  function fill_buffer(gfp, mfbuf, in_buffer, in_bufferPos, nsamples, io) {
    var gfc = gfp.internal_flags;
    if (gfc.resample_ratio < 0.9999 || gfc.resample_ratio > 1.0001) {
      for (var ch = 0; ch < gfc.channels_out; ch++) {
        var numUsed = new NumUsed();
        io.n_out = fill_buffer_resample(
          gfp,
          mfbuf[ch],
          gfc.mf_size,
          gfp.framesize,
          in_buffer[ch],
          in_bufferPos,
          nsamples,
          numUsed,
          ch
        );
        io.n_in = numUsed.num_used;
      }
    } else {
      io.n_out = Math.min(gfp.framesize, nsamples);
      io.n_in = io.n_out;
      for (var i = 0; i < io.n_out; ++i) {
        mfbuf[0][gfc.mf_size + i] = in_buffer[0][in_bufferPos + i];
        if (gfc.channels_out == 2)
          mfbuf[1][gfc.mf_size + i] = in_buffer[1][in_bufferPos + i];
      }
    }
  }
}
var Lame_1 = Lame$2;
var common$5 = common$l;
common$5.System;
var VbrMode$2 = common$5.VbrMode;
common$5.Float;
common$5.ShortBlock;
common$5.Util;
common$5.Arrays;
common$5.new_array_n;
common$5.new_byte;
common$5.new_double;
common$5.new_float;
common$5.new_float_n;
common$5.new_int;
common$5.new_int_n;
common$5.assert;
function Presets$1() {
  function VBRPresets(qual, comp, compS, y, shThreshold, shThresholdS, adj, adjShort, lower, curve, sens, inter, joint, mod2, fix) {
    this.vbr_q = qual;
    this.quant_comp = comp;
    this.quant_comp_s = compS;
    this.expY = y;
    this.st_lrm = shThreshold;
    this.st_s = shThresholdS;
    this.masking_adj = adj;
    this.masking_adj_short = adjShort;
    this.ath_lower = lower;
    this.ath_curve = curve;
    this.ath_sensitivity = sens;
    this.interch = inter;
    this.safejoint = joint;
    this.sfb21mod = mod2;
    this.msfix = fix;
  }
  function ABRPresets(kbps, comp, compS, joint, fix, shThreshold, shThresholdS, bass, sc, mask, lower, curve, interCh, sfScale) {
    this.quant_comp = comp;
    this.quant_comp_s = compS;
    this.safejoint = joint;
    this.nsmsfix = fix;
    this.st_lrm = shThreshold;
    this.st_s = shThresholdS;
    this.nsbass = bass;
    this.scale = sc;
    this.masking_adj = mask;
    this.ath_lower = lower;
    this.ath_curve = curve;
    this.interch = interCh;
    this.sfscale = sfScale;
  }
  var lame;
  this.setModules = function(_lame) {
    lame = _lame;
  };
  var vbr_old_switch_map = [
    new VBRPresets(0, 9, 9, 0, 5.2, 125, -4.2, -6.3, 4.8, 1, 0, 0, 2, 21, 0.97),
    new VBRPresets(1, 9, 9, 0, 5.3, 125, -3.6, -5.6, 4.5, 1.5, 0, 0, 2, 21, 1.35),
    new VBRPresets(2, 9, 9, 0, 5.6, 125, -2.2, -3.5, 2.8, 2, 0, 0, 2, 21, 1.49),
    new VBRPresets(3, 9, 9, 1, 5.8, 130, -1.8, -2.8, 2.6, 3, -4, 0, 2, 20, 1.64),
    new VBRPresets(4, 9, 9, 1, 6, 135, -0.7, -1.1, 1.1, 3.5, -8, 0, 2, 0, 1.79),
    new VBRPresets(5, 9, 9, 1, 6.4, 140, 0.5, 0.4, -7.5, 4, -12, 2e-4, 0, 0, 1.95),
    new VBRPresets(6, 9, 9, 1, 6.6, 145, 0.67, 0.65, -14.7, 6.5, -19, 4e-4, 0, 0, 2.3),
    new VBRPresets(7, 9, 9, 1, 6.6, 145, 0.8, 0.75, -19.7, 8, -22, 6e-4, 0, 0, 2.7),
    new VBRPresets(8, 9, 9, 1, 6.6, 145, 1.2, 1.15, -27.5, 10, -23, 7e-4, 0, 0, 0),
    new VBRPresets(9, 9, 9, 1, 6.6, 145, 1.6, 1.6, -36, 11, -25, 8e-4, 0, 0, 0),
    new VBRPresets(10, 9, 9, 1, 6.6, 145, 2, 2, -36, 12, -25, 8e-4, 0, 0, 0)
  ];
  var vbr_psy_switch_map = [
    new VBRPresets(0, 9, 9, 0, 4.2, 25, -7, -4, 7.5, 1, 0, 0, 2, 26, 0.97),
    new VBRPresets(1, 9, 9, 0, 4.2, 25, -5.6, -3.6, 4.5, 1.5, 0, 0, 2, 21, 1.35),
    new VBRPresets(2, 9, 9, 0, 4.2, 25, -4.4, -1.8, 2, 2, 0, 0, 2, 18, 1.49),
    new VBRPresets(3, 9, 9, 1, 4.2, 25, -3.4, -1.25, 1.1, 3, -4, 0, 2, 15, 1.64),
    new VBRPresets(4, 9, 9, 1, 4.2, 25, -2.2, 0.1, 0, 3.5, -8, 0, 2, 0, 1.79),
    new VBRPresets(5, 9, 9, 1, 4.2, 25, -1, 1.65, -7.7, 4, -12, 2e-4, 0, 0, 1.95),
    new VBRPresets(6, 9, 9, 1, 4.2, 25, -0, 2.47, -7.7, 6.5, -19, 4e-4, 0, 0, 2),
    new VBRPresets(7, 9, 9, 1, 4.2, 25, 0.5, 2, -14.5, 8, -22, 6e-4, 0, 0, 2),
    new VBRPresets(8, 9, 9, 1, 4.2, 25, 1, 2.4, -22, 10, -23, 7e-4, 0, 0, 2),
    new VBRPresets(9, 9, 9, 1, 4.2, 25, 1.5, 2.95, -30, 11, -25, 8e-4, 0, 0, 2),
    new VBRPresets(10, 9, 9, 1, 4.2, 25, 2, 2.95, -36, 12, -30, 8e-4, 0, 0, 2)
  ];
  function apply_vbr_preset(gfp, a, enforce) {
    var vbr_preset = gfp.VBR == VbrMode$2.vbr_rh ? vbr_old_switch_map : vbr_psy_switch_map;
    var x = gfp.VBR_q_frac;
    var p2 = vbr_preset[a];
    var q = vbr_preset[a + 1];
    var set2 = p2;
    p2.st_lrm = p2.st_lrm + x * (q.st_lrm - p2.st_lrm);
    p2.st_s = p2.st_s + x * (q.st_s - p2.st_s);
    p2.masking_adj = p2.masking_adj + x * (q.masking_adj - p2.masking_adj);
    p2.masking_adj_short = p2.masking_adj_short + x * (q.masking_adj_short - p2.masking_adj_short);
    p2.ath_lower = p2.ath_lower + x * (q.ath_lower - p2.ath_lower);
    p2.ath_curve = p2.ath_curve + x * (q.ath_curve - p2.ath_curve);
    p2.ath_sensitivity = p2.ath_sensitivity + x * (q.ath_sensitivity - p2.ath_sensitivity);
    p2.interch = p2.interch + x * (q.interch - p2.interch);
    p2.msfix = p2.msfix + x * (q.msfix - p2.msfix);
    lame_set_VBR_q(gfp, set2.vbr_q);
    if (enforce != 0)
      gfp.quant_comp = set2.quant_comp;
    else if (!(Math.abs(gfp.quant_comp - -1) > 0))
      gfp.quant_comp = set2.quant_comp;
    if (enforce != 0)
      gfp.quant_comp_short = set2.quant_comp_s;
    else if (!(Math.abs(gfp.quant_comp_short - -1) > 0))
      gfp.quant_comp_short = set2.quant_comp_s;
    if (set2.expY != 0) {
      gfp.experimentalY = set2.expY != 0;
    }
    if (enforce != 0)
      gfp.internal_flags.nsPsy.attackthre = set2.st_lrm;
    else if (!(Math.abs(gfp.internal_flags.nsPsy.attackthre - -1) > 0))
      gfp.internal_flags.nsPsy.attackthre = set2.st_lrm;
    if (enforce != 0)
      gfp.internal_flags.nsPsy.attackthre_s = set2.st_s;
    else if (!(Math.abs(gfp.internal_flags.nsPsy.attackthre_s - -1) > 0))
      gfp.internal_flags.nsPsy.attackthre_s = set2.st_s;
    if (enforce != 0)
      gfp.maskingadjust = set2.masking_adj;
    else if (!(Math.abs(gfp.maskingadjust - 0) > 0))
      gfp.maskingadjust = set2.masking_adj;
    if (enforce != 0)
      gfp.maskingadjust_short = set2.masking_adj_short;
    else if (!(Math.abs(gfp.maskingadjust_short - 0) > 0))
      gfp.maskingadjust_short = set2.masking_adj_short;
    if (enforce != 0)
      gfp.ATHlower = -set2.ath_lower / 10;
    else if (!(Math.abs(-gfp.ATHlower * 10 - 0) > 0))
      gfp.ATHlower = -set2.ath_lower / 10;
    if (enforce != 0)
      gfp.ATHcurve = set2.ath_curve;
    else if (!(Math.abs(gfp.ATHcurve - -1) > 0))
      gfp.ATHcurve = set2.ath_curve;
    if (enforce != 0)
      gfp.athaa_sensitivity = set2.ath_sensitivity;
    else if (!(Math.abs(gfp.athaa_sensitivity - -1) > 0))
      gfp.athaa_sensitivity = set2.ath_sensitivity;
    if (set2.interch > 0) {
      if (enforce != 0)
        gfp.interChRatio = set2.interch;
      else if (!(Math.abs(gfp.interChRatio - -1) > 0))
        gfp.interChRatio = set2.interch;
    }
    if (set2.safejoint > 0) {
      gfp.exp_nspsytune = gfp.exp_nspsytune | set2.safejoint;
    }
    if (set2.sfb21mod > 0) {
      gfp.exp_nspsytune = gfp.exp_nspsytune | set2.sfb21mod << 20;
    }
    if (enforce != 0)
      gfp.msfix = set2.msfix;
    else if (!(Math.abs(gfp.msfix - -1) > 0))
      gfp.msfix = set2.msfix;
    if (enforce == 0) {
      gfp.VBR_q = a;
      gfp.VBR_q_frac = x;
    }
  }
  var abr_switch_map = [
    new ABRPresets(8, 9, 9, 0, 0, 6.6, 145, 0, 0.95, 0, -30, 11, 12e-4, 1),
    /*   8, impossible to use in stereo */
    new ABRPresets(16, 9, 9, 0, 0, 6.6, 145, 0, 0.95, 0, -25, 11, 1e-3, 1),
    /*  16 */
    new ABRPresets(24, 9, 9, 0, 0, 6.6, 145, 0, 0.95, 0, -20, 11, 1e-3, 1),
    /*  24 */
    new ABRPresets(32, 9, 9, 0, 0, 6.6, 145, 0, 0.95, 0, -15, 11, 1e-3, 1),
    /*  32 */
    new ABRPresets(40, 9, 9, 0, 0, 6.6, 145, 0, 0.95, 0, -10, 11, 9e-4, 1),
    /*  40 */
    new ABRPresets(48, 9, 9, 0, 0, 6.6, 145, 0, 0.95, 0, -10, 11, 9e-4, 1),
    /*  48 */
    new ABRPresets(56, 9, 9, 0, 0, 6.6, 145, 0, 0.95, 0, -6, 11, 8e-4, 1),
    /*  56 */
    new ABRPresets(64, 9, 9, 0, 0, 6.6, 145, 0, 0.95, 0, -2, 11, 8e-4, 1),
    /*  64 */
    new ABRPresets(80, 9, 9, 0, 0, 6.6, 145, 0, 0.95, 0, 0, 8, 7e-4, 1),
    /*  80 */
    new ABRPresets(96, 9, 9, 0, 2.5, 6.6, 145, 0, 0.95, 0, 1, 5.5, 6e-4, 1),
    /*  96 */
    new ABRPresets(112, 9, 9, 0, 2.25, 6.6, 145, 0, 0.95, 0, 2, 4.5, 5e-4, 1),
    /* 112 */
    new ABRPresets(128, 9, 9, 0, 1.95, 6.4, 140, 0, 0.95, 0, 3, 4, 2e-4, 1),
    /* 128 */
    new ABRPresets(160, 9, 9, 1, 1.79, 6, 135, 0, 0.95, -2, 5, 3.5, 0, 1),
    /* 160 */
    new ABRPresets(192, 9, 9, 1, 1.49, 5.6, 125, 0, 0.97, -4, 7, 3, 0, 0),
    /* 192 */
    new ABRPresets(224, 9, 9, 1, 1.25, 5.2, 125, 0, 0.98, -6, 9, 2, 0, 0),
    /* 224 */
    new ABRPresets(256, 9, 9, 1, 0.97, 5.2, 125, 0, 1, -8, 10, 1, 0, 0),
    /* 256 */
    new ABRPresets(320, 9, 9, 1, 0.9, 5.2, 125, 0, 1, -10, 12, 0, 0, 0)
    /* 320 */
  ];
  function apply_abr_preset(gfp, preset, enforce) {
    var actual_bitrate = preset;
    var r = lame.nearestBitrateFullIndex(preset);
    gfp.VBR = VbrMode$2.vbr_abr;
    gfp.VBR_mean_bitrate_kbps = actual_bitrate;
    gfp.VBR_mean_bitrate_kbps = Math.min(gfp.VBR_mean_bitrate_kbps, 320);
    gfp.VBR_mean_bitrate_kbps = Math.max(gfp.VBR_mean_bitrate_kbps, 8);
    gfp.brate = gfp.VBR_mean_bitrate_kbps;
    if (gfp.VBR_mean_bitrate_kbps > 320) {
      gfp.disable_reservoir = true;
    }
    if (abr_switch_map[r].safejoint > 0)
      gfp.exp_nspsytune = gfp.exp_nspsytune | 2;
    if (abr_switch_map[r].sfscale > 0) {
      gfp.internal_flags.noise_shaping = 2;
    }
    if (Math.abs(abr_switch_map[r].nsbass) > 0) {
      var k = int(abr_switch_map[r].nsbass * 4);
      if (k < 0)
        k += 64;
      gfp.exp_nspsytune = gfp.exp_nspsytune | k << 2;
    }
    if (enforce != 0)
      gfp.quant_comp = abr_switch_map[r].quant_comp;
    else if (!(Math.abs(gfp.quant_comp - -1) > 0))
      gfp.quant_comp = abr_switch_map[r].quant_comp;
    if (enforce != 0)
      gfp.quant_comp_short = abr_switch_map[r].quant_comp_s;
    else if (!(Math.abs(gfp.quant_comp_short - -1) > 0))
      gfp.quant_comp_short = abr_switch_map[r].quant_comp_s;
    if (enforce != 0)
      gfp.msfix = abr_switch_map[r].nsmsfix;
    else if (!(Math.abs(gfp.msfix - -1) > 0))
      gfp.msfix = abr_switch_map[r].nsmsfix;
    if (enforce != 0)
      gfp.internal_flags.nsPsy.attackthre = abr_switch_map[r].st_lrm;
    else if (!(Math.abs(gfp.internal_flags.nsPsy.attackthre - -1) > 0))
      gfp.internal_flags.nsPsy.attackthre = abr_switch_map[r].st_lrm;
    if (enforce != 0)
      gfp.internal_flags.nsPsy.attackthre_s = abr_switch_map[r].st_s;
    else if (!(Math.abs(gfp.internal_flags.nsPsy.attackthre_s - -1) > 0))
      gfp.internal_flags.nsPsy.attackthre_s = abr_switch_map[r].st_s;
    if (enforce != 0)
      gfp.scale = abr_switch_map[r].scale;
    else if (!(Math.abs(gfp.scale - -1) > 0))
      gfp.scale = abr_switch_map[r].scale;
    if (enforce != 0)
      gfp.maskingadjust = abr_switch_map[r].masking_adj;
    else if (!(Math.abs(gfp.maskingadjust - 0) > 0))
      gfp.maskingadjust = abr_switch_map[r].masking_adj;
    if (abr_switch_map[r].masking_adj > 0) {
      if (enforce != 0)
        gfp.maskingadjust_short = abr_switch_map[r].masking_adj * 0.9;
      else if (!(Math.abs(gfp.maskingadjust_short - 0) > 0))
        gfp.maskingadjust_short = abr_switch_map[r].masking_adj * 0.9;
    } else {
      if (enforce != 0)
        gfp.maskingadjust_short = abr_switch_map[r].masking_adj * 1.1;
      else if (!(Math.abs(gfp.maskingadjust_short - 0) > 0))
        gfp.maskingadjust_short = abr_switch_map[r].masking_adj * 1.1;
    }
    if (enforce != 0)
      gfp.ATHlower = -abr_switch_map[r].ath_lower / 10;
    else if (!(Math.abs(-gfp.ATHlower * 10 - 0) > 0))
      gfp.ATHlower = -abr_switch_map[r].ath_lower / 10;
    if (enforce != 0)
      gfp.ATHcurve = abr_switch_map[r].ath_curve;
    else if (!(Math.abs(gfp.ATHcurve - -1) > 0))
      gfp.ATHcurve = abr_switch_map[r].ath_curve;
    if (enforce != 0)
      gfp.interChRatio = abr_switch_map[r].interch;
    else if (!(Math.abs(gfp.interChRatio - -1) > 0))
      gfp.interChRatio = abr_switch_map[r].interch;
    return preset;
  }
  this.apply_preset = function(gfp, preset, enforce) {
    switch (preset) {
      case Lame.R3MIX: {
        preset = Lame.V3;
        gfp.VBR = VbrMode$2.vbr_mtrh;
        break;
      }
      case Lame.MEDIUM: {
        preset = Lame.V4;
        gfp.VBR = VbrMode$2.vbr_rh;
        break;
      }
      case Lame.MEDIUM_FAST: {
        preset = Lame.V4;
        gfp.VBR = VbrMode$2.vbr_mtrh;
        break;
      }
      case Lame.STANDARD: {
        preset = Lame.V2;
        gfp.VBR = VbrMode$2.vbr_rh;
        break;
      }
      case Lame.STANDARD_FAST: {
        preset = Lame.V2;
        gfp.VBR = VbrMode$2.vbr_mtrh;
        break;
      }
      case Lame.EXTREME: {
        preset = Lame.V0;
        gfp.VBR = VbrMode$2.vbr_rh;
        break;
      }
      case Lame.EXTREME_FAST: {
        preset = Lame.V0;
        gfp.VBR = VbrMode$2.vbr_mtrh;
        break;
      }
      case Lame.INSANE: {
        preset = 320;
        gfp.preset = preset;
        apply_abr_preset(gfp, preset, enforce);
        gfp.VBR = VbrMode$2.vbr_off;
        return preset;
      }
    }
    gfp.preset = preset;
    {
      switch (preset) {
        case Lame.V9:
          apply_vbr_preset(gfp, 9, enforce);
          return preset;
        case Lame.V8:
          apply_vbr_preset(gfp, 8, enforce);
          return preset;
        case Lame.V7:
          apply_vbr_preset(gfp, 7, enforce);
          return preset;
        case Lame.V6:
          apply_vbr_preset(gfp, 6, enforce);
          return preset;
        case Lame.V5:
          apply_vbr_preset(gfp, 5, enforce);
          return preset;
        case Lame.V4:
          apply_vbr_preset(gfp, 4, enforce);
          return preset;
        case Lame.V3:
          apply_vbr_preset(gfp, 3, enforce);
          return preset;
        case Lame.V2:
          apply_vbr_preset(gfp, 2, enforce);
          return preset;
        case Lame.V1:
          apply_vbr_preset(gfp, 1, enforce);
          return preset;
        case Lame.V0:
          apply_vbr_preset(gfp, 0, enforce);
          return preset;
      }
    }
    if (8 <= preset && preset <= 320) {
      return apply_abr_preset(gfp, preset, enforce);
    }
    gfp.preset = 0;
    return preset;
  };
  function lame_set_VBR_q(gfp, VBR_q) {
    var ret = 0;
    if (0 > VBR_q) {
      ret = -1;
      VBR_q = 0;
    }
    if (9 < VBR_q) {
      ret = -1;
      VBR_q = 9;
    }
    gfp.VBR_q = VBR_q;
    gfp.VBR_q_frac = 0;
    return ret;
  }
}
var Presets_1 = Presets$1;
function VBRQuantize$1() {
  this.setModules = function(_qupvt, _tk) {
  };
}
var VBRQuantize_1 = VBRQuantize$1;
function CalcNoiseResult$2() {
  this.over_noise = 0;
  this.tot_noise = 0;
  this.max_noise = 0;
  this.over_count = 0;
  this.over_SSD = 0;
  this.bits = 0;
}
var CalcNoiseResult_1 = CalcNoiseResult$2;
var common$4 = common$l;
var new_float$1 = common$4.new_float;
var new_int = common$4.new_int;
common$4.assert;
function CalcNoiseData$1() {
  this.global_gain = 0;
  this.sfb_count1 = 0;
  this.step = new_int(39);
  this.noise = new_float$1(39);
  this.noise_log = new_float$1(39);
}
var CalcNoiseData_1 = CalcNoiseData$1;
var common$3 = common$l;
var System$1 = common$3.System;
var VbrMode$1 = common$3.VbrMode;
common$3.Float;
common$3.ShortBlock;
var Util = common$3.Util;
var Arrays$1 = common$3.Arrays;
common$3.new_array_n;
common$3.new_byte;
common$3.new_double;
var new_float = common$3.new_float;
common$3.new_float_n;
common$3.new_int;
common$3.new_int_n;
var assert$3 = common$3.assert;
var VBRQuantize = VBRQuantize_1;
var CalcNoiseResult$1 = CalcNoiseResult_1;
var CalcNoiseData = CalcNoiseData_1;
var Encoder = requireEncoder();
var GrInfo = GrInfo_1;
var L3Side$1 = L3Side_1;
function Quantize$1() {
  var bs;
  this.rv = null;
  var rv;
  this.qupvt = null;
  var qupvt;
  var vbr = new VBRQuantize();
  var tk;
  this.setModules = function(_bs, _rv, _qupvt, _tk) {
    bs = _bs;
    rv = _rv;
    this.rv = _rv;
    qupvt = _qupvt;
    this.qupvt = _qupvt;
    tk = _tk;
    vbr.setModules(qupvt, tk);
  };
  this.ms_convert = function(l3_side, gr) {
    for (var i = 0; i < 576; ++i) {
      var l = l3_side.tt[gr][0].xr[i];
      var r = l3_side.tt[gr][1].xr[i];
      l3_side.tt[gr][0].xr[i] = (l + r) * (Util.SQRT2 * 0.5);
      l3_side.tt[gr][1].xr[i] = (l - r) * (Util.SQRT2 * 0.5);
    }
  };
  function init_xrpow_core(cod_info, xrpow, upper, sum) {
    sum = 0;
    for (var i = 0; i <= upper; ++i) {
      var tmp = Math.abs(cod_info.xr[i]);
      sum += tmp;
      xrpow[i] = Math.sqrt(tmp * Math.sqrt(tmp));
      if (xrpow[i] > cod_info.xrpow_max)
        cod_info.xrpow_max = xrpow[i];
    }
    return sum;
  }
  this.init_xrpow = function(gfc, cod_info, xrpow) {
    var sum = 0;
    var upper = 0 | cod_info.max_nonzero_coeff;
    assert$3(xrpow != null);
    cod_info.xrpow_max = 0;
    assert$3(0 <= upper && upper <= 575);
    Arrays$1.fill(xrpow, upper, 576, 0);
    sum = init_xrpow_core(cod_info, xrpow, upper, sum);
    if (sum > 1e-20) {
      var j = 0;
      if ((gfc.substep_shaping & 2) != 0)
        j = 1;
      for (var i = 0; i < cod_info.psymax; i++)
        gfc.pseudohalf[i] = j;
      return true;
    }
    Arrays$1.fill(cod_info.l3_enc, 0, 576, 0);
    return false;
  };
  function psfb21_analogsilence(gfc, cod_info) {
    var ath = gfc.ATH;
    var xr = cod_info.xr;
    if (cod_info.block_type != Encoder.SHORT_TYPE) {
      var stop = false;
      for (var gsfb = Encoder.PSFB21 - 1; gsfb >= 0 && !stop; gsfb--) {
        var start = gfc.scalefac_band.psfb21[gsfb];
        var end = gfc.scalefac_band.psfb21[gsfb + 1];
        var ath21 = qupvt.athAdjust(
          ath.adjust,
          ath.psfb21[gsfb],
          ath.floor
        );
        if (gfc.nsPsy.longfact[21] > 1e-12)
          ath21 *= gfc.nsPsy.longfact[21];
        for (var j = end - 1; j >= start; j--) {
          if (Math.abs(xr[j]) < ath21)
            xr[j] = 0;
          else {
            stop = true;
            break;
          }
        }
      }
    } else {
      for (var block = 0; block < 3; block++) {
        var stop = false;
        for (var gsfb = Encoder.PSFB12 - 1; gsfb >= 0 && !stop; gsfb--) {
          var start = gfc.scalefac_band.s[12] * 3 + (gfc.scalefac_band.s[13] - gfc.scalefac_band.s[12]) * block + (gfc.scalefac_band.psfb12[gsfb] - gfc.scalefac_band.psfb12[0]);
          var end = start + (gfc.scalefac_band.psfb12[gsfb + 1] - gfc.scalefac_band.psfb12[gsfb]);
          var ath12 = qupvt.athAdjust(
            ath.adjust,
            ath.psfb12[gsfb],
            ath.floor
          );
          if (gfc.nsPsy.shortfact[12] > 1e-12)
            ath12 *= gfc.nsPsy.shortfact[12];
          for (var j = end - 1; j >= start; j--) {
            if (Math.abs(xr[j]) < ath12)
              xr[j] = 0;
            else {
              stop = true;
              break;
            }
          }
        }
      }
    }
  }
  this.init_outer_loop = function(gfc, cod_info) {
    cod_info.part2_3_length = 0;
    cod_info.big_values = 0;
    cod_info.count1 = 0;
    cod_info.global_gain = 210;
    cod_info.scalefac_compress = 0;
    cod_info.table_select[0] = 0;
    cod_info.table_select[1] = 0;
    cod_info.table_select[2] = 0;
    cod_info.subblock_gain[0] = 0;
    cod_info.subblock_gain[1] = 0;
    cod_info.subblock_gain[2] = 0;
    cod_info.subblock_gain[3] = 0;
    cod_info.region0_count = 0;
    cod_info.region1_count = 0;
    cod_info.preflag = 0;
    cod_info.scalefac_scale = 0;
    cod_info.count1table_select = 0;
    cod_info.part2_length = 0;
    cod_info.sfb_lmax = Encoder.SBPSY_l;
    cod_info.sfb_smin = Encoder.SBPSY_s;
    cod_info.psy_lmax = gfc.sfb21_extra ? Encoder.SBMAX_l : Encoder.SBPSY_l;
    cod_info.psymax = cod_info.psy_lmax;
    cod_info.sfbmax = cod_info.sfb_lmax;
    cod_info.sfbdivide = 11;
    for (var sfb = 0; sfb < Encoder.SBMAX_l; sfb++) {
      cod_info.width[sfb] = gfc.scalefac_band.l[sfb + 1] - gfc.scalefac_band.l[sfb];
      cod_info.window[sfb] = 3;
    }
    if (cod_info.block_type == Encoder.SHORT_TYPE) {
      var ixwork = new_float(576);
      cod_info.sfb_smin = 0;
      cod_info.sfb_lmax = 0;
      if (cod_info.mixed_block_flag != 0) {
        cod_info.sfb_smin = 3;
        cod_info.sfb_lmax = gfc.mode_gr * 2 + 4;
      }
      cod_info.psymax = cod_info.sfb_lmax + 3 * ((gfc.sfb21_extra ? Encoder.SBMAX_s : Encoder.SBPSY_s) - cod_info.sfb_smin);
      cod_info.sfbmax = cod_info.sfb_lmax + 3 * (Encoder.SBPSY_s - cod_info.sfb_smin);
      cod_info.sfbdivide = cod_info.sfbmax - 18;
      cod_info.psy_lmax = cod_info.sfb_lmax;
      var ix = gfc.scalefac_band.l[cod_info.sfb_lmax];
      System$1.arraycopy(cod_info.xr, 0, ixwork, 0, 576);
      for (var sfb = cod_info.sfb_smin; sfb < Encoder.SBMAX_s; sfb++) {
        var start = gfc.scalefac_band.s[sfb];
        var end = gfc.scalefac_band.s[sfb + 1];
        for (var window2 = 0; window2 < 3; window2++) {
          for (var l = start; l < end; l++) {
            cod_info.xr[ix++] = ixwork[3 * l + window2];
          }
        }
      }
      var j = cod_info.sfb_lmax;
      for (var sfb = cod_info.sfb_smin; sfb < Encoder.SBMAX_s; sfb++) {
        cod_info.width[j] = cod_info.width[j + 1] = cod_info.width[j + 2] = gfc.scalefac_band.s[sfb + 1] - gfc.scalefac_band.s[sfb];
        cod_info.window[j] = 0;
        cod_info.window[j + 1] = 1;
        cod_info.window[j + 2] = 2;
        j += 3;
      }
    }
    cod_info.count1bits = 0;
    cod_info.sfb_partition_table = qupvt.nr_of_sfb_block[0][0];
    cod_info.slen[0] = 0;
    cod_info.slen[1] = 0;
    cod_info.slen[2] = 0;
    cod_info.slen[3] = 0;
    cod_info.max_nonzero_coeff = 575;
    Arrays$1.fill(cod_info.scalefac, 0);
    psfb21_analogsilence(gfc, cod_info);
  };
  function BinSearchDirection(ordinal) {
    this.ordinal = ordinal;
  }
  BinSearchDirection.BINSEARCH_NONE = new BinSearchDirection(0);
  BinSearchDirection.BINSEARCH_UP = new BinSearchDirection(1);
  BinSearchDirection.BINSEARCH_DOWN = new BinSearchDirection(2);
  function bin_search_StepSize(gfc, cod_info, desired_rate, ch, xrpow) {
    var nBits;
    var CurrentStep = gfc.CurrentStep[ch];
    var flagGoneOver = false;
    var start = gfc.OldValue[ch];
    var Direction = BinSearchDirection.BINSEARCH_NONE;
    cod_info.global_gain = start;
    desired_rate -= cod_info.part2_length;
    assert$3(CurrentStep != 0);
    for (; ; ) {
      var step;
      nBits = tk.count_bits(gfc, xrpow, cod_info, null);
      if (CurrentStep == 1 || nBits == desired_rate)
        break;
      if (nBits > desired_rate) {
        if (Direction == BinSearchDirection.BINSEARCH_DOWN)
          flagGoneOver = true;
        if (flagGoneOver)
          CurrentStep /= 2;
        Direction = BinSearchDirection.BINSEARCH_UP;
        step = CurrentStep;
      } else {
        if (Direction == BinSearchDirection.BINSEARCH_UP)
          flagGoneOver = true;
        if (flagGoneOver)
          CurrentStep /= 2;
        Direction = BinSearchDirection.BINSEARCH_DOWN;
        step = -CurrentStep;
      }
      cod_info.global_gain += step;
      if (cod_info.global_gain < 0) {
        cod_info.global_gain = 0;
        flagGoneOver = true;
      }
      if (cod_info.global_gain > 255) {
        cod_info.global_gain = 255;
        flagGoneOver = true;
      }
    }
    assert$3(cod_info.global_gain >= 0);
    assert$3(cod_info.global_gain < 256);
    while (nBits > desired_rate && cod_info.global_gain < 255) {
      cod_info.global_gain++;
      nBits = tk.count_bits(gfc, xrpow, cod_info, null);
    }
    gfc.CurrentStep[ch] = start - cod_info.global_gain >= 4 ? 4 : 2;
    gfc.OldValue[ch] = cod_info.global_gain;
    cod_info.part2_3_length = nBits;
    return nBits;
  }
  this.trancate_smallspectrums = function(gfc, gi, l3_xmin, work) {
    var distort = new_float(L3Side$1.SFBMAX);
    if (0 == (gfc.substep_shaping & 4) && gi.block_type == Encoder.SHORT_TYPE || (gfc.substep_shaping & 128) != 0)
      return;
    qupvt.calc_noise(gi, l3_xmin, distort, new CalcNoiseResult$1(), null);
    for (var j = 0; j < 576; j++) {
      var xr = 0;
      if (gi.l3_enc[j] != 0)
        xr = Math.abs(gi.xr[j]);
      work[j] = xr;
    }
    var j = 0;
    var sfb = 8;
    if (gi.block_type == Encoder.SHORT_TYPE)
      sfb = 6;
    do {
      var allowedNoise, trancateThreshold;
      var nsame, start;
      var width = gi.width[sfb];
      j += width;
      if (distort[sfb] >= 1)
        continue;
      Arrays$1.sort(work, j - width, width);
      if (BitStream.EQ(work[j - 1], 0))
        continue;
      allowedNoise = (1 - distort[sfb]) * l3_xmin[sfb];
      trancateThreshold = 0;
      start = 0;
      do {
        var noise;
        for (nsame = 1; start + nsame < width; nsame++)
          if (BitStream.NEQ(work[start + j - width], work[start + j + nsame - width]))
            break;
        noise = work[start + j - width] * work[start + j - width] * nsame;
        if (allowedNoise < noise) {
          if (start != 0)
            trancateThreshold = work[start + j - width - 1];
          break;
        }
        allowedNoise -= noise;
        start += nsame;
      } while (start < width);
      if (BitStream.EQ(trancateThreshold, 0))
        continue;
      do {
        if (Math.abs(gi.xr[j - width]) <= trancateThreshold)
          gi.l3_enc[j - width] = 0;
      } while (--width > 0);
    } while (++sfb < gi.psymax);
    gi.part2_3_length = tk.noquant_count_bits(gfc, gi, null);
  };
  function loop_break(cod_info) {
    for (var sfb = 0; sfb < cod_info.sfbmax; sfb++)
      if (cod_info.scalefac[sfb] + cod_info.subblock_gain[cod_info.window[sfb]] == 0)
        return false;
    return true;
  }
  function penalties(noise) {
    return Util.FAST_LOG10(0.368 + 0.632 * noise * noise * noise);
  }
  function get_klemm_noise(distort, gi) {
    var klemm_noise = 1e-37;
    for (var sfb = 0; sfb < gi.psymax; sfb++)
      klemm_noise += penalties(distort[sfb]);
    return Math.max(1e-20, klemm_noise);
  }
  function quant_compare(quant_comp, best, calc, gi, distort) {
    var better;
    switch (quant_comp) {
      default:
      case 9: {
        if (best.over_count > 0) {
          better = calc.over_SSD <= best.over_SSD;
          if (calc.over_SSD == best.over_SSD)
            better = calc.bits < best.bits;
        } else {
          better = calc.max_noise < 0 && calc.max_noise * 10 + calc.bits <= best.max_noise * 10 + best.bits;
        }
        break;
      }
      case 0:
        better = calc.over_count < best.over_count || calc.over_count == best.over_count && calc.over_noise < best.over_noise || calc.over_count == best.over_count && BitStream.EQ(calc.over_noise, best.over_noise) && calc.tot_noise < best.tot_noise;
        break;
      case 8:
        calc.max_noise = get_klemm_noise(distort, gi);
      case 1:
        better = calc.max_noise < best.max_noise;
        break;
      case 2:
        better = calc.tot_noise < best.tot_noise;
        break;
      case 3:
        better = calc.tot_noise < best.tot_noise && calc.max_noise < best.max_noise;
        break;
      case 4:
        better = calc.max_noise <= 0 && best.max_noise > 0.2 || calc.max_noise <= 0 && best.max_noise < 0 && best.max_noise > calc.max_noise - 0.2 && calc.tot_noise < best.tot_noise || calc.max_noise <= 0 && best.max_noise > 0 && best.max_noise > calc.max_noise - 0.2 && calc.tot_noise < best.tot_noise + best.over_noise || calc.max_noise > 0 && best.max_noise > -0.05 && best.max_noise > calc.max_noise - 0.1 && calc.tot_noise + calc.over_noise < best.tot_noise + best.over_noise || calc.max_noise > 0 && best.max_noise > -0.1 && best.max_noise > calc.max_noise - 0.15 && calc.tot_noise + calc.over_noise + calc.over_noise < best.tot_noise + best.over_noise + best.over_noise;
        break;
      case 5:
        better = calc.over_noise < best.over_noise || BitStream.EQ(calc.over_noise, best.over_noise) && calc.tot_noise < best.tot_noise;
        break;
      case 6:
        better = calc.over_noise < best.over_noise || BitStream.EQ(calc.over_noise, best.over_noise) && (calc.max_noise < best.max_noise || BitStream.EQ(calc.max_noise, best.max_noise) && calc.tot_noise <= best.tot_noise);
        break;
      case 7:
        better = calc.over_count < best.over_count || calc.over_noise < best.over_noise;
        break;
    }
    if (best.over_count == 0) {
      better = better && calc.bits < best.bits;
    }
    return better;
  }
  function amp_scalefac_bands(gfp, cod_info, distort, xrpow, bRefine) {
    var gfc = gfp.internal_flags;
    var ifqstep34;
    if (cod_info.scalefac_scale == 0) {
      ifqstep34 = 1.2968395546510096;
    } else {
      ifqstep34 = 1.6817928305074292;
    }
    var trigger2 = 0;
    for (var sfb = 0; sfb < cod_info.sfbmax; sfb++) {
      if (trigger2 < distort[sfb])
        trigger2 = distort[sfb];
    }
    var noise_shaping_amp = gfc.noise_shaping_amp;
    if (noise_shaping_amp == 3) {
      if (bRefine)
        noise_shaping_amp = 2;
      else
        noise_shaping_amp = 1;
    }
    switch (noise_shaping_amp) {
      case 2:
        break;
      case 1:
        if (trigger2 > 1)
          trigger2 = Math.pow(trigger2, 0.5);
        else
          trigger2 *= 0.95;
        break;
      case 0:
      default:
        if (trigger2 > 1)
          trigger2 = 1;
        else
          trigger2 *= 0.95;
        break;
    }
    var j = 0;
    for (var sfb = 0; sfb < cod_info.sfbmax; sfb++) {
      var width = cod_info.width[sfb];
      var l;
      j += width;
      if (distort[sfb] < trigger2)
        continue;
      if ((gfc.substep_shaping & 2) != 0) {
        gfc.pseudohalf[sfb] = 0 == gfc.pseudohalf[sfb] ? 1 : 0;
        if (0 == gfc.pseudohalf[sfb] && gfc.noise_shaping_amp == 2)
          return;
      }
      cod_info.scalefac[sfb]++;
      for (l = -width; l < 0; l++) {
        xrpow[j + l] *= ifqstep34;
        if (xrpow[j + l] > cod_info.xrpow_max)
          cod_info.xrpow_max = xrpow[j + l];
      }
      if (gfc.noise_shaping_amp == 2)
        return;
    }
  }
  function inc_scalefac_scale(cod_info, xrpow) {
    var ifqstep34 = 1.2968395546510096;
    var j = 0;
    for (var sfb = 0; sfb < cod_info.sfbmax; sfb++) {
      var width = cod_info.width[sfb];
      var s = cod_info.scalefac[sfb];
      if (cod_info.preflag != 0)
        s += qupvt.pretab[sfb];
      j += width;
      if ((s & 1) != 0) {
        s++;
        for (var l = -width; l < 0; l++) {
          xrpow[j + l] *= ifqstep34;
          if (xrpow[j + l] > cod_info.xrpow_max)
            cod_info.xrpow_max = xrpow[j + l];
        }
      }
      cod_info.scalefac[sfb] = s >> 1;
    }
    cod_info.preflag = 0;
    cod_info.scalefac_scale = 1;
  }
  function inc_subblock_gain(gfc, cod_info, xrpow) {
    var sfb;
    var scalefac = cod_info.scalefac;
    for (sfb = 0; sfb < cod_info.sfb_lmax; sfb++) {
      if (scalefac[sfb] >= 16)
        return true;
    }
    for (var window2 = 0; window2 < 3; window2++) {
      var s1 = 0;
      var s2 = 0;
      for (sfb = cod_info.sfb_lmax + window2; sfb < cod_info.sfbdivide; sfb += 3) {
        if (s1 < scalefac[sfb])
          s1 = scalefac[sfb];
      }
      for (; sfb < cod_info.sfbmax; sfb += 3) {
        if (s2 < scalefac[sfb])
          s2 = scalefac[sfb];
      }
      if (s1 < 16 && s2 < 8)
        continue;
      if (cod_info.subblock_gain[window2] >= 7)
        return true;
      cod_info.subblock_gain[window2]++;
      var j = gfc.scalefac_band.l[cod_info.sfb_lmax];
      for (sfb = cod_info.sfb_lmax + window2; sfb < cod_info.sfbmax; sfb += 3) {
        var amp;
        var width = cod_info.width[sfb];
        var s = scalefac[sfb];
        assert$3(s >= 0);
        s = s - (4 >> cod_info.scalefac_scale);
        if (s >= 0) {
          scalefac[sfb] = s;
          j += width * 3;
          continue;
        }
        scalefac[sfb] = 0;
        {
          var gain = 210 + (s << cod_info.scalefac_scale + 1);
          amp = qupvt.IPOW20(gain);
        }
        j += width * (window2 + 1);
        for (var l = -width; l < 0; l++) {
          xrpow[j + l] *= amp;
          if (xrpow[j + l] > cod_info.xrpow_max)
            cod_info.xrpow_max = xrpow[j + l];
        }
        j += width * (3 - window2 - 1);
      }
      {
        var amp = qupvt.IPOW20(202);
        j += cod_info.width[sfb] * (window2 + 1);
        for (var l = -cod_info.width[sfb]; l < 0; l++) {
          xrpow[j + l] *= amp;
          if (xrpow[j + l] > cod_info.xrpow_max)
            cod_info.xrpow_max = xrpow[j + l];
        }
      }
    }
    return false;
  }
  function balance_noise(gfp, cod_info, distort, xrpow, bRefine) {
    var gfc = gfp.internal_flags;
    amp_scalefac_bands(gfp, cod_info, distort, xrpow, bRefine);
    var status = loop_break(cod_info);
    if (status)
      return false;
    if (gfc.mode_gr == 2)
      status = tk.scale_bitcount(cod_info);
    else
      status = tk.scale_bitcount_lsf(gfc, cod_info);
    if (!status)
      return true;
    if (gfc.noise_shaping > 1) {
      Arrays$1.fill(gfc.pseudohalf, 0);
      if (0 == cod_info.scalefac_scale) {
        inc_scalefac_scale(cod_info, xrpow);
        status = false;
      } else {
        if (cod_info.block_type == Encoder.SHORT_TYPE && gfc.subblock_gain > 0) {
          status = inc_subblock_gain(gfc, cod_info, xrpow) || loop_break(cod_info);
        }
      }
    }
    if (!status) {
      if (gfc.mode_gr == 2)
        status = tk.scale_bitcount(cod_info);
      else
        status = tk.scale_bitcount_lsf(gfc, cod_info);
    }
    return !status;
  }
  this.outer_loop = function(gfp, cod_info, l3_xmin, xrpow, ch, targ_bits) {
    var gfc = gfp.internal_flags;
    var cod_info_w = new GrInfo();
    var save_xrpow = new_float(576);
    var distort = new_float(L3Side$1.SFBMAX);
    var best_noise_info = new CalcNoiseResult$1();
    var better;
    var prev_noise = new CalcNoiseData();
    var best_part2_3_length = 9999999;
    var bEndOfSearch = false;
    var bRefine = false;
    var best_ggain_pass1 = 0;
    bin_search_StepSize(gfc, cod_info, targ_bits, ch, xrpow);
    if (0 == gfc.noise_shaping)
      return 100;
    qupvt.calc_noise(
      cod_info,
      l3_xmin,
      distort,
      best_noise_info,
      prev_noise
    );
    best_noise_info.bits = cod_info.part2_3_length;
    cod_info_w.assign(cod_info);
    var age = 0;
    System$1.arraycopy(xrpow, 0, save_xrpow, 0, 576);
    while (!bEndOfSearch) {
      do {
        var noise_info = new CalcNoiseResult$1();
        var search_limit;
        var maxggain = 255;
        if ((gfc.substep_shaping & 2) != 0) {
          search_limit = 20;
        } else {
          search_limit = 3;
        }
        if (gfc.sfb21_extra) {
          if (distort[cod_info_w.sfbmax] > 1)
            break;
          if (cod_info_w.block_type == Encoder.SHORT_TYPE && (distort[cod_info_w.sfbmax + 1] > 1 || distort[cod_info_w.sfbmax + 2] > 1))
            break;
        }
        if (!balance_noise(gfp, cod_info_w, distort, xrpow, bRefine))
          break;
        if (cod_info_w.scalefac_scale != 0)
          maxggain = 254;
        var huff_bits = targ_bits - cod_info_w.part2_length;
        if (huff_bits <= 0)
          break;
        while ((cod_info_w.part2_3_length = tk.count_bits(
          gfc,
          xrpow,
          cod_info_w,
          prev_noise
        )) > huff_bits && cod_info_w.global_gain <= maxggain)
          cod_info_w.global_gain++;
        if (cod_info_w.global_gain > maxggain)
          break;
        if (best_noise_info.over_count == 0) {
          while ((cod_info_w.part2_3_length = tk.count_bits(
            gfc,
            xrpow,
            cod_info_w,
            prev_noise
          )) > best_part2_3_length && cod_info_w.global_gain <= maxggain)
            cod_info_w.global_gain++;
          if (cod_info_w.global_gain > maxggain)
            break;
        }
        qupvt.calc_noise(
          cod_info_w,
          l3_xmin,
          distort,
          noise_info,
          prev_noise
        );
        noise_info.bits = cod_info_w.part2_3_length;
        if (cod_info.block_type != Encoder.SHORT_TYPE) {
          better = gfp.quant_comp;
        } else
          better = gfp.quant_comp_short;
        better = quant_compare(
          better,
          best_noise_info,
          noise_info,
          cod_info_w,
          distort
        ) ? 1 : 0;
        if (better != 0) {
          best_part2_3_length = cod_info.part2_3_length;
          best_noise_info = noise_info;
          cod_info.assign(cod_info_w);
          age = 0;
          System$1.arraycopy(xrpow, 0, save_xrpow, 0, 576);
        } else {
          if (gfc.full_outer_loop == 0) {
            if (++age > search_limit && best_noise_info.over_count == 0)
              break;
            if (gfc.noise_shaping_amp == 3 && bRefine && age > 30)
              break;
            if (gfc.noise_shaping_amp == 3 && bRefine && cod_info_w.global_gain - best_ggain_pass1 > 15)
              break;
          }
        }
      } while (cod_info_w.global_gain + cod_info_w.scalefac_scale < 255);
      if (gfc.noise_shaping_amp == 3) {
        if (!bRefine) {
          cod_info_w.assign(cod_info);
          System$1.arraycopy(save_xrpow, 0, xrpow, 0, 576);
          age = 0;
          best_ggain_pass1 = cod_info_w.global_gain;
          bRefine = true;
        } else {
          bEndOfSearch = true;
        }
      } else {
        bEndOfSearch = true;
      }
    }
    assert$3(cod_info.global_gain + cod_info.scalefac_scale <= 255);
    if (gfp.VBR == VbrMode$1.vbr_rh || gfp.VBR == VbrMode$1.vbr_mtrh)
      System$1.arraycopy(save_xrpow, 0, xrpow, 0, 576);
    else if ((gfc.substep_shaping & 1) != 0)
      trancate_smallspectrums(gfc, cod_info, l3_xmin, xrpow);
    return best_noise_info.over_count;
  };
  this.iteration_finish_one = function(gfc, gr, ch) {
    var l3_side = gfc.l3_side;
    var cod_info = l3_side.tt[gr][ch];
    tk.best_scalefac_store(gfc, gr, ch, l3_side);
    if (gfc.use_best_huffman == 1)
      tk.best_huffman_divide(gfc, cod_info);
    rv.ResvAdjust(gfc, cod_info);
  };
  this.VBR_encode_granule = function(gfp, cod_info, l3_xmin, xrpow, ch, min_bits, max_bits) {
    var gfc = gfp.internal_flags;
    var bst_cod_info = new GrInfo();
    var bst_xrpow = new_float(576);
    var Max_bits = max_bits;
    var real_bits = max_bits + 1;
    var this_bits = (max_bits + min_bits) / 2;
    var dbits, over, found = 0;
    var sfb21_extra = gfc.sfb21_extra;
    assert$3(Max_bits <= LameInternalFlags.MAX_BITS_PER_CHANNEL);
    Arrays$1.fill(bst_cod_info.l3_enc, 0);
    do {
      assert$3(this_bits >= min_bits);
      assert$3(this_bits <= max_bits);
      assert$3(min_bits <= max_bits);
      if (this_bits > Max_bits - 42)
        gfc.sfb21_extra = false;
      else
        gfc.sfb21_extra = sfb21_extra;
      over = outer_loop(gfp, cod_info, l3_xmin, xrpow, ch, this_bits);
      if (over <= 0) {
        found = 1;
        real_bits = cod_info.part2_3_length;
        bst_cod_info.assign(cod_info);
        System$1.arraycopy(xrpow, 0, bst_xrpow, 0, 576);
        max_bits = real_bits - 32;
        dbits = max_bits - min_bits;
        this_bits = (max_bits + min_bits) / 2;
      } else {
        min_bits = this_bits + 32;
        dbits = max_bits - min_bits;
        this_bits = (max_bits + min_bits) / 2;
        if (found != 0) {
          found = 2;
          cod_info.assign(bst_cod_info);
          System$1.arraycopy(bst_xrpow, 0, xrpow, 0, 576);
        }
      }
    } while (dbits > 12);
    gfc.sfb21_extra = sfb21_extra;
    if (found == 2) {
      System$1.arraycopy(bst_cod_info.l3_enc, 0, cod_info.l3_enc, 0, 576);
    }
    assert$3(cod_info.part2_3_length <= Max_bits);
  };
  this.get_framebits = function(gfp, frameBits) {
    var gfc = gfp.internal_flags;
    gfc.bitrate_index = gfc.VBR_min_bitrate;
    var bitsPerFrame = bs.getframebits(gfp);
    gfc.bitrate_index = 1;
    bitsPerFrame = bs.getframebits(gfp);
    for (var i = 1; i <= gfc.VBR_max_bitrate; i++) {
      gfc.bitrate_index = i;
      var mb = new MeanBits(bitsPerFrame);
      frameBits[i] = rv.ResvFrameBegin(gfp, mb);
      bitsPerFrame = mb.bits;
    }
  };
  this.VBR_old_prepare = function(gfp, pe, ms_ener_ratio, ratio, l3_xmin, frameBits, min_bits, max_bits, bands) {
    var gfc = gfp.internal_flags;
    var masking_lower_db, adjust = 0;
    var analog_silence = 1;
    var bits = 0;
    gfc.bitrate_index = gfc.VBR_max_bitrate;
    var avg = rv.ResvFrameBegin(gfp, new MeanBits(0)) / gfc.mode_gr;
    get_framebits(gfp, frameBits);
    for (var gr = 0; gr < gfc.mode_gr; gr++) {
      var mxb = qupvt.on_pe(gfp, pe, max_bits[gr], avg, gr, 0);
      if (gfc.mode_ext == Encoder.MPG_MD_MS_LR) {
        ms_convert(gfc.l3_side, gr);
        qupvt.reduce_side(max_bits[gr], ms_ener_ratio[gr], avg, mxb);
      }
      for (var ch = 0; ch < gfc.channels_out; ++ch) {
        var cod_info = gfc.l3_side.tt[gr][ch];
        if (cod_info.block_type != Encoder.SHORT_TYPE) {
          adjust = 1.28 / (1 + Math.exp(3.5 - pe[gr][ch] / 300)) - 0.05;
          masking_lower_db = gfc.PSY.mask_adjust - adjust;
        } else {
          adjust = 2.56 / (1 + Math.exp(3.5 - pe[gr][ch] / 300)) - 0.14;
          masking_lower_db = gfc.PSY.mask_adjust_short - adjust;
        }
        gfc.masking_lower = Math.pow(
          10,
          masking_lower_db * 0.1
        );
        init_outer_loop(gfc, cod_info);
        bands[gr][ch] = qupvt.calc_xmin(
          gfp,
          ratio[gr][ch],
          cod_info,
          l3_xmin[gr][ch]
        );
        if (bands[gr][ch] != 0)
          analog_silence = 0;
        min_bits[gr][ch] = 126;
        bits += max_bits[gr][ch];
      }
    }
    for (var gr = 0; gr < gfc.mode_gr; gr++) {
      for (var ch = 0; ch < gfc.channels_out; ch++) {
        if (bits > frameBits[gfc.VBR_max_bitrate]) {
          max_bits[gr][ch] *= frameBits[gfc.VBR_max_bitrate];
          max_bits[gr][ch] /= bits;
        }
        if (min_bits[gr][ch] > max_bits[gr][ch])
          min_bits[gr][ch] = max_bits[gr][ch];
      }
    }
    return analog_silence;
  };
  this.bitpressure_strategy = function(gfc, l3_xmin, min_bits, max_bits) {
    for (var gr = 0; gr < gfc.mode_gr; gr++) {
      for (var ch = 0; ch < gfc.channels_out; ch++) {
        var gi = gfc.l3_side.tt[gr][ch];
        var pxmin = l3_xmin[gr][ch];
        var pxminPos = 0;
        for (var sfb = 0; sfb < gi.psy_lmax; sfb++)
          pxmin[pxminPos++] *= 1 + 0.029 * sfb * sfb / Encoder.SBMAX_l / Encoder.SBMAX_l;
        if (gi.block_type == Encoder.SHORT_TYPE) {
          for (var sfb = gi.sfb_smin; sfb < Encoder.SBMAX_s; sfb++) {
            pxmin[pxminPos++] *= 1 + 0.029 * sfb * sfb / Encoder.SBMAX_s / Encoder.SBMAX_s;
            pxmin[pxminPos++] *= 1 + 0.029 * sfb * sfb / Encoder.SBMAX_s / Encoder.SBMAX_s;
            pxmin[pxminPos++] *= 1 + 0.029 * sfb * sfb / Encoder.SBMAX_s / Encoder.SBMAX_s;
          }
        }
        max_bits[gr][ch] = 0 | Math.max(
          min_bits[gr][ch],
          0.9 * max_bits[gr][ch]
        );
      }
    }
  };
  this.VBR_new_prepare = function(gfp, pe, ratio, l3_xmin, frameBits, max_bits) {
    var gfc = gfp.internal_flags;
    var analog_silence = 1;
    var avg = 0, bits = 0;
    var maximum_framebits;
    if (!gfp.free_format) {
      gfc.bitrate_index = gfc.VBR_max_bitrate;
      var mb = new MeanBits(avg);
      rv.ResvFrameBegin(gfp, mb);
      avg = mb.bits;
      get_framebits(gfp, frameBits);
      maximum_framebits = frameBits[gfc.VBR_max_bitrate];
    } else {
      gfc.bitrate_index = 0;
      var mb = new MeanBits(avg);
      maximum_framebits = rv.ResvFrameBegin(gfp, mb);
      avg = mb.bits;
      frameBits[0] = maximum_framebits;
    }
    for (var gr = 0; gr < gfc.mode_gr; gr++) {
      qupvt.on_pe(gfp, pe, max_bits[gr], avg, gr, 0);
      if (gfc.mode_ext == Encoder.MPG_MD_MS_LR) {
        ms_convert(gfc.l3_side, gr);
      }
      for (var ch = 0; ch < gfc.channels_out; ++ch) {
        var cod_info = gfc.l3_side.tt[gr][ch];
        gfc.masking_lower = Math.pow(
          10,
          gfc.PSY.mask_adjust * 0.1
        );
        init_outer_loop(gfc, cod_info);
        if (0 != qupvt.calc_xmin(
          gfp,
          ratio[gr][ch],
          cod_info,
          l3_xmin[gr][ch]
        ))
          analog_silence = 0;
        bits += max_bits[gr][ch];
      }
    }
    for (var gr = 0; gr < gfc.mode_gr; gr++) {
      for (var ch = 0; ch < gfc.channels_out; ch++) {
        if (bits > maximum_framebits) {
          max_bits[gr][ch] *= maximum_framebits;
          max_bits[gr][ch] /= bits;
        }
      }
    }
    return analog_silence;
  };
  this.calc_target_bits = function(gfp, pe, ms_ener_ratio, targ_bits, analog_silence_bits, max_frame_bits) {
    var gfc = gfp.internal_flags;
    var l3_side = gfc.l3_side;
    var res_factor;
    var gr, ch, totbits, mean_bits = 0;
    gfc.bitrate_index = gfc.VBR_max_bitrate;
    var mb = new MeanBits(mean_bits);
    max_frame_bits[0] = rv.ResvFrameBegin(gfp, mb);
    mean_bits = mb.bits;
    gfc.bitrate_index = 1;
    mean_bits = bs.getframebits(gfp) - gfc.sideinfo_len * 8;
    analog_silence_bits[0] = mean_bits / (gfc.mode_gr * gfc.channels_out);
    mean_bits = gfp.VBR_mean_bitrate_kbps * gfp.framesize * 1e3;
    if ((gfc.substep_shaping & 1) != 0)
      mean_bits *= 1.09;
    mean_bits /= gfp.out_samplerate;
    mean_bits -= gfc.sideinfo_len * 8;
    mean_bits /= gfc.mode_gr * gfc.channels_out;
    res_factor = 0.93 + 0.07 * (11 - gfp.compression_ratio) / (11 - 5.5);
    if (res_factor < 0.9)
      res_factor = 0.9;
    if (res_factor > 1)
      res_factor = 1;
    for (gr = 0; gr < gfc.mode_gr; gr++) {
      var sum = 0;
      for (ch = 0; ch < gfc.channels_out; ch++) {
        targ_bits[gr][ch] = int(res_factor * mean_bits);
        if (pe[gr][ch] > 700) {
          var add_bits = int((pe[gr][ch] - 700) / 1.4);
          var cod_info = l3_side.tt[gr][ch];
          targ_bits[gr][ch] = int(res_factor * mean_bits);
          if (cod_info.block_type == Encoder.SHORT_TYPE) {
            if (add_bits < mean_bits / 2)
              add_bits = mean_bits / 2;
          }
          if (add_bits > mean_bits * 3 / 2)
            add_bits = mean_bits * 3 / 2;
          else if (add_bits < 0)
            add_bits = 0;
          targ_bits[gr][ch] += add_bits;
        }
        if (targ_bits[gr][ch] > LameInternalFlags.MAX_BITS_PER_CHANNEL) {
          targ_bits[gr][ch] = LameInternalFlags.MAX_BITS_PER_CHANNEL;
        }
        sum += targ_bits[gr][ch];
      }
      if (sum > LameInternalFlags.MAX_BITS_PER_GRANULE) {
        for (ch = 0; ch < gfc.channels_out; ++ch) {
          targ_bits[gr][ch] *= LameInternalFlags.MAX_BITS_PER_GRANULE;
          targ_bits[gr][ch] /= sum;
        }
      }
    }
    if (gfc.mode_ext == Encoder.MPG_MD_MS_LR)
      for (gr = 0; gr < gfc.mode_gr; gr++) {
        qupvt.reduce_side(
          targ_bits[gr],
          ms_ener_ratio[gr],
          mean_bits * gfc.channels_out,
          LameInternalFlags.MAX_BITS_PER_GRANULE
        );
      }
    totbits = 0;
    for (gr = 0; gr < gfc.mode_gr; gr++) {
      for (ch = 0; ch < gfc.channels_out; ch++) {
        if (targ_bits[gr][ch] > LameInternalFlags.MAX_BITS_PER_CHANNEL)
          targ_bits[gr][ch] = LameInternalFlags.MAX_BITS_PER_CHANNEL;
        totbits += targ_bits[gr][ch];
      }
    }
    if (totbits > max_frame_bits[0]) {
      for (gr = 0; gr < gfc.mode_gr; gr++) {
        for (ch = 0; ch < gfc.channels_out; ch++) {
          targ_bits[gr][ch] *= max_frame_bits[0];
          targ_bits[gr][ch] /= totbits;
        }
      }
    }
  };
}
var Quantize_1 = Quantize$1;
var common$2 = common$l;
var assert$2 = common$2.assert;
function Reservoir$1() {
  var bs;
  this.setModules = function(_bs) {
    bs = _bs;
  };
  this.ResvFrameBegin = function(gfp, mean_bits) {
    var gfc = gfp.internal_flags;
    var maxmp3buf;
    var l3_side = gfc.l3_side;
    var frameLength = bs.getframebits(gfp);
    mean_bits.bits = (frameLength - gfc.sideinfo_len * 8) / gfc.mode_gr;
    var resvLimit = 8 * 256 * gfc.mode_gr - 8;
    if (gfp.brate > 320) {
      maxmp3buf = 8 * int(gfp.brate * 1e3 / (gfp.out_samplerate / 1152) / 8 + 0.5);
    } else {
      maxmp3buf = 8 * 1440;
      if (gfp.strict_ISO) {
        maxmp3buf = 8 * int(32e4 / (gfp.out_samplerate / 1152) / 8 + 0.5);
      }
    }
    gfc.ResvMax = maxmp3buf - frameLength;
    if (gfc.ResvMax > resvLimit)
      gfc.ResvMax = resvLimit;
    if (gfc.ResvMax < 0 || gfp.disable_reservoir)
      gfc.ResvMax = 0;
    var fullFrameBits = mean_bits.bits * gfc.mode_gr + Math.min(gfc.ResvSize, gfc.ResvMax);
    if (fullFrameBits > maxmp3buf)
      fullFrameBits = maxmp3buf;
    assert$2(0 == gfc.ResvMax % 8);
    assert$2(gfc.ResvMax >= 0);
    l3_side.resvDrain_pre = 0;
    if (gfc.pinfo != null) {
      gfc.pinfo.mean_bits = mean_bits.bits / 2;
      gfc.pinfo.resvsize = gfc.ResvSize;
    }
    return fullFrameBits;
  };
  this.ResvMaxBits = function(gfp, mean_bits, targ_bits, cbr) {
    var gfc = gfp.internal_flags;
    var add_bits;
    var ResvSize = gfc.ResvSize, ResvMax = gfc.ResvMax;
    if (cbr != 0)
      ResvSize += mean_bits;
    if ((gfc.substep_shaping & 1) != 0)
      ResvMax *= 0.9;
    targ_bits.bits = mean_bits;
    if (ResvSize * 10 > ResvMax * 9) {
      add_bits = ResvSize - ResvMax * 9 / 10;
      targ_bits.bits += add_bits;
      gfc.substep_shaping |= 128;
    } else {
      add_bits = 0;
      gfc.substep_shaping &= 127;
      if (!gfp.disable_reservoir && 0 == (gfc.substep_shaping & 1))
        targ_bits.bits -= 0.1 * mean_bits;
    }
    var extra_bits = ResvSize < gfc.ResvMax * 6 / 10 ? ResvSize : gfc.ResvMax * 6 / 10;
    extra_bits -= add_bits;
    if (extra_bits < 0)
      extra_bits = 0;
    return extra_bits;
  };
  this.ResvAdjust = function(gfc, gi) {
    gfc.ResvSize -= gi.part2_3_length + gi.part2_length;
  };
  this.ResvFrameEnd = function(gfc, mean_bits) {
    var over_bits;
    var l3_side = gfc.l3_side;
    gfc.ResvSize += mean_bits * gfc.mode_gr;
    var stuffingBits = 0;
    l3_side.resvDrain_post = 0;
    l3_side.resvDrain_pre = 0;
    if ((over_bits = gfc.ResvSize % 8) != 0)
      stuffingBits += over_bits;
    over_bits = gfc.ResvSize - stuffingBits - gfc.ResvMax;
    if (over_bits > 0) {
      assert$2(0 == over_bits % 8);
      assert$2(over_bits >= 0);
      stuffingBits += over_bits;
    }
    {
      var mdb_bytes = Math.min(l3_side.main_data_begin * 8, stuffingBits) / 8;
      l3_side.resvDrain_pre += 8 * mdb_bytes;
      stuffingBits -= 8 * mdb_bytes;
      gfc.ResvSize -= 8 * mdb_bytes;
      l3_side.main_data_begin -= mdb_bytes;
    }
    l3_side.resvDrain_post += stuffingBits;
    gfc.ResvSize -= stuffingBits;
  };
}
var Reservoir_1 = Reservoir$1;
function Version$1() {
  var LAME_URL = "http://www.mp3dev.org/";
  var LAME_MAJOR_VERSION = 3;
  var LAME_MINOR_VERSION = 98;
  var LAME_PATCH_VERSION = 4;
  var PSY_MAJOR_VERSION = 0;
  var PSY_MINOR_VERSION = 93;
  this.getLameVersion = function() {
    return LAME_MAJOR_VERSION + "." + LAME_MINOR_VERSION + "." + LAME_PATCH_VERSION;
  };
  this.getLameShortVersion = function() {
    return LAME_MAJOR_VERSION + "." + LAME_MINOR_VERSION + "." + LAME_PATCH_VERSION;
  };
  this.getLameVeryShortVersion = function() {
    return "LAME" + LAME_MAJOR_VERSION + "." + LAME_MINOR_VERSION + "r";
  };
  this.getPsyVersion = function() {
    return PSY_MAJOR_VERSION + "." + PSY_MINOR_VERSION;
  };
  this.getLameUrl = function() {
    return LAME_URL;
  };
  this.getLameOsBitness = function() {
    return "32bits";
  };
}
var Version_1 = Version$1;
var common$1 = common$l;
var System = common$1.System;
var VbrMode = common$1.VbrMode;
common$1.Float;
var ShortBlock = common$1.ShortBlock;
common$1.Util;
var Arrays = common$1.Arrays;
common$1.new_array_n;
var new_byte$1 = common$1.new_byte;
common$1.new_double;
common$1.new_float;
common$1.new_float_n;
common$1.new_int;
common$1.new_int_n;
var assert$1 = common$1.assert;
VBRTag$1.NUMTOCENTRIES = 100;
VBRTag$1.MAXFRAMESIZE = 2880;
function VBRTag$1() {
  var lame;
  var bs;
  var v;
  this.setModules = function(_lame, _bs, _v) {
    lame = _lame;
    bs = _bs;
    v = _v;
  };
  var FRAMES_FLAG = 1;
  var BYTES_FLAG = 2;
  var TOC_FLAG = 4;
  var VBR_SCALE_FLAG = 8;
  var NUMTOCENTRIES = VBRTag$1.NUMTOCENTRIES;
  var MAXFRAMESIZE = VBRTag$1.MAXFRAMESIZE;
  var VBRHEADERSIZE = NUMTOCENTRIES + 4 + 4 + 4 + 4 + 4;
  var LAMEHEADERSIZE = VBRHEADERSIZE + 9 + 1 + 1 + 8 + 1 + 1 + 3 + 1 + 1 + 2 + 4 + 2 + 2;
  var XING_BITRATE1 = 128;
  var XING_BITRATE2 = 64;
  var XING_BITRATE25 = 32;
  var ISO_8859_1 = null;
  var VBRTag0 = "Xing";
  var VBRTag1 = "Info";
  var crc16Lookup = [
    0,
    49345,
    49537,
    320,
    49921,
    960,
    640,
    49729,
    50689,
    1728,
    1920,
    51009,
    1280,
    50625,
    50305,
    1088,
    52225,
    3264,
    3456,
    52545,
    3840,
    53185,
    52865,
    3648,
    2560,
    51905,
    52097,
    2880,
    51457,
    2496,
    2176,
    51265,
    55297,
    6336,
    6528,
    55617,
    6912,
    56257,
    55937,
    6720,
    7680,
    57025,
    57217,
    8e3,
    56577,
    7616,
    7296,
    56385,
    5120,
    54465,
    54657,
    5440,
    55041,
    6080,
    5760,
    54849,
    53761,
    4800,
    4992,
    54081,
    4352,
    53697,
    53377,
    4160,
    61441,
    12480,
    12672,
    61761,
    13056,
    62401,
    62081,
    12864,
    13824,
    63169,
    63361,
    14144,
    62721,
    13760,
    13440,
    62529,
    15360,
    64705,
    64897,
    15680,
    65281,
    16320,
    16e3,
    65089,
    64001,
    15040,
    15232,
    64321,
    14592,
    63937,
    63617,
    14400,
    10240,
    59585,
    59777,
    10560,
    60161,
    11200,
    10880,
    59969,
    60929,
    11968,
    12160,
    61249,
    11520,
    60865,
    60545,
    11328,
    58369,
    9408,
    9600,
    58689,
    9984,
    59329,
    59009,
    9792,
    8704,
    58049,
    58241,
    9024,
    57601,
    8640,
    8320,
    57409,
    40961,
    24768,
    24960,
    41281,
    25344,
    41921,
    41601,
    25152,
    26112,
    42689,
    42881,
    26432,
    42241,
    26048,
    25728,
    42049,
    27648,
    44225,
    44417,
    27968,
    44801,
    28608,
    28288,
    44609,
    43521,
    27328,
    27520,
    43841,
    26880,
    43457,
    43137,
    26688,
    30720,
    47297,
    47489,
    31040,
    47873,
    31680,
    31360,
    47681,
    48641,
    32448,
    32640,
    48961,
    32e3,
    48577,
    48257,
    31808,
    46081,
    29888,
    30080,
    46401,
    30464,
    47041,
    46721,
    30272,
    29184,
    45761,
    45953,
    29504,
    45313,
    29120,
    28800,
    45121,
    20480,
    37057,
    37249,
    20800,
    37633,
    21440,
    21120,
    37441,
    38401,
    22208,
    22400,
    38721,
    21760,
    38337,
    38017,
    21568,
    39937,
    23744,
    23936,
    40257,
    24320,
    40897,
    40577,
    24128,
    23040,
    39617,
    39809,
    23360,
    39169,
    22976,
    22656,
    38977,
    34817,
    18624,
    18816,
    35137,
    19200,
    35777,
    35457,
    19008,
    19968,
    36545,
    36737,
    20288,
    36097,
    19904,
    19584,
    35905,
    17408,
    33985,
    34177,
    17728,
    34561,
    18368,
    18048,
    34369,
    33281,
    17088,
    17280,
    33601,
    16640,
    33217,
    32897,
    16448
  ];
  function addVbr(v2, bitrate) {
    v2.nVbrNumFrames++;
    v2.sum += bitrate;
    v2.seen++;
    if (v2.seen < v2.want) {
      return;
    }
    if (v2.pos < v2.size) {
      v2.bag[v2.pos] = v2.sum;
      v2.pos++;
      v2.seen = 0;
    }
    if (v2.pos == v2.size) {
      for (var i = 1; i < v2.size; i += 2) {
        v2.bag[i / 2] = v2.bag[i];
      }
      v2.want *= 2;
      v2.pos /= 2;
    }
  }
  function xingSeekTable(v2, t) {
    if (v2.pos <= 0)
      return;
    for (var i = 1; i < NUMTOCENTRIES; ++i) {
      var j = i / NUMTOCENTRIES, act, sum;
      var indx = 0 | Math.floor(j * v2.pos);
      if (indx > v2.pos - 1)
        indx = v2.pos - 1;
      act = v2.bag[indx];
      sum = v2.sum;
      var seek_point = 0 | 256 * act / sum;
      if (seek_point > 255)
        seek_point = 255;
      t[i] = 255 & seek_point;
    }
  }
  this.addVbrFrame = function(gfp) {
    var gfc = gfp.internal_flags;
    var kbps = Tables.bitrate_table[gfp.version][gfc.bitrate_index];
    assert$1(gfc.VBR_seek_table.bag != null);
    addVbr(gfc.VBR_seek_table, kbps);
  };
  function extractInteger(buf, bufPos) {
    var x = buf[bufPos + 0] & 255;
    x <<= 8;
    x |= buf[bufPos + 1] & 255;
    x <<= 8;
    x |= buf[bufPos + 2] & 255;
    x <<= 8;
    x |= buf[bufPos + 3] & 255;
    return x;
  }
  function createInteger(buf, bufPos, value) {
    buf[bufPos + 0] = 255 & (value >> 24 & 255);
    buf[bufPos + 1] = 255 & (value >> 16 & 255);
    buf[bufPos + 2] = 255 & (value >> 8 & 255);
    buf[bufPos + 3] = 255 & (value & 255);
  }
  function createShort(buf, bufPos, value) {
    buf[bufPos + 0] = 255 & (value >> 8 & 255);
    buf[bufPos + 1] = 255 & (value & 255);
  }
  function isVbrTag(buf, bufPos) {
    return new String(buf, bufPos, VBRTag0.length(), ISO_8859_1).equals(VBRTag0) || new String(buf, bufPos, VBRTag1.length(), ISO_8859_1).equals(VBRTag1);
  }
  function shiftInBitsValue(x, n, v2) {
    return 255 & (x << n | v2 & ~(-1 << n));
  }
  function setLameTagFrameHeader(gfp, buffer) {
    var gfc = gfp.internal_flags;
    buffer[0] = shiftInBitsValue(buffer[0], 8, 255);
    buffer[1] = shiftInBitsValue(buffer[1], 3, 7);
    buffer[1] = shiftInBitsValue(
      buffer[1],
      1,
      gfp.out_samplerate < 16e3 ? 0 : 1
    );
    buffer[1] = shiftInBitsValue(buffer[1], 1, gfp.version);
    buffer[1] = shiftInBitsValue(buffer[1], 2, 4 - 3);
    buffer[1] = shiftInBitsValue(buffer[1], 1, !gfp.error_protection ? 1 : 0);
    buffer[2] = shiftInBitsValue(buffer[2], 4, gfc.bitrate_index);
    buffer[2] = shiftInBitsValue(buffer[2], 2, gfc.samplerate_index);
    buffer[2] = shiftInBitsValue(buffer[2], 1, 0);
    buffer[2] = shiftInBitsValue(buffer[2], 1, gfp.extension);
    buffer[3] = shiftInBitsValue(buffer[3], 2, gfp.mode.ordinal());
    buffer[3] = shiftInBitsValue(buffer[3], 2, gfc.mode_ext);
    buffer[3] = shiftInBitsValue(buffer[3], 1, gfp.copyright);
    buffer[3] = shiftInBitsValue(buffer[3], 1, gfp.original);
    buffer[3] = shiftInBitsValue(buffer[3], 2, gfp.emphasis);
    buffer[0] = 255;
    var abyte = 255 & (buffer[1] & 241);
    var bitrate;
    if (1 == gfp.version) {
      bitrate = XING_BITRATE1;
    } else {
      if (gfp.out_samplerate < 16e3)
        bitrate = XING_BITRATE25;
      else
        bitrate = XING_BITRATE2;
    }
    if (gfp.VBR == VbrMode.vbr_off)
      bitrate = gfp.brate;
    var bbyte;
    if (gfp.free_format)
      bbyte = 0;
    else
      bbyte = 255 & 16 * lame.BitrateIndex(
        bitrate,
        gfp.version,
        gfp.out_samplerate
      );
    if (gfp.version == 1) {
      buffer[1] = 255 & (abyte | 10);
      abyte = 255 & (buffer[2] & 13);
      buffer[2] = 255 & (bbyte | abyte);
    } else {
      buffer[1] = 255 & (abyte | 2);
      abyte = 255 & (buffer[2] & 13);
      buffer[2] = 255 & (bbyte | abyte);
    }
  }
  this.getVbrTag = function(buf) {
    var pTagData = new VBRTagData();
    var bufPos = 0;
    pTagData.flags = 0;
    var hId = buf[bufPos + 1] >> 3 & 1;
    var hSrIndex = buf[bufPos + 2] >> 2 & 3;
    var hMode = buf[bufPos + 3] >> 6 & 3;
    var hBitrate = buf[bufPos + 2] >> 4 & 15;
    hBitrate = Tables.bitrate_table[hId][hBitrate];
    if (buf[bufPos + 1] >> 4 == 14)
      pTagData.samprate = Tables.samplerate_table[2][hSrIndex];
    else
      pTagData.samprate = Tables.samplerate_table[hId][hSrIndex];
    if (hId != 0) {
      if (hMode != 3)
        bufPos += 32 + 4;
      else
        bufPos += 17 + 4;
    } else {
      if (hMode != 3)
        bufPos += 17 + 4;
      else
        bufPos += 9 + 4;
    }
    if (!isVbrTag(buf, bufPos))
      return null;
    bufPos += 4;
    pTagData.hId = hId;
    var head_flags = pTagData.flags = extractInteger(buf, bufPos);
    bufPos += 4;
    if ((head_flags & FRAMES_FLAG) != 0) {
      pTagData.frames = extractInteger(buf, bufPos);
      bufPos += 4;
    }
    if ((head_flags & BYTES_FLAG) != 0) {
      pTagData.bytes = extractInteger(buf, bufPos);
      bufPos += 4;
    }
    if ((head_flags & TOC_FLAG) != 0) {
      if (pTagData.toc != null) {
        for (var i = 0; i < NUMTOCENTRIES; i++)
          pTagData.toc[i] = buf[bufPos + i];
      }
      bufPos += NUMTOCENTRIES;
    }
    pTagData.vbrScale = -1;
    if ((head_flags & VBR_SCALE_FLAG) != 0) {
      pTagData.vbrScale = extractInteger(buf, bufPos);
      bufPos += 4;
    }
    pTagData.headersize = (hId + 1) * 72e3 * hBitrate / pTagData.samprate;
    bufPos += 21;
    var encDelay = buf[bufPos + 0] << 4;
    encDelay += buf[bufPos + 1] >> 4;
    var encPadding = (buf[bufPos + 1] & 15) << 8;
    encPadding += buf[bufPos + 2] & 255;
    if (encDelay < 0 || encDelay > 3e3)
      encDelay = -1;
    if (encPadding < 0 || encPadding > 3e3)
      encPadding = -1;
    pTagData.encDelay = encDelay;
    pTagData.encPadding = encPadding;
    return pTagData;
  };
  this.InitVbrTag = function(gfp) {
    var gfc = gfp.internal_flags;
    var kbps_header;
    if (1 == gfp.version) {
      kbps_header = XING_BITRATE1;
    } else {
      if (gfp.out_samplerate < 16e3)
        kbps_header = XING_BITRATE25;
      else
        kbps_header = XING_BITRATE2;
    }
    if (gfp.VBR == VbrMode.vbr_off)
      kbps_header = gfp.brate;
    var totalFrameSize = (gfp.version + 1) * 72e3 * kbps_header / gfp.out_samplerate;
    var headerSize = gfc.sideinfo_len + LAMEHEADERSIZE;
    gfc.VBR_seek_table.TotalFrameSize = totalFrameSize;
    if (totalFrameSize < headerSize || totalFrameSize > MAXFRAMESIZE) {
      gfp.bWriteVbrTag = false;
      return;
    }
    gfc.VBR_seek_table.nVbrNumFrames = 0;
    gfc.VBR_seek_table.nBytesWritten = 0;
    gfc.VBR_seek_table.sum = 0;
    gfc.VBR_seek_table.seen = 0;
    gfc.VBR_seek_table.want = 1;
    gfc.VBR_seek_table.pos = 0;
    if (gfc.VBR_seek_table.bag == null) {
      gfc.VBR_seek_table.bag = new int[400]();
      gfc.VBR_seek_table.size = 400;
    }
    var buffer = new_byte$1(MAXFRAMESIZE);
    setLameTagFrameHeader(gfp, buffer);
    var n = gfc.VBR_seek_table.TotalFrameSize;
    for (var i = 0; i < n; ++i) {
      bs.add_dummy_byte(gfp, buffer[i] & 255, 1);
    }
  };
  function crcUpdateLookup(value, crc) {
    var tmp = crc ^ value;
    crc = crc >> 8 ^ crc16Lookup[tmp & 255];
    return crc;
  }
  this.updateMusicCRC = function(crc, buffer, bufferPos, size2) {
    for (var i = 0; i < size2; ++i)
      crc[0] = crcUpdateLookup(buffer[bufferPos + i], crc[0]);
  };
  function putLameVBR(gfp, musicLength, streamBuffer, streamBufferPos, crc) {
    var gfc = gfp.internal_flags;
    var bytesWritten = 0;
    var encDelay = gfp.encoder_delay;
    var encPadding = gfp.encoder_padding;
    var quality = 100 - 10 * gfp.VBR_q - gfp.quality;
    var version2 = v.getLameVeryShortVersion();
    var vbr;
    var revision = 0;
    var revMethod;
    var vbrTypeTranslator = [1, 5, 3, 2, 4, 0, 3];
    var lowpass = 0 | (gfp.lowpassfreq / 100 + 0.5 > 255 ? 255 : gfp.lowpassfreq / 100 + 0.5);
    var peakSignalAmplitude = 0;
    var radioReplayGain = 0;
    var audiophileReplayGain = 0;
    var noiseShaping = gfp.internal_flags.noise_shaping;
    var stereoMode = 0;
    var nonOptimal = 0;
    var sourceFreq = 0;
    var misc = 0;
    var musicCRC = 0;
    var expNPsyTune = (gfp.exp_nspsytune & 1) != 0;
    var safeJoint = (gfp.exp_nspsytune & 2) != 0;
    var noGapMore = false;
    var noGapPrevious = false;
    var noGapCount = gfp.internal_flags.nogap_total;
    var noGapCurr = gfp.internal_flags.nogap_current;
    var athType = gfp.ATHtype;
    var flags = 0;
    var abrBitrate;
    switch (gfp.VBR) {
      case vbr_abr:
        abrBitrate = gfp.VBR_mean_bitrate_kbps;
        break;
      case vbr_off:
        abrBitrate = gfp.brate;
        break;
      default:
        abrBitrate = gfp.VBR_min_bitrate_kbps;
    }
    if (gfp.VBR.ordinal() < vbrTypeTranslator.length)
      vbr = vbrTypeTranslator[gfp.VBR.ordinal()];
    else
      vbr = 0;
    revMethod = 16 * revision + vbr;
    if (gfc.findReplayGain) {
      if (gfc.RadioGain > 510)
        gfc.RadioGain = 510;
      if (gfc.RadioGain < -510)
        gfc.RadioGain = -510;
      radioReplayGain = 8192;
      radioReplayGain |= 3072;
      if (gfc.RadioGain >= 0) {
        radioReplayGain |= gfc.RadioGain;
      } else {
        radioReplayGain |= 512;
        radioReplayGain |= -gfc.RadioGain;
      }
    }
    if (gfc.findPeakSample)
      peakSignalAmplitude = Math.abs(0 | gfc.PeakSample / 32767 * Math.pow(2, 23) + 0.5);
    if (noGapCount != -1) {
      if (noGapCurr > 0)
        noGapPrevious = true;
      if (noGapCurr < noGapCount - 1)
        noGapMore = true;
    }
    flags = athType + ((expNPsyTune ? 1 : 0) << 4) + ((safeJoint ? 1 : 0) << 5) + ((noGapMore ? 1 : 0) << 6) + ((noGapPrevious ? 1 : 0) << 7);
    if (quality < 0)
      quality = 0;
    switch (gfp.mode) {
      case MONO:
        stereoMode = 0;
        break;
      case STEREO:
        stereoMode = 1;
        break;
      case DUAL_CHANNEL:
        stereoMode = 2;
        break;
      case JOINT_STEREO:
        if (gfp.force_ms)
          stereoMode = 4;
        else
          stereoMode = 3;
        break;
      case NOT_SET:
      default:
        stereoMode = 7;
        break;
    }
    if (gfp.in_samplerate <= 32e3)
      sourceFreq = 0;
    else if (gfp.in_samplerate == 48e3)
      sourceFreq = 2;
    else if (gfp.in_samplerate > 48e3)
      sourceFreq = 3;
    else {
      sourceFreq = 1;
    }
    if (gfp.short_blocks == ShortBlock.short_block_forced || gfp.short_blocks == ShortBlock.short_block_dispensed || gfp.lowpassfreq == -1 && gfp.highpassfreq == -1 || /* "-k" */
    gfp.scale_left < gfp.scale_right || gfp.scale_left > gfp.scale_right || gfp.disable_reservoir && gfp.brate < 320 || gfp.noATH || gfp.ATHonly || athType == 0 || gfp.in_samplerate <= 32e3)
      nonOptimal = 1;
    misc = noiseShaping + (stereoMode << 2) + (nonOptimal << 5) + (sourceFreq << 6);
    musicCRC = gfc.nMusicCRC;
    createInteger(streamBuffer, streamBufferPos + bytesWritten, quality);
    bytesWritten += 4;
    for (var j = 0; j < 9; j++) {
      streamBuffer[streamBufferPos + bytesWritten + j] = 255 & version2.charAt(j);
    }
    bytesWritten += 9;
    streamBuffer[streamBufferPos + bytesWritten] = 255 & revMethod;
    bytesWritten++;
    streamBuffer[streamBufferPos + bytesWritten] = 255 & lowpass;
    bytesWritten++;
    createInteger(
      streamBuffer,
      streamBufferPos + bytesWritten,
      peakSignalAmplitude
    );
    bytesWritten += 4;
    createShort(
      streamBuffer,
      streamBufferPos + bytesWritten,
      radioReplayGain
    );
    bytesWritten += 2;
    createShort(
      streamBuffer,
      streamBufferPos + bytesWritten,
      audiophileReplayGain
    );
    bytesWritten += 2;
    streamBuffer[streamBufferPos + bytesWritten] = 255 & flags;
    bytesWritten++;
    if (abrBitrate >= 255)
      streamBuffer[streamBufferPos + bytesWritten] = 255;
    else
      streamBuffer[streamBufferPos + bytesWritten] = 255 & abrBitrate;
    bytesWritten++;
    streamBuffer[streamBufferPos + bytesWritten] = 255 & encDelay >> 4;
    streamBuffer[streamBufferPos + bytesWritten + 1] = 255 & (encDelay << 4) + (encPadding >> 8);
    streamBuffer[streamBufferPos + bytesWritten + 2] = 255 & encPadding;
    bytesWritten += 3;
    streamBuffer[streamBufferPos + bytesWritten] = 255 & misc;
    bytesWritten++;
    streamBuffer[streamBufferPos + bytesWritten++] = 0;
    createShort(streamBuffer, streamBufferPos + bytesWritten, gfp.preset);
    bytesWritten += 2;
    createInteger(streamBuffer, streamBufferPos + bytesWritten, musicLength);
    bytesWritten += 4;
    createShort(streamBuffer, streamBufferPos + bytesWritten, musicCRC);
    bytesWritten += 2;
    for (var i = 0; i < bytesWritten; i++)
      crc = crcUpdateLookup(streamBuffer[streamBufferPos + i], crc);
    createShort(streamBuffer, streamBufferPos + bytesWritten, crc);
    bytesWritten += 2;
    return bytesWritten;
  }
  function skipId3v2(fpStream) {
    fpStream.seek(0);
    var id3v2Header = new_byte$1(10);
    fpStream.readFully(id3v2Header);
    var id3v2TagSize;
    if (!new String(id3v2Header, "ISO-8859-1").startsWith("ID3")) {
      id3v2TagSize = ((id3v2Header[6] & 127) << 21 | (id3v2Header[7] & 127) << 14 | (id3v2Header[8] & 127) << 7 | id3v2Header[9] & 127) + id3v2Header.length;
    } else {
      id3v2TagSize = 0;
    }
    return id3v2TagSize;
  }
  this.getLameTagFrame = function(gfp, buffer) {
    var gfc = gfp.internal_flags;
    if (!gfp.bWriteVbrTag) {
      return 0;
    }
    if (gfc.Class_ID != Lame.LAME_ID) {
      return 0;
    }
    if (gfc.VBR_seek_table.pos <= 0) {
      return 0;
    }
    if (buffer.length < gfc.VBR_seek_table.TotalFrameSize) {
      return gfc.VBR_seek_table.TotalFrameSize;
    }
    Arrays.fill(buffer, 0, gfc.VBR_seek_table.TotalFrameSize, 0);
    setLameTagFrameHeader(gfp, buffer);
    var toc = new_byte$1(NUMTOCENTRIES);
    if (gfp.free_format) {
      for (var i = 1; i < NUMTOCENTRIES; ++i)
        toc[i] = 255 & 255 * i / 100;
    } else {
      xingSeekTable(gfc.VBR_seek_table, toc);
    }
    var streamIndex = gfc.sideinfo_len;
    if (gfp.error_protection)
      streamIndex -= 2;
    if (gfp.VBR == VbrMode.vbr_off) {
      buffer[streamIndex++] = 255 & VBRTag1.charAt(0);
      buffer[streamIndex++] = 255 & VBRTag1.charAt(1);
      buffer[streamIndex++] = 255 & VBRTag1.charAt(2);
      buffer[streamIndex++] = 255 & VBRTag1.charAt(3);
    } else {
      buffer[streamIndex++] = 255 & VBRTag0.charAt(0);
      buffer[streamIndex++] = 255 & VBRTag0.charAt(1);
      buffer[streamIndex++] = 255 & VBRTag0.charAt(2);
      buffer[streamIndex++] = 255 & VBRTag0.charAt(3);
    }
    createInteger(buffer, streamIndex, FRAMES_FLAG + BYTES_FLAG + TOC_FLAG + VBR_SCALE_FLAG);
    streamIndex += 4;
    createInteger(buffer, streamIndex, gfc.VBR_seek_table.nVbrNumFrames);
    streamIndex += 4;
    var streamSize = gfc.VBR_seek_table.nBytesWritten + gfc.VBR_seek_table.TotalFrameSize;
    createInteger(buffer, streamIndex, 0 | streamSize);
    streamIndex += 4;
    System.arraycopy(toc, 0, buffer, streamIndex, toc.length);
    streamIndex += toc.length;
    if (gfp.error_protection) {
      bs.CRC_writeheader(gfc, buffer);
    }
    var crc = 0;
    for (var i = 0; i < streamIndex; i++)
      crc = crcUpdateLookup(buffer[i], crc);
    streamIndex += putLameVBR(gfp, streamSize, buffer, streamIndex, crc);
    return gfc.VBR_seek_table.TotalFrameSize;
  };
  this.putVbrTag = function(gfp, stream) {
    var gfc = gfp.internal_flags;
    if (gfc.VBR_seek_table.pos <= 0)
      return -1;
    stream.seek(stream.length());
    if (stream.length() == 0)
      return -1;
    var id3v2TagSize = skipId3v2(stream);
    stream.seek(id3v2TagSize);
    var buffer = new_byte$1(MAXFRAMESIZE);
    var bytes = getLameTagFrame(gfp, buffer);
    if (bytes > buffer.length) {
      return -1;
    }
    if (bytes < 1) {
      return 0;
    }
    stream.write(buffer, 0, bytes);
    return 0;
  };
}
var VBRTag_1 = VBRTag$1;
var common = common$l;
common.System;
common.VbrMode;
common.Float;
common.ShortBlock;
common.Util;
common.Arrays;
common.new_array_n;
var new_byte = common.new_byte;
common.new_double;
common.new_float;
common.new_float_n;
common.new_int;
common.new_int_n;
var assert = common.assert;
var Lame$1 = Lame_1;
var Presets = Presets_1;
var GainAnalysis$1 = GainAnalysis_1;
var QuantizePVT = QuantizePVT_1;
var Quantize = Quantize_1;
var Takehiro = Takehiro_1;
var Reservoir = Reservoir_1;
var MPEGMode$1 = MPEGMode_1;
var BitStream$1 = BitStream_1;
requireEncoder();
var Version = Version_1;
var VBRTag = VBRTag_1;
function GetAudio() {
  this.setModules = function(parse22, mpg2) {
  };
}
function Parse() {
  this.setModules = function(ver2, id32, pre2) {
  };
}
function MPGLib() {
}
function ID3Tag() {
  this.setModules = function(_bits, _ver) {
  };
}
function Mp3Encoder(channels, samplerate, kbps) {
  if (arguments.length != 3) {
    console.error("WARN: Mp3Encoder(channels, samplerate, kbps) not specified");
    channels = 1;
    samplerate = 44100;
    kbps = 128;
  }
  var lame = new Lame$1();
  var gaud = new GetAudio();
  var ga = new GainAnalysis$1();
  var bs = new BitStream$1();
  var p2 = new Presets();
  var qupvt = new QuantizePVT();
  var qu = new Quantize();
  var vbr = new VBRTag();
  var ver = new Version();
  var id3 = new ID3Tag();
  var rv = new Reservoir();
  var tak = new Takehiro();
  var parse4 = new Parse();
  var mpg = new MPGLib();
  lame.setModules(ga, bs, p2, qupvt, qu, vbr, ver, id3, mpg);
  bs.setModules(ga, mpg, ver, vbr);
  id3.setModules(bs, ver);
  p2.setModules(lame);
  qu.setModules(bs, rv, qupvt, tak);
  qupvt.setModules(tak, rv, lame.enc.psy);
  rv.setModules(bs);
  tak.setModules(qupvt);
  vbr.setModules(lame, bs, ver);
  gaud.setModules(parse4, mpg);
  parse4.setModules(ver, id3, p2);
  var gfp = lame.lame_init();
  gfp.num_channels = channels;
  gfp.in_samplerate = samplerate;
  gfp.brate = kbps;
  gfp.mode = MPEGMode$1.STEREO;
  gfp.quality = 3;
  gfp.bWriteVbrTag = false;
  gfp.disable_reservoir = true;
  gfp.write_id3tag_automatic = false;
  var retcode = lame.lame_init_params(gfp);
  assert(0 == retcode);
  var maxSamples = 1152;
  var mp3buf_size = 0 | 1.25 * maxSamples + 7200;
  var mp3buf = new_byte(mp3buf_size);
  this.encodeBuffer = function(left, right) {
    if (channels == 1) {
      right = left;
    }
    assert(left.length == right.length);
    if (left.length > maxSamples) {
      maxSamples = left.length;
      mp3buf_size = 0 | 1.25 * maxSamples + 7200;
      mp3buf = new_byte(mp3buf_size);
    }
    var _sz = lame.lame_encode_buffer(gfp, left, right, left.length, mp3buf, 0, mp3buf_size);
    return new Int8Array(mp3buf.subarray(0, _sz));
  };
  this.flush = function() {
    var _sz = lame.lame_encode_flush(gfp, mp3buf, 0, mp3buf_size);
    return new Int8Array(mp3buf.subarray(0, _sz));
  };
}
function WavHeader() {
  this.dataOffset = 0;
  this.dataLen = 0;
  this.channels = 0;
  this.sampleRate = 0;
}
function fourccToInt(fourcc) {
  return fourcc.charCodeAt(0) << 24 | fourcc.charCodeAt(1) << 16 | fourcc.charCodeAt(2) << 8 | fourcc.charCodeAt(3);
}
WavHeader.RIFF = fourccToInt("RIFF");
WavHeader.WAVE = fourccToInt("WAVE");
WavHeader.fmt_ = fourccToInt("fmt ");
WavHeader.data = fourccToInt("data");
WavHeader.readHeader = function(dataView) {
  var w = new WavHeader();
  var header = dataView.getUint32(0, false);
  if (WavHeader.RIFF != header) {
    return;
  }
  dataView.getUint32(4, true);
  if (WavHeader.WAVE != dataView.getUint32(8, false)) {
    return;
  }
  if (WavHeader.fmt_ != dataView.getUint32(12, false)) {
    return;
  }
  var fmtLen = dataView.getUint32(16, true);
  var pos = 16 + 4;
  switch (fmtLen) {
    case 16:
    case 18:
      w.channels = dataView.getUint16(pos + 2, true);
      w.sampleRate = dataView.getUint32(pos + 4, true);
      break;
    default:
      throw "extended fmt chunk not implemented";
  }
  pos += fmtLen;
  var data = WavHeader.data;
  var len = 0;
  while (data != header) {
    header = dataView.getUint32(pos, false);
    len = dataView.getUint32(pos + 4, true);
    if (data == header) {
      break;
    }
    pos += len + 8;
  }
  w.dataLen = len;
  w.dataOffset = pos + 8;
  return w;
};
js.Mp3Encoder = Mp3Encoder;
js.WavHeader = WavHeader;
var MAX_AMPLITUDE = 32767;
function encodeMp3(audioBuffer, params, onProgress, cb) {
  var nChannels = audioBuffer.numberOfChannels;
  if (nChannels !== 1 && nChannels !== 2) {
    throw new Error("Expecting mono or stereo audioBuffer");
  }
  var bitrate = params.bitrate || 128;
  if (bitrate < 96) {
    nChannels = 1;
  }
  var bufferLength = audioBuffer.length;
  var buffers = [];
  for (var channel = 0; channel < nChannels; channel++) {
    var buffer = audioBuffer.getChannelData(channel);
    var samples = new Int16Array(bufferLength);
    for (var i = 0; i < bufferLength; ++i) {
      var sample = buffer[i];
      sample = Math.min(1, Math.max(-1, sample));
      sample = Math.round(sample * MAX_AMPLITUDE);
      samples[i] = sample;
    }
    buffers.push(samples);
  }
  var BLOCK_SIZE = 1152;
  var mp3encoder = new js.Mp3Encoder(
    nChannels,
    audioBuffer.sampleRate || 44100,
    bitrate
  );
  var mp3Data = [];
  var blockIndex = 0;
  function encodeChunk() {
    var mp3buf;
    if (nChannels === 1) {
      var chunk = buffers[0].subarray(blockIndex, blockIndex + BLOCK_SIZE);
      mp3buf = mp3encoder.encodeBuffer(chunk);
    } else {
      var chunkL = buffers[0].subarray(blockIndex, blockIndex + BLOCK_SIZE);
      var chunkR = buffers[1].subarray(blockIndex, blockIndex + BLOCK_SIZE);
      var mp3buf = mp3encoder.encodeBuffer(chunkL, chunkR);
    }
    if (mp3buf.length > 0) {
      mp3Data.push(mp3buf);
    }
    blockIndex += BLOCK_SIZE;
  }
  function update() {
    if (blockIndex >= bufferLength) {
      var mp3buf = mp3encoder.flush();
      if (mp3buf.length > 0) {
        mp3Data.push(mp3buf);
      }
      return cb(new Blob(mp3Data, { type: "audio/mp3" }));
    }
    var start = performance.now();
    while (blockIndex < bufferLength && performance.now() - start < 15) {
      encodeChunk();
    }
    onProgress && onProgress(blockIndex / bufferLength);
    setTimeout(update, 16.7);
  }
  update();
}
const log$2 = debug("story");
class Story extends BaseModel {
  static get objectName() {
    return "story";
  }
  static get defaultObject() {
    return {
      id: null,
      fid: null,
      uid: null,
      shared: false,
      cloudSync: true,
      title: null,
      short_description: null,
      description: null,
      updated: (/* @__PURE__ */ new Date()).toISOString(),
      lastExport: null,
      savesSinceExport: 0,
      wc: 0,
      lastwc: 0,
      types: [],
      blueprints: [],
      scenes: [],
      characters: [],
      tags: [],
      styles: [],
      backgrounds: [],
      animation: [],
      audio: [],
      music: [],
      images: [],
      media: [],
      effectProfiles: [],
      attrs: {
        genre: "",
        language: "",
        multiplayer: false,
        players_min: 1,
        players_max: 1
      },
      settings: {},
      cover: null,
      ordering: 1,
      landing: null
    };
  }
  static get fields() {
    return {
      // cover: new Model.fieldtypes.ImageField(),
      rel_scenes: new BaseModel.fieldtypes.Relation(Scene, "scenes")
    };
  }
  get systemTypes() {
    const setting = this.settings.playerBlueprint;
    const defaultPlayerType = {
      id: "$player",
      name: "$player",
      attrs: [
        { name: "username", type: "text" },
        { name: "name", type: "text", immutable: true },
        { name: "main", type: "boolean", immutable: true }
      ]
    };
    let playerType = null;
    let playerBlueprint = this.blueprints.find((bp) => bp.id === setting);
    if (playerBlueprint) {
      playerType = this.types.find((type2) => type2.id === playerBlueprint.meta);
      if (playerType) {
        playerType = copy$1(playerType);
        for (const prop in defaultPlayerType) {
          if (defaultPlayerType[prop] instanceof Array) {
            for (const row of defaultPlayerType[prop]) {
              const existing = playerType[prop].find((r) => r.name === row.name);
              if (existing) {
                for (const attr in row) {
                  existing[attr] = row[attr];
                }
              } else {
                playerType[prop].push(row);
              }
            }
          } else {
            playerType[prop] = defaultPlayerType[prop];
          }
        }
      }
    }
    if (!playerType) {
      playerType = defaultPlayerType;
    }
    return [
      playerType,
      {
        id: "$party",
        name: "$party",
        attrs: [{ name: "name", type: "text", immutable: true }]
      }
      // {
      //   id: '$character', name: '$character', attrs: [
      //     { name: 'id', type: 'text', immutable: true },
      //   ],
      // },
    ];
  }
  get systemTags() {
    const retval = [{ id: "$item", name: "$item", type: "ref", referencing: "$current" }];
    if (this.attrs.multiplayer) {
      return retval.concat([
        {
          id: "$players",
          name: "$players",
          type: "array",
          referencing: "$player"
        },
        {
          id: "$player",
          name: "$player",
          type: "ref",
          referencing: "$player",
          immutable: true
        },
        {
          id: "$party",
          name: "$party",
          type: "instance",
          referencing: "$party",
          immutable: true
        }
      ]);
    }
    return retval;
  }
  get allTypes() {
    return [].concat(this.types, this.systemTypes);
  }
  get allTags() {
    return [].concat(this.tags, this.systemTags);
  }
  get emotes() {
    return this.characters.reduce((a, b) => {
      const emotes = copy$1(b.emotes);
      emotes.forEach((e2) => {
        e2.label = `${b.name}: ${e2.name}`;
        e2.character = b.id;
      });
      return a.concat(emotes);
    }, []);
  }
  async countSceneWords() {
    return (await this.sceneList()).map((s) => s.wc || 0).reduce((a, b) => a + b, 0);
  }
  async createScene(extra = {}) {
    const retval = new Scene({
      story: this.id,
      directions: [{ id: 1, type: "text", content: "" }]
    });
    retval.update(extra);
    await retval.save();
    const scenes = new Set(this.scenes);
    scenes.add(retval.id);
    this.scenes = Array.from(scenes);
    this.updated = (/* @__PURE__ */ new Date()).toISOString();
    await this.save();
    this.rel_scenes.addToCache(retval);
    if (this.cloudSync) {
      await retval.push();
      await this.push();
    }
    return retval;
  }
  async sceneList() {
    return (await Promise.all(this.scenes.map((s) => Scene.load(s)))).filter((a) => a);
  }
  async getStartScene() {
    const scenes = await this.rel_scenes.list();
    let scene = scenes.find((s) => s && s.start);
    if (!scene && scenes.length > 0) {
      scene = scenes[0];
    }
    return scene;
  }
  async freezeAudio() {
    console.log(">>> Freezing audio...");
    const { Offline, Player, ToneAudioBuffer, getDestination } = await __vitePreload(() => import("./index-C4XtTvKC.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url);
    const scenes = toRaw(await this.rel_scenes.list()).map((s) => toRaw(s));
    let storyChanged = true;
    for (const scene of scenes) {
      let sceneChanged = false;
      for (const direction of scene.directions) {
        let profile = null;
        let frozen = null;
        let shouldFreeze = false;
        if (direction.type === "text" && direction.audio) {
          profile = this.getEffectProfile(direction);
          frozen = direction.frozenAudio && await Media.load(direction.frozenAudio);
          if (frozen && profile) {
            shouldFreeze = await this.shouldRefreezeAudio(direction, profile, frozen);
          } else if (profile) {
            shouldFreeze = true;
          }
          console.log("freeze", shouldFreeze, frozen, direction.frozenAudio);
        }
        if (!profile && direction.frozenAudio) {
          console.log("removed unneeded frozen audio", profile, frozen);
          direction.frozenAudio = void 0;
          if (frozen) {
            await frozen.delete();
          }
          sceneChanged = true;
        }
        if (shouldFreeze) {
          const media = await Media.load(direction.audio);
          if (!media) {
            console.error("missing audio", direction);
            continue;
          }
          const url = await media.getUrl();
          let audioBuffer = new ToneAudioBuffer();
          await audioBuffer.load(url);
          audioBuffer = await Offline(async (context) => {
            const player = new Player();
            getDestination();
            await player.load(url);
            context.transport.start();
            await player.start();
          }, audioBuffer.duration + 1);
          let blob = null;
          console.time("mp3");
          const ab = audioBuffer.get();
          try {
            blob = await new Promise((resolve2) => {
              encodeMp3(ab, 128, null, (blob2) => {
                resolve2(blob2);
              });
            });
          } catch (e2) {
            console.error(e2);
            blob = null;
          }
          console.timeEnd("mp3");
          if (blob) {
            if (!frozen || frozen.id === media.id) {
              frozen = new Media();
            }
            frozen.cloud = false;
            frozen.cloudSafe = false;
            await frozen.importBlob(blob, true);
            frozen.name = `[F]${media.name}`;
            frozen.type = media.type;
            frozen.isPrivate = true;
            frozen.updated = (/* @__PURE__ */ new Date()).toISOString();
            await frozen.save();
            direction.frozenAudio = frozen.id;
            sceneChanged = true;
          } else {
            console.log("failed to freeze audio", ab);
          }
        }
      }
      if (sceneChanged) {
        console.log("save scene", scene, scene.save);
        await scene.save();
        storyChanged = true;
      }
    }
    if (storyChanged) {
      await this.saveJson(true);
    }
    console.log("<<< freeze done");
  }
  getEffectProfile(direction) {
    const character = this.characters.find((item) => item.id === direction.character);
    const profileId = direction.ep || direction.effectProfileId || (character == null ? void 0 : character.effectProfileId);
    return this.effectProfiles.find((item) => item.id === profileId);
  }
  async shouldRefreezeAudio(direction, profile, media) {
    const updated = new Date((media == null ? void 0 : media.updated) || 1);
    return profile && (!direction.frozenAudio || updated < new Date(profile.updated) || updated < new Date(direction.textUpdated));
  }
  uploadFile(type2, file, attrs = {}, sync = true) {
    if (!attrs.id) {
      attrs.id = nanoid();
    }
    let reader = new FileReader();
    reader.onload = async () => {
      const name = basename(file.name);
      if (this.cloudSync && sync) {
        const response = await Media.objects.push(
          { id: attrs.name || name },
          { content: reader.result, public: true }
        );
        if (response) {
          attrs.permalink = response.url;
          if (response.error) {
            attrs.error = response.error;
          } else if (attrs.error) {
            delete attrs.error;
          }
        } else {
          attrs.error = "Failed to upload file";
        }
      }
      if (!attrs.name) {
        attrs.name = name;
      }
      await this.proxyFile(type2, reader.result, attrs);
    };
    reader.readAsDataURL(file);
  }
  async proxyFile(type2, url, attrs = {}) {
    if (!attrs.id) {
      attrs.id = nanoid();
    }
    const parts = url.split("/");
    attrs.name = parts[parts.length - 1];
    if (/\?|\#/.test(attrs.name)) {
      attrs.name = attrs.name.split(/\?|\#/)[0];
    }
    const media = await Media.importurlToBlob(url);
    attrs.blob_id = media.id;
    if (this[type2].indexOf(attrs) === -1) {
      this[type2].push(attrs);
    }
    await this.saveAndPush();
  }
  async deleteFile(type2, id) {
    const index2 = this[type2].findIndex((i) => i.id === id);
    if (index2 > -1) {
      const ref2 = this[type2][index2];
      this[type2].splice(index2, 1);
      try {
        await Media.objects.pushDelete(ref2.name);
      } catch (ex) {
      }
      await this.saveAndPush();
    }
  }
  async fixMissingMedia(type2) {
    this.loading = true;
    for (const image of this[type2]) {
      if (image.image && !image.blob_id) {
        image.blob_id = image.image;
        await this.save();
      }
    }
    for (const image of this[type2].filter((i) => i.permalink)) {
      const img = await Media.load(image.blob_id);
      if (!img) {
        const response = await Media.importBlob(image.permalink, image.blob_id);
        log$2("missing media", response);
      }
    }
    this.loading = false;
  }
  async saveAndPush(now = false) {
    if (now || await debounce("story-save-and-push", 1e3)) {
      await this.save(now);
      if (this.cloudSync) {
        await this.push(now);
      }
    }
  }
  async save(now = false) {
    await this.saveJson(now);
    await super.save();
  }
  async delete() {
    const promises = [];
    for (const sceneId of this.data.scenes) {
      promises.push(Scene.objects.delete(sceneId));
    }
    await Promise.all(promises);
    await window.app.$stories.removeItem(this.id);
    return super.delete();
  }
  async saveJson(now) {
    const scenes = await this.rel_scenes.list();
    this.update({
      savesSinceExport: (this.savesSinceExport || 0) + 1,
      wc: scenes.reduce((a, b) => a + b.wc, 0)
    });
    const json = copy$1(this.data);
    json.scenes = scenes.map((s) => toRaw(s.data));
    if (now) {
      await window.app.saveStory(json);
    } else {
      window.app.saveStoryDebounced(json);
    }
    return json;
  }
  async pushAll() {
    for (const sceneId of this.data.scenes) {
      const scene = await Scene.objects.load(sceneId);
      scene.story = this.id;
      scene.updated = (/* @__PURE__ */ new Date()).toISOString();
      await Scene.objects.push(scene);
    }
    return this.push();
  }
  async pushDelete() {
    const promises = [];
    for (const sceneId of this.data.scenes) {
      promises.push(Scene.objects.pushDelete(sceneId));
    }
    await Promise.all(promises);
    return super.pushDelete();
  }
  async publish(unlisted = true) {
    const blob = await app.exportStory(this.id);
    if (blob.size >= 21e6) {
      throw new Error(`File is too big to publish (${prettyBytes(blob.size)})`);
    }
    const content = await new Promise((r) => {
      const reader = new FileReader();
      reader.readAsDataURL(blob);
      reader.onloadend = function() {
        r(reader.result);
      };
    });
    const attrs = copy$1(this.attrs);
    attrs.version = app.maxStoryVersion;
    attrs.scenes = this.scenes.length;
    await app.$socket.ensureConnected();
    let call = "$sendwait";
    let timeoutOrMethod = 1e3 * 60 * 10;
    {
      call = "http";
      timeoutOrMethod = "POST";
    }
    const response = await app[call](
      "file_post",
      {
        path: unlisted ? void 0 : "cyoa/stories",
        id: this.fid || null,
        title: this.title,
        short_description: this.short_description,
        description: this.description,
        cover: this.cover,
        content_type: unlisted ? `unlisted/${app.id()}` : "application/cyoa",
        content,
        attrs
      },
      timeoutOrMethod
    );
    if (response && !response.error) {
      this.fid = response.id;
      this.shared = unlisted;
      await this.saveAndPush();
    } else {
      let error = null;
      if (/413/.test(response ? response.error : "")) {
        error = "Sorry, your story is too large to post on the server, this is usually caused by image and audio files. Try using smaller or compressed images or use fewer assets";
      } else {
        error = "Error uploading story, if the problem persists, please send a message to the developer";
        if (!response) {
          error += " (Server did not respond)";
        } else if (response.error) {
          error += " (" + response.error + ")";
        }
      }
      throw new Error(error);
    }
  }
  toString() {
    return this.title || "Untitled Story";
  }
}
const story = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Story
}, Symbol.toStringTag, { value: "Module" }));
class Blueprint {
  constructor(meta, config, data = {}) {
    this.$meta = meta;
    this.$config = config;
    this.data = data;
    if (!this.data.id) {
      this.data.id = nanoid();
    }
    if (!this.data.name) {
      this.data.name = config.name;
    }
    for (const attr of this.$meta.attrs || []) {
      if (data[attr.name] === void 0) {
        const value = (this.$config.values || []).find((v) => v.name === attr.name);
        if (value) {
          this.data[value.name] = runSimpleFormula(`${value.formula}`) || null;
        } else {
          if (attr.type === "number") {
            this.data[attr.name] = parseFloat(attr.default || 0);
          } else if (attr.type === "text") {
            this.data[attr.name] = attr.default || "";
          } else if (attr.type === "boolean") {
            this.data[attr.name] = !!(attr.default || false);
          } else {
            this.data[attr.name] = attr.default || null;
          }
        }
      }
      Object.defineProperty(this, attr.name, {
        get: () => this.getValue(attr.name),
        set: (v) => {
          this.setValue(attr.name, v);
        }
      });
    }
  }
  get id() {
    return this.data.id;
  }
  get name() {
    return this.data.name;
  }
  getValue(n) {
    if (this.data[n] || this.data[n] === 0) {
      return this.data[n];
    } else if (this.$config[n]) {
      return runSimpleFormula(this.$config[n].formula, this.data);
    }
  }
  setValue(n, v) {
    this.data[n] = v;
  }
  toJSON() {
    const retval = {
      $meta: [this.$meta.id, this.$config.id]
    };
    Object.keys(this.data).forEach((key) => {
      retval[key] = this.data[key];
    });
    return retval;
  }
  static parse(story2, value) {
    if (!(value instanceof Blueprint) && value.$meta) {
      let [meta, config] = value.$meta;
      meta = story2.allTypes.find((type2) => type2.id === meta);
      config = story2.blueprints.find((bp) => bp.id === config);
      if (!config && meta.name === "$player") {
        config = { id: "$player", name: "$player" };
      }
      if (meta && config) {
        delete value.$meta;
        return new Blueprint(meta, config, value);
      }
    }
    return value;
  }
}
function cancelableTimer(func, timeout) {
  const object = {};
  const promise = new Promise((resolve2) => {
    object.resolve = (value = true) => {
      clearTimeout(object.timer);
      resolve2(func(value));
    };
  });
  object.promise = promise;
  object.timer = setTimeout(object.resolve, timeout);
  return object;
}
class Campfire {
  static register(signal, parties, timeout = null) {
    if (!Campfire.signals[signal]) {
      Campfire.signals[signal] = new Campfire(signal, parties, timeout);
    }
    return Campfire.signals[signal];
  }
  constructor(signal, needs, timeout = null) {
    this.signal = signal;
    this.needs = needs;
    this.timeout = timeout;
    this.arrived = /* @__PURE__ */ new Set();
    this.gifts = {};
    this.timer = null;
  }
  arrival(party, gift = true) {
    this.arrived.add(party);
    this.gifts[party] = gift;
    if (this.needs.filter((n) => !this.arrived.has(n)).length === 0) {
      return this.cleanup();
    }
    if (this.timeout) {
      if (this.timer) {
        this.timer.resolve(false);
      }
      this.timer = cancelableTimer(() => {
        return this.cleanup();
      }, this.timeout);
      return this.timer.promise;
    }
    return false;
  }
  cleanup() {
    delete Campfire.signals[this.signal];
    return this.gifts;
  }
}
Campfire.signals = {};
var lib$1 = { exports: {} };
var seed = 1;
function getNextValue() {
  seed = (seed * 9301 + 49297) % 233280;
  return seed / 233280;
}
function setSeed$1(_seed_) {
  seed = _seed_;
}
var randomFromSeed$1 = {
  nextValue: getNextValue,
  seed: setSeed$1
};
var randomFromSeed = randomFromSeed$1;
var ORIGINAL = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-";
var alphabet$2;
var previousSeed;
var shuffled;
function reset() {
  shuffled = false;
}
function setCharacters(_alphabet_) {
  if (!_alphabet_) {
    if (alphabet$2 !== ORIGINAL) {
      alphabet$2 = ORIGINAL;
      reset();
    }
    return;
  }
  if (_alphabet_ === alphabet$2) {
    return;
  }
  if (_alphabet_.length !== ORIGINAL.length) {
    throw new Error("Custom alphabet for shortid must be " + ORIGINAL.length + " unique characters. You submitted " + _alphabet_.length + " characters: " + _alphabet_);
  }
  var unique = _alphabet_.split("").filter(function(item, ind, arr) {
    return ind !== arr.lastIndexOf(item);
  });
  if (unique.length) {
    throw new Error("Custom alphabet for shortid must be " + ORIGINAL.length + " unique characters. These characters were not unique: " + unique.join(", "));
  }
  alphabet$2 = _alphabet_;
  reset();
}
function characters(_alphabet_) {
  setCharacters(_alphabet_);
  return alphabet$2;
}
function setSeed(seed2) {
  randomFromSeed.seed(seed2);
  if (previousSeed !== seed2) {
    reset();
    previousSeed = seed2;
  }
}
function shuffle() {
  if (!alphabet$2) {
    setCharacters(ORIGINAL);
  }
  var sourceArray = alphabet$2.split("");
  var targetArray = [];
  var r = randomFromSeed.nextValue();
  var characterIndex;
  while (sourceArray.length > 0) {
    r = randomFromSeed.nextValue();
    characterIndex = Math.floor(r * sourceArray.length);
    targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
  }
  return targetArray.join("");
}
function getShuffled() {
  if (shuffled) {
    return shuffled;
  }
  shuffled = shuffle();
  return shuffled;
}
function lookup(index2) {
  var alphabetShuffled = getShuffled();
  return alphabetShuffled[index2];
}
function get3() {
  return alphabet$2 || ORIGINAL;
}
var alphabet_1 = {
  get: get3,
  characters,
  seed: setSeed,
  lookup,
  shuffled: getShuffled
};
var crypto$1 = typeof window === "object" && (window.crypto || window.msCrypto);
var randomByte;
if (!crypto$1 || !crypto$1.getRandomValues) {
  randomByte = function(size2) {
    var bytes = [];
    for (var i = 0; i < size2; i++) {
      bytes.push(Math.floor(Math.random() * 256));
    }
    return bytes;
  };
} else {
  randomByte = function(size2) {
    return crypto$1.getRandomValues(new Uint8Array(size2));
  };
}
var randomByteBrowser = randomByte;
var format_browser = function(random2, alphabet2, size2) {
  var mask = (2 << Math.log(alphabet2.length - 1) / Math.LN2) - 1;
  var step = -~(1.6 * mask * size2 / alphabet2.length);
  var id = "";
  while (true) {
    var bytes = random2(step);
    var i = step;
    while (i--) {
      id += alphabet2[bytes[i] & mask] || "";
      if (id.length === +size2)
        return id;
    }
  }
};
var alphabet$1 = alphabet_1;
var random = randomByteBrowser;
var format = format_browser;
function generate$1(number2) {
  var loopCounter = 0;
  var done;
  var str = "";
  while (!done) {
    str = str + format(random, alphabet$1.get(), 1);
    done = number2 < Math.pow(16, loopCounter + 1);
    loopCounter++;
  }
  return str;
}
var generate_1 = generate$1;
var generate2 = generate_1;
var REDUCE_TIME = 1567752802062;
var version$1 = 7;
var counter;
var previousSeconds;
function build2(clusterWorkerId) {
  var str = "";
  var seconds = Math.floor((Date.now() - REDUCE_TIME) * 1e-3);
  if (seconds === previousSeconds) {
    counter++;
  } else {
    counter = 0;
    previousSeconds = seconds;
  }
  str = str + generate2(version$1);
  str = str + generate2(clusterWorkerId);
  if (counter > 0) {
    str = str + generate2(counter);
  }
  str = str + generate2(seconds);
  return str;
}
var build_1 = build2;
var alphabet = alphabet_1;
function isShortId(id) {
  if (!id || typeof id !== "string" || id.length < 6) {
    return false;
  }
  var nonAlphabetic = new RegExp("[^" + alphabet.get().replace(/[|\\{}()[\]^$+*?.-]/g, "\\$&") + "]");
  return !nonAlphabetic.test(id);
}
var isValid = isShortId;
(function(module) {
  var alphabet2 = alphabet_1;
  var build3 = build_1;
  var isValid$1 = isValid;
  var clusterWorkerId = 0;
  function seed2(seedValue) {
    alphabet2.seed(seedValue);
    return module.exports;
  }
  function worker(workerId) {
    clusterWorkerId = workerId;
    return module.exports;
  }
  function characters2(newCharacters) {
    if (newCharacters !== void 0) {
      alphabet2.characters(newCharacters);
    }
    return alphabet2.shuffled();
  }
  function generate3() {
    return build3(clusterWorkerId);
  }
  module.exports = generate3;
  module.exports.generate = generate3;
  module.exports.seed = seed2;
  module.exports.worker = worker;
  module.exports.characters = characters2;
  module.exports.isValid = isValid$1;
})(lib$1);
var libExports = lib$1.exports;
var shortid = libExports;
const shortid$1 = /* @__PURE__ */ getDefaultExportFromCjs(shortid);
const parser = new Parser();
parser.functions.array = (len) => new Array(len);
class Character {
  constructor(sheet, base = null) {
    this.id = shortid$1();
    this.base = base || {};
    this.sheet = sheet;
    this.team = null;
    this.results = null;
    this.reset();
  }
  reset() {
    this.setInitiative();
    this.modifiers = [];
    this.heat = {};
    this.actionFormulas = {};
    this.effectFormulas = {};
    this.requireFormulas = {};
    this.sheet.actions = this.sheet.actions ? this.sheet.actions : [];
    this.sheet.attributes = this.sheet.attributes ? this.sheet.attributes : [];
    this.sheet.actions.forEach((a) => {
      try {
        this.actionFormulas[a.name] = a.formula ? parser.parse(a.formula.toLowerCase()) : null;
        this.requireFormulas[a.name] = a.requires ? parser.parse(a.requires.toLowerCase()) : null;
        this.effectFormulas[a.name] = a.effectFormula ? parser.parse(a.effectFormula.toLowerCase()) : null;
        this.heat[a.name] = 0;
      } catch (ex) {
        console.error(ex);
        for (const dict of [this.actionFormulas, this.requireFormulas, this.effectFormulas, this.heat]) {
          if (dict[a.name]) {
            dict[a.name] = void 0;
          }
        }
      }
    });
    this.calcBaseValues();
  }
  alive() {
    for (const vital of this.sheet.attributes.filter((a) => a.vital)) {
      const label = (vital.abbrev || vital.name).toLowerCase();
      if (this.value(label) <= 0) {
        return false;
      }
    }
    return true;
  }
  attr(name) {
    return this.sheet.attributes.find((a) => {
      return a.name.toLowerCase() === name.toLowerCase() || (a.abbrev || "").toLowerCase() === name.toLowerCase();
    });
  }
  getAttrLabel(name) {
    const attr = this.attr(name);
    let retval = name;
    if (attr) {
      retval = attr.abbrev || attr.name;
    }
    return retval.toLowerCase();
  }
  mods(name, mode = "out") {
    return this.modifiers.filter((m) => (!name || m.attr.toLowerCase() === name.toLowerCase()) && (!mode || m.mode === mode));
  }
  addMod(mod2) {
    this.modifiers.push({
      attr: mod2.attr,
      mode: mod2.mode,
      turns: mod2.turns,
      f: typeof mod2.formula === "string" ? parser.parse(mod2.formula.toLowerCase()) : mod2.formula
    });
  }
  calcBaseValues() {
    const retval = {};
    for (const attr of this.sheet.attributes.filter((a) => !a.formula)) {
      const label = attr.abbrev || attr.name;
      let base = 0;
      if (this.base[label]) {
        base = this.base[label];
      } else {
        base = parseInt(attr.default) || 0;
      }
      if (attr.abbrev) {
        retval[attr.abbrev.toLowerCase()] = base;
      } else {
        retval[attr.name.toLowerCase()] = base;
      }
    }
    this.baseValues = retval;
    return retval;
  }
  baseValue(name) {
    const label = this.getAttrLabel(name);
    return this.baseValues[label] || 0;
  }
  value(name) {
    const attr = this.attr(name);
    let value = null;
    if (attr && attr.formula) {
      try {
        const formula = parser.parse(attr.formula.toLowerCase());
        const args = this.getFormulaArgs(formula);
        value = Math.floor(formula.evaluate(args)) + this.baseValue(name);
      } catch (ex) {
        value = 0;
      }
    } else {
      value = this.baseValue(name);
    }
    return this.modifyValue(name, "out", value);
  }
  modifyValue(name, mode, value) {
    let val = value;
    for (const mod2 of this.mods(name, mode)) {
      this.baseValues.$value = val;
      const delta = Math.floor(mod2.f.evaluate(this.getFormulaArgs(mod2.f)));
      if (mod2.f.variables().indexOf("$value") > -1) {
        val = delta;
      } else {
        val += delta;
      }
    }
    return val;
  }
  modify(name, delta) {
    if (delta !== 0) {
      let d = this.modifyValue(name, "in", Math.abs(delta));
      if (delta > 0) {
        d = Math.max(0, d);
      } else {
        d = -Math.max(0, d);
      }
      const attr = this.attr(name);
      const label = this.getAttrLabel(name);
      let value = (this.baseValues[label] || 0) + d;
      if (attr) {
        if (attr.min || attr.min === 0) {
          value = Math.max(attr.min, value);
        }
        if (attr.max || attr.max === 0) {
          value = Math.min(attr.max, value);
        }
      }
      this.baseValues[label] = value;
      return d;
    }
    return 0;
  }
  setValue(name, value) {
    const attr = this.attr(name);
    if (attr) {
      const label = this.getAttrLabel(name);
      if (attr.min || attr.min === 0) {
        value = Math.max(attr.min, value);
      }
      if (attr.max || attr.max === 0) {
        value = Math.min(attr.max, value);
      }
      this.baseValues[label] = value;
      return value;
    }
  }
  setValues(values) {
    for (const key in values) {
      if (!/\$/.test(key)) {
        this.setValue(key, values[key]);
      }
    }
  }
  getFormulaArgs(f) {
    const args = {};
    for (const v of f.variables()) {
      if (/^\$rand(\d+)/.test(v)) {
        const match = /^\$rand(\d+)/.exec(v);
        args[v] = Math.floor(Math.random() * (parseInt(match[1], 10) + 1));
      } else {
        args[v] = this.value(this.getAttrLabel(v));
      }
    }
    return args;
  }
  canPerform(name, targets = null, world = null) {
    const action = this.sheet.actions.find((a) => a.name === name);
    if (!action) {
      return { possible: false, reason: "Action unavailable" };
    }
    if (this.sheet.actions.filter((a) => a.name === name).length > 1) {
      return { possible: false, reason: `Writer didn't make action names unique` };
    }
    if (!action.effectAttr) {
      return { possible: false, reason: `Writer didn't set "Effect Attribute"` };
    }
    if (!action.effectFormula) {
      return { possible: false, reason: `Writer didn't set "Effect Formula"` };
    }
    if (action.cost && action.costAttr) {
      const cost = this.modifyValue(action.costAttr, "in", action.cost);
      if (cost > this.value(action.costAttr)) {
        return { possible: false, reason: `requires ${cost} ${action.costAttr}` };
      }
    }
    if (action.cooldown) {
      if (this.heat[action.name]) {
        return { possible: false, reason: `cooldown for ${this.heat[action.name]} turns` };
      }
    }
    return { possible: true };
  }
  perform(name, targets) {
    const action = this.sheet.actions.find((a) => a.name === name);
    if (action.cost && action.costAttr) {
      this.modify(action.costAttr, -action.cost);
    }
    if (action.cooldown) {
      this.heat[action.name] += parseFloat(action.cooldown);
    }
    const test2 = this.actionFormulas[name];
    const args = test2 && this.getFormulaArgs(test2);
    const success = test2 && test2.evaluate(args);
    if (test2 === null || typeof success === "boolean" && success === true || success > 0) {
      const attrLabel = this.getAttrLabel(action.effectAttr);
      const modifiers = {};
      for (const target of targets) {
        const f = this.effectFormulas[name];
        const before = target.value(attrLabel);
        if (action.effect === "bless" || action.effect === "poison") {
          const modifier = {
            attr: attrLabel,
            mode: "round",
            formula: f,
            before,
            turns: action.effectTurns,
            name: target.sheet.name
          };
          target.addMod(modifier);
          const after = target.value(attrLabel);
          modifier.effectiveAmount = after - before;
          modifiers[target.id] = modifier;
        } else if (action.effect === "debuff" || action.effect === "buff") {
          const modifier = {
            attr: attrLabel,
            mode: "out",
            formula: f,
            before,
            turns: action.effectTurns,
            name: target.sheet.name
          };
          target.addMod(modifier);
          const after = target.value(attrLabel);
          modifier.effectiveAmount = after - before;
          modifiers[target.id] = modifier;
        } else {
          let q = 1;
          try {
            const eArgs = this.getFormulaArgs(f);
            q = Math.floor(f.evaluate(eArgs));
          } catch (ex) {
            console.error("evaluate error", ex, f, args);
            q = 0;
          }
          const amount = target.modify(attrLabel, q);
          const after = target.value(attrLabel);
          modifiers[target.id] = {
            attr: attrLabel,
            amount,
            before,
            after,
            effectiveAmount: after - before,
            name: target.sheet.name
          };
        }
      }
      return { success: true, modifiers };
    }
    return { success: false };
  }
  cooldown() {
    const mods = this.modifiers.filter((m) => ["round"].indexOf(m.mode) > -1);
    for (const mod2 of mods) {
      const v = Math.floor(mod2.f.evaluate(this.baseValues));
      this.modify(mod2.attr, v);
    }
    for (const mod2 of this.modifiers.filter((m) => m.turns > 0)) {
      mod2.turns -= 1;
    }
    for (const action in this.heat) {
      if (this.heat[action] > 0) {
        this.heat[action] -= 1;
      }
    }
    this.modifiers = this.modifiers.filter(
      (m) => m.turns === void 0 || m.turns === null || m.turns > 0
    );
  }
  initiative() {
    return Math.floor(this.initiativeFormula.evaluate(
      this.getFormulaArgs(this.initiativeFormula)
      //, this.baseValues),
    ));
  }
  setInitiative(formula = null) {
    this.initiativeFormula = parser.parse((formula || this.sheet.initiative || "1").toLowerCase());
  }
  toObject() {
    const retval = { name: this.sheet.name };
    for (const attr of this.sheet.attributes) {
      const label = this.getAttrLabel(attr.name);
      retval[label] = this.value(label);
    }
    return retval;
  }
  toString() {
    return "$internal";
  }
}
debug("read");
class Directive {
  constructor(reader, data) {
    this.reader = reader;
    this.data = copy$2(data);
  }
  movePlayersToGroup(players, split) {
    const groups = /* @__PURE__ */ new Set();
    const tags = copy$2(this.reader.tags);
    players.forEach((player) => {
      tags.$player = player;
      let groupname = runFormula(this.reader.story, split, tags);
      if (groupname === void 0) {
        groupname = split;
      }
      const group = this.reader.players.getPartyIdByName(groupname);
      player.party = group;
      groups.add(group);
    });
    Array.from(groups).forEach((group, index2) => {
      this.reader.players.getParty(group).savepoint = {
        microcosms: copy$2(this.reader.microcosms),
        choices: [],
        scene: this.reader.scene.id,
        idx: this.reader.directionIndex
      };
      if (index2 === 0) {
        this.reader.activateParty(groups[0]);
      }
    });
    this.reader.notify("players", this.reader.players.players);
    return groups;
  }
  splitGroups() {
    const currentParty = this.reader.players.partyId;
    let players = shuffle$1(
      this.reader.players.players.filter((p2) => p2.party === currentParty)
    );
    const switching = players.slice(0, this.data.playerCount || players.length);
    const groups = this.movePlayersToGroup(switching, this.data.split);
    if (players.filter((p2) => p2.party === currentParty).length > 0) {
      this.reader.activateParty(currentParty);
      this.reader.recordChoice(this.data);
      this.reader.proceed();
    }
    Array.from(groups).forEach((group, index2) => {
      this.reader.activateParty(group);
      this.reader.recordChoice(this.data);
      if (this.data.scene) {
        this.reader.changeScene(this.data.scene);
        this.reader.players.getParty(group).savepoint = {
          choices: [],
          microcosms: copy$2(this.reader.microcosms),
          scene: this.reader.scene.id,
          idx: this.reader.directionIndex
        };
      } else {
        this.reader.proceed();
      }
    });
  }
  fetchArray(name) {
    let tag = this.reader.story.tags.find((t) => t.id === name);
    if (/^\$players/.test(name)) {
      tag = { name: "$players", type: "array", referencing: "$player" };
    }
    if (tag && tag.type === "array") {
      return {
        tag,
        array: this.reader.tags[name] || []
      };
    }
    return {
      tag,
      array: []
    };
  }
  generateArrayText(array, text, each) {
    const texts = {};
    const tags = copy$2(this.reader.tags);
    for (const item of array) {
      tags.$item = item.data;
      const result = insertTags(text, this.reader.story, tags);
      if (each) {
        each(item, result);
      }
      texts[item.id] = result;
    }
    return texts;
  }
  adjustArrayEffects(prefix, array, effects2, each) {
    array.forEach((item, index2) => {
      const replacement = copy$2(effects2);
      replacement.forEach((effect) => {
        let tag = `${prefix}.${item.id}`;
        if (effect.op === "<t>" || effect.op === "<f>") {
          tag = `${prefix}[${index2}]`;
        }
        if (effect.tag) {
          effect.tag = effect.tag.replace(/\$item/gi, tag);
        }
        if (typeof effect.value === "string") {
          effect.value = effect.value.replace(/\$item/gi, tag);
        }
        if (typeof effect.other === "string") {
          effect.other = effect.other.replace(/\$item/gi, tag);
        }
      });
      each(item, replacement);
    });
  }
  /** read this directive and return true if it redirects to another scene */
  apply() {
  }
  startsBlock() {
    return false;
  }
  endsBlock() {
    return false;
  }
  allowStacking() {
    return false;
  }
  willRedirect() {
    return false;
  }
  shouldRecordEffects() {
    return true;
  }
  get stackingType() {
    return this.data.type;
  }
}
class TextDirective extends Directive {
  apply() {
    this.reader.changeText(this.data);
  }
  startsBlock() {
    return !this.data.auto_advance;
  }
  // endsBlock() { return !this.data.auto_advance; }
  allowStacking() {
    return this.data.auto_advance;
  }
}
class ImageDirective extends Directive {
  apply() {
    this.reader.setImage(this.data);
  }
  // startsBlock() { return true; }
  startsBlock() {
    return !this.data.auto_advance;
  }
  allowStacking() {
    return this.data.auto_advance;
  }
}
class SceneChangingDirective extends Directive {
  applyMicrocosm() {
    const microcosm = this.data.microcosm;
    const scene = this.reader.story.scenes.filter((a) => a).find((s) => s.id === this.data.scene);
    if (microcosm || scene && scene.microcosm) {
      this.reader.microcosms.push({
        scene: this.reader.scene.id,
        idx: this.reader.directionIndex
      });
    }
  }
  waitForAll() {
    if (this.data.waitFor) {
      const firename = `join-${this.reader.scene.id}-${this.data.id}`;
      const partyIds = this.data.waitFor.map(
        (a) => this.reader.players.getPartyIdByName(a)
      ).filter(
        (a) => this.reader.players.players.filter((p2) => p2.party === a).length > 0
      );
      if (partyIds.length > 1) {
        const fire = Campfire.register(firename, partyIds);
        const retval = fire.arrival(this.reader.players.partyId);
        this.reader.notify("waiting", {
          scene: this.reader.scene.id,
          direction: this.data.id,
          needs: fire.needs,
          has: Array.from(fire.arrived)
        });
        if (retval) {
          const players = this.reader.players.players.filter((p2) => partyIds.indexOf(p2.party) > -1);
          this.movePlayersToGroup(players, this.data.split);
          return false;
        }
      }
      return true;
    }
  }
  // willRedirect() { return true; }
  willRedirect() {
    return this.data.scene;
  }
}
class ChoiceDirective extends SceneChangingDirective {
  apply() {
    return this.applyChoice();
  }
  applyChoice() {
    if (this.data.array) {
      const { tag, array } = this.fetchArray(this.data.array);
      if (array) {
        this.generateArrayText(array, this.data.label, (item, text) => {
          const choice2 = copy$2(this.data);
          choice2.type = "choice";
          choice2.id = item.id;
          choice2.label = text;
          this.reader.addChoice(choice2);
        });
      } else {
        const choice2 = {
          id: -1,
          label: "Sorry, the author had a vote setup here, but there are no options to choose"
        };
        console.log("adding broken choice", choice2);
        this.reader.addChoice(choice2);
      }
    } else {
      const choice2 = copy$2(this.data);
      choice2.label = insertTags(this.data.label, this.reader.story, this.reader.tags);
      if (choice2.thoughts) {
        for (let x = 0; x < choice2.thoughts.length; x++) {
          choice2.thoughts[x] = insertTags(
            choice2.thoughts[x],
            this.reader.story,
            this.reader.tags
          );
        }
      }
      this.reader.addChoice(choice2);
    }
  }
  endsBlock() {
    return true;
  }
  allowStacking() {
    return true;
  }
  shouldRecordEffects() {
    return false;
  }
}
class RedirectDirective extends SceneChangingDirective {
  apply() {
    if (this.data.scene) {
      this.applyMicrocosm();
    }
    if (this.data.split) {
      this.splitGroups();
      return true;
    } else if (this.data.scene) {
      this.reader.recordChoice(this.data);
      this.reader.changeScene(this.data.scene);
      return true;
    }
  }
}
class InputDirective extends Directive {
  apply() {
    const data = copy$2(this.data);
    const { array } = this.fetchArray(data.content);
    if (data.attr && array) {
      data.array = [];
      this.generateArrayText(array, data.label, (item, text) => {
        data.array.push({
          id: item.id,
          start: item[data.attr] || 0,
          label: text
        });
      });
      if (typeof data.points === "string") {
        data.points = runFormula(this.reader.story, data.points, this.reader.tags);
      }
    } else if (data.label) {
      data.label = insertTags(data.label, this.reader.story, this.reader.tags);
    }
    this.reader.notify("input", data);
  }
  startsBlock() {
    return !!this.data.label;
  }
  endsBlock() {
    return true;
  }
}
class PauseDirective extends Directive {
  apply() {
    this.reader.startPause(this.data.ms);
  }
  endsBlock() {
    return true;
  }
  get stackingType() {
    return "choice";
  }
}
class TimerDirective extends Directive {
  apply() {
    this.reader.startTimer(this.data.seconds * 1e3, this.data.scene);
  }
  endsBlock() {
    return true;
  }
  allowStacking() {
    return true;
  }
  get stackingType() {
    return "choice";
  }
}
class SetDirective extends Directive {
  apply() {
    if (this.data.type === "background") {
      this.reader.changeBackground(this.data);
    } else if (this.data.type === "audio") {
      this.reader.changeClip(this.data);
    } else if (this.data.type === "music") {
      this.reader.changeMusic(this.data);
    } else if (this.data.type === "lighting") {
      this.reader.changeLighting(this.data.light);
    } else if (this.data.type === "video") {
      this.reader.changeVideo(this.data);
    }
  }
}
class EmptyDirective extends Directive {
  apply() {
    if (this.data.array) {
      const { tag, array } = this.fetchArray(this.data.array);
      this.adjustArrayEffects(this.data.array, array, this.data.effects, (item, effects2) => {
        if (shouldShowDirection(this.reader.story, { effects: effects2 }, this.reader.tags)) {
          this.reader.recordChoice({ effects: effects2 });
        }
      });
    }
    if (this.data.split) {
      this.splitGroups();
      return true;
    }
  }
}
class ReturnDirective extends Directive {
  apply() {
    if (this.reader.microcosms.length > 0) {
      this.reader.finish();
      return true;
    } else {
      const choices = this.reader.player.choices.slice(0);
      choices.reverse();
      for (const mod2 of choices) {
        if (mod2.scene && mod2.from && mod2.type !== "return") {
          this.reader.changeScene(mod2.from.scene, mod2.from.idx);
          return true;
        }
      }
    }
  }
  willRedirect() {
    return true;
  }
  // needs Break() { return true; }
}
class ContestantDirective extends Directive {
  apply() {
    this.reader.notify("contestants", this.data);
  }
}
class BattleDirective extends Directive {
  apply() {
    this.reader.notify("battle", this.data);
  }
  startsBlock() {
    return true;
  }
}
class GroupDirective extends Directive {
  findDirection() {
    let options = [];
    let directionType = null;
    let index2 = this.reader.scene.directions.findIndex((d) => d.id === this.data.id) + 1;
    for (; index2 < this.reader.scene.directions.length; index2 += 1) {
      const direction = this.reader.scene.directions[index2];
      if (direction.type === "group" || directionType != null && direction.type !== directionType) {
        break;
      }
      directionType = direction.type;
      if (shouldShowDirection(this.reader.story, direction, this.reader.tags)) {
        options.push(direction);
      }
    }
    if (options.filter((o) => o.weight === -1).length !== options.length) {
      options = options.filter((o) => o.weight !== -1);
    }
    const total = options.reduce((a, b) => a + (b.weight === void 0 ? 1 : parseInt(b.weight, 10)), 0);
    const lots = new Array(total);
    let idx = 0;
    for (const option of options) {
      let num = parseInt(option.weight === void 0 ? 1 : option.weight);
      if (num > 0) {
        lots.fill(option.id, idx, idx + num);
        idx += num;
      }
    }
    const lotIndex = Math.random() * lots.length;
    const lotId = lots[Math.floor(lotIndex)];
    const next = options.find((o) => o.id === lotId);
    return { data: next, index: index2 - 1 };
  }
  get direction() {
    if (this._direction === void 0) {
      const { data, index: index2 } = this.findDirection();
      if (data) {
        this._direction = new directives[data.type](this.reader, data);
        this._index = index2;
      }
    }
    return this._direction;
  }
  apply() {
    if (this.direction) {
      this.reader.directionIndex = this._index;
      return this.direction.apply();
    }
  }
  startsBlock() {
    if (this.direction) {
      return this.direction.startsBlock();
    }
    return false;
  }
  endsBlock() {
    if (this.direction) {
      return this.direction.endsBlock();
    }
    return false;
  }
  allowStacking() {
    if (this.direction) {
      return this.direction.allowStacking();
    }
    return false;
  }
  willRedirect() {
    if (this.direction) {
      return this.direction.willRedirect();
    }
    return false;
  }
  get stackingType() {
    if (this.direction) {
      return this.direction.stackingType;
    }
    return "group";
  }
}
class AchievementDirective extends Directive {
  apply() {
    this.reader.notify("achievement", this.data);
  }
  startsBlock() {
    return this.data.silent !== true;
  }
}
class EventDirective extends Directive {
  apply() {
    this.reader.notify("event", this.data);
    this.reader.lockUntilEvent(this.data.name);
  }
  startsBlock() {
    return this.data.silent !== true;
  }
}
class OptionDirective extends Directive {
  apply() {
    const data = copy$2(this.data);
    data.label = insertTags(data.label, this.reader.story, this.reader.tags);
    data.content = insertTags(
      data.content,
      this.reader.story,
      this.reader.tags
    );
    this.reader.notify("option", data);
  }
  startsBlock() {
    return false;
  }
  endsBlock() {
    return true;
  }
  allowStacking() {
    return true;
  }
  shouldRecordEffects() {
    return false;
  }
}
class VideoDirective extends SetDirective {
  startsBlock() {
    return true;
  }
  endsBlock() {
    return true;
  }
  allowStacking() {
    return false;
  }
  shouldRecordEffects() {
    return false;
  }
}
class LayoutDirective extends Directive {
  apply() {
    this.reader.notify("settings", this.data);
  }
}
class ClearDirective extends Directive {
  apply() {
    this.reader.notify("settings", { execute: "clear" });
  }
}
var directives = {
  "choice-timer": TimerDirective,
  achievement: AchievementDirective,
  audio: SetDirective,
  background: SetDirective,
  battle: BattleDirective,
  clear: ClearDirective,
  choice: ChoiceDirective,
  contestant: ContestantDirective,
  empty: EmptyDirective,
  event: EventDirective,
  group: GroupDirective,
  image: ImageDirective,
  input: InputDirective,
  lighting: SetDirective,
  music: SetDirective,
  notes: EmptyDirective,
  option: OptionDirective,
  pause: PauseDirective,
  redirect: RedirectDirective,
  return: ReturnDirective,
  text: TextDirective,
  video: VideoDirective,
  layout: LayoutDirective
};
class PlayerManager {
  constructor(settings) {
    this.clear();
    this.settings = settings;
    this.waiting = {};
  }
  get length() {
    return this.players.length;
  }
  get party() {
    const retval = this.parties.find((p2) => p2.id === this.partyId);
    if (retval) {
      return retval;
    }
    return { id: -1 };
  }
  get partyCount() {
    return this.parties.length;
  }
  get choices() {
    return this.party.picks;
  }
  clear() {
    this.players = [];
    this.partyId = 0;
    this.parties = [{ id: 0, name: "main", picks: [], savepoint: null }];
    this.min = {};
    this.max = {};
  }
  partySize(playerId) {
    const player = this.player(playerId);
    return this.players.filter((p2) => p2.party === player.party).length;
  }
  player(id) {
    return this.players.find((p2) => p2.id === id);
  }
  getParty(id) {
    return this.parties.find((p2) => p2.id === id);
  }
  getPartyIdByName(name) {
    let party = this.parties.find((p2) => p2.name === name);
    if (!party) {
      party = {
        id: this.parties.reduce((a, b) => Math.max(a, b.id) + 1, 0),
        name,
        picks: [],
        savepoint: null
      };
      this.parties.push(party);
    }
    return party.id;
  }
  isMultiplayer() {
    return this.players.length > 1;
  }
  isInParty(playerId) {
    const player = this.players.find((p2) => p2.id === playerId);
    if (player) {
      return player.party === this.partyId;
    }
    return false;
  }
  add(id, name, main = false, partyName = "main") {
    this.players.push({
      id,
      name,
      username: name,
      main,
      party: this.getPartyIdByName(partyName)
    });
  }
  closeParty(party = null) {
    if (!party) {
      party = this.party;
    }
    if (party) {
      party.savepoint = null;
    }
    const idx = this.parties.findIndex((p2) => p2.id === this.party.id);
    if (idx > -1) {
      this.parties.splice(idx, 1);
    }
  }
  nextParty(savepoint) {
    this.party.savepoint = savepoint;
    this.partyId = (this.partyId + 1) % this.parties.length;
    if (this.party) {
      return this.party.savepoint;
    }
    return null;
  }
  waitFor(party) {
    this.choices.push({ party });
  }
  minPicks(choiceId, min2) {
    this.min[choiceId] = min2;
  }
  maxPicks(choiceId, max2) {
    this.max[choiceId] = max2;
  }
  choice(id, playerId, party = null, opts = {}, evaluate2 = true) {
    const previous = this.choices.find((c) => c.playerId === playerId);
    if (previous) {
      previous.id = id;
      previous.switch = party;
      previous.opts = opts;
    } else {
      const player = this.players.find((p2) => p2.id === playerId);
      this.party.picks.push({
        playerId,
        id,
        party: player.party,
        switch: party,
        opts
      });
    }
    if (evaluate2) {
      return this.evaluateChoices();
    }
  }
  evaluateChoices(force = false) {
    const choices = this.choices.filter((c) => c.id || c.id === 0);
    const tally = {};
    for (const choice2 of choices) {
      if (!tally[choice2.id]) {
        tally[choice2.id] = {
          count: 0,
          min: choice2.opts.min,
          max: choice2.opts.max,
          party: choice2.switch || choice2.switch === 0 ? choice2.switch : choice2.party
        };
      }
      tally[choice2.id].count += 1;
    }
    if (!force) {
      const counts = {};
      for (const group of this.choices.filter((c) => !c.id && c.id !== 0)) {
        if (group.party !== this.partyId) {
          const party = this.getParty(group.party);
          for (const pick2 of party.picks.filter((p2) => p2.id || p2.id === 0)) {
            choices.push(pick2);
          }
        }
      }
      for (const pick2 of choices) {
        counts[pick2.party] = (counts[pick2.party] || 0) + (pick2.weight || 1);
      }
      const parties = new Set(this.choices.map((p2) => p2.party));
      for (const partyId of parties) {
        const players = this.players.filter((p2) => p2.party === partyId);
        if (counts[partyId] !== players.length) {
          return false;
        }
      }
      for (const cid in tally) {
        if (tally[cid].min && tally[cid].count < tally[cid].min) {
          return false;
        }
        if (tally[cid].max && tally[cid].count > tally[cid].max) {
          return false;
        }
      }
    }
    const groups = [];
    for (const pick2 of choices) {
      const party = pick2.party;
      let item = groups.find((i) => i.partyId === party);
      if (!item) {
        item = { partyId: party, choices: [], players: [], tally: [] };
        groups.push(item);
      }
      item.choices.push(pick2.id);
      if (!item.tally.find((row) => row.id === pick2.id)) {
        item.tally.push({ id: pick2.id, count: tally[pick2.id].count });
      }
      item.players.push(pick2.playerId);
    }
    for (const group of groups) {
      group.tally.sort(sortby("-count"));
      const idx = Math.floor(Math.random() * group.choices.length);
      const choiceId = group.choices[idx];
      const choice2 = choices.find((c) => c.id === choiceId);
      group.choice = choice2;
    }
    this.party.picks = [];
    return groups.length > 0 ? groups : false;
  }
  splitParty(partyId, players) {
    this.parties.find((p2) => p2.id === partyId);
    for (const player of this.players.filter((p2) => players.indexOf(p2.id) > -1)) {
      player.party = partyId;
    }
  }
  clearChoices() {
    this.choices.length = 0;
    this.min = {};
    this.max = {};
  }
}
const log$1 = debug("read");
class Reader {
  constructor(story2, player, settings, listener) {
    this.timer = null;
    this.mptimers = {};
    this.story = copy$2(story2);
    if (!this.story.tags) {
      this.story.tags = [];
    }
    if (!this.story.blueprints) {
      this.story.blueprints = [];
    }
    this.storyObject = new Story(copy$2(this.story));
    this.story.allTypes = this.storyObject.allTypes;
    this.story.allTags = this.storyObject.allTags;
    this.settings = settings || {};
    this.waitingGroups = /* @__PURE__ */ new Set();
    this.waitingFor = {};
    this.players = new PlayerManager(settings);
    this.player = player || {
      tags: {},
      choices: [],
      microcosms: [],
      bookmark: null
    };
    this.eventLock = false;
    this.processing = [];
    this.listeners = [];
    if (listener) {
      this.listeners.push(listener);
    }
    this.directives = directives;
    this.init();
  }
  init() {
    this.scene = null;
    this.directionIndex = -1;
    this.direction = null;
    this.finished = false;
    this.characters = [];
    this.tags = {};
    this.story.tags.filter((t) => t.default).forEach((tag) => {
      if (tag.default) {
        if (tag.type === "tag" && (tag.format === "numeric" || !tag.format)) {
          this.tags[tag.id] = parseFloat(tag.default);
        } else {
          this.tags[tag.id] = tag.default;
        }
      }
    });
    this.afterPause = null;
    this.text = "";
    this.image = null;
    this.block = { directions: [], startType: null, endType: null };
    this.currentBlock = [];
    this.choices = [];
    this.microcosms = [];
    this.characterImage = null;
    this.characterAura = null;
    this.background = null;
    this.music = null;
    this.clip = null;
    if (!this.player.choices) {
      this.player.choices = [];
    }
    if (document._taglistener) {
      document.removeEventListener("tag", document._taglistener);
    }
    const taglistener = (e2) => {
      const tag = this.story.tags.find((t) => t.name === e2.detail.name);
      if (tag) {
        const value = e2.detail.value;
        if (tag.format === "text") {
          this.tags[tag.id] = `${value}`;
        } else {
          this.tags[tag.id] = value;
        }
      }
    };
    document._taglistener = taglistener;
    document.addEventListener("tag", taglistener);
  }
  reset() {
    this.init();
    this.player.choices = [];
  }
  getStartScene() {
    let scene = this.story.scenes.find((s) => s && s.start);
    if (!scene && this.story.scenes.length > 0) {
      scene = this.story.scenes[0];
    }
    if (!scene) {
      scene = {
        id: 1,
        directions: [{ id: 1, type: "text", content: "Hello! You need to set a start scene" }]
      };
    }
    return scene;
  }
  async start() {
    const choices = this.player.choices.filter((c) => c.scene);
    this.tags = copy$2(this.player.session || this.player.tags || {});
    this.initializeTags();
    if (choices.length === 0) {
      this.scene = this.getStartScene();
      this.notify("scene", this.scene.id);
      if (this.scene.act && this.scene.directions.filter((d) => d.type === "choice").length === this.scene.directions.length) {
        this.randomizedDirection(this.scene);
      } else {
        await this.proceed();
      }
    } else {
      const count = choices.length;
      const lastChoice = choices[count - 1];
      const index2 = this.player.choices.indexOf(lastChoice);
      this.player.choices = this.player.choices.slice(0, index2 + 1);
      if (this.player.microcosms) {
        this.microcosms = copy$2(this.player.microcosms);
      }
      this.changeScene(lastChoice.scene, lastChoice.idx === void 0 ? -1 : lastChoice.idx);
    }
  }
  process(lambda) {
    this.processing.push(lambda);
    if (!this._isProcessing) {
      this._isProcessing = true;
      while (this.processing.length > 0) {
        this.processing.shift()();
      }
      this._isProcessing = false;
    }
  }
  async next(playerId = null) {
    if (this.eventLock) {
      log$1("cannot proceed, eventlocked", this.eventLock);
      return;
    }
    let cont = true;
    if (playerId !== null && this.players.isMultiplayer()) {
      this.activatePartyByPlayer(playerId);
      this.notify("player-pick", {
        id: true,
        playerId,
        scene: this.scene.id,
        direction: this.direction.id
      });
      cont = !!await this.waitForParties([this.players.partyId], playerId);
    }
    if (cont) {
      log$1(` *> next [${playerId}]`);
      return this.proceed();
    }
  }
  async choice(id, playerId = null) {
    clearTimeout(this.timer);
    let cont = true;
    if (this.players.isMultiplayer()) {
      this.activatePartyByPlayer(playerId);
      if (this.choices.length === 0) {
        log$1(" ?? choice, but not choices", playerId, id, this.choices, this.players.party);
        return -1;
      } else {
        log$1(" *> choice", playerId, id);
      }
      this.notify("player-pick", {
        id,
        playerId,
        scene: this.scene.id,
        direction: this.direction.id
      });
      let waitFor = [this.players.partyId];
      if (this.direction.waitFor) {
        waitFor = this.direction.waitFor.map((p2) => this.players.getPartyIdByName(p2));
      }
      const votes = await this.waitForParties(waitFor, playerId, id);
      cont = false;
      if (votes) {
        if (this.direction.type === "vote") {
          let array = null;
          const tag = this.story.tags.find((t) => t.name === this.direction.array);
          if (!tag) {
            console.error(" >> tag", tag);
          } else if (this.tags[tag.id]) {
            array = this.tags[tag.id];
          }
          Object.keys(votes).forEach((party) => {
            votes[party].slice(0, this.direction.count || 1).forEach((vote) => {
              const item = array.find((i) => i.id === vote);
              if (item) {
                item[this.direction.attr] += 1;
              }
            });
          });
          const effects2 = [
            {
              tag: `${this.direction.array}`,
              op: "r",
              // TODO: reset votes
              value: copy$2(array)
            }
          ];
          this.recordChoice({ effects: effects2 });
          this.proceed();
        } else {
          const tags = copy$2(this.tags);
          const playerVotes = [];
          const splits = {};
          for (const player in votes) {
            const vote = votes[player];
            const choice2 = this.choices.find((c) => c.id === vote);
            if (choice2) {
              let partyId = null;
              if (choice2.split) {
                tags.$player = tags.$players.find((p2) => p2.id === player);
                let groupname = null;
                groupname = runFormula(this.story, choice2.split, tags);
                if (!groupname) {
                  groupname = choice2.split;
                }
                if (groupname) {
                  partyId = this.players.getPartyIdByName(groupname);
                }
              } else {
                partyId = this.players.players.find((p2) => p2.id === player).party;
              }
              if (!splits[partyId]) {
                splits[partyId] = {
                  choice: choice2,
                  players: [],
                  effects: []
                };
              }
              splits[partyId].players.push(player);
              if (choice2.effects) {
                splits[partyId].effects = splits[partyId].effects.concat(
                  generateEffectsWithSubstitutions(
                    choice2.effects,
                    player,
                    `${this.direction.array}.${choice2.id}`
                  )
                );
              }
            }
          }
          id = [];
          if (playerVotes.length > 0) {
            const idIndex = Math.floor(Math.random() * playerVotes.length);
            const nextId = playerVotes[idIndex].vote;
            id.push({
              partyId: parseInt(this.players.partyId),
              choice: this.choices.find((c) => c.id === nextId),
              players: playerVotes.map((v) => v.player)
            });
          }
          if (Object.keys(splits).length > 0) {
            for (const partyId in splits) {
              id.push({
                partyId: parseInt(partyId),
                choice: splits[partyId].choice,
                players: splits[partyId].players,
                effects: splits[partyId].effects
              });
            }
          }
          log$1("  > id", id);
          cont = true;
          log$1(` u> choice: [${id}] [${cont}] [${playerId}]`);
        }
      }
    }
    if (cont) {
      this.readChoice(id);
    }
  }
  async options(value, playerId = null) {
    log$1(` *> options "${value}" [${playerId}]`);
    this.activatePartyByPlayer(playerId);
    const values = await this.waitForParties([this.players.partyId], playerId, value);
    if (values) {
      const effects2 = [];
      for (const playerId2 in values) {
        for (const choice2 in values[playerId2]) {
          const value2 = values[playerId2][choice2];
          const direction = this.currentBlock.find((d) => d.data.id == choice2);
          if (direction) {
            for (const effect of direction.data.effects || []) {
              const neffect = copy$2(effect);
              if (/\$value\b/.test(neffect.value)) {
                neffect.value = neffect.value.replace(/\$value\b/g, value2);
              }
              effects2.push(neffect);
            }
          }
        }
      }
      if (effects2.length > 0) {
        this.recordChoice({ effects: effects2 });
      }
      this.proceed();
    }
  }
  async input(value, playerId = null) {
    log$1(` *> input "${value}" [${playerId}]`);
    this.activatePartyByPlayer(playerId);
    const values = await this.waitForParties([this.players.partyId], playerId, value);
    if (values) {
      let points = null;
      if (this.direction.points) {
        points = StoryTag.formula(this.story, this.tags, `${this.direction.points}`);
      }
      const effects2 = [];
      for (const player in values) {
        let pp = points;
        let tag = this.direction.content;
        if (/^\$player/.test(this.direction.content)) {
          tag = tag.replace("$player", "$" + player);
        }
        if (values[player] instanceof Object) {
          for (const key in values[player]) {
            let value2 = values[player][key];
            const reference = `${tag}.${key}.${this.direction.attr}`;
            const inst = StoryTag.generate(this.story, this.tags, reference);
            if (inst) {
              if (pp !== null) {
                const start = inst[this.direction.attr];
                const delta = value2 - start;
                if (delta >= pp) {
                  value2 = start + pp;
                  pp = 0;
                } else {
                  pp -= delta;
                }
              }
              if (pp === null || value2 !== 0) {
                effects2.push({
                  tag: reference,
                  op: this.direction.op || ":",
                  value: value2
                });
              }
            }
          }
        } else {
          effects2.push({ tag, op: ":", value: values[player] });
        }
      }
      this.recordChoice({ effects: effects2 });
      return this.next();
    } else {
      return false;
    }
  }
  async proceed() {
    if (this.choices.length === 0 && Date.now() < this.afterPause) {
      return false;
    }
    if (!this.scene) {
      this.start();
    }
    if (this.scene) {
      const directive = this.getNextDirective(this.directionIndex + 1);
      if (directive) {
        this.directionIndex = directive.index;
        this.direction = directive.data;
        let sub2 = directive;
        if (this.direction.type === "group") {
          sub2 = directive.direction;
        }
        if (sub2 && directive.shouldRecordEffects() && !directive.willRedirect() && directionWillModify(sub2.data) && !sub2.data.array) {
          this.recordChoice(sub2.data);
        }
        if (this.block.directions.length === 0) {
          this.notify("block-start");
        }
        const redirected = directive.apply(this);
        if (!redirected) {
          this.block.directions.push(directive);
          if (directive.startsBlock()) {
            this.block.startType = directive.stackingType;
          }
          if (directive.endsBlock()) {
            this.block.startType = this.block.startType || directive.stackingType;
            this.block.endType = directive.stackingType;
          }
          const nextDirective = this.getNextDirective(this.directionIndex + 1);
          let isEmpty2 = !this.block.startType && !this.block.endType;
          let canStartBlock = false;
          let canEndBlock = false;
          if (nextDirective) {
            const startsBlock = nextDirective.startsBlock();
            canStartBlock = startsBlock && // ...this block hasn't started
            (!this.block.startType || // ...or fits in the current stack
            nextDirective.allowStacking() && this.block.startType === nextDirective.stackingType);
            canEndBlock = !startsBlock && this.block.startType && nextDirective.endsBlock() && // ... this block hasn't ended
            (!this.block.endType || // ...or fits in the current stack
            directive.allowStacking() && this.block.endType === nextDirective.stackingType);
          }
          if (!this.block.startType && this.choices.length === 0 && !nextDirective) {
            this.endThread();
          } else if (nextDirective && (isEmpty2 || canStartBlock || canEndBlock)) {
            return this.proceed();
          } else {
            this.endBlock();
            this.placeSavepoint();
          }
        }
      } else {
        this.endThread();
      }
    }
    return true;
  }
  fastForwardThroughGroup(index2) {
    let groupType = null;
    while (index2 < this.scene.directions.length) {
      index2 += 1;
      this.direction = this.scene.directions[index2];
      if (groupType === null) {
        groupType = this.direction.type;
      } else if (groupType != this.direction.type) {
        index2 -= 1;
        break;
      }
    }
    return index2;
  }
  placeSavepoint() {
    this.players.party.savepoint = {
      scene: this.scene.id,
      idx: this.directionIndex,
      microcosms: copy$2(this.microcosms),
      choices: copy$2(this.choices)
    };
  }
  endThread() {
    log$1(` ?> finish? (${this.scene.id}/${this.directionIndex})`, this.players.partyId);
    let finish = true;
    if (this.microcosms.length === 0 && this.players.isMultiplayer()) {
      if (this.players.party) {
        this.notify("completed", this.players.party.id);
        this.players.parties.slice().forEach((party) => {
          if (this.players.players.filter((p2) => p2.party === party.id).length === 0) {
            this.players.closeParty(party);
          }
        });
        this.players.closeParty();
        if (this.players.parties.length > 1) {
          finish = false;
        }
      }
    }
    if (finish) {
      this.finish();
    }
  }
  endBlock() {
    log$1(" <> block cleared");
    this.notify("block-clear");
    this.currentBlock = this.block.directions.slice();
    this.block.directions.length = 0;
    this.block.endType = null;
    this.block.startType = null;
  }
  finish() {
    if (this.microcosms.length > 0) {
      const microcosm = this.microcosms.pop();
      log$1(" ** popping microcosm");
      this.changeScene(microcosm.scene, microcosm.idx);
    } else {
      for (const partyId in this.mppromises) {
        if (this.mppromises[partyId]) {
          this.mppromises[partyId].resolve(false);
        }
      }
      log$1("finished!");
      this.notify("finished", true);
      this.finished = true;
    }
  }
  waitFor(id, needs) {
    if (!this.waitingFor[id]) {
      this.waitingFor[id] = { needs: /* @__PURE__ */ new Set(), has: /* @__PURE__ */ new Set() };
    }
    const node = this.waitingFor[id];
    needs.forEach((group) => node.needs.add(group));
    log$1(" ww waiting for:", Array.from(node.needs).join(", "));
    node.has.add(this.players.party.name);
    this.waitingGroups.add(this.players.party.id);
    log$1(" ww now has:", Array.from(node.has).join(", "));
    this.notify("waiting", {
      needs: Array.from(node.needs),
      has: Array.from(node.has)
    });
    const result = new Set([...node.needs].filter((x) => !node.has.has(x)));
    return result.size === 0;
  }
  readChoice(id) {
    if (this.players.isMultiplayer()) {
      for (const group of id) {
        const party = this.players.getParty(group.partyId);
        if (party) {
          log$1(" == saving party", group.partyId);
          party.savepoint = {
            microcosms: copy$2(this.microcosms),
            choices: copy$2(this.choices),
            scene: this.scene.id,
            idx: this.directionIndex
          };
          this.players.splitParty(group.partyId, group.players);
        } else {
          console.error("no party?", group, this.players.parties);
        }
      }
      this.notify("players", this.players.players);
      for (const group of id) {
        this.activateParty(group.partyId);
        if (group.choice.id) {
          this.continueChoice(group.choice.id, group.effects);
        } else {
          this.proceed();
        }
      }
    } else {
      this.continueChoice(id);
    }
  }
  continueChoice(id, effects2 = null) {
    this.players.clearChoices();
    this._lastChangeSceneCount = 0;
    const choice2 = copy$2(this.choices.find((d) => d.id === id));
    if (choice2) {
      log$1(" ** cleared choices");
      this.notify("pick", choice2);
      this.choices.length = 0;
      this.endBlock();
      if (effects2) {
        choice2.effects = effects2;
      } else if (choice2.array) {
        this.tags[choice2.array].find((item) => item.id === choice2.id);
        if (choice2.effects) {
          choice2.effects = generateEffectsWithSubstitutions(
            choice2.effects,
            null,
            `${choice2.array}.${choice2.id}`
          );
        }
      }
      if (choice2.scene) {
        this.recordChoice(choice2);
        this.applyMicrocosm(choice2.scene, choice2);
        this.changeScene(choice2.scene);
      } else {
        if (directionWillModify(choice2)) {
          this.recordChoice(choice2);
        }
        this.proceed();
      }
    } else {
      console.error(
        `invalid choice: ${id}`,
        this.choices,
        this.choices.map((c) => c.id)
      );
    }
  }
  waitForParties(parties, playerId, choice2 = true) {
    const players = this.players.players.filter((p2) => {
      return parties.indexOf(p2.party) > -1;
    }).map((p2) => p2.id);
    const fire = Campfire.register(
      `waiting-${this.scene.id}-${this.direction.id}`,
      players,
      this.settings.choiceTimer
    );
    const retval = fire.arrival(playerId, choice2);
    this.notify("waiting", {
      scene: this.scene.id,
      direction: this.direction.id,
      needs: fire.needs,
      has: Array.from(fire.arrived)
    });
    return retval;
  }
  lockUntilEvent(name) {
    this.players.clearChoices();
    this.choices.length = 0;
    log$1("waiting for", name);
    this.eventLock = name;
  }
  // TODO: wait for event?
  event(name) {
    log$1(" *> event", name);
    this.eventLock = false;
    this.next();
  }
  recordChoice(userChoice) {
    if (userChoice.effects) {
      for (const effect of userChoice.effects.filter((e2) => e2.tag && e2.op)) {
        applyEffect(this.story, effect, this.tags);
      }
      this.notify("tags", this.tags);
    }
    if (userChoice.scene) {
      this.player.choices.push({
        scene: userChoice.scene,
        idx: userChoice.idx,
        from: {
          scene: this.scene.id,
          idx: this.directionIndex
        }
      });
      this.player.choices = this.player.choices.slice(-15);
      this.player.session = copy$2(this.tags);
    }
    this.notify("player", this.player);
  }
  getNextDirective(idx) {
    let i = idx;
    while (i >= 0 && i < this.scene.directions.length) {
      const direction = this.scene.directions[i];
      if (shouldShowDirection(this.story, direction, this.tags)) {
        const directive = this.directives[direction.type] || this.directives.empty;
        const retval = new directive(this, direction);
        retval.index = i;
        return retval;
      } else {
        if (direction.type === "group") {
          i = this.fastForwardThroughGroup(i);
        }
      }
      i += 1;
    }
    return null;
  }
  initializeTags() {
    this.tags = {};
    if (this.player.session) {
      this.tags = copy$2(this.player.session);
    } else {
      this.tags = copy$2(this.player.tags || {});
      if (this.player.tags) {
        for (const key in copy$2(this.player.tags)) {
          this.tags[key] = this.player.tags[key];
        }
      }
      const playerType = this.story.allTypes.find((t) => t.id === "$player");
      let playerBlueprint = { id: "$player", name: "$player" };
      if ((this.story.settings || {}).playerBlueprint) {
        playerBlueprint = this.story.blueprints.find(
          (t) => t.id === this.story.settings.playerBlueprint
        );
      }
      let players = [{ id: "player", name: "player" }];
      if (this.players.isMultiplayer()) {
        players = this.players.players.map((p2) => {
          return new Blueprint(playerType, playerBlueprint, copy$2(p2));
        });
      } else {
        players = [new Blueprint(playerType, playerBlueprint, players[0])];
      }
      this.tags.$players = players;
      if (this.story.tags) {
        for (const tag of this.story.tags) {
          if (tag.type === "character" && this.story.characters) {
            const char2 = this.story.characters.find((char3) => char3.id === tag.character);
            if (char2) {
              if (!this.characters[tag.id]) {
                this.characters[tag.id] = new Character(char2);
              }
              if (this.tags[tag.id]) {
                this.characters[tag.id].setValues(this.tags[tag.id]);
              }
              this.tags[tag.id] = this.characters[tag.id].toObject();
            }
          } else if (tag.type === "tag" && tag.default) {
            if (tag.format !== "text") {
              this.tags[tag.id] = parseFloat(tag.default);
            } else {
              this.tags[tag.id] = tag.default;
            }
          } else if (tag.type === "ref") {
            if (tag.default) {
              const values = this.story.blueprints.find((b) => b.id === tag.default);
              const config = this.story.types.find((t) => t.id === values.meta);
              const instanceId = "__" + nanoid();
              this.tags[instanceId] = new Blueprint(config, values);
              this.tags[instanceId].data.iid = instanceId;
              this.tags[tag.id] = new Proxy(this.tags[instanceId], {});
            } else {
              this.tags[tag.id] = null;
            }
          } else if (tag.type === "array") {
            if (tag.referencing) {
              const array = [];
              const bps = (this.story.blueprints || []).filter((b) => b.meta === tag.referencing);
              const defaults = tag.default || [];
              const fill = tag.arrayFill === "all" ? bps.filter((b) => defaults.indexOf(b.id) === -1) : bps.filter((b) => defaults.indexOf(b.id) > -1);
              for (const values of fill) {
                const config = (this.story.types || []).find((t) => t.id === values.meta) || {};
                const instance2 = new Blueprint(config, values);
                array.push(instance2);
              }
              this.tags[tag.id] = array;
            } else {
              this.tags[tag.id] = null;
            }
          } else if (tag.default) {
            this.tags[tag.id] = tag.default;
          }
        }
      }
    }
    this.addTagsFromChoices();
    this.notify("tags", this.tags);
  }
  // CHANGEME
  addTagsFromChoices() {
    const choices = this.player.choices;
    choices.reduce((a, b, i) => b.tags ? i : a, -1);
    this._setupBlueprints(this.tags);
    if (this.players.isMultiplayer()) {
      this.tags.$players.forEach((player) => {
        const inst = this.players.players.find((p2) => p2.id === player.id);
        player.$meta.attrs.forEach((attr) => {
          if (player[attr.name] !== void 0 && inst[attr.name] !== player[attr.name]) {
            inst[attr.name] = player[attr.name];
          }
        });
      });
    }
    this.tags.$party = this.players.party;
    return this.tags;
  }
  _setupBlueprints(response) {
    for (const key in response) {
      const value = response[key];
      if (value) {
        if (value instanceof Array) {
          response[key] = value.map((r) => this._setupBlueprints({ $item: r }).$item);
        }
        if (!(value instanceof Blueprint) && value.$meta) {
          response[key] = Blueprint.parse(this.story, value);
        }
      }
    }
    return response;
  }
  _collapseBlueprints(response) {
    for (const key in response) {
      const value = response[key];
      if (value) {
        if (value instanceof Array) {
          response[key] = value.map((r) => this._collapseBlueprints({ $it: r }).$it);
        }
        if (value.$meta) {
          const data = value.data;
          data.$meta = value.$meta.id;
          data.$config = value.$config.id;
          response[key] = data;
        }
      }
    }
    return response;
  }
  startPause(ms2) {
    this.afterPause = Date.now() + ms2;
    this.notify("pause", ms2);
    this.timer = setTimeout(() => this.next(), ms2);
  }
  startTimer(ms2, scene) {
    const timeout = ms2 || this.settings.defaultChoiceTimer || 10 * 1e3;
    const myTimer = () => {
      this.notify("choice-timer", timeout);
      this.timer = setTimeout(() => {
        log$1("timer! choices cleared, scene change...");
        this.notify("choice-timer-timeout");
        this.choices.length = 0;
        if (scene) {
          this.applyMicrocosm(scene);
          this.changeScene(scene);
        } else {
          this.proceed();
        }
      }, timeout);
      return timeout;
    };
    if (this.settings.deferTimer) {
      this.notify("choice-timer-ready", myTimer);
    } else {
      myTimer();
    }
  }
  applyMicrocosm(sceneId, direction = null) {
    const microcosm = direction ? direction.microcosm : false;
    const scene = this.story.scenes.filter((a) => a).find((s) => s.id === sceneId);
    if (microcosm || scene && scene.microcosm) {
      this.microcosms.push({
        scene: this.scene.id,
        idx: this.directionIndex
      });
    }
  }
  showMicrocoms() {
    console.log("\n === microcosms");
    for (const micro of this.player.microcosms) {
      const scene = this.story.scenes.find((a) => a.id === micro.scene);
      console.log("  - ", scene.title, micro);
    }
    console.log("\n");
  }
  changeScene(id, idx = -1) {
    if (this._lastChangeScene !== id) {
      this._lastChangeScene = id;
    } else {
      this._lastChangeSceneCount = (this._lastChangeSceneCount || 0) + 1;
      const now = Date.now();
      if (this._lastChangeSceneCount > 5 && now - this._lastChangeSceneTime < 1500) {
        throw new Error("Infinite loop detected");
      }
      this._lastChangeSceneTime = now;
    }
    clearTimeout(this.timer);
    const scene = this.story.scenes.find((s) => `${s.id}` === `${id}`);
    if (scene) {
      this.scene = scene;
      this.notify("scene", id);
      if (scene.act) {
        this.randomizedDirection(scene);
      } else {
        this.directionIndex = idx;
        this.text = "";
        this.choices.length = 0;
        this.proceed();
      }
    } else {
      console.error(
        "invalid scene",
        "available:",
        this.story.scenes.map((s) => `${s.id}`),
        "missing:",
        id
      );
      throw new Error(`invalid scene: ${id}`);
    }
  }
  addChoice(choice2) {
    choice2.direction = this.direction.id;
    this.choices.push(choice2);
    this.notify("choice", choice2);
  }
  changeText(textChange) {
    const value = copy$2(textChange);
    const context = {};
    for (const tag in this.characters) {
      context[tag] = this.characters[tag].toObject();
    }
    value.label = insertTags(value.label, this.story, this.tags, context);
    value.content = insertTags(value.content, this.story, this.tags, context);
    this.text = value.content;
    this.characterImage = {
      character: value.character,
      state: value.state
    };
    this.notify("text", value);
  }
  setImage(value) {
    this.image = value.content;
    this.notify("image", value);
  }
  changeBackground(bg) {
    this.background = bg.content;
    this.notify("background", bg);
  }
  changeLighting(light) {
    this.lighting = light;
    this.notify("lighting", light);
  }
  changeClip(clip) {
    this.clip = clip;
    this.notify("audio", clip);
  }
  changeMusic(clip) {
    this.music = clip;
    this.notify("music", clip);
  }
  changeVideo(data) {
    this.notify("video", data);
  }
  randomizedDirection(scene, idx = 0) {
    const options = [];
    let directionType = null;
    for (let index2 = idx; index2 < scene.directions.length; index2 += 1) {
      const direction = scene.directions[index2];
      if (directionType != null && direction.type !== directionType) {
        break;
      }
      if (shouldShowDirection(this.story, direction, this.tags)) {
        directionType = direction.type;
        options.push(direction);
      }
    }
    const total = options.reduce(
      (a, b) => a + (b.weight === void 0 ? 1 : parseInt(b.weight, 10)),
      0
    );
    let lots = [];
    for (const option of options) {
      let num = 1 / options.length;
      if (total > 0) {
        num = (option.weight === void 0 ? 1 : option.weight) / total;
      }
      if (num > 0) {
        lots = lots.concat(new Array(Math.floor(num * 10)).fill(option.id));
      }
    }
    const nextId = lots[Math.floor(Math.random() * lots.length)];
    const next = options.find((o) => o.id === nextId);
    this.recordChoice(next);
    this.changeScene(next.scene);
  }
  activatePartyByPlayer(playerId) {
    const player = this.players.player(playerId);
    if (player) {
      this.activateParty(player.party);
    }
  }
  activateParty(partyId) {
    if (this.players.partyId !== partyId) {
      this.players.partyId = partyId;
      const party = this.players.party;
      this.tags.$party = this.players.party;
      if (party.savepoint) {
        this.scene = this.story.scenes.find((s) => s.id === party.savepoint.scene);
        this.directionIndex = party.savepoint.idx;
        this.direction = this.scene.directions[this.directionIndex];
        this.choices = copy$2(party.savepoint.choices);
        this.microcosms = copy$2(party.savepoint.microcosms) || [];
      } else {
        log$1(" -- no savepoint");
      }
    }
  }
  clearMultiplayerTimers() {
    for (const key in this.mptimers) {
      clearTimeout(this.mptimers[key]);
      delete this.mptimers[key];
    }
  }
  notify(changed, data) {
    this.listeners.forEach(
      (l) => l({
        changed,
        value: data,
        party: this.players.partyId
      })
    );
  }
}
const _sfc_main$b = {
  name: "author-plug",
  props: {
    author: Object,
    showUser: { type: Boolean, default: false }
  }
};
const _hoisted_1$8 = {
  key: 0,
  class: "author static"
};
const _hoisted_2$7 = {
  key: 0,
  class: "author-line flex-row flex-center flex-align-center"
};
const _hoisted_3$7 = {
  key: 1,
  class: "author-line"
};
const _hoisted_4$4 = {
  key: 2,
  class: "bio"
};
const _hoisted_5$3 = {
  key: 3,
  class: "bio short"
};
const _hoisted_6$3 = {
  key: 4,
  class: "links static row center"
};
const _hoisted_7$3 = ["href"];
const _hoisted_8$3 = { key: 0 };
const _hoisted_9$3 = {
  key: 1,
  style: { "width": "24px", "height": "24px" },
  viewBox: "0 0 24 24"
};
const _hoisted_10$3 = {
  key: 2,
  style: { "width": "24px", "height": "24px" },
  viewBox: "0 0 80 80"
};
const _hoisted_11$3 = {
  key: 3,
  style: { "color": "var(--spark_text)" }
};
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_user_tag = resolveComponent("user-tag");
  const _component_router_link = resolveComponent("router-link");
  const _component_vector_image = resolveComponent("vector-image");
  return $props.author ? (openBlock(), createElementBlock("div", _hoisted_1$8, [
    $props.showUser ? (openBlock(), createElementBlock("div", _hoisted_2$7, [
      createBaseVNode("span", null, toDisplayString$1(_ctx.$t("author_plug.written-by")), 1),
      _cache[0] || (_cache[0] = createTextVNode()),
      createVNode(_component_user_tag, {
        uid: $props.author.id
      }, null, 8, ["uid"])
    ])) : (openBlock(), createElementBlock("div", _hoisted_3$7, [
      createVNode(_component_router_link, { to: "/account" }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString$1($props.author.username), 1)
        ]),
        _: 1
      })
    ])),
    $props.showUser && $props.author.bio ? (openBlock(), createElementBlock("div", _hoisted_4$4, toDisplayString$1($props.author.bio), 1)) : $props.author.bio ? (openBlock(), createElementBlock("div", _hoisted_5$3, toDisplayString$1($props.author.bio), 1)) : createCommentVNode("", true),
    $props.author && $props.author.links && $props.author.links.length > 0 ? (openBlock(), createElementBlock("ul", _hoisted_6$3, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($props.author.links, (link2) => {
        return openBlock(), createElementBlock("li", {
          key: link2.type
        }, [
          createBaseVNode("a", {
            href: link2.url,
            target: "_system"
          }, [
            link2.type == "ko-fi" ? (openBlock(), createElementBlock("span", _hoisted_8$3, "ko-fi")) : link2.type == "flattr" ? (openBlock(), createElementBlock("svg", _hoisted_9$3, _cache[1] || (_cache[1] = [
              createBaseVNode("path", {
                fill: "var(--spark_text)",
                d: "M21,12A9,9 0 0,1 12,21H4.5L9.74,15.76L11.16,17.17L9.33,19H12A7,7 0 0,0 19,12V7L21,5V12M3,12A9,9 0 0,1 12,3H19.5L14.26,8.24L12.84,6.83L14.67,5H12A7,7 0 0,0 5,12V17L3,19V12Z"
              }, null, -1)
            ]))) : link2.type == "liberapay" ? (openBlock(), createElementBlock("svg", _hoisted_10$3, _cache[2] || (_cache[2] = [
              createBaseVNode("g", { transform: "translate(-81.76206,-211.304)" }, [
                createBaseVNode("path", {
                  fill: "var(--spark_text)",
                  d: "m104.28 271.1c-3.571 0-6.373-.466-8.41-1.396-2.037-.93-3.495-2.199-4.375-3.809-.88-1.609-1.308-3.457-1.282-5.544.025-2.086.313-4.311.868-6.675l9.579-40.05 11.69-1.81-10.484 43.44c-.202.905-.314 1.735-.339 2.489-.026.754.113 1.421.415 1.999.302.579.817 1.044 1.546 1.395.729.353 1.747.579 3.055.679l-2.263 9.278"
                }),
                createBaseVNode("path", {
                  fill: "var(--spark_text)",
                  d: "m146.52 246.14c0 3.671-.604 7.03-1.811 10.07-1.207 3.043-2.879 5.669-5.01 7.881-2.138 2.213-4.702 3.935-7.693 5.167-2.992 1.231-6.248 1.848-9.767 1.848-1.71 0-3.42-.151-5.129-.453l-3.394 13.651h-11.162l12.52-52.19c2.01-.603 4.311-1.143 6.901-1.622 2.589-.477 5.393-.716 8.41-.716 2.815 0 5.242.428 7.278 1.282 2.037.855 3.708 2.024 5.02 3.507 1.307 1.484 2.274 3.219 2.904 5.205.627 1.987.942 4.11.942 6.373m-27.378 15.461c.854.202 1.91.302 3.167.302 1.961 0 3.746-.364 5.355-1.094 1.609-.728 2.979-1.747 4.111-3.055 1.131-1.307 2.01-2.877 2.64-4.714.628-1.835.943-3.858.943-6.071 0-2.161-.479-3.998-1.433-5.506-.956-1.508-2.615-2.263-4.978-2.263-1.61 0-3.118.151-4.525.453l-5.28 21.948"
                })
              ], -1)
            ]))) : link2.type == "discord" ? (openBlock(), createElementBlock("span", _hoisted_11$3, [
              createVNode(_component_vector_image, { name: "discord" })
            ])) : (openBlock(), createElementBlock("i", {
              key: 4,
              class: normalizeClass(["fa", `fa-${link2.type}`]),
              style: { "color": "var(--spark_text)" }
            }, null, 2))
          ], 8, _hoisted_7$3)
        ]);
      }), 128))
    ])) : createCommentVNode("", true)
  ])) : createCommentVNode("", true);
}
const AuthorPlug = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$9], ["__scopeId", "data-v-07a2a669"]]);
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "ScrollSticker",
  props: {
    scrollSelector: { default: null },
    tolerance: { default: 50 }
  },
  setup(__props) {
    const props = __props;
    const el = ref(null);
    const paused = ref(false);
    let scrollerReference = -1;
    let unpauseReference = -1;
    let prevHeight = -1;
    let parent = null;
    onMounted(() => {
      if (props.scrollSelector) {
        parent = el.value.closest(props.scrollSelector);
      } else {
        parent = el.value.parentElement;
      }
      if (parent) {
        parent.addEventListener("scroll", scrollToBottom);
        parent.addEventListener("mousemove", pauseScroller);
        parent.addEventListener("touchmove", pauseScroller);
        parent.addEventListener("wheel", pauseScroller);
      }
      startScroller();
    });
    onUnmounted(() => {
      clearTimeout(unpauseReference);
      if (parent) {
        parent.removeEventListener("scroll", scrollToBottom);
        parent.removeEventListener("mousemove", pauseScroller);
        parent.removeEventListener("touchmove", pauseScroller);
        parent.removeEventListener("wheel", pauseScroller);
      }
      stopScroller();
    });
    function pauseScroller() {
      paused.value = true;
      unpauseReference = window.setTimeout(() => {
        paused.value = false;
      }, 20);
    }
    function startScroller() {
      scrollerReference = requestAnimationFrame(() => {
        startScroller();
        scrollToBottom();
      });
    }
    function scrollToBottom(event = null) {
      if (el.value && !paused.value) {
        const parentBox = parent.getBoundingClientRect();
        const box = el.value.getBoundingClientRect();
        const diff2 = parentBox.bottom - box.bottom;
        const aDiff = Math.abs(diff2);
        const scrollDiff = parent.scrollHeight - prevHeight;
        if (scrollDiff > 0) {
          if (aDiff > 0 && aDiff < props.tolerance + scrollDiff) {
            parent.scrollTop -= diff2;
          }
          prevHeight = parent.scrollHeight;
        }
      }
    }
    function stopScroller() {
      cancelAnimationFrame(scrollerReference);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "el",
        ref: el,
        class: "scroll-sticker"
      }, null, 512);
    };
  }
});
const ScrollSticker = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__scopeId", "data-v-0c1d65ab"]]);
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "ImageAura",
  props: {
    value: {},
    position: { default: "left" },
    size: { default: 300 }
  },
  setup(__props) {
    useCssVars((_ctx) => ({
      "2d6f1737": widthPx.value,
      "18fd93b2": halfPx.value,
      "25ddb93d": origin.value
    }));
    const props = __props;
    const origin = computed(() => {
      if (props.position === "right") {
        return "50% 50%";
      }
      if (props.position === "center") {
        return "0 50%";
      }
      return "50% 50%";
    });
    const widthPx = computed(() => {
      return `${props.size}px`;
    });
    const halfPx = computed(() => {
      return `${props.size / 2}px`;
    });
    computed(() => {
      return `${props.size / 4}px`;
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, {
        appear: "",
        name: "emotefade"
      }, {
        default: withCtx(() => [
          createBaseVNode("div", {
            ref: "aura",
            class: normalizeClass(["image-aura", {
              [`position-${_ctx.position}`]: true
            }]),
            style: normalizeStyle({
              "--aura": props.value.color || "white",
              "--auraShine": props.value.shine || "transparent",
              "--auraShineSpeed": props.value.speed || "0s",
              "--auraQty": props.value.quantity || 12,
              "--auraSize": props.value.size || 10,
              "--auraPx": widthPx.value,
              "--layoutPosition": props.position
            })
          }, null, 6)
        ]),
        _: 1
      });
    };
  }
});
const ImageAura = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__scopeId", "data-v-49f91659"]]);
function pick(array, num) {
  const possible = array.slice(0);
  const choices = [];
  for (let n = 0; n < num; n += 1) {
    const idx = Math.floor(Math.random() * possible.length);
    choices.push(possible.splice(idx, 1)[0]);
    if (possible.length === 0) {
      break;
    }
  }
  return choices;
}
function plot(characters2) {
  for (const char2 of characters2.filter((c) => !!c.action_order)) {
    const choices = [];
    for (const { name, probability } of char2.action_order) {
      const performance2 = char2.canPerform(name);
      if (performance2.possible) {
        for (let x = 0; x < (probability || 1); x += 1) {
          choices.push(name);
        }
      }
    }
    if (choices.length > 0) {
      const names2 = pick(choices, 3);
      for (const name of names2) {
        const action = char2.sheet.actions.find((a) => a.name === name);
        if (!action) {
          throw new Error(`Failed to find action named ${name} [set: ${char2.sheet.actions.map((a) => a.name)}]`);
        }
        let targets = [];
        if (action.targets === "me") {
          targets = [char2];
        } else if (action.targets === "friendly") {
          targets = characters2.filter((c) => c.team === char2.team);
        } else if (action.targets === "any" || action.targets === "random") {
          targets = characters2;
        } else {
          targets = characters2.filter((c) => c.team !== char2.team);
        }
        if (targets.length > 0) {
          targets = pick(targets, action.targetQuantity || 1).map((t) => t.id);
          char2.action = { name, targets };
          break;
        }
      }
    } else {
      char2.action = null;
    }
  }
}
function round(characters2) {
  for (const char2 of characters2) {
    char2.cooldown();
  }
  for (const char2 of characters2) {
    char2.init = char2.initiative();
  }
  characters2.sort(sortby("-init"));
  const teams = /* @__PURE__ */ new Set();
  for (const char2 of characters2) {
    teams.add(char2.team);
    char2.results = null;
    if (char2.alive() && char2.action) {
      const targets = characters2.filter((c) => char2.action.targets.indexOf(c.id) > -1);
      char2.results = char2.perform(char2.action.name, targets);
    } else {
      char2.action = null;
    }
  }
  let winners = [];
  for (const team of teams) {
    if (characters2.filter((c) => c.team === team).some((c) => c.alive())) {
      winners.push(team);
    }
  }
  return {
    winner: winners.length === 1 ? winners[0] : null,
    finished: winners.length <= 1,
    results: characters2
  };
}
function timer$1(t) {
  return new Promise((r) => {
    setTimeout(() => {
      r();
    }, t);
  });
}
const _sfc_main$8 = {
  name: "BattleResults",
  components: {
    FallingNumbers
  },
  props: {
    story: { type: Object, required: true },
    contestants: { type: Array, required: true },
    character: { type: Object, required: true }
  },
  data() {
    return {
      showAction: false,
      showEffects: []
    };
  },
  computed: {
    choiceStyle() {
      return this.story.styles.find((s) => s.default_choice);
    },
    visibleEffects() {
      const retval = {};
      for (const key of this.showEffects) {
        retval[key] = this.character.results.modifiers[key];
      }
      return retval;
    }
  },
  async mounted() {
    await timer$1(1500);
    this.showAction = true;
    if (this.character.results && this.character.results.success) {
      for (const name in this.character.results.modifiers) {
        await timer$1(1e3);
        const target = this.contestants.find((c) => c.id === name);
        if (target) {
          const image = target.sheet.emotes.find((e2) => e2.name === "default");
          if (image) {
            this.$emit("character-image", { image, aura: image.aura, position: target.team === "protagonist" ? "left" : "right" });
          }
        }
        this.showEffects.push(name);
      }
    }
  },
  methods: {
    textStyle
  }
};
const _hoisted_1$7 = { key: 0 };
const _hoisted_2$6 = { key: 0 };
const _hoisted_3$6 = { key: 1 };
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_typer = resolveComponent("typer");
  const _component_falling_numbers = resolveComponent("falling-numbers");
  return openBlock(), createElementBlock("div", {
    class: "action result",
    style: normalizeStyle($options.textStyle($options.choiceStyle))
  }, [
    $props.character.action ? (openBlock(), createElementBlock("div", _hoisted_1$7, [
      createBaseVNode("div", null, [
        createVNode(_component_typer, {
          text: `${$props.character.sheet.name} uses ${$props.character.action.name}...`
        }, null, 8, ["text"]),
        $data.showAction ? (openBlock(), createBlock(_component_typer, {
          key: 0,
          text: $props.character.results && $props.character.results.success ? "Success!" : "Failure!"
        }, null, 8, ["text"])) : createCommentVNode("", true)
      ]),
      $props.character.results && $props.character.results.success ? (openBlock(), createElementBlock("div", _hoisted_2$6, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($options.visibleEffects, (mod2, target) => {
          return openBlock(), createElementBlock("div", {
            key: target,
            class: "block"
          }, [
            createTextVNode(toDisplayString$1(mod2.name) + ": " + toDisplayString$1($props.character.attr(mod2.attr).name) + " ", 1),
            createVNode(_component_falling_numbers, {
              start: mod2.before,
              delta: mod2.effectiveAmount
            }, null, 8, ["start", "delta"])
          ]);
        }), 128))
      ])) : createCommentVNode("", true)
    ])) : !$props.character.alive() ? (openBlock(), createElementBlock("div", _hoisted_3$6, toDisplayString$1(_ctx.$t("battle_effects.character-sheet-name-is-dead", { character_name: $props.character.sheet.name })), 1)) : (openBlock(), createBlock(_component_typer, {
      key: 2,
      text: `${$props.character.sheet.name} does nothing`
    }, null, 8, ["text"])),
    _cache[1] || (_cache[1] = createBaseVNode("div", { class: "stretch spacer" }, null, -1)),
    createBaseVNode("button", {
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click"))
    }, toDisplayString$1(_ctx.$t("battle_effects.next")), 1)
  ], 4);
}
const BattleResults = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8], ["__scopeId", "data-v-836f4ff3"]]);
const _sfc_main$7 = {
  components: {
    BattleResults
  },
  props: {
    story: { type: Object, required: true },
    contestants: { type: Array, required: true },
    rounds: { default: null }
  },
  data() {
    return {
      character: null,
      disabled: {},
      targets: [],
      step: "choose",
      started: false,
      waiting: null
    };
  },
  computed: {
    roundsNum() {
      return this.rounds ? parseInt(this.rounds, 10) : 0;
    },
    protagonists() {
      return this.contestants.filter((c) => c.team.toLowerCase() === "protagonist");
    },
    antagonists() {
      return this.contestants.filter((c) => c.team.toLowerCase() !== "protagonist");
    },
    defaultStyle() {
      return this.story.styles.find((s) => s.default);
    },
    choiceStyle() {
      return this.story.styles.find((s) => s.default_choice);
    }
  },
  mounted() {
    if (this.protagonists.length > 0 && this.antagonists.length > 0) {
      this.startBattle();
    }
  },
  methods: {
    waitForInput() {
      return new Promise((resolve2, reject) => {
        this.waiting = resolve2;
        this.cancel = reject;
      }).then((r) => {
        this.cancel = null;
        this.waiting = null;
        return r;
      });
    },
    async chooseActions() {
      this.step = "action";
      for (const char2 of this.protagonists) {
        this.character = char2;
        char2.action = null;
        while (char2.action === null) {
          try {
            this.step = "action";
            let possibleCount = 0;
            for (const action of char2.sheet.actions) {
              const possible = char2.canPerform(action.name);
              if (possible.possible) {
                possibleCount += 1;
              }
              this.disabled[action.name] = possible.possible ? false : possible.reason;
            }
            const image = char2.sheet.emotes.find((e2) => e2.name === "default");
            if (image) {
              this.$emit("character-image", { image, aura: image.aura, position: "left" });
            }
            if (possibleCount === 0) {
              await this.waitForInput();
              char2.action = false;
            } else {
              const name = await this.waitForInput();
              char2.action = {
                name,
                // eslint-disable-next-line no-await-in-loop
                targets: await this.chooseTargets(char2, name)
              };
            }
          } catch (ex) {
            console.log("cancel", ex);
          }
        }
        console.log("action", char2.sheet.name, char2.action.targets);
      }
      this.character = null;
      console.log("all actions have been selected");
    },
    async chooseTargets(char2, action) {
      this.step = "targets";
      const object = char2.sheet.actions.find((a) => a.name === action);
      const targets = [];
      const targetQty = object.targetQuantity || 1;
      for (let x = 0; x < targetQty; x += 1) {
        if (object.targets === "friendly") {
          this.targets = this.contestants.filter((c) => c.team === char2.team);
        } else if (action.targets === "any" || action.targets === "random") {
          this.targets = this.contestants;
        } else {
          this.targets = this.contestants.filter((c) => c.team !== char2.team);
        }
        if (targetQty == 1 && this.targets.length === 1) {
          targets.push(this.targets[0].id);
        } else {
          const target = await this.waitForInput();
          targets.push(target);
        }
      }
      return targets;
    },
    async showResults(results) {
      this.step = "results";
      for (const char2 of results) {
        this.character = char2;
        const image = char2.sheet.emotes.find((e2) => e2.name === "default");
        if (image) {
          this.$emit("character-image", { image, aura: image.aura, position: char2.team === "protagonist" ? "left" : "right" });
        }
        await this.waitForInput();
      }
      this.character = null;
    },
    async startBattle() {
      this.started = true;
      for (const c of this.contestants) {
        c.action_order = c.sheet.actions.map((a) => ({ name: a.name, probability: a.aiProbability || 1 }));
      }
      let rounds = 0;
      while (!this.roundsNum || rounds < this.roundsNum) {
        plot(this.contestants);
        await this.chooseActions();
        const results = round(this.contestants);
        await this.showResults(results.results);
        if (results.finished) {
          break;
        }
        rounds += 1;
      }
      const pAlive = this.protagonists.some((p2) => p2.alive());
      const aAlive = this.antagonists.some((a) => a.alive());
      let winner = 0;
      if (pAlive && !aAlive) {
        winner = 1;
      } else if (aAlive && !pAlive) {
        winner = -1;
      }
      this.$emit("finished", winner);
    },
    playerName(target) {
      return this.contestants.find((f) => f.id === target).sheet.name;
    },
    textStyle
  }
};
const _hoisted_1$6 = {
  key: 0,
  class: "battle"
};
const _hoisted_2$5 = {
  key: 0,
  class: "choose-action"
};
const _hoisted_3$5 = { class: "stretch" };
const _hoisted_4$3 = ["onClick"];
const _hoisted_5$2 = { class: "static" };
const _hoisted_6$2 = { class: "flex column" };
const _hoisted_7$2 = {
  key: 0,
  class: "cost-marker row right"
};
const _hoisted_8$2 = {
  key: 1,
  class: "reason"
};
const _hoisted_9$2 = {
  key: 2,
  class: "description"
};
const _hoisted_10$2 = { key: 2 };
const _hoisted_11$2 = {
  key: 1,
  class: "choose-targets"
};
const _hoisted_12$2 = ["onClick"];
const _hoisted_13$2 = { key: 0 };
const _hoisted_14$2 = { key: 1 };
const _hoisted_15$2 = {
  key: 2,
  class: "show-results"
};
const _hoisted_16$2 = {
  key: 2,
  class: "battle broken accented"
};
const _hoisted_17$2 = { key: 0 };
const _hoisted_18 = { key: 1 };
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_typer = resolveComponent("typer");
  const _component_battle_results = resolveComponent("battle-results");
  return $options.protagonists.length > 0 && $options.antagonists.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_1$6, [
    $data.step === "action" ? (openBlock(), createElementBlock("div", _hoisted_2$5, [
      $data.character ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "directions flex row",
        style: normalizeStyle($options.textStyle($options.defaultStyle))
      }, [
        createBaseVNode("span", _hoisted_3$5, toDisplayString$1($data.character ? $data.character.sheet.name : "..."), 1),
        (openBlock(true), createElementBlock(Fragment, null, renderList($data.character.sheet.attributes.filter((a) => a.display), (attr) => {
          return openBlock(), createElementBlock("span", {
            key: attr.id,
            class: "attr"
          }, toDisplayString$1($data.character.value(attr.abbrev)) + " " + toDisplayString$1(attr.abbrev), 1);
        }), 128))
      ], 4)) : createCommentVNode("", true),
      $data.character ? (openBlock(), createBlock(TransitionGroup, {
        key: 1,
        name: "rotate-slide",
        tag: "div",
        appear: ""
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList($data.character.sheet.actions, (action, idx) => {
            return openBlock(), createElementBlock("div", {
              class: "action-container",
              key: action.id,
              style: normalizeStyle({ "transition-delay": `${idx * 100}ms` }),
              onClick: ($event) => $data.disabled[action.name] ? null : $data.waiting(action.name)
            }, [
              createBaseVNode("div", {
                class: normalizeClass(["action", { disabled: $data.disabled[action.name] }]),
                style: normalizeStyle($options.textStyle($options.choiceStyle))
              }, [
                createBaseVNode("div", _hoisted_5$2, toDisplayString$1(action.name), 1),
                createBaseVNode("div", _hoisted_6$2, [
                  action.cost > 0 && action.costAttr ? (openBlock(), createElementBlock("div", _hoisted_7$2, [
                    createBaseVNode("span", null, toDisplayString$1(action.cost) + " " + toDisplayString$1(action.costAttr), 1)
                  ])) : createCommentVNode("", true),
                  $data.disabled[action.name] ? (openBlock(), createElementBlock("div", _hoisted_8$2, toDisplayString$1($data.disabled[action.name]), 1)) : action.description ? (openBlock(), createElementBlock("div", _hoisted_9$2, toDisplayString$1(action.description), 1)) : createCommentVNode("", true)
                ])
              ], 6)
            ], 12, _hoisted_4$3);
          }), 128)),
          Object.values($data.disabled).filter((a) => a).length === $data.character.sheet.actions.length ? (openBlock(), createElementBlock("div", {
            class: "action-container",
            key: "$NONE",
            style: normalizeStyle({ "transition-delay": `${$data.character.sheet.actions.length * 100}ms` }),
            onClick: _cache[0] || (_cache[0] = ($event) => $data.waiting())
          }, [
            createBaseVNode("div", {
              class: "action",
              style: normalizeStyle($options.textStyle($options.choiceStyle))
            }, toDisplayString$1(_ctx.$t("battle.do-nothing")), 5)
          ], 4)) : createCommentVNode("", true)
        ]),
        _: 1
      })) : (openBlock(), createElementBlock("div", _hoisted_10$2, "Loading..."))
    ])) : $data.step === "targets" ? (openBlock(), createElementBlock("div", _hoisted_11$2, [
      createBaseVNode("div", {
        class: "directions",
        style: normalizeStyle($options.textStyle($options.defaultStyle))
      }, [
        createVNode(_component_typer, { text: "Choose your targets:" })
      ], 4),
      $data.character ? (openBlock(), createBlock(TransitionGroup, {
        key: 0,
        name: "rotate-slide",
        appear: "",
        tag: "div"
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList($data.targets, (target, idx) => {
            return openBlock(), createElementBlock("div", {
              class: "action",
              key: target.id,
              style: normalizeStyle({ "transition-delay": `${idx * 100}ms` }),
              onClick: ($event) => $data.waiting(target.id)
            }, [
              createBaseVNode("div", {
                class: "row left",
                style: normalizeStyle($options.textStyle($options.choiceStyle))
              }, [
                createBaseVNode("div", null, toDisplayString$1(target.sheet.name), 1),
                !target.alive() ? (openBlock(), createElementBlock("i", _hoisted_13$2, toDisplayString$1(_ctx.$t("battle.dead")), 1)) : createCommentVNode("", true)
              ], 4)
            ], 12, _hoisted_12$2);
          }), 128)),
          createBaseVNode("div", {
            key: "$cancel",
            class: "action",
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.cancel())
          }, [
            createBaseVNode("div", {
              class: "row left",
              style: normalizeStyle($options.textStyle($options.choiceStyle))
            }, [
              _cache[5] || (_cache[5] = createBaseVNode("i", { class: "fa fa-arrow-left" }, null, -1)),
              createTextVNode(" " + toDisplayString$1(_ctx.$t("battle.change-action")), 1)
            ], 4)
          ])
        ]),
        _: 1
      })) : (openBlock(), createElementBlock("div", _hoisted_14$2, "Loading..."))
    ])) : (openBlock(), createElementBlock("div", _hoisted_15$2, [
      $data.character ? (openBlock(), createBlock(_component_battle_results, {
        key: $data.character.id,
        story: $props.story,
        character: $data.character,
        contestants: $props.contestants,
        onCharacterImage: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("character-image", $event)),
        onClick: _cache[3] || (_cache[3] = ($event) => $data.waiting())
      }, null, 8, ["story", "character", "contestants"])) : createCommentVNode("", true)
    ]))
  ])) : $data.started ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [], 64)) : (openBlock(), createElementBlock("div", _hoisted_16$2, [
    $options.antagonists.length === 0 && $options.protagonists.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_17$2, toDisplayString$1(_ctx.$t("battle.there-was-supposed-to-be-a-battle-here-but-it-looks-like-no-contestants-showed-up")), 1)) : (openBlock(), createElementBlock("div", _hoisted_18, toDisplayString$1(_ctx.$t("battle.there-was-supposed-to-be-a-battle-here-but-only-one-side-showed-up")), 1)),
    createBaseVNode("button", {
      onClick: _cache[4] || (_cache[4] = withModifiers(($event) => _ctx.$emit("finished", 0), ["prevent"]))
    }, toDisplayString$1(_ctx.$t("battle.proceed")), 1)
  ]));
}
const Battle = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7], ["__scopeId", "data-v-183ef574"]]);
const _sfc_main$6 = {
  name: "HeightTransition",
  props: {
    startFromInitial: { type: Boolean, default: false },
    value: { type: Number, default: null },
    speed: { type: String, default: "300ms" }
  },
  data() {
    return {
      height: this.startFromInitial ? "auto" : "0px",
      running: false,
      // height: '0px',
      timeout: null
    };
  },
  computed: {
    stepMod() {
      return this.steps;
    }
  },
  watch: {
    value() {
      this.transition();
    }
  },
  async mounted() {
    this.$refs.outer.style.height = this.height;
    this._observers = [];
    if (window.MutationObserver) {
      const mutator = new window.MutationObserver(async (changes) => {
        for (const change of changes) {
          if (change.target !== this.$refs.inner && change.target !== this.$refs.outer || change.attributeName !== "style") {
            this.transition();
          }
        }
      });
      mutator.observe(
        this.$refs.inner,
        {
          attributes: true,
          childList: true,
          subtree: true
        }
      );
      this._observers.push(mutator);
    }
    if (!this.startFromInitial) {
      await this.$nextTick();
      this.transition();
    }
  },
  unmounted() {
    this._observers.forEach((o) => o.disconnect());
    clearTimeout(this.timeout);
  },
  methods: {
    transition() {
      if (this.$refs.inner) {
        clearTimeout(this.timeout);
        this.timeout = setTimeout(() => {
          this.getHeight();
        }, 1);
      }
    },
    async getHeight() {
      if (!this.running) {
        this.running = true;
        const outer = this.$refs.outer;
        const element = this.$refs.inner;
        const original = getComputedStyle(element);
        const width = original.width;
        element.style.width = width;
        element.style.position = "absolute";
        element.style.visibility = "hidden";
        const height = getComputedStyle(element).height;
        element.style.width = null;
        element.style.position = null;
        element.style.visibility = null;
        if (this.height != height) {
          this.height = height;
          outer.style.height = height;
        }
        this.running = false;
      }
    },
    pxToInteger(value) {
      return parseInt(value.slice(0, -2));
    }
  }
};
const __injectCSSVars__ = () => {
  useCssVars((_ctx) => ({
    "b0df19a8": _ctx.speed
  }));
};
const __setup__ = _sfc_main$6.setup;
_sfc_main$6.setup = __setup__ ? (props, ctx) => {
  __injectCSSVars__();
  return __setup__(props, ctx);
} : __injectCSSVars__;
const _hoisted_1$5 = { class: "height-transition" };
const _hoisted_2$4 = {
  class: "outer",
  ref: "outer"
};
const _hoisted_3$4 = {
  class: "inner",
  ref: "inner"
};
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$5, [
    createBaseVNode("div", _hoisted_2$4, [
      createBaseVNode("div", _hoisted_3$4, [
        renderSlot(_ctx.$slots, "default", { ref: "slot" }, void 0, true)
      ], 512)
    ], 512)
  ]);
}
const HeightTransition = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6], ["__scopeId", "data-v-16a3ce5a"]]);
const useReaderStore = defineStore("reader", () => {
  const reader = shallowRef(null);
  const characters2 = ref({});
  const contestants = ref([]);
  const story2 = computed(() => {
    var _a;
    return (_a = reader.value) == null ? void 0 : _a.story;
  });
  const combatants = computed(() => {
    var _a;
    console.log("getting combatants", reader.value, (_a = story2.value) == null ? void 0 : _a.id, contestants.value.length);
    const retval = [];
    if (contestants.value && story2.value) {
      for (const value of contestants.value) {
        const char2 = value.character;
        if (!characters2.value[char2]) {
          const sheet = story2.value.characters.find((c) => `${c.id}` === `${char2}`);
          if (sheet) {
            characters2.value[char2] = new Character(sheet);
            const tagged = story2.value.tags.find(
              (t) => t.type === "character" && t.character === sheet.id
            );
            if (tagged) {
              characters2.value[char2].setValues((void 0).tags[tagged.id]);
            }
            characters2.value[char2].id = nanoid();
            characters2.value[char2].team = value.team;
          } else {
            console.error("this character has no sheet", char2, story2.value.characters);
          }
        }
        console.log("character", char2, characters2.value);
        if (characters2.value[char2]) {
          if (value.reset) {
            characters2.value[char2].reset();
          } else {
            characters2.value[char2].modifiers = [];
          }
          retval.push(characters2.value[char2]);
        }
      }
    } else {
      console.log("no story");
    }
    return retval;
  });
  watch(story2, function() {
    contestants.value = [];
    characters2.value = {};
  });
  return {
    reader,
    story: story2,
    contestants,
    combatants
  };
});
const _sfc_main$5 = {
  name: "ReaderContent",
  components: {
    HeightTransition,
    Battle,
    ImageAura
  },
  props: {
    story: Object,
    picks: Object,
    block: Object,
    first: Boolean,
    last: Boolean,
    optionChoices: Object,
    tags: Object,
    idle: { type: Boolean }
  },
  data() {
    return {
      completed: {},
      error: null,
      input: null,
      inputPoints: this.block.points,
      timer: this.block.timer ? Date.now() : 0,
      timeLeft: this.block.timer || 0,
      thought: "",
      thoughtIdx: -1,
      isThoughtfinished: true,
      isInTransition: false,
      transitionPromise: null,
      transitionPromiseResolve: null,
      typeSounds: [],
      audio: null
    };
  },
  computed: {
    styleObject() {
      var _a, _b;
      let style = this.story.styles.find((s) => s.default);
      if (this.block.type === "choice" || this.block.type === "choice-timer") {
        style = this.story.styles.find((s) => s.default_choice) || style;
      }
      let styleId = [(_a = this.character) == null ? void 0 : _a.style, (_b = this.emote) == null ? void 0 : _b.style, this.block.style];
      styleId = styleId.filter((a) => a).pop();
      if (styleId) {
        style = this.story.styles.find((s) => s.id === styleId) || style;
      }
      return style;
    },
    myPicks() {
      const retval = [];
      for (const player in this.picks) {
        if (this.picks[player].pick === this.block.id) {
          retval.push({ id: player, username: this.picks[player].username });
        }
      }
      return retval;
    },
    tag() {
      if (this.block.type === "input") {
        return this.story.tags.find((t) => t.id === this.block.content);
      }
      return null;
    },
    animation() {
      let animation = this.block.animationId;
      if (this.block.type === "choice") {
        animation = animation || this.story.settings.animationChoice;
      }
      animation = animation || this.story.settings.animation;
      if (!animation) {
        const animations = this.story.animations || [];
        if (animations.length > 0) {
          return animations[0].id;
        }
      }
      return animation;
    },
    character() {
      let charId = this.block.character;
      if (this.block.charTag) {
        charId = this.tags[this.block.charTag];
      }
      return this.story.characters.find((c) => c.id === charId);
    },
    emote() {
      let retval = null;
      if (this.character) {
        if (this.block.emoteName) {
          retval = this.character.emotes.find((e2) => e2.name === this.block.emoteName);
        }
        if (!retval) {
          retval = this.character.emotes.find((e2) => e2.id === this.block.state);
        }
      }
      return retval;
    },
    label() {
      if (this.block.label) {
        return this.block.label;
      }
      if (this.emote) {
        return this.emote.label;
      }
      return "";
    },
    position() {
      var _a;
      let retval = "left";
      if ((_a = this.emote) == null ? void 0 : _a.position) {
        retval = this.emote.position;
      }
      if (this.block.position) {
        retval = this.block.position;
      }
      if (!retval || retval === "undefined") {
        retval = "left";
      }
      return retval;
    },
    aura() {
      var _a, _b;
      let retval = {
        color: "white"
      };
      if ((_a = this.emote) == null ? void 0 : _a.auraConfig) {
        retval = this.emote.auraConfig;
      } else if ((_b = this.character) == null ? void 0 : _b.auraConfig) {
        retval = this.character.auraConfig;
      }
      return retval;
    },
    image() {
      if (this.block.type === "image") {
        const img = this.story.images.find((i) => i.id === this.block.content);
        return img;
      }
    },
    transitionSteps() {
      let steps = Math.max(0, this.block.speed || this.story.settings.typeSpeed || 5);
      return steps;
    },
    ...mapStores(useReaderStore),
    emoteWidth() {
      var _a, _b;
      const width = ((_a = this.character) == null ? void 0 : _a.width) || ((_b = this.story.settings) == null ? void 0 : _b.emoteWidth) || 150;
      return width;
    },
    emoteWidthPx() {
      return `${this.emoteWidth}px`;
    }
  },
  async mounted() {
    if (["video", "choice", "contestant"].includes(this.block.type)) {
      this.$emit("finished");
    } else if (this.block.timer) {
      this.$emit("finished");
      this.countdown();
    }
    if (this.block.type === "input" && this.block.array) {
      const input = {};
      for (const row of this.block.array) {
        input[row.id] = row.start || 0;
      }
      this.input = input;
    }
  },
  watch: {
    isInTransition() {
      if (this.transitionPromise) {
        this.transitionPromiseResolve();
      }
    }
  },
  unmounted() {
    clearTimeout(this.__countdown);
    for (const old of this.typeSounds) {
      old.pause();
    }
    if (this.audio) {
      this.audio.pause();
    }
  },
  methods: {
    hurry() {
      if (this.audio) {
        this.audio.pause();
      }
      for (const block of ["text", "label"]) {
        const ref2 = this.$refs[block];
        if (ref2 && ref2.speedup) {
          ref2.speedup();
        }
      }
    },
    countdown() {
      this.timeLeft = this.block.timer - (Date.now() - this.timer);
      if (this.timeLeft <= 0) {
        this.timeLeft = 0;
      } else {
        this.__countdown = setTimeout(() => this.countdown(), 1e3 / 120);
      }
    },
    async useSuggestion() {
      if (this.block.suggestions && this.block.suggestions.length > 0) {
        const idx = Math.floor(Math.random() * this.block.suggestions.length);
        this.input = this.block.suggestions[idx];
      }
    },
    thoughtfinished() {
      this.isThoughtfinished = true;
    },
    handleChoice() {
      if (this.$refs.thought && !this.isThoughtfinished) {
        this.$refs.thought.speedup();
        this.isThoughtfinished = true;
      } else {
        if (!this.block.thoughts || this.thoughtIdx >= this.block.thoughts.length) {
          if (this.idle) {
            this.$emit("choice", this.block.id);
          } else {
            console.log("is not idle, ignoring choice");
          }
        } else {
          this.thoughtIdx += 1;
          this.isThoughtfinished = false;
          this.thought = this.block.thoughts[this.thoughtIdx];
        }
      }
    },
    waitForTransitionEnd() {
      if (this.isInTransition) {
        this.transitionPromise = new Promise((resolve2) => {
          this.transitionPromiseResolve = resolve2;
        });
        return this.transitionPromise;
      }
    },
    handleHeightTransitionStart() {
      this.isInTransition = true;
    },
    handleHeightTransitionEnd() {
      this.isInTransition = false;
    },
    async finished(block) {
      this.$emit("finished", block);
    },
    textStyleId(id, extra = {}) {
      let style = this.story.styles.find((s) => s.default);
      if (this.block.type === "choice" || this.block.type === "choice-timer") {
        style = this.story.styles.find((s) => s.default_choice) || style;
      }
      if (id) {
        style = this.story.styles.find((s) => s.id === id) || style;
      }
      const retval = textStyle(style);
      for (const prop in extra) {
        retval[prop] = extra[prop];
      }
      return retval;
    },
    textLabelStyle(extra) {
      let style = this.story.styles.find((s) => s.default);
      if (this.story.settings.textLabelStyle) {
        style = this.story.styles.find((s) => s.id == this.story.settings.textLabelStyle) || style;
      }
      const retval = textStyle(style);
      for (const prop in extra) {
        retval[prop] = extra[prop];
      }
      return retval;
    },
    assignPoints(element, amount = 1) {
      if (amount > 0) {
        if (this.inputPoints >= amount) {
          this.input[element.id] += amount;
          this.inputPoints -= amount;
        }
      } else {
        if (element.start <= this.input[element.id] + amount) {
          this.input[element.id] += amount;
          this.inputPoints -= amount;
        }
      }
    },
    handleTypeSound(e2) {
    },
    textStyle,
    async handleBattleCharacterImage(e2) {
      console.log(e2);
    },
    async handleBattleOver(winner) {
      console.log("over", winner, this.block.id);
      if (this.block.result) {
        this.readerStore.reader.recordChoice({
          effects: [
            {
              tag: this.block.result,
              op: ":",
              value: winner
            }
          ]
        });
      }
      this.finished(this.block);
      this.readerStore.reader.next();
      this.completed[this.block.id] = true;
      this.readerStore.contestants = [];
    }
  }
};
const _hoisted_1$4 = ["src"];
const _hoisted_2$3 = {
  key: "image-filler",
  class: "image-filler"
};
const _hoisted_3$3 = {
  key: 0,
  class: "picks"
};
const _hoisted_4$2 = { class: "timer-text flex-row flex-left flex-static" };
const _hoisted_5$1 = { class: "padded" };
const _hoisted_6$1 = { class: "progress" };
const _hoisted_7$1 = {
  key: 3,
  class: "image"
};
const _hoisted_8$1 = ["maxlength"];
const _hoisted_9$1 = ["max", "step"];
const _hoisted_10$1 = { key: 6 };
const _hoisted_11$1 = {
  key: 0,
  class: "fa fa-check-square"
};
const _hoisted_12$1 = {
  key: 1,
  class: "fa fa-square"
};
const _hoisted_13$1 = {
  key: 1,
  class: "flex-static flex-row flex-align-center option-input option-roller"
};
const _hoisted_14$1 = { class: "option-label" };
const _hoisted_15$1 = {
  key: 7,
  class: "video flex-column flex-center"
};
const _hoisted_16$1 = ["src", "title"];
const _hoisted_17$1 = {
  key: 9,
  class: "card"
};
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ImageAura = resolveComponent("ImageAura");
  const _component_blob_image = resolveComponent("blob-image");
  const _component_typer = resolveComponent("typer");
  const _component_battle = resolveComponent("battle");
  const _component_height_transition = resolveComponent("height-transition");
  const _component_animation = resolveComponent("animation");
  return openBlock(), createBlock(_component_animation, {
    id: $options.animation,
    animations: $props.story.animation,
    "play-reverse": false,
    class: "reader-content-item flex-static",
    tag: "div",
    appear: ""
  }, {
    default: withCtx(() => [
      createVNode(_component_height_transition, {
        class: "reader-content-item flex-static",
        onTransitionstart: $options.handleHeightTransitionStart,
        onTransitionend: $options.handleHeightTransitionEnd,
        steps: $options.transitionSteps
      }, {
        default: withCtx(() => {
          var _a;
          return [
            $props.block.type === "text" ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(["text-content2", {
                [`position-${$options.position}`]: true
              }])
            }, [
              ((_a = $options.emote) == null ? void 0 : _a.blob_id) ? (openBlock(), createBlock(_component_ImageAura, {
                key: 0,
                size: $options.emoteWidth,
                value: $options.aura,
                position: $options.position
              }, null, 8, ["size", "value", "position"])) : createCommentVNode("", true),
              createVNode(TransitionGroup, {
                appear: "",
                tag: "span",
                name: "fade",
                class: "text-block-emote flex-column"
              }, {
                default: withCtx(() => [
                  $options.emote && $options.emote.permalink ? (openBlock(), createElementBlock("img", {
                    key: 0,
                    src: $options.emote.permalink,
                    style: normalizeStyle({
                      width: $options.emoteWidthPx,
                      margin: $options.character && $options.character.padding ? `${$options.character.padding}px` : false
                    })
                  }, null, 12, _hoisted_1$4)) : $options.emote && $options.emote.blob_id ? (openBlock(), createBlock(_component_blob_image, {
                    key: 1,
                    blob: $options.emote.blob_id,
                    style: normalizeStyle({
                      width: $options.emoteWidthPx,
                      margin: $options.character && $options.character.padding ? `${$options.character.padding}px` : false
                    })
                  }, null, 8, ["blob", "style"])) : $options.label ? (openBlock(), createElementBlock("div", _hoisted_2$3)) : createCommentVNode("", true),
                  $props.block.type === "text" && $options.label ? (openBlock(), createBlock(_component_typer, {
                    key: "label",
                    class: "text-block-label",
                    ref: "label",
                    text: $options.label,
                    style: normalizeStyle(
                      $options.textLabelStyle({
                        "min-width": $options.emoteWidthPx
                      })
                    ),
                    speed: $props.story.settings.typeSpeed,
                    "particle-config": $options.styleObject && $options.styleObject.particlesEnabled ? $options.styleObject.particles : null,
                    "animation-config": $options.styleObject ? $options.styleObject.animation : null,
                    animations: $props.story.animation,
                    story: $props.story,
                    variables: $props.tags,
                    allowImages: true
                  }, null, 8, ["text", "style", "speed", "particle-config", "animation-config", "animations", "story", "variables"])) : createCommentVNode("", true)
                ]),
                _: 1
              }),
              createVNode(_component_typer, {
                class: "text-block",
                ref: "text",
                text: $props.block.content,
                style: normalizeStyle($options.textStyle($options.styleObject)),
                speed: ($props.block ? $props.block.speed : null) || $props.story.settings.typeSpeed,
                "particle-config": $options.styleObject && $options.styleObject.particlesEnabled ? $options.styleObject.particles : null,
                "animation-config": $options.styleObject ? $options.styleObject.animation : null,
                animations: $props.story.animation,
                story: $props.story,
                variables: $props.tags,
                allowImages: true,
                onType: $options.handleTypeSound,
                onEnd: _cache[0] || (_cache[0] = ($event) => $options.finished($props.block))
              }, null, 8, ["text", "style", "speed", "particle-config", "animation-config", "animations", "story", "variables", "onType"])
            ], 2)) : $props.block.type === "choice" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              $data.thought ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "thought",
                style: normalizeStyle($options.textStyle($options.styleObject)),
                onClick: _cache[1] || (_cache[1] = ($event) => $data.thought = "")
              }, [
                createVNode(_component_typer, {
                  ref: "thought",
                  text: $data.thought,
                  speed: $props.story.settings.typeSpeed,
                  story: $props.story,
                  variables: $props.tags,
                  allowImages: true,
                  onEnd: $options.thoughtfinished
                }, null, 8, ["text", "speed", "story", "variables", "onEnd"])
              ], 4)) : createCommentVNode("", true),
              createBaseVNode("div", {
                class: "choice",
                onClick: _cache[2] || (_cache[2] = (...args) => $options.handleChoice && $options.handleChoice(...args)),
                style: normalizeStyle($options.textStyle($options.styleObject)),
                key: "choice"
              }, [
                createVNode(_component_typer, {
                  ref: "text",
                  text: $props.block.label,
                  speed: $props.story.settings.typeSpeed,
                  story: $props.story,
                  variables: $props.tags,
                  allowImages: true
                }, null, 8, ["text", "speed", "story", "variables"]),
                $options.myPicks.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_3$3, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList($options.myPicks, (pick2) => {
                    return openBlock(), createElementBlock("div", {
                      class: "pick",
                      key: pick2.id
                    }, toDisplayString$1(pick2.username), 1);
                  }), 128))
                ])) : createCommentVNode("", true)
              ], 4)
            ], 64)) : $props.block.type === "choice-timer" ? (openBlock(), createElementBlock("a", {
              key: 2,
              href: "#",
              onClick: _cache[3] || (_cache[3] = withModifiers(() => {
              }, ["prevent"])),
              style: normalizeStyle($options.textStyle($options.styleObject)),
              class: "timer flex-row"
            }, [
              createBaseVNode("div", _hoisted_4$2, [
                _cache[16] || (_cache[16] = createBaseVNode("div", { class: "padded" }, [
                  createBaseVNode("i", { class: "fa fa-clock-o" })
                ], -1)),
                createBaseVNode("div", _hoisted_5$1, toDisplayString$1(($data.timeLeft / 1e3).toFixed(0)), 1)
              ]),
              createBaseVNode("div", _hoisted_6$1, [
                createBaseVNode("div", {
                  style: normalizeStyle({ width: `${Math.max(0, $data.timeLeft - 0) / $props.block.timer * 100}%` }),
                  class: "progress-meter"
                }, null, 4)
              ])
            ], 4)) : $props.block.type === "image" ? (openBlock(), createElementBlock("div", _hoisted_7$1, [
              $options.image ? (openBlock(), createBlock(_component_blob_image, {
                key: 0,
                blob: $options.image.blob_id,
                onLoad: _cache[4] || (_cache[4] = ($event) => $options.finished($props.block)),
                onError: _cache[5] || (_cache[5] = ($event) => $data.error = $event.toString())
              }, null, 8, ["blob"])) : createCommentVNode("", true),
              $data.error ? (openBlock(), createBlock(_component_typer, {
                key: 1,
                text: $data.error,
                onEnd: _cache[6] || (_cache[6] = ($event) => $options.finished($props.block))
              }, null, 8, ["text"])) : createCommentVNode("", true)
            ])) : $props.block.type === "input" ? (openBlock(), createElementBlock("div", {
              key: 4,
              class: "input-content",
              style: normalizeStyle($options.textLabelStyle({}))
            }, [
              $props.block.label ? (openBlock(), createBlock(_component_typer, {
                key: 0,
                text: $props.block.label,
                speed: $props.story.settings.typeSpeed,
                story: $props.story,
                variables: $props.tags,
                allowImages: true
              }, null, 8, ["text", "speed", "story", "variables"])) : createCommentVNode("", true),
              createBaseVNode("form", {
                class: "flex-row flex-align-center",
                key: "input",
                onSubmit: _cache[10] || (_cache[10] = withModifiers(($event) => {
                  _ctx.$emit("user-input", $data.input);
                  $options.finished($props.block);
                }, ["prevent"]))
              }, [
                $props.block.suggestions && $props.block.suggestions.length ? (openBlock(), createElementBlock("a", {
                  key: 0,
                  href: "#",
                  onClick: _cache[7] || (_cache[7] = withModifiers((...args) => $options.useSuggestion && $options.useSuggestion(...args), ["prevent"]))
                }, _cache[17] || (_cache[17] = [
                  createBaseVNode("i", { class: "fa fa-random" }, null, -1)
                ]))) : createCommentVNode("", true),
                !$options.tag || $options.tag.format === "text" ? withDirectives((openBlock(), createElementBlock("input", {
                  key: 1,
                  "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => $data.input = $event),
                  type: "text",
                  required: "",
                  maxlength: $props.block.max
                }, null, 8, _hoisted_8$1)), [
                  [vModelText, $data.input]
                ]) : withDirectives((openBlock(), createElementBlock("input", {
                  key: 2,
                  type: "number",
                  "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => $data.input = $event),
                  required: "",
                  max: $props.block.max,
                  step: $options.tag.precision ? 1 / 10 ** $options.tag.precision : 1
                }, null, 8, _hoisted_9$1)), [
                  [
                    vModelText,
                    $data.input,
                    void 0,
                    { number: true }
                  ]
                ]),
                _cache[18] || (_cache[18] = createBaseVNode("button", null, [
                  createBaseVNode("i", { class: "fa fa-check" })
                ], -1))
              ], 32)
            ], 4)) : $props.block.type === "achievement" ? (openBlock(), createElementBlock("div", {
              key: 5,
              class: "achievement-content text-block flex-column",
              style: normalizeStyle($options.textStyle($options.styleObject))
            }, [
              $props.block.title ? (openBlock(), createBlock(_component_typer, {
                key: 0,
                class: "achievement-title",
                ref: "label",
                text: $props.block.title || "",
                style: normalizeStyle($options.textStyle($props.block.titleStyle, {})),
                story: $props.story,
                variables: $props.tags,
                allowImages: true
              }, null, 8, ["text", "style", "story", "variables"])) : createCommentVNode("", true),
              createVNode(_component_typer, {
                class: "achievement-text",
                ref: "text",
                text: $props.block.content || "",
                story: $props.story,
                variables: $props.tags,
                allowImages: true,
                onEnd: _cache[11] || (_cache[11] = ($event) => $options.finished($props.block))
              }, null, 8, ["text", "story", "variables"])
            ], 4)) : $props.block.type === "option" ? (openBlock(), createElementBlock("div", _hoisted_10$1, [
              createBaseVNode("div", {
                class: "option flex-align-stretch",
                style: normalizeStyle($options.textStyle($options.styleObject))
              }, [
                ($props.block.min || 0) === 0 && ($props.block.max || 1) === ($props.block.step || 1) ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  onClick: _cache[12] || (_cache[12] = ($event) => _ctx.$emit("option", { action: "toggle", option: $props.block })),
                  class: "padded flex-static option-input"
                }, [
                  $props.optionChoices[$props.block.id] > 0 ? (openBlock(), createElementBlock("i", _hoisted_11$1)) : (openBlock(), createElementBlock("i", _hoisted_12$1))
                ])) : (openBlock(), createElementBlock("div", _hoisted_13$1, [
                  createBaseVNode("div", {
                    class: "padded",
                    onClick: _cache[13] || (_cache[13] = ($event) => _ctx.$emit("option", { action: "down", option: $props.block }))
                  }, _cache[19] || (_cache[19] = [
                    createBaseVNode("i", { class: "fa fa-chevron-left" }, null, -1)
                  ])),
                  createBaseVNode("div", null, toDisplayString$1($props.optionChoices[$props.block.id] || 0), 1),
                  createBaseVNode("div", {
                    class: "padded",
                    onClick: _cache[14] || (_cache[14] = ($event) => _ctx.$emit("option", { action: "up", option: $props.block }))
                  }, _cache[20] || (_cache[20] = [
                    createBaseVNode("i", { class: "fa fa-chevron-right" }, null, -1)
                  ]))
                ])),
                createBaseVNode("div", _hoisted_14$1, [
                  createVNode(_component_typer, {
                    text: $props.block.label || $props.block.content,
                    story: $props.story,
                    variables: $props.tags,
                    allowImages: true,
                    onEnd: _cache[15] || (_cache[15] = ($event) => $options.finished($props.block)),
                    class: "padded"
                  }, null, 8, ["text", "story", "variables"])
                ])
              ], 4)
            ])) : $props.block.type === "video" ? (openBlock(), createElementBlock("div", _hoisted_15$1, [
              $props.block.youtube ? (openBlock(), createElementBlock("iframe", {
                key: 0,
                src: `https://www.youtube-nocookie.com/embed/${$props.block.youtube}`,
                title: _ctx.$t("video_content.youtube-video-player"),
                frameborder: "0",
                allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",
                allowfullscreen: "",
                autoplay: ""
              }, null, 8, _hoisted_16$1)) : createCommentVNode("", true)
            ])) : $props.block.type === "battle" ? (openBlock(), createBlock(_component_battle, {
              key: 8,
              contestants: _ctx.readerStore.combatants,
              rounds: $props.block.rounds,
              story: $props.story,
              onCharacterImage: $options.handleBattleCharacterImage,
              onFinished: $options.handleBattleOver
            }, null, 8, ["contestants", "rounds", "story", "onCharacterImage", "onFinished"])) : (openBlock(), createElementBlock("p", _hoisted_17$1, "Don't know what this is: " + toDisplayString$1($props.block), 1))
          ];
        }),
        _: 1
      }, 8, ["onTransitionstart", "onTransitionend", "steps"])
    ]),
    _: 1
  }, 8, ["id", "animations"]);
}
const ReaderContent = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5], ["__scopeId", "data-v-6fe508a6"]]);
const _sfc_main$4 = {
  name: "ReaderArea",
  components: {
    ReaderContent,
    HeightTransition,
    ScrollSticker
  },
  props: {
    modelValue: Boolean,
    // idle
    story: Object,
    name: String,
    activeName: String,
    picks: Object,
    blocks: Array,
    tags: Object,
    bottom: { type: Boolean, value: false },
    canExplore: { type: Boolean, default: false }
  },
  data() {
    return {
      optionChoices: {},
      optionPoints: {},
      moreIndicator: false
    };
  },
  computed: {
    filteredBlocks() {
      return this.blocks.filter((block) => {
        var _a;
        return block.type !== "choice" || !((_a = block.glyphs) == null ? void 0 : _a.length);
      });
    },
    exploreChoice() {
      return this.blocks.find((block) => {
        var _a;
        return block.type === "choice" && ((_a = block.glyphs) == null ? void 0 : _a.length) > 0;
      });
    },
    lastBlock() {
      if (this.blocks.length > 0) {
        return this.blocks[this.blocks.length - 1];
      }
      return null;
    },
    showExplorePrompt() {
      return this.canExplore && !!this.exploreChoice && ["choice", "choice-timer"].includes(this.lastBlock.type);
    },
    optionUses() {
      const retval = {};
      for (const choice2 in this.optionChoices) {
        const option = this.blocks.find((b) => b.id == choice2);
        if (option && option.points) {
          if (!retval[option.points]) {
            retval[option.points] = 0;
          }
          retval[option.points] += this.optionChoices[choice2];
        }
      }
      return retval;
    },
    active() {
      return this.name === this.activeName;
    },
    blocking() {
      return this.blocks.filter((b) => ["timer"].indexOf(b.type) === -1);
    },
    hasOptions() {
      return this.blocks.filter((b) => b.type === "option").length > 0;
    }
  },
  watch: {
    modelValue() {
      if (this.modelValue && this.hasOptions) {
        this.handleOptions();
      }
    },
    blocks: {
      handler(ov, nv) {
        if (this.filteredBlocks.length > 0) {
          this.startScroller();
        }
        this.moreIndicator = false;
      },
      deep: true
    },
    blocking: {
      handler(ov, nv) {
        if (this.blocking.length > 0) {
          this.$emit("update:modelValue", false);
        } else {
          this.$emit("update:modelValue", true);
        }
      },
      deep: true
    }
  },
  unmounted() {
    this.stopScroller();
  },
  methods: {
    async handleOptions() {
      await new Promise((r) => setTimeout(r, 100));
      if (this.modelValue && this.hasOptions) {
        this.optionChoices = {};
        const points = {};
        for (const option of this.blocks.filter((b) => b.type === "option" && b.points)) {
          points[option.points] = true;
        }
        for (const key in points) {
          points[key] = runFormula(this.story, key, this.tags);
        }
        this.optionPoints = points;
        this.$emit("show-next-button", true);
      }
    },
    handleOptionChange(packet) {
      const option = packet.option;
      if (!this.optionChoices[option.id]) {
        this.optionChoices[option.id] = 0;
      }
      const step = option.step || 1;
      const uses = option.points ? this.optionUses[option.points] || 0 : null;
      const value = this.optionChoices[option.id] || 0;
      let max2 = option.max;
      if (option.points) {
        max2 = Math.min(max2 || 1, option.points - uses + value);
      }
      let target = value;
      if (packet.action === "toggle") {
        if (this.optionChoices[option.id]) {
          target = 0;
        } else if (step <= max2 || 1) {
          target = step;
        }
      } else if (packet.action === "up" && max2 > 0 && value + step <= max2) {
        target = value + step;
      } else if (packet.action === "down" && value - step >= (option.min || 0)) {
        target = value - step;
      }
      let valid = true;
      if (max2 || max2 === 0) {
        valid &= max2 >= target;
      }
      if (option.min) {
        valid &= target <= option.min;
      }
      if (valid) {
        this.optionChoices[option.id] = target;
        const valued = {};
        for (const key in this.optionChoices) {
          if (this.optionChoices[key] > 0) {
            valued[key] = this.optionChoices[key];
          }
        }
        this.$emit("option-choices", valued);
      }
    },
    handleChoice(e2) {
      if (this.modelValue) {
        this.$emit("choice", e2);
      } else {
        console.log("ignored choice while typing/animating");
      }
    },
    handleFinished(e2, index2) {
      if (this.filteredBlocks.length - 1 === index2) {
        this.$emit("update:modelValue", true);
        if (this.active) {
          this.$emit("finished");
        }
      }
    },
    handleScroll(e2) {
      clearTimeout(this._handleScroll);
      this._handleScroll = setTimeout(() => {
        const bottom = window.innerHeight - 50;
        const ref2 = this.$refs.bottom;
        const rect = ref2.getBoundingClientRect();
        this.moreIndicator = !(rect.top >= 50 && rect.bottom <= bottom + 25);
      }, 100);
    },
    hurry() {
      for (const block of this.filteredBlocks) {
        const ref2 = this.$refs[`block_${block.id}`];
        if (ref2 && ref2.length > 0 && ref2[0].hurry) {
          ref2[0].hurry();
        }
      }
    },
    scrollToBottom() {
      let scrolled = false;
      const box = this.$el.getBoundingClientRect();
      if (box.bottom - 10 <= box.height) {
        this.$refs.bottom.scrollIntoView({ block: "end", inline: "end" });
        scrolled = true;
      }
      if (!scrolled) {
        this.stopScroller();
      }
    },
    startScroller() {
      this.__scroller = requestAnimationFrame(() => {
        this.startScroller();
      });
    },
    stopScroller() {
      cancelAnimationFrame(this.__scroller);
    }
  }
};
const _hoisted_1$3 = {
  key: 0,
  class: "flex-stretch no-touch"
};
const _hoisted_2$2 = { class: "option-remaining block" };
const _hoisted_3$2 = {
  key: 2,
  class: "flex-row flex-center flex-align-center flex-static"
};
const _hoisted_4$1 = {
  class: "scroll-snap",
  ref: "bottom"
};
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_reader_content = resolveComponent("reader-content");
  const _component_height_transition = resolveComponent("height-transition");
  const _component_ScrollSticker = resolveComponent("ScrollSticker");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["area", { [$props.name]: true, active: $options.active }]),
    key: $props.name,
    draggable: "false",
    onScroll: _cache[3] || (_cache[3] = (...args) => $options.handleScroll && $options.handleScroll(...args))
  }, [
    $props.bottom ? (openBlock(), createElementBlock("div", _hoisted_1$3)) : createCommentVNode("", true),
    (openBlock(true), createElementBlock(Fragment, null, renderList($options.filteredBlocks, (block, index2) => {
      return openBlock(), createBlock(_component_reader_content, {
        key: block.id,
        story: $props.story,
        picks: $props.picks,
        block,
        "option-choices": $data.optionChoices,
        first: index2 === 0,
        last: index2 === $options.filteredBlocks.length - 1,
        ref_for: true,
        ref: `block_${block.id}`,
        idle: $props.modelValue,
        tags: $props.tags,
        onUserInput: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("user-input", $event)),
        onChoice: $options.handleChoice,
        onFinished: ($event) => $options.handleFinished($event, index2),
        onOption: $options.handleOptionChange
      }, null, 8, ["story", "picks", "block", "option-choices", "first", "last", "idle", "tags", "onChoice", "onFinished", "onOption"]);
    }), 128)),
    $options.hasOptions && Object.keys($data.optionPoints).length > 0 ? (openBlock(), createBlock(_component_height_transition, {
      key: 1,
      class: "flex-static"
    }, {
      default: withCtx(() => [
        createBaseVNode("div", _hoisted_2$2, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($data.optionPoints, (key) => {
            return openBlock(), createElementBlock("span", null, toDisplayString$1($data.optionPoints[key] - ($options.optionUses[key] || 0)) + " / " + toDisplayString$1(key), 1);
          }), 256))
        ])
      ]),
      _: 1
    })) : createCommentVNode("", true),
    $options.showExplorePrompt ? (openBlock(), createElementBlock("div", _hoisted_3$2, [
      createBaseVNode("button", {
        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("explore"))
      }, [
        _cache[4] || (_cache[4] = createBaseVNode("i", { class: "fa fa-compass" }, null, -1)),
        createTextVNode(" " + toDisplayString$1($options.exploreChoice.prompt || "Explore Background"), 1)
      ])
    ])) : createCommentVNode("", true),
    $data.moreIndicator ? (openBlock(), createElementBlock("div", {
      key: 3,
      onClick: _cache[2] || (_cache[2] = (...args) => $options.scrollToBottom && $options.scrollToBottom(...args)),
      class: "more"
    }, _cache[5] || (_cache[5] = [
      createBaseVNode("i", { class: "fa fa-chevron-down" }, null, -1)
    ]))) : createCommentVNode("", true),
    createBaseVNode("span", _hoisted_4$1, null, 512),
    createVNode(_component_ScrollSticker)
  ], 34);
}
const ReaderArea = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4], ["__scopeId", "data-v-58474d01"]]);
var lib = {};
var estimators = {};
var I = function() {
  return { a: 1, b: 0, x: 0, y: 0 };
};
var L = function(domain, range, angle) {
  const N = Math.min(domain.length, range.length);
  let a = 0;
  let b = 0;
  let c = 0;
  let d = 0;
  const co = Math.cos(angle);
  const si = Math.sin(angle);
  if (N < 1) {
    return { a: 1, b: 0, x: 0, y: 0 };
  }
  for (let i = 0; i < N; i += 1) {
    a += domain[i].x;
    b += domain[i].y;
    c += range[i].x;
    d += range[i].y;
  }
  const t = (co * (c - a) + si * (d - b)) / N;
  const tx = t * co;
  const ty = t * si;
  return {
    a: 1,
    b: 0,
    x: tx,
    y: ty
  };
};
var X = function(domain, range) {
  const N = Math.min(domain.length, range.length);
  if (N < 1) {
    return { a: 1, b: 0, x: 0, y: 0 };
  }
  let dxs = 0;
  let rxs = 0;
  for (let i = 0; i < N; i += 1) {
    dxs += domain[i].x;
    rxs += range[i].x;
  }
  return {
    a: 1,
    b: 0,
    x: (rxs - dxs) / N,
    y: 0
  };
};
var Y = function(domain, range) {
  const N = Math.min(domain.length, range.length);
  if (N < 1) {
    return { a: 1, b: 0, x: 0, y: 0 };
  }
  let dys = 0;
  let rys = 0;
  for (let i = 0; i < N; i += 1) {
    dys += domain[i].y;
    rys += range[i].y;
  }
  return {
    a: 1,
    b: 0,
    x: 0,
    y: (rys - dys) / N
  };
};
var T = function(domain, range) {
  const N = Math.min(domain.length, range.length);
  if (N < 1) {
    return { a: 1, b: 0, x: 0, y: 0 };
  }
  let dxs = 0;
  let dys = 0;
  let rxs = 0;
  let rys = 0;
  for (let i = 0; i < N; i += 1) {
    dxs += domain[i].x;
    dys += domain[i].y;
    rxs += range[i].x;
    rys += range[i].y;
  }
  const xhat = (rxs - dxs) / N;
  const yhat = (rys - dys) / N;
  return {
    a: 1,
    b: 0,
    x: xhat,
    y: yhat
  };
};
var tolerance = 1e-10;
const TOLERANCE$b = tolerance;
var S = function(domain, range, center) {
  const N = Math.min(domain.length, range.length);
  let ac = 0;
  let bd = 0;
  let aa = 0;
  let bb = 0;
  const cx = center.x;
  const cy = center.y;
  let i, a, b, c, d;
  for (i = 0; i < N; i += 1) {
    a = domain[i].x - cx;
    b = domain[i].y - cy;
    c = range[i].x - cx;
    d = range[i].y - cy;
    ac += a * c;
    bd += b * d;
    aa += a * a;
    bb += b * b;
  }
  const det = aa + bb;
  if (Math.abs(det) < TOLERANCE$b) {
    return { a: 1, b: 0, x: 0, y: 0 };
  }
  const ahat = Math.max(0, (ac + bd) / det);
  const xhat = (1 - ahat) * cx;
  const yhat = (1 - ahat) * cy;
  return {
    a: ahat,
    b: 0,
    x: xhat,
    y: yhat
  };
};
const TOLERANCE$a = tolerance;
var R = function(domain, range, center) {
  const N = Math.min(domain.length, range.length);
  let ac = 0;
  let ad = 0;
  let bc = 0;
  let bd = 0;
  const cx = center.x;
  const cy = center.y;
  let i, a, b, c, d;
  for (i = 0; i < N; i += 1) {
    a = domain[i].x - cx;
    b = domain[i].y - cy;
    c = range[i].x - cx;
    d = range[i].y - cy;
    ac += a * c;
    ad += a * d;
    bc += b * c;
    bd += b * d;
  }
  const p2 = ac + bd;
  const q = ad - bc;
  const det = Math.sqrt(p2 * p2 + q * q);
  if (Math.abs(det) < TOLERANCE$a) {
    return { a: 1, b: 0, x: 0, y: 0 };
  }
  const ahat = p2 / det;
  const bhat = q / det;
  const xhat = cx - cx * ahat + cy * bhat;
  const yhat = cy - cx * bhat - cy * ahat;
  return {
    a: ahat,
    b: bhat,
    x: xhat,
    y: yhat
  };
};
const TOLERANCE$9 = tolerance;
var TS = function(domain, range) {
  const N = Math.min(domain.length, range.length);
  let a1 = 0;
  let b1 = 0;
  let c1 = 0;
  let d1 = 0;
  let a2 = 0;
  let b2 = 0;
  let ac = 0;
  let bd = 0;
  let i, a, b, c, d;
  for (i = 0; i < N; i += 1) {
    a = domain[i].x;
    b = domain[i].y;
    c = range[i].x;
    d = range[i].y;
    a1 += a;
    b1 += b;
    c1 += c;
    d1 += d;
    a2 += a * a;
    b2 += b * b;
    ac += a * c;
    bd += b * d;
  }
  const N2 = N * N;
  const a12 = a1 * a1;
  const b12 = b1 * b1;
  const p2 = a2 + b2;
  const q = ac + bd;
  const det = N2 * p2 - N * (a12 + b12);
  if (Math.abs(det) < TOLERANCE$9) {
    if (N === 0) {
      return { a: 1, b: 0, x: 0, y: 0 };
    }
    return {
      a: 1,
      b: 0,
      x: c1 / N - a,
      y: d1 / N - b
    };
  }
  const ahat = (N2 * q - N * (a1 * c1 + b1 * d1)) / det;
  const xhat = (-N * a1 * q + N * c1 * p2 - b12 * c1 + a1 * b1 * d1) / det;
  const yhat = (-N * b1 * q + N * d1 * p2 - a12 * d1 + a1 * b1 * c1) / det;
  return {
    a: ahat,
    b: 0,
    x: xhat,
    y: yhat
  };
};
const TOLERANCE$8 = tolerance;
var TR = function(domain, range) {
  const N = Math.min(domain.length, range.length);
  let asum = 0;
  let bsum = 0;
  let csum = 0;
  let dsum = 0;
  let ac = 0;
  let ad = 0;
  let bc = 0;
  let bd = 0;
  let i, a, b, c, d;
  for (i = 0; i < N; i += 1) {
    a = domain[i].x;
    b = domain[i].y;
    c = range[i].x;
    d = range[i].y;
    asum += a;
    bsum += b;
    csum += c;
    dsum += d;
    ac += a * c;
    ad += a * d;
    bc += b * c;
    bd += b * d;
  }
  const v = N * (ac + bd) - asum * csum - bsum * dsum;
  const w = N * (ad - bc) - asum * dsum + bsum * csum;
  const det = Math.sqrt(v * v + w * w);
  if (det < TOLERANCE$8) {
    if (N === 0) {
      return { a: 1, b: 0, x: 0, y: 0 };
    }
    return {
      a: 1,
      b: 0,
      x: (csum - asum) / N,
      y: (dsum - bsum) / N
    };
  }
  const ahat = v / det;
  const bhat = w / det;
  const xhat = (-asum * ahat + bsum * bhat + csum) / N;
  const yhat = (-asum * bhat - bsum * ahat + dsum) / N;
  return {
    a: ahat,
    b: bhat,
    x: xhat,
    y: yhat
  };
};
const TOLERANCE$7 = tolerance;
var SR = function(domain, range, center) {
  const N = Math.min(domain.length, range.length);
  const cx = center.x;
  const cy = center.y;
  let a2 = 0;
  let b2 = 0;
  let ac = 0;
  let bd = 0;
  let bc = 0;
  let ad = 0;
  let i, a, b, c, d;
  for (i = 0; i < N; i += 1) {
    a = domain[i].x - cx;
    b = domain[i].y - cy;
    c = range[i].x - cx;
    d = range[i].y - cy;
    a2 += a * a;
    b2 += b * b;
    ac += a * c;
    bd += b * d;
    bc += b * c;
    ad += a * d;
  }
  const det = a2 + b2;
  if (Math.abs(det) < TOLERANCE$7) {
    return { a: 1, b: 0, x: 0, y: 0 };
  }
  const ahat = (ac + bd) / det;
  const bhat = (-bc + ad) / det;
  const xhat = cy * bhat - cx * ahat + cx;
  const yhat = -cx * bhat - cy * ahat + cy;
  return {
    a: ahat,
    b: bhat,
    x: xhat,
    y: yhat
  };
};
const TOLERANCE$6 = tolerance;
var TSR = function(domain, range) {
  const N = Math.min(domain.length, range.length);
  if (N === 0) {
    return { a: 1, b: 0, x: 0, y: 0 };
  }
  let a1 = 0;
  let b1 = 0;
  let c1 = 0;
  let d1 = 0;
  let a2 = 0;
  let b2 = 0;
  let ad = 0;
  let bc = 0;
  let ac = 0;
  let bd = 0;
  let i, a, b, c, d;
  for (i = 0; i < N; i += 1) {
    a = domain[i].x;
    b = domain[i].y;
    c = range[i].x;
    d = range[i].y;
    a1 += a;
    b1 += b;
    c1 += c;
    d1 += d;
    a2 += a * a;
    b2 += b * b;
    ad += a * d;
    bc += b * c;
    ac += a * c;
    bd += b * d;
  }
  const det = N * a2 + N * b2 - a1 * a1 - b1 * b1;
  if (Math.abs(det) < TOLERANCE$6) {
    return {
      a: 1,
      b: 0,
      x: c1 / N - a,
      y: d1 / N - b
    };
  }
  const ahat = (N * (ac + bd) - a1 * c1 - b1 * d1) / det;
  const bhat = (N * (ad - bc) + b1 * c1 - a1 * d1) / det;
  const xhat = (-a1 * (ac + bd) + b1 * (ad - bc) + a2 * c1 + b2 * c1) / det;
  const yhat = (-b1 * (ac + bd) - a1 * (ad - bc) + a2 * d1 + b2 * d1) / det;
  return {
    a: ahat,
    b: bhat,
    x: xhat,
    y: yhat
  };
};
estimators.I = I;
estimators.L = L;
estimators.X = X;
estimators.Y = Y;
estimators.T = T;
estimators.S = S;
estimators.R = R;
estimators.TS = TS;
estimators.TR = TR;
estimators.SR = SR;
estimators.TSR = TSR;
const es = estimators;
var estimate = function(params) {
  switch (params.estimator.toUpperCase()) {
    case "I":
      return es.I();
    case "L":
      return es.L(params.domain, params.range, params.angle);
    case "X":
      return es.X(params.domain, params.range);
    case "Y":
      return es.Y(params.domain, params.range);
    case "T":
      return es.T(params.domain, params.range);
    case "S":
      return es.S(params.domain, params.range, params.center);
    case "R":
      return es.R(params.domain, params.range, params.center);
    case "TS":
      return es.TS(params.domain, params.range);
    case "TR":
      return es.TR(params.domain, params.range);
    case "SR":
      return es.SR(params.domain, params.range, params.center);
    case "TSR":
      return es.TSR(params.domain, params.range);
    default:
      throw new Error("Unknown estimator type: " + params.type);
  }
};
var point = {};
const TOLERANCE$5 = tolerance;
var almostEqual$1 = function(p2, q, tolerance2) {
  if (typeof tolerance2 !== "number") {
    tolerance2 = TOLERANCE$5;
  }
  const dx = Math.abs(p2.x - q.x);
  const dy = Math.abs(p2.y - q.y);
  return dx <= tolerance2 && dy <= tolerance2;
};
var create$1 = (x, y) => {
  return {
    x,
    y
  };
};
var distance$1 = (p2, q) => {
  const dx = p2.x - q.x;
  const dy = p2.y - q.y;
  return Math.sqrt(dx * dx + dy * dy);
};
var equal$1 = (p2, q) => {
  return p2.x === q.x && p2.y === q.y;
};
var fromArray$1 = (arrp) => {
  if (arrp.length !== 2) {
    throw new Error("Cannot read a point from array: " + JSON.stringify(arrp));
  }
  return {
    x: arrp[0],
    y: arrp[1]
  };
};
var offset = (p2, dx, dy) => {
  return {
    x: p2.x + dx,
    y: p2.y + dy
  };
};
var polarOffset = (p2, distance2, angle) => {
  return {
    x: p2.x + distance2 * Math.cos(angle),
    y: p2.y + distance2 * Math.sin(angle)
  };
};
var toArray$1 = (p2) => {
  return [p2.x, p2.y];
};
var transform$2 = function(p2, tr) {
  return {
    x: tr.a * p2.x - tr.b * p2.y + tr.x,
    y: tr.b * p2.x + tr.a * p2.y + tr.y
  };
};
const transform$1 = transform$2;
var transformMany$3 = (points, tr) => {
  if (!Array.isArray(points)) {
    const type2 = typeof points;
    const msg = "Expected an array but saw " + type2 + " instead.";
    throw TypeError(msg);
  }
  const ps = [];
  for (let i = 0; i < points.length; i += 1) {
    ps.push(transform$1(points[i], tr));
  }
  return ps;
};
var validate$1 = (p2) => {
  if (typeof p2.x !== "number" || !Number.isFinite(p2.x)) {
    return false;
  }
  if (typeof p2.y !== "number" || !Number.isFinite(p2.y)) {
    return false;
  }
  return true;
};
point.almostEqual = almostEqual$1;
point.create = create$1;
point.distance = distance$1;
point.equal = equal$1;
point.fromArray = fromArray$1;
point.offset = offset;
point.polarOffset = polarOffset;
point.toArray = toArray$1;
point.transform = transform$2;
point.transformMany = transformMany$3;
point.validate = validate$1;
var transform4 = {};
const TOLERANCE$4 = tolerance;
var almostEqual = function(tr, ts, tolerance2) {
  if (typeof tolerance2 !== "number") {
    tolerance2 = TOLERANCE$4;
  }
  const da = Math.abs(tr.a - ts.a);
  const db = Math.abs(tr.b - ts.b);
  const dx = Math.abs(tr.x - ts.x);
  const dy = Math.abs(tr.y - ts.y);
  return da + db + dx + dy <= tolerance2;
};
var compose = function(tr, ts) {
  return {
    a: tr.a * ts.a - tr.b * ts.b,
    b: tr.a * ts.b + tr.b * ts.a,
    x: tr.a * ts.x - tr.b * ts.y + tr.x,
    y: tr.b * ts.x + tr.a * ts.y + tr.y
  };
};
var create = function(a, b, x, y) {
  return {
    a,
    b,
    x,
    y
  };
};
var equal = function(tr, ts) {
  return tr.a === ts.a && tr.b === ts.b && tr.x === ts.x && tr.y === ts.y;
};
var fromArray = (arrtr) => {
  return {
    a: arrtr[0],
    b: arrtr[1],
    x: arrtr[2],
    y: arrtr[3]
  };
};
var fromPolar = function(center, scale, rotation) {
  const cx = center.x;
  const cy = center.y;
  const m = scale;
  if (m < 0) {
    const msg = "Expected zero or positive scale factor but negative: ";
    throw new Error(msg + m);
  }
  const co = Math.cos(rotation);
  const si = Math.sin(rotation);
  const ahat = co;
  const bhat = si;
  const xhat = -cx * co + cy * si + cx;
  const yhat = -cx * si - cy * co + cy;
  return {
    a: m * ahat,
    b: m * bhat,
    x: m * xhat + (1 - m) * cx,
    y: m * yhat + (1 - m) * cy
  };
};
var fromRotation = function(center, radians) {
  const co = Math.cos(radians);
  const si = Math.sin(radians);
  const cx = center.x;
  const cy = center.y;
  const ahat = co;
  const bhat = si;
  const xhat = -cx * co + cy * si + cx;
  const yhat = -cx * si - cy * co + cy;
  return {
    a: ahat,
    b: bhat,
    x: xhat,
    y: yhat
  };
};
var fromScale = function(center, multiplier) {
  const cx = center.x;
  const cy = center.y;
  const m = multiplier;
  if (m < 0) {
    const msg = "Expected zero or positive scale factor but saw negative: ";
    throw new Error(msg + m);
  }
  return {
    a: m,
    b: 0,
    x: (1 - m) * cx,
    y: (1 - m) * cy
  };
};
const cssMatrix = /\s*matrix\(([-+\w ,.%]+)\)/;
const cssMatrixDelimiter = /\s*,\s*/;
var fromString = function(str) {
  const matrixMatch = str.match(cssMatrix);
  if (!matrixMatch) {
    throw new Error("Invalid CSS matrix string: " + str);
  }
  const elemStrings = matrixMatch[1].split(cssMatrixDelimiter);
  const elems = elemStrings.map((els) => parseFloat(els));
  return {
    a: elems[0],
    b: elems[1],
    x: elems[4],
    y: elems[5]
  };
};
var fromTranslation = function(p2) {
  return {
    a: 1,
    b: 0,
    x: p2.x,
    y: p2.y
  };
};
var getRotation = function(tr) {
  return Math.atan2(tr.b, tr.a);
};
var getScale = function(tr) {
  return Math.sqrt(tr.b * tr.b + tr.a * tr.a);
};
var getTranslation = function(tr) {
  return {
    x: tr.x,
    y: tr.y
  };
};
const TOLERANCE$3 = tolerance;
var inverse = function(tr) {
  const det = tr.a * tr.a + tr.b * tr.b;
  if (Math.abs(det) < TOLERANCE$3) {
    throw new Error("Singular transformations cannot be inversed.");
  }
  const ahat = tr.a / det;
  const bhat = -tr.b / det;
  const xhat = (-tr.a * tr.x - tr.b * tr.y) / det;
  const yhat = (tr.b * tr.x - tr.a * tr.y) / det;
  return {
    a: ahat,
    b: bhat,
    x: xhat,
    y: yhat
  };
};
var rotateBy$1 = function(tr, center, radians) {
  const co = Math.cos(radians);
  const si = Math.sin(radians);
  const cx = center.x;
  const cy = center.y;
  const ahat = tr.a * co - tr.b * si;
  const bhat = tr.a * si + tr.b * co;
  const xhat = (tr.x - cx) * co - (tr.y - cy) * si + cx;
  const yhat = (tr.x - cx) * si + (tr.y - cy) * co + cy;
  return {
    a: ahat,
    b: bhat,
    x: xhat,
    y: yhat
  };
};
const rotateBy = rotateBy$1;
var rotateTo = function(tr, center, radians) {
  const r = Math.atan2(tr.b, tr.a);
  return rotateBy(tr, center, radians - r);
};
const TOLERANCE$2 = tolerance;
var scaleBy$1 = function(tr, center, multiplier) {
  const m = multiplier;
  const cx = center.x;
  const cy = center.y;
  if (m < TOLERANCE$2) {
    const msg = "Expected positive scale factor but saw zero or negative: ";
    throw new Error(msg + m);
  }
  return {
    a: m * tr.a,
    b: m * tr.b,
    x: m * tr.x + (1 - m) * cx,
    y: m * tr.y + (1 - m) * cy
  };
};
const scaleBy = scaleBy$1;
const TOLERANCE$1 = tolerance;
var scaleTo = function(tr, center, scale) {
  const orig = Math.sqrt(tr.a * tr.a + tr.b * tr.b);
  if (orig < TOLERANCE$1) {
    throw new Error("Cannot scale singular transformation");
  }
  return scaleBy(tr, center, scale / orig);
};
var toArray = function(tr) {
  return [tr.a, tr.b, tr.x, tr.y];
};
var toMatrix = function(tr) {
  return {
    a: tr.a,
    b: tr.b,
    c: -tr.b,
    d: tr.a,
    e: tr.x,
    f: tr.y
  };
};
var toString = function(tr) {
  const a = tr.a.toFixed(8);
  const b = tr.b.toFixed(8);
  const c = (-tr.b).toFixed(8);
  const x = tr.x.toFixed(8);
  const y = tr.y.toFixed(8);
  return "matrix(" + a + "," + b + "," + c + "," + a + "," + x + "," + y + ")";
};
var translateBy = function(tr, vec) {
  return {
    a: tr.a,
    b: tr.b,
    x: tr.x + vec.x,
    y: tr.y + vec.y
  };
};
var translateTo = function(tr, point2) {
  return {
    a: tr.a,
    b: tr.b,
    x: point2.x,
    y: point2.y
  };
};
const TOLERANCE = tolerance;
var validate = (tr) => {
  if (typeof tr.a !== "number") {
    return false;
  }
  if (typeof tr.b !== "number") {
    return false;
  }
  if (typeof tr.x !== "number") {
    return false;
  }
  if (typeof tr.y !== "number") {
    return false;
  }
  if (tr.a * tr.a + tr.b * tr.b < TOLERANCE) {
    return false;
  }
  return true;
};
(function(exports) {
  exports.SINGULAR = {
    a: 0,
    b: 0,
    x: 0,
    y: 0
  };
  exports.IDENTITY = {
    a: 1,
    b: 0,
    x: 0,
    y: 0
  };
  const isqrt2 = 1 / Math.sqrt(2);
  exports.ROT45 = { a: isqrt2, b: isqrt2, x: 0, y: 0 };
  exports.ROT90 = { a: 0, b: 1, x: 0, y: 0 };
  exports.ROT180 = { a: -1, b: 0, x: 0, y: 0 };
  exports.ROT270 = { a: 0, b: -1, x: 0, y: 0 };
  exports.HALF = { a: 0.5, b: 0, x: 0, y: 0 };
  exports.X2 = { a: 2, b: 0, x: 0, y: 0 };
  exports.almostEqual = almostEqual;
  exports.compose = compose;
  exports.create = create;
  exports.equal = equal;
  exports.fromArray = fromArray;
  exports.fromPolar = fromPolar;
  exports.fromRotation = fromRotation;
  exports.fromScale = fromScale;
  exports.fromString = fromString;
  exports.fromTranslation = fromTranslation;
  exports.getRotation = getRotation;
  exports.getScale = getScale;
  exports.getTranslation = getTranslation;
  exports.multiply = exports.compose;
  exports.inverse = inverse;
  exports.rotateBy = rotateBy$1;
  exports.rotateTo = rotateTo;
  exports.scaleBy = scaleBy$1;
  exports.scaleTo = scaleTo;
  exports.toArray = toArray;
  exports.toMatrix = toMatrix;
  exports.toString = toString;
  exports.translateBy = translateBy;
  exports.translateTo = translateTo;
  exports.validate = validate;
})(transform4);
var analysis = {};
const transformMany$2 = transformMany$3;
var mse = (tr, domain, range) => {
  const n = Math.min(domain.length, range.length);
  const codomain = transformMany$2(domain, tr);
  let sum = 0;
  let dx, dy;
  for (let i = 0; i < n; i += 1) {
    dx = codomain[i].x - range[i].x;
    dy = codomain[i].y - range[i].y;
    sum += dx * dx + dy * dy;
  }
  return sum / n;
};
const distance = distance$1;
const transformMany$1 = transformMany$3;
var residuals = (tr, domain, range) => {
  const n = Math.min(domain.length, range.length);
  const codomain = transformMany$1(domain, tr);
  const arr = [];
  for (let i = 0; i < n; i += 1) {
    arr.push(distance(codomain[i], range[i]));
  }
  return arr;
};
const transformMany = transformMany$3;
var rss = (tr, domain, range) => {
  const n = Math.min(domain.length, range.length);
  const codomain = transformMany(domain, tr);
  let sum = 0;
  let dx, dy;
  for (let i = 0; i < n; i += 1) {
    dx = codomain[i].x - range[i].x;
    dy = codomain[i].y - range[i].y;
    sum += dx * dx + dy * dy;
  }
  return sum;
};
analysis.mse = mse;
analysis.residuals = residuals;
analysis.rss = rss;
var version = "2.0.0";
lib.estimate = estimate;
lib.estimators = estimators;
lib.point = point;
lib.transform = transform4;
lib.analysis = analysis;
lib.tolerance = tolerance;
lib.version = version;
var nudged = lib;
const nudged$1 = /* @__PURE__ */ getDefaultExportFromCjs(nudged);
class Explore {
  constructor({ width, height, scale } = { width: 100, height: 100, scale: 1 }, screen = null) {
    __publicField(this, "width");
    __publicField(this, "height");
    __publicField(this, "move");
    __publicField(this, "offset");
    __publicField(this, "start");
    __publicField(this, "end");
    __publicField(this, "position");
    __publicField(this, "screen");
    __publicField(this, "minScale", 1);
    __publicField(this, "maxScale", 1);
    this.width = width;
    this.height = height;
    this.start = {};
    this.end = {};
    this.offset = { x: 0, y: 0 };
    this.changeContainer(screen, scale);
  }
  get x() {
    return this.position.x + this.move.x;
  }
  get y() {
    return this.position.y + this.move.y;
  }
  get scale() {
    var _a, _b;
    return ((_a = this.position) == null ? void 0 : _a.scale) * ((_b = this.move) == null ? void 0 : _b.scale) || 1;
  }
  get w() {
    return this.width * this.scale - this.screen.x;
  }
  get h() {
    return this.height * this.scale - this.screen.y;
  }
  set x(v) {
    this.position.x = v - this.move.x;
  }
  set y(v) {
    this.position.y = v - this.move.y;
  }
  set scale(v) {
    this.position.scale = v / this.move.scale;
  }
  changeContainer(screen, scale = null) {
    if (scale === null) {
      scale = this.scale || 0;
    }
    if (screen) {
      this.screen = screen;
    } else {
      this.screen = { x: window.innerWidth, y: window.innerHeight };
    }
    this.minScale = Math.max(this.screen.x / this.width, this.screen.y / this.height);
    this.maxScale = Math.max(this.minScale, scale || 1) + 2;
    this.move = { x: 0, y: 0, scale: 1 };
    scale = Math.min(this.maxScale, Math.max(this.minScale, scale || 0));
    this.position = {
      x: this.screen.x / 2 - this.width * scale * 0.5,
      y: this.screen.y / 2 - this.height * scale * 0.5,
      scale
    };
  }
  handle(event) {
    if (event.type === "pointercancel") {
      console.log("pointercancel was sent, you need to set `touch-actions: none`");
      return;
    }
    let x = event.x - this.position.x - this.offset.x;
    let y = event.y - this.position.y - this.offset.y;
    if (event.type === "wheel") {
      const d = Math.max(
        this.minScale / this.position.scale,
        Math.min(this.maxScale / this.position.scale, 1 - event.deltaY * 5e-4)
      );
      this.start["wheel1"] = { x: x + 1, y };
      this.start["wheel2"] = { x: x - 1, y };
      this.end["wheel1"] = { x: x + 1 * d, y };
      this.end["wheel2"] = { x: x - 1 * d, y };
    } else {
      if (event.type === "pointerdown" && !this.start[event.pointerId]) {
        this.start[event.pointerId] = { x, y };
        event.preventDefault();
      }
      if (this.start[event.pointerId]) {
        this.end[event.pointerId] = { x, y };
      }
    }
    if (Object.keys(this.start).length > 0) {
      const keys = Object.keys(this.start);
      const move = nudged$1.estimate({
        estimator: "TS",
        domain: keys.map((k) => this.start[k]),
        range: keys.map((k) => this.end[k])
      });
      const mv = nudged$1.transform.getTranslation(move);
      const scale = nudged$1.transform.getScale(move);
      const s = Math.round(this.position.scale * scale * 10) / 10;
      if (s >= this.minScale && s <= this.maxScale) {
        this.move.scale = scale;
        this.move.x = Math.max(-this.w - this.position.x, Math.min(0 - this.position.x, mv.x));
        this.move.y = Math.max(-this.h - this.position.y, Math.min(0 - this.position.y, mv.y));
      }
      if (["pointerup", "wheel"].includes(event.type)) {
        this.position.scale = this.scale;
        this.position.x = this.x;
        this.position.y = this.y;
        this.move = { x: 0, y: 0, scale: 1 };
        this.start = {};
        this.end = {};
      }
    }
  }
}
const _sfc_main$3 = {
  props: {
    story: Story,
    backgrounds: Array,
    glyphs: {
      type: Array,
      default() {
        return [];
      }
    },
    exploring: { type: Boolean, default: false }
  },
  data() {
    return {
      explore: new Explore(),
      start: {},
      end: {},
      images: []
    };
  },
  computed: {
    zoom() {
      return this.backgrounds.reduce((a, b) => Math.max(a, b.zoom), 0) || 2;
    },
    zoomMin() {
      return this.backgrounds.reduce((a, b) => Math.max(a, b.zoomMin), 0) || 0;
    },
    zoomMax() {
      return this.backgrounds.reduce((a, b) => Math.max(a, b.zoomMax), 0) || 4;
    },
    xy() {
      return this.explore;
    },
    size() {
      return this.images.filter((i) => i).reduce(
        (a, b) => {
          return {
            x: Math.max(a.x, b.width),
            y: Math.max(a.y, b.height)
          };
        },
        { x: 0, y: 0 }
      );
    },
    isExplore() {
      return this.backgrounds.reduce((a, b) => {
        return a || b.size === "explore";
      }, false);
    }
  },
  watch: {
    backgrounds: {
      handler() {
        this.getSizes();
      },
      deep: true
    },
    isExplore() {
      this.$emit("update:exploring", this.isExplore);
    }
  },
  async mounted() {
    await this.getSizes();
    if (window.ResizeObserver) {
      this._resizer = new window.ResizeObserver(() => {
        this.getSizes();
      });
      this._resizer.observe(this.$el);
    }
  },
  async unmounted() {
    if (this._resizer) {
      this._resizer.disconnect();
    }
  },
  methods: {
    async getSizes() {
      this.images = await Promise.all(
        this.backgrounds.map((b) => {
          return Media.load(b.blob_id);
        })
      );
      this.explore = new Explore({
        width: this.size.x,
        height: this.size.y,
        scale: this.zoom
      });
      await new Promise((r) => setTimeout(r, 100));
      this.explore.changeContainer(null);
      this.explore.minScale = Math.max(this.explore.minScale, this.zoomMin);
      this.explore.maxScale = this.zoomMax;
    },
    handleClick(e2) {
      const refs = document.elementsFromPoint(e2.x, e2.y).filter((el) => el.classList.contains("glyph-dot"));
      if (refs.length > 0) {
        refs[0].click();
      }
    },
    handlePan(e2) {
      if (this.isExplore) {
        this.explore.handle(e2);
      }
    }
  }
};
const _hoisted_1$2 = ["onClick", "title"];
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(TransitionGroup, {
    class: "background-image",
    tag: "div",
    appear: "",
    name: "fade-slow",
    onPointermove: $options.handlePan,
    onPointerdown: $options.handlePan,
    onPointercancel: $options.handlePan,
    onPointerup: $options.handlePan,
    onWheel: withModifiers($options.handlePan, ["prevent"]),
    onClick: withModifiers($options.handleClick, ["prevent"])
  }, {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList($props.backgrounds, (bg) => {
        return openBlock(), createElementBlock("div", {
          key: `bg-${bg.id}`,
          class: normalizeClass({ bg: true, repeat: bg.repeat }),
          style: normalizeStyle({
            "background-color": bg.color ? bg.color : "",
            "background-image": bg.url ? `url(${bg.url})` : "",
            "background-repeat": bg.repeat ? "repeat" : "no-repeat",
            "background-size": bg.size === "explore" ? `${$options.size.x * $options.xy.scale}px ${$options.size.y * $options.xy.scale}px` : bg.size || "cover",
            "background-position": bg.size === "explore" ? `calc(${$options.xy.x}px) calc(${$options.xy.y}px)` : "",
            "transition-duration": `${$props.story.settings.bgSpeed || 3 + 1e-3}s !important`
          })
        }, null, 6);
      }), 128)),
      (openBlock(true), createElementBlock(Fragment, null, renderList($props.glyphs, (glyph) => {
        return openBlock(), createElementBlock("div", {
          key: `glyph-${glyph.id}`,
          class: normalizeClass(["glyph-dot", { "glyph-hidden": glyph.hidden }]),
          style: normalizeStyle({
            transform: `
          translate(${glyph.x * $options.xy.scale + $options.xy.x}px,
                    ${glyph.y * $options.xy.scale + $options.xy.y}px)
          scale(${$options.xy.scale / glyph.size})
        `,
            zIndex: 4
          }),
          onClick: ($event) => _ctx.$emit("glyph-click", glyph.choice),
          title: `glyph-${glyph.id}`
        }, null, 14, _hoisted_1$2);
      }), 128))
    ]),
    _: 1
  }, 8, ["onPointermove", "onPointerdown", "onPointercancel", "onPointerup", "onWheel", "onClick"]);
}
const ReaderBackgrounds = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3], ["__scopeId", "data-v-2dd444f2"]]);
const log = debug("over");
function timer(t) {
  return new Promise((r) => setTimeout(r, t));
}
const _sfc_main$2 = {
  name: "SceneReader",
  mixins: [MultiplayerMixin],
  components: {
    AuthorPlug,
    Comments,
    ReaderContent,
    ReaderArea,
    ReaderBackgrounds,
    DocumentKeycapture: _sfc_main$c
  },
  props: {
    story: Object,
    remoteApi: Function
  },
  data() {
    const defaultSettings = {
      persistence: this.story.settings.stackDialog ? "scene" : "block"
    };
    return {
      queue: new DeferredList(),
      picks: {},
      overlay: null,
      finished: false,
      waiting: { needs: [], has: [] },
      scene: null,
      reader: null,
      player: null,
      isIdle: false,
      audioVolume: 1,
      audioFade: 1,
      musicSrc: null,
      musicNextSrc: null,
      musicVolumeLocal: 1,
      musicVolume: 1,
      musicFade: 1,
      narrationVolume: 1,
      currentAudio: [],
      backgroundColor: null,
      backgroundImage: null,
      activeArea: "bottom",
      last: { id: -1 },
      areas: {
        top: { blocks: [], bgs: [], idle: true, settings: this.copy(defaultSettings) },
        bottom: { blocks: [], bgs: [], idle: true, settings: this.copy(defaultSettings) },
        left: { blocks: [], bgs: [], idle: true, settings: this.copy(defaultSettings) },
        right: { blocks: [], bgs: [], idle: true, settings: this.copy(defaultSettings) },
        over: { blocks: [], bgs: [], idle: true, settings: this.copy(defaultSettings) }
      },
      choiceCount: 0,
      showNextButton: false,
      optionChoices: null,
      exploring: false,
      canExplore: false,
      glyphs: [],
      tags: {},
      listeners: {
        idle: []
      },
      musicOnCanPlayThrough: (async function musicOnCanPlayThrough() {
        var _a;
        if ((_a = this.$refs) == null ? void 0 : _a.music) {
          this.$refs.music.play();
        }
        await this.fadeMusic();
      }).bind(this)
    };
  },
  computed: {
    directionsNeedingNext() {
      return ["video", "text", "image", "achievement"];
    },
    needsNextButton() {
      const hasContent = Object.keys(this.areas).some((key) => {
        const area = this.areas[key];
        return area.blocks.length > 0;
      });
      return this.showNextButton || hasContent && Object.keys(this.areas).every((key) => {
        const area = this.areas[key];
        return area.blocks.length === 0 || this.directionsNeedingNext.indexOf(area.blocks[area.blocks.length - 1].type) > -1;
      });
    },
    hasYourPick() {
      return !!this.picks[this.$root.user.id];
    },
    hasChoices() {
      return this.reader && this.choiceCount > 0;
    },
    settings() {
      const retval = {
        background: "lightgrey",
        deferTimer: true
      };
      for (const prop in this.story.settings) {
        retval[prop] = this.story.settings[prop];
      }
      return retval;
    },
    fadedMusicVolume() {
      return this.musicVolume * this.musicVolumeLocal * this.musicFade;
    },
    isClient() {
      return this.code && !this.$root.iamHosting;
    },
    isServer() {
      return this.code && this.$root.iamHosting;
    },
    /** is waiting for other players */
    isWaiting() {
      if (this.reader && this.code && this.waiting.needs.size > 0) {
        const player = this.reader.players.player(this.$root.user.id);
        if (player) {
          const party = this.reader.players.getParty(player.party);
          if (!party) {
            return true;
          } else {
            return this.waiting.has.some((g) => g === party.name);
          }
        } else {
          console.log("missing player?", this.reader.players.players);
        }
      }
      return false;
    },
    ...mapStores(useReaderStore)
  },
  watch: {
    areas: {
      handler() {
        var _a;
        let retval = true;
        for (const name in this.areas) {
          retval &= this.areas[name].idle;
        }
        clearTimeout(this.changeIsIdleTimeout);
        if (retval) {
          const speed = Math.max(((_a = this.story.settings) == null ? void 0 : _a.typeSpeed) || 30, 30);
          if (speed) {
            this.changeIsIdleTimeout = setTimeout(() => this.isIdle = true, speed);
          } else {
            this.isIdle = true;
          }
        } else {
          this.isIdle = false;
        }
      },
      deep: true
    },
    isIdle() {
      if (this.isIdle) {
        for (const listener of this.listeners.idle) {
          listener();
        }
      } else {
        this.exploring = false;
      }
    },
    currentAudio() {
      while (this.currentAudio.length > 10) {
        const audio = this.currentAudio.shift();
        this.disposeAudio(audio);
      }
    }
  },
  async mounted() {
    this.musicVolume = this.fetch("music-volume", 1);
    this.audioVolume = this.fetch("audio-volume", 1);
    this.narrationVolume = this.fetch("narration-volume", 1);
    this.$root.onInternal("audio-volume", (e2) => {
      this.audioVolume = e2;
      this.put("audio-volume", e2);
      for (const audio of this.currentAudio) {
        if (!audio.dataset.narration) {
          audio.volume = this.audioVolume;
        }
      }
    });
    this.$root.onInternal("music-volume", (e2) => {
      this.musicVolume = e2;
      this.put("music-volume", e2);
    });
    this.$root.onInternal("narration-volume", (e2) => {
      this.narrationVolume = e2;
      this.put("narration-volume", e2);
      for (const audio of this.currentAudio) {
        if (audio.dataset.narration) {
          audio.volume = this.narrationVolume;
        }
      }
    });
    this.gameEventListener = (event, data) => {
      if (this.isServer) {
        log(" *** server command", event, data);
      }
      if (this.isServer) {
        if (event === "player-next") {
          this.reader.next(data.user);
        } else if (event === "player-choice") {
          this.reader.choice(data.choice, data.user);
        } else if (event === "player-input") {
          this.reader.input(data.input, data.user);
        } else if (event === "player-options") {
          this.reader.options(data.options, data.user);
        }
      } else if (event === "reader") {
        log(" => remote event", event, data);
        this.handleReaderEvent(data);
      } else if (event === "restart") {
        this.$emit("restart");
      }
    };
    this.$root.onInternal("game-event", this.gameEventListener);
    if (this.remoteApi) {
      try {
        const author = await this.remoteApi("user_info", { id: this.story.uid });
        author.id = this.story.uid;
        if (!author.error) {
          this.author = author;
        }
      } catch (ex) {
        console.warn("failed to load user");
      }
    }
    if (this.code) {
      this.player = { tags: {}, choices: [], microcosms: [] };
      this.reader = new Reader(
        this.story,
        this.player,
        this.settings,
        this.handleReaderEvent,
        this.isClient
      );
      this.readerStore.reader = this.reader;
      for (const id of this.$root.playerIds) {
        log("added player", id, this.state[id].username);
        this.reader.players.add(id, this.state[id].username, id === this.$root.user.id);
      }
      if (this.$root.iamHosting) {
        this.reader.reset();
        this.reader.start();
        window.reader = this.reader;
      }
    } else {
      this.player = this.loadPlayer(this.story);
      console.log("starting single player", this.copy(this.player));
      this.reader = new Reader(this.story, this.player, this.settings, this.handleReaderEvent);
      this.readerStore.reader = this.reader;
      console.log("reader set");
      this.reader.start();
      window.reader = this.reader;
    }
    if (this.reader.scene) {
      this.$emit("update:sceneId", this.reader.scene.id);
    }
    this.queue.run();
    App$1.addListener("pause", () => {
      console.log("pause");
      for (const audio of this.currentAudio) {
        audio.pause();
      }
    });
    App$1.addListener("resume", () => {
      console.log("resume");
      for (const audio of this.currentAudio) {
        audio.play();
      }
    });
  },
  beforeUnmount() {
    this.silenceAudio();
    App$1.removeAllListeners();
  },
  unmounted() {
    this.$root.offInternal("game-event", this.gameEventListener);
  },
  methods: {
    async disposeAudio(audio) {
      audio.currentTime = 0;
      audio.pause();
    },
    async waitForIdle() {
      if (this.isIdle) {
        return;
      }
      return new Promise((r) => {
        this.listeners.idle.push(r);
      });
    },
    async clearBlocks(scene = false) {
      this.glyphs = [];
      for (const name in this.areas) {
        const area = this.areas[name];
        if (area.blocks.length > 0) {
          let shouldClear = true;
          if (area.settings.persistence === "scene") {
            shouldClear = scene;
          } else if (area.settings.persistence === "manual") {
            shouldClear = false;
          }
          if (shouldClear) {
            await this.forceClearBlocks(area);
          }
        }
      }
    },
    async forceClearBlocks(area) {
      const len = area.blocks.length;
      area.blocks = area.blocks.slice(len - 3, len);
      while (area.blocks.length > 0) {
        area.blocks.shift();
        await timer(100);
      }
    },
    async handleReaderEvent({ changed, value, party }) {
      if (this.isServer) {
        this.$root.playerSendEvent("reader", { changed, value, party });
      }
      const player = this.reader ? this.reader.players.player(this.$root.user.id) : { party: 0 };
      let inParty = true;
      if ((party || party === 0) && this.reader) {
        if (player && player.party !== party) {
          inParty = false;
        }
      }
      if (changed === "begin") {
        log("begin");
        this.reader.next();
      } else if (changed === "player") {
        await this.$nextTick();
        this.savePlayer(this.story);
      } else if (changed === "players") {
        for (const player2 of value) {
          const local = this.reader.players.players.find((p2) => p2.id === player2.id);
          local.party = player2.party;
        }
      } else if (changed === "waiting") {
        if (this.scene === value.scene && this.last.id === value.direction) {
          this.waiting = value;
        }
      } else if (changed === "tags") {
        log("tags", this.player, JSON.stringify(this.player));
        this.$emit("update:tags", { player: this.player.tags, tags: value });
        this.tags = value;
      } else if (changed === "settings") {
        this.queue.add(async () => {
          console.log("*> settings change value", value);
          if (value.execute) {
            if (value.execute === "clear") {
              for (const name in this.areas) {
                console.log(" -->2 clearing blocks", name);
                await this.forceClearBlocks(this.areas[name]);
              }
            }
          } else if (value.layout && this.areas[value.layout]) {
            const area = this.areas[value.layout];
            for (const key in value) {
              if (key !== "key") {
                area.settings[key] = value[key];
              }
            }
          } else {
            console.error("settings could not be changed", value);
          }
        });
      } else if (changed === "scene") {
        if (!this.code || party === player.party) {
          this.queue.add(async () => {
            await this.clearBlocks(true);
            this.scene = value;
            this.$emit("update:sceneId", value);
          });
        }
      } else if (changed === "music") {
        this.setMusic(value);
      } else if (changed === "audio") {
        this.setAudio(value);
      } else if (changed === "choice-timer") {
        this.areas.bottom.blocks.push({ type: "choice-timer", timer: value });
      } else if (changed === "choice-timer-ready") {
        this.queue.add(value);
      } else if (changed === "choice-timer-timeout") {
        this.choiceCount = 0;
      } else if (changed === "background") {
        this.queue.add(async () => {
          const layout = value.layout || "bottom";
          if (this.player) {
            this.player.backgrounds[layout] = value;
          }
          const id = this.areas[layout].bgs.reduce((a, b) => Math.max(a, b.id), 0) + 1;
          const bg = { id, repeat: false, url: null, color: null, zoom: 1, zoomMin: 1, zoomMax: 4 };
          let background = null;
          if (value.content) {
            background = this.story.backgrounds.find((b) => b.id == value.content);
            if (background) {
              if (background.blob_id) {
                const media = await Media.load(background.blob_id);
                if (media) {
                  bg.url = await media.getUrl();
                }
              }
              bg.blob_id = background.blob_id;
              bg.repeat = background.repeat;
              bg.zoom = value.zoom || 1;
              bg.zoomMin = value.zoom_min || 1;
              bg.zoomMax = value.zoom_max || 4;
              bg.size = value.size;
            }
          }
          if (value.bgcolor) {
            bg.color = value.bgcolor;
          }
          if (bg.url) {
            await new Promise((r, e2) => {
              const img = new Image();
              img.onload = r;
              img.onerror = e2;
              img.src = bg.url;
            });
          } else {
            console.warn("Background image is missing", bg, value, background);
          }
          this.areas[layout].bgs.push(bg);
          await this.$nextTick();
          if (this.areas[layout].bgs.length > 1) {
            this.areas[layout].bgs.shift();
          }
        });
      } else if (changed === "pick") {
        if (inParty) {
          log("choice picked");
          this.choiceCount = 0;
          for (const name in this.areas) {
            for (const block of this.areas[name].blocks.filter((b) => b.type === "choice")) {
              const index2 = this.areas[name].blocks.findIndex((b) => b.id === block.id);
              if (index2 > -1 && value.id !== block.id) {
                this.areas[name].blocks.splice(index2, 1);
                await timer(100);
                this.areas[name].idle = true;
              }
            }
          }
          this.picks = {};
        }
      } else if (changed === "player-pick") {
        if (this.scene === value.scene && (this.last.direction === value.direction || this.last.id === value.direction)) {
          this.picks[value.playerId] = {
            pick: value.id,
            username: this.state[value.playerId].username
          };
        }
        log("player pick", value, this.last, this.picks);
      } else if (changed === "pause") {
        this.queue.add(async () => {
          await timer(value);
        });
      } else if (changed === "completed" || changed === "finished") {
        this.finished = true;
        this.overlay = null;
      } else if (changed === "event") {
        this.last = value;
        console.warn("event", value);
        const layout = value.layout || "bottom";
        this.areas[layout].idle = false;
        await this.clearBlocks();
        this.$emit("event", value);
      } else if (changed === "block-clear")
        ;
      else if (changed === "block-start") {
        this.queue.add(async () => {
          this.exploring = false;
          await this.clearBlocks();
        });
      } else if (changed === "achievement" && value.silent) {
        console.log("silent achievement", value);
      } else if (changed === "contestants") {
        console.log("contestant", value);
        this.readerStore.contestants.push(value);
      } else {
        if (changed === "text" && value.audio && this.narrationVolume > 0) {
          const audioUrl = value.frozenAudio || value.audio;
          Media.load(audioUrl).then(async (media) => {
            if (media) {
              for (const narration of this.currentAudio) {
                if (narration.dataset.narration) {
                  narration.currentTime = 0;
                  narration.pause();
                }
              }
              const audio = new Audio(await media.getUrl());
              audio.volume = this.narrationVolume;
              audio.dataset.narration = true;
              audio.play();
              this.currentAudio.push(audio);
            } else {
              console.warn(
                "missing narration",
                audioUrl,
                value.frozenAudio,
                value.audio,
                (await Media.list()).map((item) => item.id)
              );
            }
          });
        }
        if (inParty) {
          this.last = value;
          this.queue.add(async () => {
            var _a;
            const layout = value.layout || "bottom";
            this.areas[layout].idle = false;
            await this.$nextTick();
            this.picks = {};
            let skip = false;
            if (changed === "choice") {
              if (((_a = value.glyphs) == null ? void 0 : _a.length) > 0) {
                skip = true;
                for (const glyph of value.glyphs) {
                  this.glyphs.push({
                    id: `${value.id}-${glyph.id}`,
                    x: glyph.x,
                    y: glyph.y,
                    size: glyph.size,
                    hidden: glyph.hidden,
                    choice: value.id
                  });
                }
              } else {
                this.choiceCount += 1;
              }
            }
            const choice2 = this.copy(value);
            choice2.type = choice2.type || changed;
            if (layout === "under" || layout === "over") {
              this.areas[layout].blocks.length = 0;
            }
            if (layout !== "top" && layout !== "bottom") {
              this.overlay = layout;
            } else {
              this.overlay = null;
            }
            if (["choice", "input", "option"].indexOf(changed) === -1 && (changed !== "input" || value.label)) {
              log("clearing block stack", changed, value.label);
              await this.clearBlocks();
            }
            this.areas[layout].blocks.push(choice2);
            if (!skip) {
              await this.waitForIdle();
            }
          });
        }
      }
    },
    hurry() {
      for (const name of ["bottom", "top", "left", "right", "over"]) {
        if (this.$refs[name]) {
          this.$refs[name].hurry();
        }
      }
    },
    handleNext() {
      this.showNextButton = false;
      if (this.optionChoices) {
        if (this.isClient) {
          this.$root.playerSendEvent("player-options", this.optionChoices);
        } else {
          this.reader.options(this.optionChoices);
        }
        this.optionChoices = null;
      } else {
        if (this.isClient) {
          this.$root.playerSendEvent("player-next", { next: true });
        } else {
          this.reader.next(this.code ? this.$root.user.id : null);
        }
      }
    },
    handleChoice(c) {
      if (this.isClient) {
        log(
          "sending choice to server",
          this.code,
          this.$root.iamHosting,
          this.isClient,
          this.isServer
        );
        this.$root.playerSendEvent("player-choice", { choice: c });
      } else {
        this.reader.choice(c, this.code ? this.$root.user.id : null);
      }
    },
    handleInput(e2) {
      if (this.isClient) {
        this.$root.playerSendEvent("player-input", { input: e2 });
      } else {
        this.reader.input(e2, this.code ? this.$root.user.id : null);
      }
    },
    handleEvent(name) {
      this.reader.event(name);
    },
    cycleMusicVolume() {
      this.musicVolume = this.cycleVolume(this.musicVolume);
    },
    cycleAudioVolume() {
      this.audioVolume = this.cycleVolume(this.audioVolume);
    },
    cycleNarrationVolume() {
      this.narrationVolume = this.cycleVolume(this.narrationVolume);
    },
    cycleVolume(vol) {
      let retval = vol;
      if (retval === 1) {
        retval = 0.5;
      } else if (retval === 0.5) {
        retval = 0;
      } else {
        retval = 1;
      }
      return retval;
    },
    async fadeMusic(on = true) {
      for (let x = 0; x < 100; x += 1) {
        if (on) {
          this.musicFade = x / 100;
        } else {
          this.musicFade = (100 - x) / 100;
        }
        await timer(5);
      }
    },
    async setMusic(value) {
      if (this.player) {
        this.player.music = value;
      }
      const mediaId = value.blob_id || value.content;
      if (!mediaId) {
        if (this.musicSrc) {
          await this.fadeMusic(false);
          this.musicSrc = null;
        }
      } else if (this.musicNextSrc != mediaId) {
        const current = this.musicNextSrc;
        this.musicNextSrc = mediaId;
        if (this.musicSrc !== current)
          ;
        else if (this.musicSrc) {
          await this.fadeMusic(false);
        } else
          ;
        let clip = await Media.load(mediaId);
        if (clip) {
          clip = mediaId;
        } else {
          clip = this.story.music.find((a) => a.id == mediaId);
          if (clip && this.musicSrc != clip.blob_id) {
            this.musicSrc = null;
            clip = clip.blob_id;
          }
        }
        if (clip) {
          const audio = this.$refs.music;
          audio.pause();
          this.musicSrc = mediaId;
          this.musicVolumeLocal = value.volume || 1;
          await this.fadeMusic();
        } else {
          this.musicSrc = null;
        }
      }
    },
    async setAudio(value) {
      if (value) {
        const mediaId = value.blob_id || value.content;
        const clip = this.story.audio.find((a) => a.id == mediaId);
        const blob = clip ? clip.blob_id : mediaId;
        const media = await Media.load(blob);
        const audio = new Audio();
        if (media) {
          this.currentAudio.push(audio);
          audio.oncanplaythrough = () => {
            audio.volume = this.audioVolume;
            if (!audio.dataset.played) {
              audio.dataset.played = true;
              audio.play();
            }
          };
          audio.src = await media.getUrl();
        }
      } else {
        this.silenceAudio();
      }
    },
    silenceAudio() {
      for (const audio of this.currentAudio) {
        this.disposeAudio(audio);
      }
      this.currentAudio = [];
    },
    async handleKeyEvent(e2) {
      if ((e2.which === 32 || e2.which == 13) && e2.target) {
        if (this.isIdle && !this.isWaiting && !this.hasYourPick && this.needsNextButton) {
          this.handleNext();
        } else {
          this.hurry();
        }
      }
    },
    savePlayer(story2) {
      for (const choice2 of this.player.choices) {
        for (const effect of (choice2.effects || []).filter((e2) => ":+-".indexOf(e2.op) > -1)) {
          const tag = this.story.tags.find((t) => t.id === effect.tag);
          if (tag && tag.permanent) {
            if (!this.player.tags) {
              this.player.tags = {};
            }
            this.player.tags[tag.id] = this.reader.tags[tag.id] || 1;
          }
        }
      }
      if (!this.code) {
        this.player.microcosms = this.reader.microcosms;
        console.warn("saving player", story2.id, JSON.stringify(this.player));
        this.put(`story_${story2.id}`, this.player);
      }
    },
    loadPlayer(story2) {
      let player = this.fetch(`story_${story2.id}`);
      console.warn("loaded player", story2.id, player);
      if (!player) {
        player = { tags: {}, choices: [], backgrounds: {}, music: null };
      }
      if (!player.backgrounds) {
        player.backgrounds = {};
      } else {
        Object.values(player.backgrounds).forEach((v) => {
          this.handleReaderEvent({ changed: "background", value: v });
        });
      }
      if (player.music) {
        this.handleReaderEvent({ changed: "music", value: player.music });
      }
      if (!player.tags) {
        player.tags = {};
      }
      return player;
    },
    resetPlayer(story2, permanent = false) {
      this.player.choices = [];
      if (permanent) {
        this.player.tags = {};
      }
      this.choiceCount = 0;
      this.glyphs = [];
      this.player.session = null;
      this.player.bookmark = null;
      this.player.music = null;
      this.player.backgrounds = {};
      this.player.microcosms = [];
      this.put(`story_${story2.id}`, this.player);
    },
    async handleRestart() {
      if (this.code) {
        this.$root.playerSendEvent("restart", {});
        this.$emit("restart");
      } else {
        this.put(`story_${this.story.id}`, null);
        this.resetPlayer(this.story);
        this.finished = false;
        this.queue.length = 0;
        for (let name in this.areas) {
          this.areas[name].blocks.length = 0;
          this.areas[name].bgs.length = 0;
        }
        this.$refs.music.pause();
        this.musicSrc = null;
        await timer(100);
        this.reader.tags = {};
        this.reader.scene = this.story.scenes.find((s) => s.start);
        this.ready = true;
        this.nextReady = true;
        this.idx = 0;
        this.reader.reset();
        this.reader.start();
      }
    },
    async handleReset() {
      if (confirm(i18n.global.t("layout.this-will-erase-all-player-data-for-this-story"))) {
        this.player.tags = {};
        await this.handleRestart();
      }
    },
    t(...args) {
      return i18n.global.t(...args);
    }
  }
};
const _hoisted_1$1 = { class: "top-buttons" };
const _hoisted_2$1 = { class: "overlays flex-static" };
const _hoisted_3$1 = {
  key: 1,
  class: "area overlay"
};
const _hoisted_4 = {
  key: 0,
  class: "flex-static align-top close"
};
const _hoisted_5 = { class: "content-cols flex-row flex-stretch" };
const _hoisted_6 = { class: "flex-static align-right close" };
const _hoisted_7 = { class: "center-col flex-column flex-stretch" };
const _hoisted_8 = {
  key: 0,
  class: "top-col flex-stretch no-scroll"
};
const _hoisted_9 = {
  key: 0,
  class: "accented finished"
};
const _hoisted_10 = { class: "the-end" };
const _hoisted_11 = { class: "flex-static align-left close" };
const _hoisted_12 = { class: "flex-static indicators flex-row" };
const _hoisted_13 = { class: "sidebar-indicator" };
const _hoisted_14 = {
  key: 0,
  class: "list-indicator"
};
const _hoisted_15 = {
  key: 0,
  class: "next"
};
const _hoisted_16 = {
  key: "waiting",
  class: "pick-count"
};
const _hoisted_17 = {
  key: "picks",
  class: "pick-count"
};
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_reader_backgrounds = resolveComponent("reader-backgrounds");
  const _component_reader_area = resolveComponent("reader-area");
  const _component_AuthorPlug = resolveComponent("AuthorPlug");
  const _component_comments = resolveComponent("comments");
  const _component_blob_audio = resolveComponent("blob-audio");
  const _component_DocumentKeycapture = resolveComponent("DocumentKeycapture");
  return openBlock(), createElementBlock("div", {
    class: "reader-layout story-read",
    style: normalizeStyle({
      "--story-color": $options.settings.color || "#222222",
      "--story-bg": $options.settings.background || "#D3D3D3"
    })
  }, [
    createBaseVNode("div", _hoisted_1$1, [
      renderSlot(_ctx.$slots, "top-buttons", {}, void 0, true)
    ]),
    createBaseVNode("div", _hoisted_2$1, [
      renderSlot(_ctx.$slots, "overlays", {}, void 0, true)
    ]),
    createVNode(_component_reader_backgrounds, {
      story: $props.story,
      backgrounds: $data.areas.bottom.bgs,
      glyphs: $data.glyphs,
      exploring: $data.canExplore,
      "onUpdate:exploring": _cache[0] || (_cache[0] = ($event) => $data.canExplore = $event),
      ref: "bgs",
      onGlyphClick: $options.handleChoice
    }, null, 8, ["story", "backgrounds", "glyphs", "exploring", "onGlyphClick"]),
    $data.canExplore && $data.exploring ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "explorer",
      onPointermove: _cache[1] || (_cache[1] = (...args) => _ctx.$refs.bgs.handlePan && _ctx.$refs.bgs.handlePan(...args)),
      onPointerdown: _cache[2] || (_cache[2] = (...args) => _ctx.$refs.bgs.handlePan && _ctx.$refs.bgs.handlePan(...args)),
      onPointercancel: _cache[3] || (_cache[3] = (...args) => _ctx.$refs.bgs.handlePan && _ctx.$refs.bgs.handlePan(...args)),
      onPointerup: _cache[4] || (_cache[4] = (...args) => _ctx.$refs.bgs.handlePan && _ctx.$refs.bgs.handlePan(...args)),
      onWheel: _cache[5] || (_cache[5] = withModifiers((...args) => _ctx.$refs.bgs.handlePan && _ctx.$refs.bgs.handlePan(...args), ["prevent"])),
      onClick: _cache[6] || (_cache[6] = withModifiers((...args) => _ctx.$refs.bgs.handleClick && _ctx.$refs.bgs.handleClick(...args), ["prevent"]))
    }, null, 32)) : createCommentVNode("", true),
    createBaseVNode("div", {
      class: normalizeClass([{ subdued: $data.canExplore && $data.exploring }, "reader-content flex-stretch"])
    }, [
      $data.overlay ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "backdrop",
        onClick: _cache[7] || (_cache[7] = ($event) => $data.overlay != "over" ? $data.overlay = null : null)
      })) : createCommentVNode("", true),
      $data.overlay === "over" && $data.areas.over.blocks.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_3$1, [
        createVNode(_component_reader_backgrounds, {
          story: $props.story,
          backgrounds: $data.areas.over.bgs
        }, null, 8, ["story", "backgrounds"]),
        $options.hasChoices ? (openBlock(), createElementBlock("div", _hoisted_4, [
          createBaseVNode("a", {
            onClick: _cache[8] || (_cache[8] = withModifiers(($event) => $data.overlay = null, ["prevent"]))
          }, "")
        ])) : createCommentVNode("", true),
        createVNode(_component_reader_area, {
          name: "over",
          ref: "over",
          modelValue: $data.areas.over.idle,
          "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => $data.areas.over.idle = $event),
          onUserInput: $options.handleInput,
          onChoice: $options.handleChoice,
          onExplore: _cache[10] || (_cache[10] = ($event) => $data.exploring = true),
          canExplore: $data.canExplore,
          picks: $data.picks,
          blocks: $data.areas.over.blocks,
          "active-name": $data.activeArea,
          story: $props.story
        }, null, 8, ["modelValue", "onUserInput", "onChoice", "canExplore", "picks", "blocks", "active-name", "story"])
      ])) : createCommentVNode("", true),
      createBaseVNode("div", _hoisted_5, [
        $data.areas.left.blocks.length > 0 ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass([{ open: $data.overlay === "left" }, "left-col flex-column flex-stretch"])
        }, [
          createVNode(_component_reader_backgrounds, {
            story: $props.story,
            backgrounds: $data.areas.left.bgs
          }, null, 8, ["story", "backgrounds"]),
          createBaseVNode("div", _hoisted_6, [
            createBaseVNode("a", {
              onClick: _cache[11] || (_cache[11] = withModifiers(($event) => $data.overlay = null, ["prevent"]))
            }, "")
          ]),
          createVNode(_component_reader_area, {
            name: "left",
            ref: "left",
            modelValue: $data.areas.left.idle,
            "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => $data.areas.left.idle = $event),
            onUserInput: $options.handleInput,
            onChoice: $options.handleChoice,
            onExplore: _cache[13] || (_cache[13] = ($event) => $data.exploring = true),
            canExplore: $data.canExplore,
            picks: $data.picks,
            blocks: $data.areas.left.blocks,
            "active-name": $data.activeArea,
            story: $props.story
          }, null, 8, ["modelValue", "onUserInput", "onChoice", "canExplore", "picks", "blocks", "active-name", "story"])
        ], 2)) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_7, [
          $data.areas.top.blocks.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_8, [
            createVNode(_component_reader_backgrounds, {
              story: $props.story,
              backgrounds: $data.areas.top.bgs
            }, null, 8, ["story", "backgrounds"]),
            createVNode(_component_reader_area, {
              name: "top",
              ref: "top",
              modelValue: $data.areas.top.idle,
              "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => $data.areas.top.idle = $event),
              onUserInput: $options.handleInput,
              onChoice: $options.handleChoice,
              onExplore: _cache[15] || (_cache[15] = ($event) => $data.exploring = true),
              canExplore: $data.canExplore,
              picks: $data.picks,
              blocks: $data.areas.top.blocks,
              "active-name": $data.activeArea,
              story: $props.story,
              tags: $data.tags
            }, null, 8, ["modelValue", "onUserInput", "onChoice", "canExplore", "picks", "blocks", "active-name", "story", "tags"])
          ])) : createCommentVNode("", true),
          createVNode(_component_reader_area, {
            name: "bottom",
            ref: "bottom",
            modelValue: $data.areas.bottom.idle,
            "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => $data.areas.bottom.idle = $event),
            onUserInput: $options.handleInput,
            onShowNextButton: _cache[17] || (_cache[17] = ($event) => $data.showNextButton = $event),
            onOptionChoices: _cache[18] || (_cache[18] = ($event) => $data.optionChoices = $event),
            onChoice: $options.handleChoice,
            onExplore: _cache[19] || (_cache[19] = ($event) => $data.exploring = true),
            canExplore: $data.canExplore,
            picks: $data.picks,
            blocks: $data.areas.bottom.blocks,
            "active-name": $data.activeArea,
            story: $props.story,
            tags: $data.tags,
            bottom: true
          }, null, 8, ["modelValue", "onUserInput", "onChoice", "canExplore", "picks", "blocks", "active-name", "story", "tags"]),
          createVNode(Transition, {
            name: "slideup",
            appear: ""
          }, {
            default: withCtx(() => [
              $data.finished ? (openBlock(), createElementBlock("div", _hoisted_9, [
                renderSlot(_ctx.$slots, "default", { restartCmd: $options.handleRestart }, () => [
                  $props.remoteApi ? (openBlock(), createBlock(_component_AuthorPlug, {
                    key: 0,
                    "show-user": true,
                    author: _ctx.author
                  }, null, 8, ["author"])) : createCommentVNode("", true),
                  $props.remoteApi && $props.story.fid ? (openBlock(), createBlock(_component_comments, {
                    key: 1,
                    story: $props.story.fid,
                    "remote-api": $props.remoteApi
                  }, null, 8, ["story", "remote-api"])) : createCommentVNode("", true),
                  createBaseVNode("div", _hoisted_10, [
                    _ctx.$router ? (openBlock(), createElementBlock("button", {
                      key: 0,
                      "aria-label": "Exit story",
                      class: "the-end-restart",
                      onClick: _cache[20] || (_cache[20] = withModifiers(($event) => _ctx.$router.go(-1), ["prevent"]))
                    }, [
                      _cache[30] || (_cache[30] = createBaseVNode("i", { class: "fa fa-arrow-left" }, null, -1)),
                      createTextVNode(" " + toDisplayString$1($options.t("layout.back")), 1)
                    ])) : createCommentVNode("", true),
                    createBaseVNode("button", {
                      class: "the-end-restart flex-row gap-1",
                      onClick: _cache[21] || (_cache[21] = withModifiers((...args) => $options.handleRestart && $options.handleRestart(...args), ["prevent"]))
                    }, [
                      _cache[31] || (_cache[31] = createBaseVNode("i", { class: "fa fa-refresh" }, null, -1)),
                      createBaseVNode("span", null, toDisplayString$1($options.t("layout.read-again")), 1)
                    ]),
                    renderSlot(_ctx.$slots, "restart-adornment", {}, void 0, true)
                  ])
                ], true)
              ])) : createCommentVNode("", true)
            ]),
            _: 3
          })
        ]),
        $data.areas.right.blocks.length > 0 ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass([{ open: $data.overlay === "right" }, "right-col flex-column flex-stretch"])
        }, [
          createVNode(_component_reader_backgrounds, {
            story: $props.story,
            backgrounds: $data.areas.right.bgs
          }, null, 8, ["story", "backgrounds"]),
          createBaseVNode("div", _hoisted_11, [
            createBaseVNode("a", {
              onClick: _cache[22] || (_cache[22] = withModifiers(($event) => $data.overlay = null, ["prevent"]))
            }, "")
          ]),
          createVNode(_component_reader_area, {
            name: "right",
            ref: "right",
            modelValue: $data.areas.right.idle,
            "onUpdate:modelValue": _cache[23] || (_cache[23] = ($event) => $data.areas.right.idle = $event),
            onUserInput: $options.handleInput,
            onChoice: $options.handleChoice,
            onExplore: _cache[24] || (_cache[24] = ($event) => $data.exploring = true),
            canExplore: $data.canExplore,
            picks: $data.picks,
            blocks: $data.areas.right.blocks,
            "active-name": $data.activeArea,
            story: $props.story
          }, null, 8, ["modelValue", "onUserInput", "onChoice", "canExplore", "picks", "blocks", "active-name", "story"])
        ], 2)) : createCommentVNode("", true)
      ])
    ], 2),
    !$data.finished ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: "reader-footer",
      onClick: _cache[29] || (_cache[29] = withModifiers((...args) => $options.hurry && $options.hurry(...args), ["prevent"]))
    }, [
      createBaseVNode("div", _hoisted_12, [
        createBaseVNode("div", _hoisted_13, [
          createVNode(TransitionGroup, {
            appear: "",
            name: "quickfade",
            tag: "div"
          }, {
            default: withCtx(() => [
              $data.areas.left.blocks.length > 0 ? (openBlock(), createElementBlock("a", {
                key: "left",
                onClick: _cache[25] || (_cache[25] = withModifiers(($event) => $data.overlay = "left", ["prevent"]))
              }, _cache[32] || (_cache[32] = [
                createBaseVNode("i", { class: "fa fa-chevron-left" }, null, -1)
              ]))) : createCommentVNode("", true),
              $data.areas.right.blocks.length > 0 ? (openBlock(), createElementBlock("a", {
                key: "right",
                onClick: _cache[26] || (_cache[26] = withModifiers(($event) => $data.overlay = $data.overlay === "right" ? null : "right", ["prevent"]))
              }, _cache[33] || (_cache[33] = [
                createBaseVNode("i", { class: "fa fa-chevron-right" }, null, -1)
              ]))) : createCommentVNode("", true)
            ]),
            _: 1
          })
        ]),
        $data.canExplore && $data.exploring ? (openBlock(), createElementBlock("div", _hoisted_14, [
          createBaseVNode("button", {
            onClick: _cache[27] || (_cache[27] = withModifiers(($event) => $data.exploring = false, ["prevent"])),
            class: "icon"
          }, _cache[34] || (_cache[34] = [
            createBaseVNode("i", { class: "fa fa-chevron-up" }, null, -1)
          ]))
        ])) : createCommentVNode("", true)
      ]),
      _cache[36] || (_cache[36] = createBaseVNode("div", { class: "flex-stretch flex-row" }, null, -1)),
      $data.reader && $data.choiceCount === 0 ? (openBlock(), createElementBlock("div", _hoisted_15, [
        createVNode(TransitionGroup, {
          name: "quickfade",
          tag: "div"
        }, {
          default: withCtx(() => [
            withDirectives(createBaseVNode("a", {
              key: "next",
              "aria-label": "next",
              onClick: _cache[28] || (_cache[28] = withModifiers((...args) => $options.handleNext && $options.handleNext(...args), ["prevent", "stop"]))
            }, _cache[35] || (_cache[35] = [
              createBaseVNode("i", { class: "fa fa-chevron-right" }, null, -1)
            ]), 512), [
              [vShow, $data.isIdle && !$options.isWaiting && !$options.hasYourPick && $options.needsNextButton]
            ]),
            $options.isWaiting ? (openBlock(), createElementBlock("span", _hoisted_16, toDisplayString$1($data.waiting.has.length), 1)) : createCommentVNode("", true),
            $data.isIdle && $options.hasYourPick ? (openBlock(), createElementBlock("span", _hoisted_17, toDisplayString$1(Object.keys($data.picks).length), 1)) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ])) : createCommentVNode("", true)
    ])) : createCommentVNode("", true),
    createVNode(_component_blob_audio, {
      autoplay: "",
      loop: "",
      volume: $options.fadedMusicVolume,
      blob: $data.musicSrc,
      ref: "music",
      oncanplaythrough: $data.musicOnCanPlayThrough
    }, null, 8, ["volume", "blob", "oncanplaythrough"]),
    createVNode(_component_DocumentKeycapture, { onKeypress: $options.handleKeyEvent }, null, 8, ["onKeypress"])
  ], 4);
}
const SceneReader = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2], ["__scopeId", "data-v-d0e57976"]]);
var localforage = { exports: {} };
/*!
    localForage -- Offline Storage, Improved
    Version 1.10.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
(function(module, exports) {
  (function(f) {
    {
      module.exports = f();
    }
  })(function() {
    return function e2(t, n, r) {
      function s(o2, u) {
        if (!n[o2]) {
          if (!t[o2]) {
            var a = typeof commonjsRequire == "function" && commonjsRequire;
            if (!u && a)
              return a(o2, true);
            if (i)
              return i(o2, true);
            var f = new Error("Cannot find module '" + o2 + "'");
            throw f.code = "MODULE_NOT_FOUND", f;
          }
          var l = n[o2] = { exports: {} };
          t[o2][0].call(l.exports, function(e3) {
            var n2 = t[o2][1][e3];
            return s(n2 ? n2 : e3);
          }, l, l.exports, e2, t, n, r);
        }
        return n[o2].exports;
      }
      var i = typeof commonjsRequire == "function" && commonjsRequire;
      for (var o = 0; o < r.length; o++)
        s(r[o]);
      return s;
    }({ 1: [function(_dereq_, module2, exports2) {
      (function(global2) {
        var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
        var scheduleDrain;
        {
          if (Mutation) {
            var called = 0;
            var observer = new Mutation(nextTick2);
            var element = global2.document.createTextNode("");
            observer.observe(element, {
              characterData: true
            });
            scheduleDrain = function() {
              element.data = called = ++called % 2;
            };
          } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
            var channel = new global2.MessageChannel();
            channel.port1.onmessage = nextTick2;
            scheduleDrain = function() {
              channel.port2.postMessage(0);
            };
          } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
            scheduleDrain = function() {
              var scriptEl = global2.document.createElement("script");
              scriptEl.onreadystatechange = function() {
                nextTick2();
                scriptEl.onreadystatechange = null;
                scriptEl.parentNode.removeChild(scriptEl);
                scriptEl = null;
              };
              global2.document.documentElement.appendChild(scriptEl);
            };
          } else {
            scheduleDrain = function() {
              setTimeout(nextTick2, 0);
            };
          }
        }
        var draining;
        var queue2 = [];
        function nextTick2() {
          draining = true;
          var i, oldQueue;
          var len = queue2.length;
          while (len) {
            oldQueue = queue2;
            queue2 = [];
            i = -1;
            while (++i < len) {
              oldQueue[i]();
            }
            len = queue2.length;
          }
          draining = false;
        }
        module2.exports = immediate;
        function immediate(task) {
          if (queue2.push(task) === 1 && !draining) {
            scheduleDrain();
          }
        }
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 2: [function(_dereq_, module2, exports2) {
      var immediate = _dereq_(1);
      function INTERNAL() {
      }
      var handlers2 = {};
      var REJECTED = ["REJECTED"];
      var FULFILLED = ["FULFILLED"];
      var PENDING = ["PENDING"];
      module2.exports = Promise2;
      function Promise2(resolver) {
        if (typeof resolver !== "function") {
          throw new TypeError("resolver must be a function");
        }
        this.state = PENDING;
        this.queue = [];
        this.outcome = void 0;
        if (resolver !== INTERNAL) {
          safelyResolveThenable(this, resolver);
        }
      }
      Promise2.prototype["catch"] = function(onRejected) {
        return this.then(null, onRejected);
      };
      Promise2.prototype.then = function(onFulfilled, onRejected) {
        if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
          return this;
        }
        var promise = new this.constructor(INTERNAL);
        if (this.state !== PENDING) {
          var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
          unwrap(promise, resolver, this.outcome);
        } else {
          this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
        }
        return promise;
      };
      function QueueItem(promise, onFulfilled, onRejected) {
        this.promise = promise;
        if (typeof onFulfilled === "function") {
          this.onFulfilled = onFulfilled;
          this.callFulfilled = this.otherCallFulfilled;
        }
        if (typeof onRejected === "function") {
          this.onRejected = onRejected;
          this.callRejected = this.otherCallRejected;
        }
      }
      QueueItem.prototype.callFulfilled = function(value) {
        handlers2.resolve(this.promise, value);
      };
      QueueItem.prototype.otherCallFulfilled = function(value) {
        unwrap(this.promise, this.onFulfilled, value);
      };
      QueueItem.prototype.callRejected = function(value) {
        handlers2.reject(this.promise, value);
      };
      QueueItem.prototype.otherCallRejected = function(value) {
        unwrap(this.promise, this.onRejected, value);
      };
      function unwrap(promise, func, value) {
        immediate(function() {
          var returnValue;
          try {
            returnValue = func(value);
          } catch (e2) {
            return handlers2.reject(promise, e2);
          }
          if (returnValue === promise) {
            handlers2.reject(promise, new TypeError("Cannot resolve promise with itself"));
          } else {
            handlers2.resolve(promise, returnValue);
          }
        });
      }
      handlers2.resolve = function(self2, value) {
        var result = tryCatch(getThen, value);
        if (result.status === "error") {
          return handlers2.reject(self2, result.value);
        }
        var thenable = result.value;
        if (thenable) {
          safelyResolveThenable(self2, thenable);
        } else {
          self2.state = FULFILLED;
          self2.outcome = value;
          var i = -1;
          var len = self2.queue.length;
          while (++i < len) {
            self2.queue[i].callFulfilled(value);
          }
        }
        return self2;
      };
      handlers2.reject = function(self2, error) {
        self2.state = REJECTED;
        self2.outcome = error;
        var i = -1;
        var len = self2.queue.length;
        while (++i < len) {
          self2.queue[i].callRejected(error);
        }
        return self2;
      };
      function getThen(obj) {
        var then = obj && obj.then;
        if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
          return function appyThen() {
            then.apply(obj, arguments);
          };
        }
      }
      function safelyResolveThenable(self2, thenable) {
        var called = false;
        function onError(value) {
          if (called) {
            return;
          }
          called = true;
          handlers2.reject(self2, value);
        }
        function onSuccess(value) {
          if (called) {
            return;
          }
          called = true;
          handlers2.resolve(self2, value);
        }
        function tryToUnwrap() {
          thenable(onSuccess, onError);
        }
        var result = tryCatch(tryToUnwrap);
        if (result.status === "error") {
          onError(result.value);
        }
      }
      function tryCatch(func, value) {
        var out = {};
        try {
          out.value = func(value);
          out.status = "success";
        } catch (e2) {
          out.status = "error";
          out.value = e2;
        }
        return out;
      }
      Promise2.resolve = resolve2;
      function resolve2(value) {
        if (value instanceof this) {
          return value;
        }
        return handlers2.resolve(new this(INTERNAL), value);
      }
      Promise2.reject = reject;
      function reject(reason) {
        var promise = new this(INTERNAL);
        return handlers2.reject(promise, reason);
      }
      Promise2.all = all;
      function all(iterable) {
        var self2 = this;
        if (Object.prototype.toString.call(iterable) !== "[object Array]") {
          return this.reject(new TypeError("must be an array"));
        }
        var len = iterable.length;
        var called = false;
        if (!len) {
          return this.resolve([]);
        }
        var values = new Array(len);
        var resolved = 0;
        var i = -1;
        var promise = new this(INTERNAL);
        while (++i < len) {
          allResolver(iterable[i], i);
        }
        return promise;
        function allResolver(value, i2) {
          self2.resolve(value).then(resolveFromAll, function(error) {
            if (!called) {
              called = true;
              handlers2.reject(promise, error);
            }
          });
          function resolveFromAll(outValue) {
            values[i2] = outValue;
            if (++resolved === len && !called) {
              called = true;
              handlers2.resolve(promise, values);
            }
          }
        }
      }
      Promise2.race = race;
      function race(iterable) {
        var self2 = this;
        if (Object.prototype.toString.call(iterable) !== "[object Array]") {
          return this.reject(new TypeError("must be an array"));
        }
        var len = iterable.length;
        var called = false;
        if (!len) {
          return this.resolve([]);
        }
        var i = -1;
        var promise = new this(INTERNAL);
        while (++i < len) {
          resolver(iterable[i]);
        }
        return promise;
        function resolver(value) {
          self2.resolve(value).then(function(response) {
            if (!called) {
              called = true;
              handlers2.resolve(promise, response);
            }
          }, function(error) {
            if (!called) {
              called = true;
              handlers2.reject(promise, error);
            }
          });
        }
      }
    }, { "1": 1 }], 3: [function(_dereq_, module2, exports2) {
      (function(global2) {
        if (typeof global2.Promise !== "function") {
          global2.Promise = _dereq_(2);
        }
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "2": 2 }], 4: [function(_dereq_, module2, exports2) {
      var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      function _classCallCheck2(instance2, Constructor) {
        if (!(instance2 instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function getIDB() {
        try {
          if (typeof indexedDB !== "undefined") {
            return indexedDB;
          }
          if (typeof webkitIndexedDB !== "undefined") {
            return webkitIndexedDB;
          }
          if (typeof mozIndexedDB !== "undefined") {
            return mozIndexedDB;
          }
          if (typeof OIndexedDB !== "undefined") {
            return OIndexedDB;
          }
          if (typeof msIndexedDB !== "undefined") {
            return msIndexedDB;
          }
        } catch (e2) {
          return;
        }
      }
      var idb = getIDB();
      function isIndexedDBValid() {
        try {
          if (!idb || !idb.open) {
            return false;
          }
          var isSafari = typeof openDatabase !== "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
          var hasFetch = typeof fetch === "function" && fetch.toString().indexOf("[native code") !== -1;
          return (!isSafari || hasFetch) && typeof indexedDB !== "undefined" && // some outdated implementations of IDB that appear on Samsung
          // and HTC Android devices <4.4 are missing IDBKeyRange
          // See: https://github.com/mozilla/localForage/issues/128
          // See: https://github.com/mozilla/localForage/issues/272
          typeof IDBKeyRange !== "undefined";
        } catch (e2) {
          return false;
        }
      }
      function createBlob(parts, properties) {
        parts = parts || [];
        properties = properties || {};
        try {
          return new Blob(parts, properties);
        } catch (e2) {
          if (e2.name !== "TypeError") {
            throw e2;
          }
          var Builder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : WebKitBlobBuilder;
          var builder = new Builder();
          for (var i = 0; i < parts.length; i += 1) {
            builder.append(parts[i]);
          }
          return builder.getBlob(properties.type);
        }
      }
      if (typeof Promise === "undefined") {
        _dereq_(3);
      }
      var Promise$1 = Promise;
      function executeCallback(promise, callback) {
        if (callback) {
          promise.then(function(result) {
            callback(null, result);
          }, function(error) {
            callback(error);
          });
        }
      }
      function executeTwoCallbacks(promise, callback, errorCallback) {
        if (typeof callback === "function") {
          promise.then(callback);
        }
        if (typeof errorCallback === "function") {
          promise["catch"](errorCallback);
        }
      }
      function normalizeKey2(key2) {
        if (typeof key2 !== "string") {
          console.warn(key2 + " used as a key, but it is not a string.");
          key2 = String(key2);
        }
        return key2;
      }
      function getCallback() {
        if (arguments.length && typeof arguments[arguments.length - 1] === "function") {
          return arguments[arguments.length - 1];
        }
      }
      var DETECT_BLOB_SUPPORT_STORE = "local-forage-detect-blob-support";
      var supportsBlobs = void 0;
      var dbContexts = {};
      var toString2 = Object.prototype.toString;
      var READ_ONLY = "readonly";
      var READ_WRITE = "readwrite";
      function _binStringToArrayBuffer(bin) {
        var length2 = bin.length;
        var buf = new ArrayBuffer(length2);
        var arr = new Uint8Array(buf);
        for (var i = 0; i < length2; i++) {
          arr[i] = bin.charCodeAt(i);
        }
        return buf;
      }
      function _checkBlobSupportWithoutCaching(idb2) {
        return new Promise$1(function(resolve2) {
          var txn = idb2.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
          var blob = createBlob([""]);
          txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, "key");
          txn.onabort = function(e2) {
            e2.preventDefault();
            e2.stopPropagation();
            resolve2(false);
          };
          txn.oncomplete = function() {
            var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
            var matchedEdge = navigator.userAgent.match(/Edge\//);
            resolve2(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
          };
        })["catch"](function() {
          return false;
        });
      }
      function _checkBlobSupport(idb2) {
        if (typeof supportsBlobs === "boolean") {
          return Promise$1.resolve(supportsBlobs);
        }
        return _checkBlobSupportWithoutCaching(idb2).then(function(value) {
          supportsBlobs = value;
          return supportsBlobs;
        });
      }
      function _deferReadiness(dbInfo) {
        var dbContext = dbContexts[dbInfo.name];
        var deferredOperation = {};
        deferredOperation.promise = new Promise$1(function(resolve2, reject) {
          deferredOperation.resolve = resolve2;
          deferredOperation.reject = reject;
        });
        dbContext.deferredOperations.push(deferredOperation);
        if (!dbContext.dbReady) {
          dbContext.dbReady = deferredOperation.promise;
        } else {
          dbContext.dbReady = dbContext.dbReady.then(function() {
            return deferredOperation.promise;
          });
        }
      }
      function _advanceReadiness(dbInfo) {
        var dbContext = dbContexts[dbInfo.name];
        var deferredOperation = dbContext.deferredOperations.pop();
        if (deferredOperation) {
          deferredOperation.resolve();
          return deferredOperation.promise;
        }
      }
      function _rejectReadiness(dbInfo, err) {
        var dbContext = dbContexts[dbInfo.name];
        var deferredOperation = dbContext.deferredOperations.pop();
        if (deferredOperation) {
          deferredOperation.reject(err);
          return deferredOperation.promise;
        }
      }
      function _getConnection(dbInfo, upgradeNeeded) {
        return new Promise$1(function(resolve2, reject) {
          dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
          if (dbInfo.db) {
            if (upgradeNeeded) {
              _deferReadiness(dbInfo);
              dbInfo.db.close();
            } else {
              return resolve2(dbInfo.db);
            }
          }
          var dbArgs = [dbInfo.name];
          if (upgradeNeeded) {
            dbArgs.push(dbInfo.version);
          }
          var openreq = idb.open.apply(idb, dbArgs);
          if (upgradeNeeded) {
            openreq.onupgradeneeded = function(e2) {
              var db = openreq.result;
              try {
                db.createObjectStore(dbInfo.storeName);
                if (e2.oldVersion <= 1) {
                  db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                }
              } catch (ex) {
                if (ex.name === "ConstraintError") {
                  console.warn('The database "' + dbInfo.name + '" has been upgraded from version ' + e2.oldVersion + " to version " + e2.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                } else {
                  throw ex;
                }
              }
            };
          }
          openreq.onerror = function(e2) {
            e2.preventDefault();
            reject(openreq.error);
          };
          openreq.onsuccess = function() {
            var db = openreq.result;
            db.onversionchange = function(e2) {
              e2.target.close();
            };
            resolve2(db);
            _advanceReadiness(dbInfo);
          };
        });
      }
      function _getOriginalConnection(dbInfo) {
        return _getConnection(dbInfo, false);
      }
      function _getUpgradedConnection(dbInfo) {
        return _getConnection(dbInfo, true);
      }
      function _isUpgradeNeeded(dbInfo, defaultVersion) {
        if (!dbInfo.db) {
          return true;
        }
        var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
        var isDowngrade = dbInfo.version < dbInfo.db.version;
        var isUpgrade = dbInfo.version > dbInfo.db.version;
        if (isDowngrade) {
          if (dbInfo.version !== defaultVersion) {
            console.warn('The database "' + dbInfo.name + `" can't be downgraded from version ` + dbInfo.db.version + " to version " + dbInfo.version + ".");
          }
          dbInfo.version = dbInfo.db.version;
        }
        if (isUpgrade || isNewStore) {
          if (isNewStore) {
            var incVersion = dbInfo.db.version + 1;
            if (incVersion > dbInfo.version) {
              dbInfo.version = incVersion;
            }
          }
          return true;
        }
        return false;
      }
      function _encodeBlob(blob) {
        return new Promise$1(function(resolve2, reject) {
          var reader = new FileReader();
          reader.onerror = reject;
          reader.onloadend = function(e2) {
            var base64 = btoa(e2.target.result || "");
            resolve2({
              __local_forage_encoded_blob: true,
              data: base64,
              type: blob.type
            });
          };
          reader.readAsBinaryString(blob);
        });
      }
      function _decodeBlob(encodedBlob) {
        var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
        return createBlob([arrayBuff], { type: encodedBlob.type });
      }
      function _isEncodedBlob(value) {
        return value && value.__local_forage_encoded_blob;
      }
      function _fullyReady(callback) {
        var self2 = this;
        var promise = self2._initReady().then(function() {
          var dbContext = dbContexts[self2._dbInfo.name];
          if (dbContext && dbContext.dbReady) {
            return dbContext.dbReady;
          }
        });
        executeTwoCallbacks(promise, callback, callback);
        return promise;
      }
      function _tryReconnect(dbInfo) {
        _deferReadiness(dbInfo);
        var dbContext = dbContexts[dbInfo.name];
        var forages = dbContext.forages;
        for (var i = 0; i < forages.length; i++) {
          var forage = forages[i];
          if (forage._dbInfo.db) {
            forage._dbInfo.db.close();
            forage._dbInfo.db = null;
          }
        }
        dbInfo.db = null;
        return _getOriginalConnection(dbInfo).then(function(db) {
          dbInfo.db = db;
          if (_isUpgradeNeeded(dbInfo)) {
            return _getUpgradedConnection(dbInfo);
          }
          return db;
        }).then(function(db) {
          dbInfo.db = dbContext.db = db;
          for (var i2 = 0; i2 < forages.length; i2++) {
            forages[i2]._dbInfo.db = db;
          }
        })["catch"](function(err) {
          _rejectReadiness(dbInfo, err);
          throw err;
        });
      }
      function createTransaction(dbInfo, mode, callback, retries) {
        if (retries === void 0) {
          retries = 1;
        }
        try {
          var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
          callback(null, tx);
        } catch (err) {
          if (retries > 0 && (!dbInfo.db || err.name === "InvalidStateError" || err.name === "NotFoundError")) {
            return Promise$1.resolve().then(function() {
              if (!dbInfo.db || err.name === "NotFoundError" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                if (dbInfo.db) {
                  dbInfo.version = dbInfo.db.version + 1;
                }
                return _getUpgradedConnection(dbInfo);
              }
            }).then(function() {
              return _tryReconnect(dbInfo).then(function() {
                createTransaction(dbInfo, mode, callback, retries - 1);
              });
            })["catch"](callback);
          }
          callback(err);
        }
      }
      function createDbContext() {
        return {
          // Running localForages sharing a database.
          forages: [],
          // Shared database.
          db: null,
          // Database readiness (promise).
          dbReady: null,
          // Deferred operations on the database.
          deferredOperations: []
        };
      }
      function _initStorage(options) {
        var self2 = this;
        var dbInfo = {
          db: null
        };
        if (options) {
          for (var i in options) {
            dbInfo[i] = options[i];
          }
        }
        var dbContext = dbContexts[dbInfo.name];
        if (!dbContext) {
          dbContext = createDbContext();
          dbContexts[dbInfo.name] = dbContext;
        }
        dbContext.forages.push(self2);
        if (!self2._initReady) {
          self2._initReady = self2.ready;
          self2.ready = _fullyReady;
        }
        var initPromises = [];
        function ignoreErrors() {
          return Promise$1.resolve();
        }
        for (var j = 0; j < dbContext.forages.length; j++) {
          var forage = dbContext.forages[j];
          if (forage !== self2) {
            initPromises.push(forage._initReady()["catch"](ignoreErrors));
          }
        }
        var forages = dbContext.forages.slice(0);
        return Promise$1.all(initPromises).then(function() {
          dbInfo.db = dbContext.db;
          return _getOriginalConnection(dbInfo);
        }).then(function(db) {
          dbInfo.db = db;
          if (_isUpgradeNeeded(dbInfo, self2._defaultConfig.version)) {
            return _getUpgradedConnection(dbInfo);
          }
          return db;
        }).then(function(db) {
          dbInfo.db = dbContext.db = db;
          self2._dbInfo = dbInfo;
          for (var k = 0; k < forages.length; k++) {
            var forage2 = forages[k];
            if (forage2 !== self2) {
              forage2._dbInfo.db = dbInfo.db;
              forage2._dbInfo.version = dbInfo.version;
            }
          }
        });
      }
      function getItem(key2, callback) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store.get(key2);
                req.onsuccess = function() {
                  var value = req.result;
                  if (value === void 0) {
                    value = null;
                  }
                  if (_isEncodedBlob(value)) {
                    value = _decodeBlob(value);
                  }
                  resolve2(value);
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function iterate(iterator2, callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store.openCursor();
                var iterationNumber = 1;
                req.onsuccess = function() {
                  var cursor = req.result;
                  if (cursor) {
                    var value = cursor.value;
                    if (_isEncodedBlob(value)) {
                      value = _decodeBlob(value);
                    }
                    var result = iterator2(value, cursor.key, iterationNumber++);
                    if (result !== void 0) {
                      resolve2(result);
                    } else {
                      cursor["continue"]();
                    }
                  } else {
                    resolve2();
                  }
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function setItem(key2, value, callback) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          var dbInfo;
          self2.ready().then(function() {
            dbInfo = self2._dbInfo;
            if (toString2.call(value) === "[object Blob]") {
              return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {
                if (blobSupport) {
                  return value;
                }
                return _encodeBlob(value);
              });
            }
            return value;
          }).then(function(value2) {
            createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                if (value2 === null) {
                  value2 = void 0;
                }
                var req = store.put(value2, key2);
                transaction.oncomplete = function() {
                  if (value2 === void 0) {
                    value2 = null;
                  }
                  resolve2(value2);
                };
                transaction.onabort = transaction.onerror = function() {
                  var err2 = req.error ? req.error : req.transaction.error;
                  reject(err2);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function removeItem(key2, callback) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store["delete"](key2);
                transaction.oncomplete = function() {
                  resolve2();
                };
                transaction.onerror = function() {
                  reject(req.error);
                };
                transaction.onabort = function() {
                  var err2 = req.error ? req.error : req.transaction.error;
                  reject(err2);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function clear2(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store.clear();
                transaction.oncomplete = function() {
                  resolve2();
                };
                transaction.onabort = transaction.onerror = function() {
                  var err2 = req.error ? req.error : req.transaction.error;
                  reject(err2);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function length(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store.count();
                req.onsuccess = function() {
                  resolve2(req.result);
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function key(n, callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          if (n < 0) {
            resolve2(null);
            return;
          }
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var advanced = false;
                var req = store.openKeyCursor();
                req.onsuccess = function() {
                  var cursor = req.result;
                  if (!cursor) {
                    resolve2(null);
                    return;
                  }
                  if (n === 0) {
                    resolve2(cursor.key);
                  } else {
                    if (!advanced) {
                      advanced = true;
                      cursor.advance(n);
                    } else {
                      resolve2(cursor.key);
                    }
                  }
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function keys(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store.openKeyCursor();
                var keys2 = [];
                req.onsuccess = function() {
                  var cursor = req.result;
                  if (!cursor) {
                    resolve2(keys2);
                    return;
                  }
                  keys2.push(cursor.key);
                  cursor["continue"]();
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function dropInstance(options, callback) {
        callback = getCallback.apply(this, arguments);
        var currentConfig = this.config();
        options = typeof options !== "function" && options || {};
        if (!options.name) {
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
        }
        var self2 = this;
        var promise;
        if (!options.name) {
          promise = Promise$1.reject("Invalid arguments");
        } else {
          var isCurrentDb = options.name === currentConfig.name && self2._dbInfo.db;
          var dbPromise = isCurrentDb ? Promise$1.resolve(self2._dbInfo.db) : _getOriginalConnection(options).then(function(db) {
            var dbContext = dbContexts[options.name];
            var forages = dbContext.forages;
            dbContext.db = db;
            for (var i = 0; i < forages.length; i++) {
              forages[i]._dbInfo.db = db;
            }
            return db;
          });
          if (!options.storeName) {
            promise = dbPromise.then(function(db) {
              _deferReadiness(options);
              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              db.close();
              for (var i = 0; i < forages.length; i++) {
                var forage = forages[i];
                forage._dbInfo.db = null;
              }
              var dropDBPromise = new Promise$1(function(resolve2, reject) {
                var req = idb.deleteDatabase(options.name);
                req.onerror = function() {
                  var db2 = req.result;
                  if (db2) {
                    db2.close();
                  }
                  reject(req.error);
                };
                req.onblocked = function() {
                  console.warn('dropInstance blocked for database "' + options.name + '" until all open connections are closed');
                };
                req.onsuccess = function() {
                  var db2 = req.result;
                  if (db2) {
                    db2.close();
                  }
                  resolve2(db2);
                };
              });
              return dropDBPromise.then(function(db2) {
                dbContext.db = db2;
                for (var i2 = 0; i2 < forages.length; i2++) {
                  var _forage = forages[i2];
                  _advanceReadiness(_forage._dbInfo);
                }
              })["catch"](function(err) {
                (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                });
                throw err;
              });
            });
          } else {
            promise = dbPromise.then(function(db) {
              if (!db.objectStoreNames.contains(options.storeName)) {
                return;
              }
              var newVersion = db.version + 1;
              _deferReadiness(options);
              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              db.close();
              for (var i = 0; i < forages.length; i++) {
                var forage = forages[i];
                forage._dbInfo.db = null;
                forage._dbInfo.version = newVersion;
              }
              var dropObjectPromise = new Promise$1(function(resolve2, reject) {
                var req = idb.open(options.name, newVersion);
                req.onerror = function(err) {
                  var db2 = req.result;
                  db2.close();
                  reject(err);
                };
                req.onupgradeneeded = function() {
                  var db2 = req.result;
                  db2.deleteObjectStore(options.storeName);
                };
                req.onsuccess = function() {
                  var db2 = req.result;
                  db2.close();
                  resolve2(db2);
                };
              });
              return dropObjectPromise.then(function(db2) {
                dbContext.db = db2;
                for (var j = 0; j < forages.length; j++) {
                  var _forage2 = forages[j];
                  _forage2._dbInfo.db = db2;
                  _advanceReadiness(_forage2._dbInfo);
                }
              })["catch"](function(err) {
                (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                });
                throw err;
              });
            });
          }
        }
        executeCallback(promise, callback);
        return promise;
      }
      var asyncStorage = {
        _driver: "asyncStorage",
        _initStorage,
        _support: isIndexedDBValid(),
        iterate,
        getItem,
        setItem,
        removeItem,
        clear: clear2,
        length,
        key,
        keys,
        dropInstance
      };
      function isWebSQLValid() {
        return typeof openDatabase === "function";
      }
      var BASE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var BLOB_TYPE_PREFIX = "~~local_forage_type~";
      var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
      var SERIALIZED_MARKER = "__lfsc__:";
      var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
      var TYPE_ARRAYBUFFER = "arbf";
      var TYPE_BLOB = "blob";
      var TYPE_INT8ARRAY = "si08";
      var TYPE_UINT8ARRAY = "ui08";
      var TYPE_UINT8CLAMPEDARRAY = "uic8";
      var TYPE_INT16ARRAY = "si16";
      var TYPE_INT32ARRAY = "si32";
      var TYPE_UINT16ARRAY = "ur16";
      var TYPE_UINT32ARRAY = "ui32";
      var TYPE_FLOAT32ARRAY = "fl32";
      var TYPE_FLOAT64ARRAY = "fl64";
      var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
      var toString$1 = Object.prototype.toString;
      function stringToBuffer(serializedString) {
        var bufferLength = serializedString.length * 0.75;
        var len = serializedString.length;
        var i;
        var p2 = 0;
        var encoded1, encoded2, encoded3, encoded4;
        if (serializedString[serializedString.length - 1] === "=") {
          bufferLength--;
          if (serializedString[serializedString.length - 2] === "=") {
            bufferLength--;
          }
        }
        var buffer = new ArrayBuffer(bufferLength);
        var bytes = new Uint8Array(buffer);
        for (i = 0; i < len; i += 4) {
          encoded1 = BASE_CHARS.indexOf(serializedString[i]);
          encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
          encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
          encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);
          bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
          bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
          bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
        }
        return buffer;
      }
      function bufferToString(buffer) {
        var bytes = new Uint8Array(buffer);
        var base64String = "";
        var i;
        for (i = 0; i < bytes.length; i += 3) {
          base64String += BASE_CHARS[bytes[i] >> 2];
          base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
          base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
          base64String += BASE_CHARS[bytes[i + 2] & 63];
        }
        if (bytes.length % 3 === 2) {
          base64String = base64String.substring(0, base64String.length - 1) + "=";
        } else if (bytes.length % 3 === 1) {
          base64String = base64String.substring(0, base64String.length - 2) + "==";
        }
        return base64String;
      }
      function serialize(value, callback) {
        var valueType = "";
        if (value) {
          valueType = toString$1.call(value);
        }
        if (value && (valueType === "[object ArrayBuffer]" || value.buffer && toString$1.call(value.buffer) === "[object ArrayBuffer]")) {
          var buffer;
          var marker = SERIALIZED_MARKER;
          if (value instanceof ArrayBuffer) {
            buffer = value;
            marker += TYPE_ARRAYBUFFER;
          } else {
            buffer = value.buffer;
            if (valueType === "[object Int8Array]") {
              marker += TYPE_INT8ARRAY;
            } else if (valueType === "[object Uint8Array]") {
              marker += TYPE_UINT8ARRAY;
            } else if (valueType === "[object Uint8ClampedArray]") {
              marker += TYPE_UINT8CLAMPEDARRAY;
            } else if (valueType === "[object Int16Array]") {
              marker += TYPE_INT16ARRAY;
            } else if (valueType === "[object Uint16Array]") {
              marker += TYPE_UINT16ARRAY;
            } else if (valueType === "[object Int32Array]") {
              marker += TYPE_INT32ARRAY;
            } else if (valueType === "[object Uint32Array]") {
              marker += TYPE_UINT32ARRAY;
            } else if (valueType === "[object Float32Array]") {
              marker += TYPE_FLOAT32ARRAY;
            } else if (valueType === "[object Float64Array]") {
              marker += TYPE_FLOAT64ARRAY;
            } else {
              callback(new Error("Failed to get type for BinaryArray"));
            }
          }
          callback(marker + bufferToString(buffer));
        } else if (valueType === "[object Blob]") {
          var fileReader = new FileReader();
          fileReader.onload = function() {
            var str = BLOB_TYPE_PREFIX + value.type + "~" + bufferToString(this.result);
            callback(SERIALIZED_MARKER + TYPE_BLOB + str);
          };
          fileReader.readAsArrayBuffer(value);
        } else {
          try {
            callback(JSON.stringify(value));
          } catch (e2) {
            console.error("Couldn't convert value into a JSON string: ", value);
            callback(null, e2);
          }
        }
      }
      function deserialize(value) {
        if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
          return JSON.parse(value);
        }
        var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
        var type2 = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
        var blobType;
        if (type2 === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
          var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
          blobType = matcher[1];
          serializedString = serializedString.substring(matcher[0].length);
        }
        var buffer = stringToBuffer(serializedString);
        switch (type2) {
          case TYPE_ARRAYBUFFER:
            return buffer;
          case TYPE_BLOB:
            return createBlob([buffer], { type: blobType });
          case TYPE_INT8ARRAY:
            return new Int8Array(buffer);
          case TYPE_UINT8ARRAY:
            return new Uint8Array(buffer);
          case TYPE_UINT8CLAMPEDARRAY:
            return new Uint8ClampedArray(buffer);
          case TYPE_INT16ARRAY:
            return new Int16Array(buffer);
          case TYPE_UINT16ARRAY:
            return new Uint16Array(buffer);
          case TYPE_INT32ARRAY:
            return new Int32Array(buffer);
          case TYPE_UINT32ARRAY:
            return new Uint32Array(buffer);
          case TYPE_FLOAT32ARRAY:
            return new Float32Array(buffer);
          case TYPE_FLOAT64ARRAY:
            return new Float64Array(buffer);
          default:
            throw new Error("Unkown type: " + type2);
        }
      }
      var localforageSerializer = {
        serialize,
        deserialize,
        stringToBuffer,
        bufferToString
      };
      function createDbTable(t, dbInfo, callback, errorCallback) {
        t.executeSql("CREATE TABLE IF NOT EXISTS " + dbInfo.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], callback, errorCallback);
      }
      function _initStorage$1(options) {
        var self2 = this;
        var dbInfo = {
          db: null
        };
        if (options) {
          for (var i in options) {
            dbInfo[i] = typeof options[i] !== "string" ? options[i].toString() : options[i];
          }
        }
        var dbInfoPromise = new Promise$1(function(resolve2, reject) {
          try {
            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
          } catch (e2) {
            return reject(e2);
          }
          dbInfo.db.transaction(function(t) {
            createDbTable(t, dbInfo, function() {
              self2._dbInfo = dbInfo;
              resolve2();
            }, function(t2, error) {
              reject(error);
            });
          }, reject);
        });
        dbInfo.serializer = localforageSerializer;
        return dbInfoPromise;
      }
      function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
        t.executeSql(sqlStatement, args, callback, function(t2, error) {
          if (error.code === error.SYNTAX_ERR) {
            t2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [dbInfo.storeName], function(t3, results) {
              if (!results.rows.length) {
                createDbTable(t3, dbInfo, function() {
                  t3.executeSql(sqlStatement, args, callback, errorCallback);
                }, errorCallback);
              } else {
                errorCallback(t3, error);
              }
            }, errorCallback);
          } else {
            errorCallback(t2, error);
          }
        }, errorCallback);
      }
      function getItem$1(key2, callback) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t) {
              tryExecuteSql(t, dbInfo, "SELECT * FROM " + dbInfo.storeName + " WHERE key = ? LIMIT 1", [key2], function(t2, results) {
                var result = results.rows.length ? results.rows.item(0).value : null;
                if (result) {
                  result = dbInfo.serializer.deserialize(result);
                }
                resolve2(result);
              }, function(t2, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function iterate$1(iterator2, callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t) {
              tryExecuteSql(t, dbInfo, "SELECT * FROM " + dbInfo.storeName, [], function(t2, results) {
                var rows = results.rows;
                var length2 = rows.length;
                for (var i = 0; i < length2; i++) {
                  var item = rows.item(i);
                  var result = item.value;
                  if (result) {
                    result = dbInfo.serializer.deserialize(result);
                  }
                  result = iterator2(result, item.key, i + 1);
                  if (result !== void 0) {
                    resolve2(result);
                    return;
                  }
                }
                resolve2();
              }, function(t2, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function _setItem(key2, value, callback, retriesLeft) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            if (value === void 0) {
              value = null;
            }
            var originalValue = value;
            var dbInfo = self2._dbInfo;
            dbInfo.serializer.serialize(value, function(value2, error) {
              if (error) {
                reject(error);
              } else {
                dbInfo.db.transaction(function(t) {
                  tryExecuteSql(t, dbInfo, "INSERT OR REPLACE INTO " + dbInfo.storeName + " (key, value) VALUES (?, ?)", [key2, value2], function() {
                    resolve2(originalValue);
                  }, function(t2, error2) {
                    reject(error2);
                  });
                }, function(sqlError) {
                  if (sqlError.code === sqlError.QUOTA_ERR) {
                    if (retriesLeft > 0) {
                      resolve2(_setItem.apply(self2, [key2, originalValue, callback, retriesLeft - 1]));
                      return;
                    }
                    reject(sqlError);
                  }
                });
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function setItem$1(key2, value, callback) {
        return _setItem.apply(this, [key2, value, callback, 1]);
      }
      function removeItem$1(key2, callback) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t) {
              tryExecuteSql(t, dbInfo, "DELETE FROM " + dbInfo.storeName + " WHERE key = ?", [key2], function() {
                resolve2();
              }, function(t2, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function clear$1(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t) {
              tryExecuteSql(t, dbInfo, "DELETE FROM " + dbInfo.storeName, [], function() {
                resolve2();
              }, function(t2, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function length$1(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t) {
              tryExecuteSql(t, dbInfo, "SELECT COUNT(key) as c FROM " + dbInfo.storeName, [], function(t2, results) {
                var result = results.rows.item(0).c;
                resolve2(result);
              }, function(t2, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function key$1(n, callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t) {
              tryExecuteSql(t, dbInfo, "SELECT key FROM " + dbInfo.storeName + " WHERE id = ? LIMIT 1", [n + 1], function(t2, results) {
                var result = results.rows.length ? results.rows.item(0).key : null;
                resolve2(result);
              }, function(t2, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function keys$1(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t) {
              tryExecuteSql(t, dbInfo, "SELECT key FROM " + dbInfo.storeName, [], function(t2, results) {
                var keys2 = [];
                for (var i = 0; i < results.rows.length; i++) {
                  keys2.push(results.rows.item(i).key);
                }
                resolve2(keys2);
              }, function(t2, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function getAllStoreNames(db) {
        return new Promise$1(function(resolve2, reject) {
          db.transaction(function(t) {
            t.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(t2, results) {
              var storeNames = [];
              for (var i = 0; i < results.rows.length; i++) {
                storeNames.push(results.rows.item(i).name);
              }
              resolve2({
                db,
                storeNames
              });
            }, function(t2, error) {
              reject(error);
            });
          }, function(sqlError) {
            reject(sqlError);
          });
        });
      }
      function dropInstance$1(options, callback) {
        callback = getCallback.apply(this, arguments);
        var currentConfig = this.config();
        options = typeof options !== "function" && options || {};
        if (!options.name) {
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
        }
        var self2 = this;
        var promise;
        if (!options.name) {
          promise = Promise$1.reject("Invalid arguments");
        } else {
          promise = new Promise$1(function(resolve2) {
            var db;
            if (options.name === currentConfig.name) {
              db = self2._dbInfo.db;
            } else {
              db = openDatabase(options.name, "", "", 0);
            }
            if (!options.storeName) {
              resolve2(getAllStoreNames(db));
            } else {
              resolve2({
                db,
                storeNames: [options.storeName]
              });
            }
          }).then(function(operationInfo) {
            return new Promise$1(function(resolve2, reject) {
              operationInfo.db.transaction(function(t) {
                function dropTable(storeName) {
                  return new Promise$1(function(resolve3, reject2) {
                    t.executeSql("DROP TABLE IF EXISTS " + storeName, [], function() {
                      resolve3();
                    }, function(t2, error) {
                      reject2(error);
                    });
                  });
                }
                var operations = [];
                for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
                  operations.push(dropTable(operationInfo.storeNames[i]));
                }
                Promise$1.all(operations).then(function() {
                  resolve2();
                })["catch"](function(e2) {
                  reject(e2);
                });
              }, function(sqlError) {
                reject(sqlError);
              });
            });
          });
        }
        executeCallback(promise, callback);
        return promise;
      }
      var webSQLStorage = {
        _driver: "webSQLStorage",
        _initStorage: _initStorage$1,
        _support: isWebSQLValid(),
        iterate: iterate$1,
        getItem: getItem$1,
        setItem: setItem$1,
        removeItem: removeItem$1,
        clear: clear$1,
        length: length$1,
        key: key$1,
        keys: keys$1,
        dropInstance: dropInstance$1
      };
      function isLocalStorageValid() {
        try {
          return typeof localStorage !== "undefined" && "setItem" in localStorage && // in IE8 typeof localStorage.setItem === 'object'
          !!localStorage.setItem;
        } catch (e2) {
          return false;
        }
      }
      function _getKeyPrefix(options, defaultConfig) {
        var keyPrefix = options.name + "/";
        if (options.storeName !== defaultConfig.storeName) {
          keyPrefix += options.storeName + "/";
        }
        return keyPrefix;
      }
      function checkIfLocalStorageThrows() {
        var localStorageTestKey = "_localforage_support_test";
        try {
          localStorage.setItem(localStorageTestKey, true);
          localStorage.removeItem(localStorageTestKey);
          return false;
        } catch (e2) {
          return true;
        }
      }
      function _isLocalStorageUsable() {
        return !checkIfLocalStorageThrows() || localStorage.length > 0;
      }
      function _initStorage$2(options) {
        var self2 = this;
        var dbInfo = {};
        if (options) {
          for (var i in options) {
            dbInfo[i] = options[i];
          }
        }
        dbInfo.keyPrefix = _getKeyPrefix(options, self2._defaultConfig);
        if (!_isLocalStorageUsable()) {
          return Promise$1.reject();
        }
        self2._dbInfo = dbInfo;
        dbInfo.serializer = localforageSerializer;
        return Promise$1.resolve();
      }
      function clear$2(callback) {
        var self2 = this;
        var promise = self2.ready().then(function() {
          var keyPrefix = self2._dbInfo.keyPrefix;
          for (var i = localStorage.length - 1; i >= 0; i--) {
            var key2 = localStorage.key(i);
            if (key2.indexOf(keyPrefix) === 0) {
              localStorage.removeItem(key2);
            }
          }
        });
        executeCallback(promise, callback);
        return promise;
      }
      function getItem$2(key2, callback) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var result = localStorage.getItem(dbInfo.keyPrefix + key2);
          if (result) {
            result = dbInfo.serializer.deserialize(result);
          }
          return result;
        });
        executeCallback(promise, callback);
        return promise;
      }
      function iterate$2(iterator2, callback) {
        var self2 = this;
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var keyPrefix = dbInfo.keyPrefix;
          var keyPrefixLength = keyPrefix.length;
          var length2 = localStorage.length;
          var iterationNumber = 1;
          for (var i = 0; i < length2; i++) {
            var key2 = localStorage.key(i);
            if (key2.indexOf(keyPrefix) !== 0) {
              continue;
            }
            var value = localStorage.getItem(key2);
            if (value) {
              value = dbInfo.serializer.deserialize(value);
            }
            value = iterator2(value, key2.substring(keyPrefixLength), iterationNumber++);
            if (value !== void 0) {
              return value;
            }
          }
        });
        executeCallback(promise, callback);
        return promise;
      }
      function key$2(n, callback) {
        var self2 = this;
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var result;
          try {
            result = localStorage.key(n);
          } catch (error) {
            result = null;
          }
          if (result) {
            result = result.substring(dbInfo.keyPrefix.length);
          }
          return result;
        });
        executeCallback(promise, callback);
        return promise;
      }
      function keys$2(callback) {
        var self2 = this;
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var length2 = localStorage.length;
          var keys2 = [];
          for (var i = 0; i < length2; i++) {
            var itemKey = localStorage.key(i);
            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
              keys2.push(itemKey.substring(dbInfo.keyPrefix.length));
            }
          }
          return keys2;
        });
        executeCallback(promise, callback);
        return promise;
      }
      function length$2(callback) {
        var self2 = this;
        var promise = self2.keys().then(function(keys2) {
          return keys2.length;
        });
        executeCallback(promise, callback);
        return promise;
      }
      function removeItem$2(key2, callback) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          localStorage.removeItem(dbInfo.keyPrefix + key2);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function setItem$2(key2, value, callback) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = self2.ready().then(function() {
          if (value === void 0) {
            value = null;
          }
          var originalValue = value;
          return new Promise$1(function(resolve2, reject) {
            var dbInfo = self2._dbInfo;
            dbInfo.serializer.serialize(value, function(value2, error) {
              if (error) {
                reject(error);
              } else {
                try {
                  localStorage.setItem(dbInfo.keyPrefix + key2, value2);
                  resolve2(originalValue);
                } catch (e2) {
                  if (e2.name === "QuotaExceededError" || e2.name === "NS_ERROR_DOM_QUOTA_REACHED") {
                    reject(e2);
                  }
                  reject(e2);
                }
              }
            });
          });
        });
        executeCallback(promise, callback);
        return promise;
      }
      function dropInstance$2(options, callback) {
        callback = getCallback.apply(this, arguments);
        options = typeof options !== "function" && options || {};
        if (!options.name) {
          var currentConfig = this.config();
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
        }
        var self2 = this;
        var promise;
        if (!options.name) {
          promise = Promise$1.reject("Invalid arguments");
        } else {
          promise = new Promise$1(function(resolve2) {
            if (!options.storeName) {
              resolve2(options.name + "/");
            } else {
              resolve2(_getKeyPrefix(options, self2._defaultConfig));
            }
          }).then(function(keyPrefix) {
            for (var i = localStorage.length - 1; i >= 0; i--) {
              var key2 = localStorage.key(i);
              if (key2.indexOf(keyPrefix) === 0) {
                localStorage.removeItem(key2);
              }
            }
          });
        }
        executeCallback(promise, callback);
        return promise;
      }
      var localStorageWrapper = {
        _driver: "localStorageWrapper",
        _initStorage: _initStorage$2,
        _support: isLocalStorageValid(),
        iterate: iterate$2,
        getItem: getItem$2,
        setItem: setItem$2,
        removeItem: removeItem$2,
        clear: clear$2,
        length: length$2,
        key: key$2,
        keys: keys$2,
        dropInstance: dropInstance$2
      };
      var sameValue = function sameValue2(x, y) {
        return x === y || typeof x === "number" && typeof y === "number" && isNaN(x) && isNaN(y);
      };
      var includes = function includes2(array, searchElement) {
        var len = array.length;
        var i = 0;
        while (i < len) {
          if (sameValue(array[i], searchElement)) {
            return true;
          }
          i++;
        }
        return false;
      };
      var isArray2 = Array.isArray || function(arg) {
        return Object.prototype.toString.call(arg) === "[object Array]";
      };
      var DefinedDrivers = {};
      var DriverSupport = {};
      var DefaultDrivers = {
        INDEXEDDB: asyncStorage,
        WEBSQL: webSQLStorage,
        LOCALSTORAGE: localStorageWrapper
      };
      var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];
      var OptionalDriverMethods = ["dropInstance"];
      var LibraryMethods = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(OptionalDriverMethods);
      var DefaultConfig = {
        description: "",
        driver: DefaultDriverOrder.slice(),
        name: "localforage",
        // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
        // we can use without a prompt.
        size: 4980736,
        storeName: "keyvaluepairs",
        version: 1
      };
      function callWhenReady(localForageInstance, libraryMethod) {
        localForageInstance[libraryMethod] = function() {
          var _args = arguments;
          return localForageInstance.ready().then(function() {
            return localForageInstance[libraryMethod].apply(localForageInstance, _args);
          });
        };
      }
      function extend2() {
        for (var i = 1; i < arguments.length; i++) {
          var arg = arguments[i];
          if (arg) {
            for (var _key in arg) {
              if (arg.hasOwnProperty(_key)) {
                if (isArray2(arg[_key])) {
                  arguments[0][_key] = arg[_key].slice();
                } else {
                  arguments[0][_key] = arg[_key];
                }
              }
            }
          }
        }
        return arguments[0];
      }
      var LocalForage = function() {
        function LocalForage2(options) {
          _classCallCheck2(this, LocalForage2);
          for (var driverTypeKey in DefaultDrivers) {
            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
              var driver = DefaultDrivers[driverTypeKey];
              var driverName = driver._driver;
              this[driverTypeKey] = driverName;
              if (!DefinedDrivers[driverName]) {
                this.defineDriver(driver);
              }
            }
          }
          this._defaultConfig = extend2({}, DefaultConfig);
          this._config = extend2({}, this._defaultConfig, options);
          this._driverSet = null;
          this._initDriver = null;
          this._ready = false;
          this._dbInfo = null;
          this._wrapLibraryMethodsWithReady();
          this.setDriver(this._config.driver)["catch"](function() {
          });
        }
        LocalForage2.prototype.config = function config(options) {
          if ((typeof options === "undefined" ? "undefined" : _typeof2(options)) === "object") {
            if (this._ready) {
              return new Error("Can't call config() after localforage has been used.");
            }
            for (var i in options) {
              if (i === "storeName") {
                options[i] = options[i].replace(/\W/g, "_");
              }
              if (i === "version" && typeof options[i] !== "number") {
                return new Error("Database version must be a number.");
              }
              this._config[i] = options[i];
            }
            if ("driver" in options && options.driver) {
              return this.setDriver(this._config.driver);
            }
            return true;
          } else if (typeof options === "string") {
            return this._config[options];
          } else {
            return this._config;
          }
        };
        LocalForage2.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
          var promise = new Promise$1(function(resolve2, reject) {
            try {
              var driverName = driverObject._driver;
              var complianceError = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
              if (!driverObject._driver) {
                reject(complianceError);
                return;
              }
              var driverMethods = LibraryMethods.concat("_initStorage");
              for (var i = 0, len = driverMethods.length; i < len; i++) {
                var driverMethodName = driverMethods[i];
                var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== "function") {
                  reject(complianceError);
                  return;
                }
              }
              var configureMissingMethods = function configureMissingMethods2() {
                var methodNotImplementedFactory = function methodNotImplementedFactory2(methodName) {
                  return function() {
                    var error = new Error("Method " + methodName + " is not implemented by the current driver");
                    var promise2 = Promise$1.reject(error);
                    executeCallback(promise2, arguments[arguments.length - 1]);
                    return promise2;
                  };
                };
                for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                  var optionalDriverMethod = OptionalDriverMethods[_i];
                  if (!driverObject[optionalDriverMethod]) {
                    driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                  }
                }
              };
              configureMissingMethods();
              var setDriverSupport = function setDriverSupport2(support) {
                if (DefinedDrivers[driverName]) {
                  console.info("Redefining LocalForage driver: " + driverName);
                }
                DefinedDrivers[driverName] = driverObject;
                DriverSupport[driverName] = support;
                resolve2();
              };
              if ("_support" in driverObject) {
                if (driverObject._support && typeof driverObject._support === "function") {
                  driverObject._support().then(setDriverSupport, reject);
                } else {
                  setDriverSupport(!!driverObject._support);
                }
              } else {
                setDriverSupport(true);
              }
            } catch (e2) {
              reject(e2);
            }
          });
          executeTwoCallbacks(promise, callback, errorCallback);
          return promise;
        };
        LocalForage2.prototype.driver = function driver() {
          return this._driver || null;
        };
        LocalForage2.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
          var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error("Driver not found."));
          executeTwoCallbacks(getDriverPromise, callback, errorCallback);
          return getDriverPromise;
        };
        LocalForage2.prototype.getSerializer = function getSerializer(callback) {
          var serializerPromise = Promise$1.resolve(localforageSerializer);
          executeTwoCallbacks(serializerPromise, callback);
          return serializerPromise;
        };
        LocalForage2.prototype.ready = function ready(callback) {
          var self2 = this;
          var promise = self2._driverSet.then(function() {
            if (self2._ready === null) {
              self2._ready = self2._initDriver();
            }
            return self2._ready;
          });
          executeTwoCallbacks(promise, callback, callback);
          return promise;
        };
        LocalForage2.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
          var self2 = this;
          if (!isArray2(drivers)) {
            drivers = [drivers];
          }
          var supportedDrivers = this._getSupportedDrivers(drivers);
          function setDriverToConfig() {
            self2._config.driver = self2.driver();
          }
          function extendSelfWithDriver(driver) {
            self2._extend(driver);
            setDriverToConfig();
            self2._ready = self2._initStorage(self2._config);
            return self2._ready;
          }
          function initDriver(supportedDrivers2) {
            return function() {
              var currentDriverIndex = 0;
              function driverPromiseLoop() {
                while (currentDriverIndex < supportedDrivers2.length) {
                  var driverName = supportedDrivers2[currentDriverIndex];
                  currentDriverIndex++;
                  self2._dbInfo = null;
                  self2._ready = null;
                  return self2.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                }
                setDriverToConfig();
                var error = new Error("No available storage method found.");
                self2._driverSet = Promise$1.reject(error);
                return self2._driverSet;
              }
              return driverPromiseLoop();
            };
          }
          var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function() {
            return Promise$1.resolve();
          }) : Promise$1.resolve();
          this._driverSet = oldDriverSetDone.then(function() {
            var driverName = supportedDrivers[0];
            self2._dbInfo = null;
            self2._ready = null;
            return self2.getDriver(driverName).then(function(driver) {
              self2._driver = driver._driver;
              setDriverToConfig();
              self2._wrapLibraryMethodsWithReady();
              self2._initDriver = initDriver(supportedDrivers);
            });
          })["catch"](function() {
            setDriverToConfig();
            var error = new Error("No available storage method found.");
            self2._driverSet = Promise$1.reject(error);
            return self2._driverSet;
          });
          executeTwoCallbacks(this._driverSet, callback, errorCallback);
          return this._driverSet;
        };
        LocalForage2.prototype.supports = function supports(driverName) {
          return !!DriverSupport[driverName];
        };
        LocalForage2.prototype._extend = function _extend(libraryMethodsAndProperties) {
          extend2(this, libraryMethodsAndProperties);
        };
        LocalForage2.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
          var supportedDrivers = [];
          for (var i = 0, len = drivers.length; i < len; i++) {
            var driverName = drivers[i];
            if (this.supports(driverName)) {
              supportedDrivers.push(driverName);
            }
          }
          return supportedDrivers;
        };
        LocalForage2.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
          for (var i = 0, len = LibraryMethods.length; i < len; i++) {
            callWhenReady(this, LibraryMethods[i]);
          }
        };
        LocalForage2.prototype.createInstance = function createInstance(options) {
          return new LocalForage2(options);
        };
        return LocalForage2;
      }();
      var localforage_js = new LocalForage();
      module2.exports = localforage_js;
    }, { "3": 3 }] }, {}, [4])(4);
  });
})(localforage);
var localforageExports = localforage.exports;
const localForage = /* @__PURE__ */ getDefaultExportFromCjs(localforageExports);
class LocalForageDriver extends BaseDriver {
  constructor(name) {
    super();
    this.db = localForage.createInstance({ name });
    this.name = name;
    this.type = "localforage";
  }
  async length() {
    return this.db.length();
  }
  async iterate(predicate) {
    return this.db.iterate(predicate);
  }
  async setItem(name, value) {
    try {
      if (value.__filepath) {
        delete value.__filepath;
      }
      return this.db.setItem(name, value);
    } catch (ex) {
      window.app.addAlert({
        title: "Failed to write to with localStorage driver",
        message: `${ex.message}`,
        ex
      });
    }
  }
  async getItem(name, def2) {
    return this.db.getItem(name, def2);
  }
  async removeItem(name) {
    return this.db.removeItem(name);
  }
}
clearTimeout(window.errorTimeout);
const _sfc_main$1 = {
  name: "app",
  components: {
    ApkStartScreen,
    SceneReader
  },
  data() {
    return {
      user: { id: null },
      status: "loading",
      story: null,
      choices: [],
      cachedURLs: {},
      dark: true,
      accent: "#B3B3B3",
      spark: "#E27300",
      titleStyle: null,
      choiceStyle: null,
      count: 0,
      percent: 0
    };
  },
  computed: {
    ...mapStores(useThemeStore)
  },
  async created() {
    Media.ManagerClass.prefix = "shell";
    this.themeStore.reset();
  },
  async mounted() {
    await Promise.all([Media.ready()]);
    window.app = this;
    this.story = await this.downloadStory();
    const settings = this.story.settings || {};
    const landing = this.story.landing || {};
    this.dark = !(settings.darkMode === false);
    this.accent = landing.themeAccent || "#b3b3b3";
    this.spark = landing.themeSpark || "#009CE0";
    this.themeStore.current.accent = this.accent;
    this.themeStore.current.spark = this.spark;
    this.themeStore.current.dark = landing.themeDark !== false;
    console.log("landing", landing);
    console.log(`%caccent: ${this.accent}`, `color: ${this.accent}`);
    console.log(`%cspark: ${this.spark}`, `color: ${this.spark}`);
    this.themeStore.update();
    this.getChoices();
    this.status = null;
    if (this.story.settings.titleStyle) {
      this.titleStyle = this.story.styles.find((s) => s.id === this.story.settings.titleStyle);
    }
    if (!this.titleStyle) {
      this.titleStyle = this.story.styles.find((s) => s.default);
    }
    this.choiceStyle = this.story.styles.find((s) => s.default_choice);
    document.addEventListener("backbutton", this.androidBack, false);
  },
  methods: {
    onInternal(...args) {
      emitter.on(...args);
    },
    offInternal: emitter.off,
    onceInternal: emitter.once,
    emitInternal(...args) {
      emitter.emit(...args);
    },
    async getFilesystem(name, ext = "json") {
      return new LocalForageDriver(name, ext);
    },
    async downloadStory() {
      this.status = "Loading";
      let download = await fetch("./story/story.json");
      let story2 = null;
      if (download.status === 200) {
        story2 = await download.json();
        console.log("download", story2);
        await this.importStoryAssets(story2);
      } else {
        download = await fetch("./story.zip");
        if (download.ok) {
          const blob = await download.blob();
          story2 = await this.importStoryZip(blob);
          this.status = null;
        } else {
          this.status = "error";
        }
      }
      return story2;
    },
    async importStoryZip(blob) {
      const zip = new JSZip();
      await zip.loadAsync(blob);
      let retval = null;
      const files = [];
      zip.forEach(async (path, file) => {
        files.push([path, file]);
      });
      for (const [path, file] of files) {
        if (/.json$/.test(path)) {
          retval = JSON.parse(await file.async("string"));
        } else {
          let name = path.split(".")[0];
          if (/\//.test(name)) {
            name = name.split("/");
            name = name[name.length - 1];
          }
          if (name) {
            const value = await file.async("blob");
            const media = await Media.importBlob(value, name, true);
            this.$root.cachedURLs[name] = await media.getUrl();
          }
        }
      }
      return retval;
    },
    async importStoryAssets(story2) {
      const existing = {};
      for (const m of await Media.list()) {
        existing[m.id] = true;
        const blob = await m.getBlob();
        if (blob) {
          this.$root.cachedURLs[m.id] = await URL.createObjectURL(blob);
        } else {
          console.log("blob is none", m.id, blob);
        }
      }
      await this.permalinkLoader(story2, existing);
    },
    async importAssetFile(name) {
      const response = await Promise.race([
        // fetch(`story/${name}`),
        fetch(`./story/${name}.png`)
        // fetch(`story/${name}.blob`),
        // fetch(`story/${name}.octet-stream`),
      ]);
      if (response.status === 200) {
        const blob = await response.blob();
        await Media.importBlob(blob, name, true);
        this.$root.cachedURLs[name] = await URL.createObjectURL(blob);
      } else {
        console.error("failed to load", name);
      }
    },
    androidBack(e2) {
      e2.preventDefault();
      if (this.status === "play") {
        this.status = null;
      } else if (confirm("Are you sure you want to exit ?")) {
        navigator.app.exitApp();
      }
    },
    reset() {
      if (confirm("Reset your progress?")) {
        localStorage.clear();
        this.choices = [];
      }
    },
    start(scene) {
      if (scene) {
        this.startHere(scene);
      }
      this.status = "play";
    },
    textStyle,
    async permalinkLoader(story2, existing) {
      this.status = "Downloading Assets";
      this.count = 0;
      this.percent = 0;
      const permalinks = (story2.mediaManifest || story2.permalinks || []).filter(
        (p2) => !existing[p2.id]
      );
      for (const permalink of permalinks) {
        if (!existing[permalink.id]) {
          existing[permalink.id] = true;
        }
      }
      const promises = [];
      for (let x = 0; x < 8; x += 1) {
        promises.push(this.permalinkWorker(x, permalinks.length, permalinks));
      }
      await Promise.all(promises);
    },
    async permalinkWorker(worker, total, permalinks) {
      while (permalinks.length > 0) {
        await this.loadPermalink(worker, permalinks.shift());
        this.count += 1;
        this.percent = this.count / total;
      }
    },
    async loadPermalink(worker, permalink) {
      let url = permalink.url;
      const invalid = ["null", "undefined"];
      if (!url && permalink.name && !invalid.includes(permalink.name)) {
        url = `/story/${permalink.name}`;
      }
      if (!url && permalink.id && !invalid.includes(permalink.id)) {
        url = `/story/${permalink.id}`;
      }
      if (url) {
        try {
          console.log(" <-  downloading", worker, url);
          const response = await fetch(permalink.url);
          if (response.ok) {
            const blob = await response.blob();
            await Media.importBlob(blob, permalink.id, true);
            this.$root.cachedURLs[permalink.id] = await URL.createObjectURL(blob);
          }
        } catch (ex) {
          console.error(ex);
        }
      }
    },
    backToMenu() {
      this.status = null;
      this.getChoices();
    },
    getChoices() {
      const key = `story_${this.story.id}`;
      const profile = fetch$1(key, { choices: [] });
      this.choices = profile.choices || [];
    },
    startHere(sceneId) {
      const key = `story_${this.story.id}`;
      let player = fetch$1(key, { choices: [] });
      const indexOf = player.choices.findIndex((c) => c.scene === sceneId);
      if (indexOf > -1) {
        player.choices = player.choices.slice(0, indexOf + 1);
      }
      put(key, player);
    }
  }
};
const _hoisted_1 = {
  key: 1,
  class: "start screen about"
};
const _hoisted_2 = {
  key: 2,
  class: "game screen"
};
const _hoisted_3 = {
  key: 3,
  class: "loading"
};
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ApkStartScreen = resolveComponent("ApkStartScreen");
  const _component_scene_reader = resolveComponent("scene-reader");
  return openBlock(), createElementBlock("div", null, [
    $data.story && $data.status != "play" ? (openBlock(), createBlock(_component_ApkStartScreen, {
      key: 0,
      class: "start-screen",
      onStart: $options.start,
      onReset: $options.reset,
      onAbout: _cache[0] || (_cache[0] = ($event) => $data.status = "about"),
      story: $data.story,
      choices: $data.choices
    }, null, 8, ["onStart", "onReset", "story", "choices"])) : $data.status === "about" ? (openBlock(), createElementBlock("div", _hoisted_1, [
      createBaseVNode("a", {
        class: "close",
        onClick: _cache[1] || (_cache[1] = ($event) => $data.status = null)
      }, ""),
      _cache[3] || (_cache[3] = createStaticVNode('<p>This story was made with<br>CYOA Factory</p><p>Find more stories and make your own adventures:</p><div class="links"><div><a href="https://play.google.com/store/apps/details?id=com.morphosisgames.cyocyoa" target="_system"><i class="fa fa-android"></i> Android </a></div><div><a href="https://apps.apple.com/us/app/cyoa-factory/id1358855111" target="_system"><i class="fa fa-apple"></i> iOS </a></div><div><a href="https://leitjohn.itch.io/cyoa-factory" target="_system"><i class="fa fa-windows"></i><i class="fa fa-linux"></i> Windows/Linux/Mac </a></div><div><a href="https://tsunami.darkchocolate.dev/static/cyoa/" target="_system"><i class="fa fa-globe"></i> Website </a></div></div>', 3))
    ])) : $data.story ? (openBlock(), createElementBlock("div", _hoisted_2, [
      createBaseVNode("div", {
        class: "backbutton",
        onClick: _cache[2] || (_cache[2] = (...args) => $options.backToMenu && $options.backToMenu(...args))
      }, _cache[4] || (_cache[4] = [
        createBaseVNode("i", { class: "fa fa-close" }, null, -1)
      ])),
      createVNode(_component_scene_reader, { story: $data.story }, null, 8, ["story"])
    ])) : (openBlock(), createElementBlock("div", _hoisted_3, [
      createTextVNode(toDisplayString$1($data.status) + " ", 1),
      $data.percent ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createTextVNode(toDisplayString$1(Math.floor($data.percent * 100)) + "%", 1)
      ], 64)) : createCommentVNode("", true),
      _cache[5] || (_cache[5] = createTextVNode(" ... "))
    ]))
  ]);
}
const App = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
const _sfc_main = {
  name: "blob-image",
  props: {
    blob: String,
    thumb: { type: Boolean, default: false }
  },
  data() {
    return {
      image: null
    };
  },
  watch: {
    async blob() {
      await this.getImage();
    }
  },
  async mounted() {
    await this.getImage();
  },
  methods: {
    async getImage() {
      if (this.blob) {
        const instance2 = await Media.load(this.blob);
        if (instance2) {
          if (this.thumb) {
            this.image = await instance2.getThumbnail();
          } else {
            this.image = await instance2.getUrl();
          }
        }
      } else {
        this.image = null;
      }
    }
  }
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return $data.image ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: "blog-background",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event)),
    style: normalizeStyle({ backgroundImage: $data.image ? `url(${$data.image})` : "" })
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 4)) : createCommentVNode("", true);
}
const BlobBackground = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
var isVue2 = false;
/*!
 * pinia v2.1.7
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */
const piniaSymbol = (
  /* istanbul ignore next */
  Symbol()
);
var MutationType;
(function(MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType || (MutationType = {}));
function createPinia() {
  const scope = effectScope(true);
  const state2 = scope.run(() => ref({}));
  let _p = [];
  let toBeInstalled = [];
  const pinia = markRaw({
    install(app2) {
      {
        pinia._a = app2;
        app2.provide(piniaSymbol, pinia);
        app2.config.globalProperties.$pinia = pinia;
        toBeInstalled.forEach((plugin) => _p.push(plugin));
        toBeInstalled = [];
      }
    },
    use(plugin) {
      if (!this._a && !isVue2) {
        toBeInstalled.push(plugin);
      } else {
        _p.push(plugin);
      }
      return this;
    },
    _p,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: scope,
    _s: /* @__PURE__ */ new Map(),
    state: state2
  });
  return pinia;
}
const mixin = {
  components: {
    Animation,
    BlobAudio,
    BlobBackground,
    BlobImage,
    Typer
  },
  computed: {
    $router() {
    },
    $socket() {
      return {
        ensureConnected() {
          return false;
        }
      };
    }
  },
  methods: {
    copy: copy$2,
    put,
    fetch: fetch$1,
    async saveBlob(name, data) {
      this.$root.cachedURLs[name] = await URL.createObjectURL(data);
    },
    async blobURL(name) {
      return this.$root.cachedURLs[name];
    }
  }
};
const app$1 = createApp(App);
app$1.config.globalProperties.$i18n = i18n;
app$1.mixin(mixin);
app$1.use(createPinia());
app$1.mount("#app");
export {
  BaseDriver as B,
  Encoding as E,
  WebPlugin2 as W,
  WebPlugin$1 as a,
  buildRequestInit$1 as b,
  debug$1 as d,
  localForage$1 as l
};
function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = []
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}
